# ! [ doc = "Peripheral access API for ATSAMC21N18A microcontrollers (generated using svd2rust v0.16.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.16.0/svd2rust/#peripheral-api" ] # ! [ deny ( missing_docs ) ] # ! [ deny ( warnings ) ] # ! [ allow ( non_camel_case_types ) ] # ! [ no_std ]
extern crate cortex_m ; # [ cfg ( feature = "rt" ) ] extern crate cortex_m_rt ;
extern crate bare_metal ; extern crate vcell ; use core :: ops :: Deref ; use core :: marker :: PhantomData ;
# [ doc = r"Number available in the NVIC for configuring priority" ] pub const NVIC_PRIO_BITS : u8 = 2 ;
# [ cfg ( feature = "rt" ) ] extern "C" { fn WDT ( ) ; fn RTC ( ) ; fn EIC ( ) ; fn FREQM ( ) ; fn TSENS ( ) ; fn NVMCTRL ( ) ; fn DMAC ( ) ; fn EVSYS ( ) ; fn SERCOM2 ( ) ; fn SERCOM3 ( ) ; fn SERCOM4 ( ) ; fn SERCOM5 ( ) ; fn CAN0 ( ) ; fn CAN1 ( ) ; fn TCC0 ( ) ; fn TCC1 ( ) ; fn TCC2 ( ) ; fn TC3 ( ) ; fn TC4 ( ) ; fn ADC0 ( ) ; fn ADC1 ( ) ; fn AC ( ) ; fn DAC ( ) ; fn SDADC ( ) ; fn PTC ( ) ; } # [ doc ( hidden ) ] pub union Vector { _handler : unsafe extern "C" fn ( ) , _reserved : u32 , } # [ cfg ( feature = "rt" ) ] # [ doc ( hidden ) ] # [ link_section = ".vector_table.interrupts" ] # [ no_mangle ] pub static __INTERRUPTS : [ Vector ; 31 ] = [ Vector { _reserved : 0 } , Vector { _handler : WDT } , Vector { _handler : RTC } , Vector { _handler : EIC } , Vector { _handler : FREQM } , Vector { _handler : TSENS } , Vector { _handler : NVMCTRL } , Vector { _handler : DMAC } , Vector { _handler : EVSYS } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : SERCOM2 } , Vector { _handler : SERCOM3 } , Vector { _handler : SERCOM4 } , Vector { _handler : SERCOM5 } , Vector { _handler : CAN0 } , Vector { _handler : CAN1 } , Vector { _handler : TCC0 } , Vector { _handler : TCC1 } , Vector { _handler : TCC2 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : TC3 } , Vector { _handler : TC4 } , Vector { _handler : ADC0 } , Vector { _handler : ADC1 } , Vector { _handler : AC } , Vector { _handler : DAC } , Vector { _handler : SDADC } , Vector { _handler : PTC } , ] ;
# [ doc = r"Enumeration of all the interrupts" ] # [ derive ( Copy , Clone , Debug ) ] pub enum Interrupt { # [ doc = "1 - WDT" ] WDT , # [ doc = "2 - RTC" ] RTC , # [ doc = "3 - EIC" ] EIC , # [ doc = "4 - FREQM" ] FREQM , # [ doc = "5 - TSENS" ] TSENS , # [ doc = "6 - NVMCTRL" ] NVMCTRL , # [ doc = "7 - DMAC" ] DMAC , # [ doc = "8 - EVSYS" ] EVSYS , # [ doc = "11 - SERCOM2" ] SERCOM2 , # [ doc = "12 - SERCOM3" ] SERCOM3 , # [ doc = "13 - SERCOM4" ] SERCOM4 , # [ doc = "14 - SERCOM5" ] SERCOM5 , # [ doc = "15 - CAN0" ] CAN0 , # [ doc = "16 - CAN1" ] CAN1 , # [ doc = "17 - TCC0" ] TCC0 , # [ doc = "18 - TCC1" ] TCC1 , # [ doc = "19 - TCC2" ] TCC2 , # [ doc = "23 - TC3" ] TC3 , # [ doc = "24 - TC4" ] TC4 , # [ doc = "25 - ADC0" ] ADC0 , # [ doc = "26 - ADC1" ] ADC1 , # [ doc = "27 - AC" ] AC , # [ doc = "28 - DAC" ] DAC , # [ doc = "29 - SDADC" ] SDADC , # [ doc = "30 - PTC" ] PTC , } unsafe impl bare_metal :: Nr for Interrupt { # [ inline ] fn nr ( & self ) -> u8 { match * self { Interrupt :: WDT => 1 , Interrupt :: RTC => 2 , Interrupt :: EIC => 3 , Interrupt :: FREQM => 4 , Interrupt :: TSENS => 5 , Interrupt :: NVMCTRL => 6 , Interrupt :: DMAC => 7 , Interrupt :: EVSYS => 8 , Interrupt :: SERCOM2 => 11 , Interrupt :: SERCOM3 => 12 , Interrupt :: SERCOM4 => 13 , Interrupt :: SERCOM5 => 14 , Interrupt :: CAN0 => 15 , Interrupt :: CAN1 => 16 , Interrupt :: TCC0 => 17 , Interrupt :: TCC1 => 18 , Interrupt :: TCC2 => 19 , Interrupt :: TC3 => 23 , Interrupt :: TC4 => 24 , Interrupt :: ADC0 => 25 , Interrupt :: ADC1 => 26 , Interrupt :: AC => 27 , Interrupt :: DAC => 28 , Interrupt :: SDADC => 29 , Interrupt :: PTC => 30 , } } }
pub use cortex_m :: peripheral :: Peripherals as CorePeripherals ; # [ cfg ( feature = "rt" ) ] pub use cortex_m_rt :: interrupt ; # [ cfg ( feature = "rt" ) ] pub use self :: Interrupt as interrupt ;
pub use cortex_m :: peripheral :: { CBP , CPUID , DCB , DWT , FPB , ITM , MPU , NVIC , SCB , SYST , TPIU , } ;
# [ allow ( unused_imports ) ] use generic :: * ; # [ doc = r"Common register and bit access and modify traits" ] pub mod generic { use core :: marker ; ///This trait shows that register has `read` method
 ///
 ///Registers marked with `Writable` can be also `modify`'ed
 pub trait Readable { } ///This trait shows that register has `write`, `write_with_zero` and `reset` method
 ///
 ///Registers marked with `Readable` can be also `modify`'ed
 pub trait Writable { } ///Reset value of the register
 ///
 ///This value is initial value for `write` method.
 ///It can be also directly writed to register by `reset` method.
 pub trait ResetValue { ///Register size
 type Type ; ///Reset value of the register
 fn reset_value ( ) -> Self :: Type ; } ///Converting enumerated values to bits
 pub trait ToBits < N > { ///Conversion method
 fn _bits ( & self ) -> N ; } ///This structure provides volatile access to register
 pub struct Reg < U , REG > { register : vcell :: VolatileCell < U > , _marker : marker :: PhantomData < REG > } unsafe impl < U : Send , REG > Send for Reg < U , REG > { } impl < U , REG > Reg < U , REG > where Self : Readable , U : Copy { ///Reads the contents of `Readable` register
 ///
 ///You can read the contents of a register in such way:
 ///```ignore
 ///let bits = periph.reg.read().bits();
 ///```
 ///or get the content of a particular field of a register.
 ///```ignore
 ///let reader = periph.reg.read();
 ///let bits = reader.field1().bits();
 ///let flag = reader.field2().bit_is_set();
 ///```
 # [ inline ( always ) ] pub fn read ( & self ) -> R < U , Self > { R { bits : self . register . get ( ) , _reg : marker :: PhantomData } } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy { ///Writes the reset value to `Writable` register
 ///
 ///Resets the register to its initial state
 # [ inline ( always ) ] pub fn reset ( & self ) { self . register . set ( Self :: reset_value ( ) ) } } impl < U , REG > Reg < U , REG > where Self : ResetValue < Type = U > + Writable , U : Copy { ///Writes bits to `Writable` register
 ///
 ///You can write raw bits into a register:
 ///```ignore
 ///periph.reg.write(|w| unsafe { w.bits(rawbits) });
 ///```
 ///or write only the fields you need:
 ///```ignore
 ///periph.reg.write(|w| w
 ///    .field1().bits(newfield1bits)
 ///    .field2().set_bit()
 ///    .field3().variant(VARIANT)
 ///);
 ///```
 ///Other fields will have reset value.
 # [ inline ( always ) ] pub fn write < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : Self :: reset_value ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Writable , U : Copy + Default { ///Writes Zero to `Writable` register
 ///
 ///Similar to `write`, but unused bits will contain 0.
 # [ inline ( always ) ] pub fn write_with_zero < F > ( & self , f : F ) where F : FnOnce ( & mut W < U , Self > ) -> & mut W < U , Self > { self . register . set ( f ( & mut W { bits : U :: default ( ) , _reg : marker :: PhantomData } ) . bits ) ; } } impl < U , REG > Reg < U , REG > where Self : Readable + Writable , U : Copy { ///Modifies the contents of the register
 ///
 ///E.g. to do a read-modify-write sequence to change parts of a register:
 ///```ignore
 ///periph.reg.modify(|r, w| unsafe { w.bits(
 ///   r.bits() | 3
 ///) });
 ///```
 ///or
 ///```ignore
 ///periph.reg.modify(|_, w| w
 ///    .field1().bits(newfield1bits)
 ///    .field2().set_bit()
 ///    .field3().variant(VARIANT)
 ///);
 ///```
 ///Other fields will have value they had before call `modify`.
 # [ inline ( always ) ] pub fn modify < F > ( & self , f : F ) where for < 'w > F : FnOnce ( & R < U , Self > , & 'w mut W < U , Self > ) -> & 'w mut W < U , Self > { let bits = self . register . get ( ) ; self . register . set ( f ( & R { bits , _reg : marker :: PhantomData } , & mut W { bits , _reg : marker :: PhantomData } ) . bits ) ; } } ///Register/field reader
 ///
 ///Result of the [`read`](Reg::read) method of a register.
 ///Also it can be used in the [`modify`](Reg::read) method
 pub struct R < U , T > { pub ( crate ) bits : U , _reg : marker :: PhantomData < T > } impl < U , T > R < U , T > where U : Copy { ///Create new instance of reader
 # [ inline ( always ) ] pub ( crate ) fn new ( bits : U ) -> Self { Self { bits , _reg : marker :: PhantomData } } ///Read raw bits from register/field
 # [ inline ( always ) ] pub fn bits ( & self ) -> U { self . bits } } impl < U , T , FI > PartialEq < FI > for R < U , T > where U : PartialEq , FI : ToBits < U > { # [ inline ( always ) ] fn eq ( & self , other : & FI ) -> bool { self . bits . eq ( & other . _bits ( ) ) } } impl < FI > R < bool , FI > { ///Value of the field as raw bits
 # [ inline ( always ) ] pub fn bit ( & self ) -> bool { self . bits } ///Returns `true` if the bit is clear (0)
 # [ inline ( always ) ] pub fn bit_is_clear ( & self ) -> bool { ! self . bit ( ) } ///Returns `true` if the bit is set (1)
 # [ inline ( always ) ] pub fn bit_is_set ( & self ) -> bool { self . bit ( ) } } ///Register writer
 ///
 ///Used as an argument to the closures in the [`write`](Reg::write) and [`modify`](Reg::modify) methods of the register
 pub struct W < U , REG > { ///Writable bits
 pub ( crate ) bits : U , _reg : marker :: PhantomData < REG > } impl < U , REG > W < U , REG > { ///Writes raw bits to the register
 # [ inline ( always ) ] pub unsafe fn bits ( & mut self , bits : U ) -> & mut Self { self . bits = bits ; self } } ///Used if enumerated values cover not the whole range
 # [ derive ( Clone , Copy , PartialEq ) ] pub enum Variant < U , T > { ///Expected variant
 Val ( T ) , ///Raw bits
 Res ( U ) , } }
# [ doc = "Analog Comparators" ] pub struct AC { _marker : PhantomData < * const ( ) > } unsafe impl Send for AC { } impl AC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const ac :: RegisterBlock { 0x4200_5000 as * const _ } } impl Deref for AC { type Target = ac :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * AC :: ptr ( ) } } }
# [ doc = "Analog Comparators" ] pub mod ac {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control A" ] pub ctrla : CTRLA , # [ doc = "0x01 - Control B" ] pub ctrlb : CTRLB , # [ doc = "0x02 - Event Control" ] pub evctrl : EVCTRL , # [ doc = "0x04 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x05 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x06 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x07 - Status A" ] pub statusa : STATUSA , # [ doc = "0x08 - Status B" ] pub statusb : STATUSB , # [ doc = "0x09 - Debug Control" ] pub dbgctrl : DBGCTRL , # [ doc = "0x0a - Window Control" ] pub winctrl : WINCTRL , _reserved10 : [ u8 ; 1usize ] , # [ doc = "0x0c - Scaler n" ] pub scaler : [ SCALER ; 4 ] , # [ doc = "0x10 - Comparator Control n" ] pub compctrl : [ COMPCTRL ; 4 ] , # [ doc = "0x20 - Synchronization Busy" ] pub syncbusy : SYNCBUSY , }
# [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control A" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
}
}
# [ doc = "Control B\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u8 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ;
# [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { }
# [ doc = "Control B" ] pub mod ctrlb {
# [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u8 , super :: CTRLB > ;
# [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Write proxy for field `START0`" ] pub struct START0_W < 'a > { w : & 'a mut W , } impl < 'a > START0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Write proxy for field `START1`" ] pub struct START1_W < 'a > { w : & 'a mut W , } impl < 'a > START1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Write proxy for field `START2`" ] pub struct START2_W < 'a > { w : & 'a mut W , } impl < 'a > START2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Write proxy for field `START3`" ] pub struct START3_W < 'a > { w : & 'a mut W , } impl < 'a > START3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
impl W {
# [ doc = "Bit 0 - Comparator 0 Start Comparison" ] # [ inline ( always ) ] pub fn start0 ( & mut self ) -> START0_W { START0_W { w : self } }
# [ doc = "Bit 1 - Comparator 1 Start Comparison" ] # [ inline ( always ) ] pub fn start1 ( & mut self ) -> START1_W { START1_W { w : self } }
# [ doc = "Bit 2 - Comparator 2 Start Comparison" ] # [ inline ( always ) ] pub fn start2 ( & mut self ) -> START2_W { START2_W { w : self } }
# [ doc = "Bit 3 - Comparator 3 Start Comparison" ] # [ inline ( always ) ] pub fn start3 ( & mut self ) -> START3_W { START3_W { w : self } }
}
}
# [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u16 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event Control" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u16 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u16 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `COMPEO0`" ] pub type COMPEO0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMPEO0`" ] pub struct COMPEO0_W < 'a > { w : & 'a mut W , } impl < 'a > COMPEO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `COMPEO1`" ] pub type COMPEO1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMPEO1`" ] pub struct COMPEO1_W < 'a > { w : & 'a mut W , } impl < 'a > COMPEO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `COMPEO2`" ] pub type COMPEO2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMPEO2`" ] pub struct COMPEO2_W < 'a > { w : & 'a mut W , } impl < 'a > COMPEO2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `COMPEO3`" ] pub type COMPEO3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMPEO3`" ] pub struct COMPEO3_W < 'a > { w : & 'a mut W , } impl < 'a > COMPEO3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `WINEO0`" ] pub type WINEO0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINEO0`" ] pub struct WINEO0_W < 'a > { w : & 'a mut W , } impl < 'a > WINEO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `WINEO1`" ] pub type WINEO1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINEO1`" ] pub struct WINEO1_W < 'a > { w : & 'a mut W , } impl < 'a > WINEO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `COMPEI0`" ] pub type COMPEI0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMPEI0`" ] pub struct COMPEI0_W < 'a > { w : & 'a mut W , } impl < 'a > COMPEI0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `COMPEI1`" ] pub type COMPEI1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMPEI1`" ] pub struct COMPEI1_W < 'a > { w : & 'a mut W , } impl < 'a > COMPEI1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `COMPEI2`" ] pub type COMPEI2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMPEI2`" ] pub struct COMPEI2_W < 'a > { w : & 'a mut W , } impl < 'a > COMPEI2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `COMPEI3`" ] pub type COMPEI3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMPEI3`" ] pub struct COMPEI3_W < 'a > { w : & 'a mut W , } impl < 'a > COMPEI3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `INVEI0`" ] pub type INVEI0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEI0`" ] pub struct INVEI0_W < 'a > { w : & 'a mut W , } impl < 'a > INVEI0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `INVEI1`" ] pub type INVEI1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEI1`" ] pub struct INVEI1_W < 'a > { w : & 'a mut W , } impl < 'a > INVEI1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `INVEI2`" ] pub type INVEI2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEI2`" ] pub struct INVEI2_W < 'a > { w : & 'a mut W , } impl < 'a > INVEI2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `INVEI3`" ] pub type INVEI3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEI3`" ] pub struct INVEI3_W < 'a > { w : & 'a mut W , } impl < 'a > INVEI3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator 0 Event Output Enable" ] # [ inline ( always ) ] pub fn compeo0 ( & self ) -> COMPEO0_R { COMPEO0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator 1 Event Output Enable" ] # [ inline ( always ) ] pub fn compeo1 ( & self ) -> COMPEO1_R { COMPEO1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator 2 Event Output Enable" ] # [ inline ( always ) ] pub fn compeo2 ( & self ) -> COMPEO2_R { COMPEO2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Comparator 3 Event Output Enable" ] # [ inline ( always ) ] pub fn compeo3 ( & self ) -> COMPEO3_R { COMPEO3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Window 0 Event Output Enable" ] # [ inline ( always ) ] pub fn wineo0 ( & self ) -> WINEO0_R { WINEO0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Window 1 Event Output Enable" ] # [ inline ( always ) ] pub fn wineo1 ( & self ) -> WINEO1_R { WINEO1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Comparator 0 Event Input Enable" ] # [ inline ( always ) ] pub fn compei0 ( & self ) -> COMPEI0_R { COMPEI0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Comparator 1 Event Input Enable" ] # [ inline ( always ) ] pub fn compei1 ( & self ) -> COMPEI1_R { COMPEI1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Comparator 2 Event Input Enable" ] # [ inline ( always ) ] pub fn compei2 ( & self ) -> COMPEI2_R { COMPEI2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Comparator 3 Event Input Enable" ] # [ inline ( always ) ] pub fn compei3 ( & self ) -> COMPEI3_R { COMPEI3_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Comparator 0 Input Event Invert Enable" ] # [ inline ( always ) ] pub fn invei0 ( & self ) -> INVEI0_R { INVEI0_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Comparator 1 Input Event Invert Enable" ] # [ inline ( always ) ] pub fn invei1 ( & self ) -> INVEI1_R { INVEI1_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Comparator 2 Input Event Invert Enable" ] # [ inline ( always ) ] pub fn invei2 ( & self ) -> INVEI2_R { INVEI2_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Comparator 3 Input Event Invert Enable" ] # [ inline ( always ) ] pub fn invei3 ( & self ) -> INVEI3_R { INVEI3_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Comparator 0 Event Output Enable" ] # [ inline ( always ) ] pub fn compeo0 ( & mut self ) -> COMPEO0_W { COMPEO0_W { w : self } }
# [ doc = "Bit 1 - Comparator 1 Event Output Enable" ] # [ inline ( always ) ] pub fn compeo1 ( & mut self ) -> COMPEO1_W { COMPEO1_W { w : self } }
# [ doc = "Bit 2 - Comparator 2 Event Output Enable" ] # [ inline ( always ) ] pub fn compeo2 ( & mut self ) -> COMPEO2_W { COMPEO2_W { w : self } }
# [ doc = "Bit 3 - Comparator 3 Event Output Enable" ] # [ inline ( always ) ] pub fn compeo3 ( & mut self ) -> COMPEO3_W { COMPEO3_W { w : self } }
# [ doc = "Bit 4 - Window 0 Event Output Enable" ] # [ inline ( always ) ] pub fn wineo0 ( & mut self ) -> WINEO0_W { WINEO0_W { w : self } }
# [ doc = "Bit 5 - Window 1 Event Output Enable" ] # [ inline ( always ) ] pub fn wineo1 ( & mut self ) -> WINEO1_W { WINEO1_W { w : self } }
# [ doc = "Bit 8 - Comparator 0 Event Input Enable" ] # [ inline ( always ) ] pub fn compei0 ( & mut self ) -> COMPEI0_W { COMPEI0_W { w : self } }
# [ doc = "Bit 9 - Comparator 1 Event Input Enable" ] # [ inline ( always ) ] pub fn compei1 ( & mut self ) -> COMPEI1_W { COMPEI1_W { w : self } }
# [ doc = "Bit 10 - Comparator 2 Event Input Enable" ] # [ inline ( always ) ] pub fn compei2 ( & mut self ) -> COMPEI2_W { COMPEI2_W { w : self } }
# [ doc = "Bit 11 - Comparator 3 Event Input Enable" ] # [ inline ( always ) ] pub fn compei3 ( & mut self ) -> COMPEI3_W { COMPEI3_W { w : self } }
# [ doc = "Bit 12 - Comparator 0 Input Event Invert Enable" ] # [ inline ( always ) ] pub fn invei0 ( & mut self ) -> INVEI0_W { INVEI0_W { w : self } }
# [ doc = "Bit 13 - Comparator 1 Input Event Invert Enable" ] # [ inline ( always ) ] pub fn invei1 ( & mut self ) -> INVEI1_W { INVEI1_W { w : self } }
# [ doc = "Bit 14 - Comparator 2 Input Event Invert Enable" ] # [ inline ( always ) ] pub fn invei2 ( & mut self ) -> INVEI2_W { INVEI2_W { w : self } }
# [ doc = "Bit 15 - Comparator 3 Input Event Invert Enable" ] # [ inline ( always ) ] pub fn invei3 ( & mut self ) -> INVEI3_W { INVEI3_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `COMP0`" ] pub type COMP0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP0`" ] pub struct COMP0_W < 'a > { w : & 'a mut W , } impl < 'a > COMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `COMP1`" ] pub type COMP1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP1`" ] pub struct COMP1_W < 'a > { w : & 'a mut W , } impl < 'a > COMP1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `COMP2`" ] pub type COMP2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP2`" ] pub struct COMP2_W < 'a > { w : & 'a mut W , } impl < 'a > COMP2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `COMP3`" ] pub type COMP3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP3`" ] pub struct COMP3_W < 'a > { w : & 'a mut W , } impl < 'a > COMP3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `WIN0`" ] pub type WIN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WIN0`" ] pub struct WIN0_W < 'a > { w : & 'a mut W , } impl < 'a > WIN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `WIN1`" ] pub type WIN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WIN1`" ] pub struct WIN1_W < 'a > { w : & 'a mut W , } impl < 'a > WIN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp0 ( & self ) -> COMP0_R { COMP0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp1 ( & self ) -> COMP1_R { COMP1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp2 ( & self ) -> COMP2_R { COMP2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Comparator 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp3 ( & self ) -> COMP3_R { COMP3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Window 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn win0 ( & self ) -> WIN0_R { WIN0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Window 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn win1 ( & self ) -> WIN1_R { WIN1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Comparator 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp0 ( & mut self ) -> COMP0_W { COMP0_W { w : self } }
# [ doc = "Bit 1 - Comparator 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp1 ( & mut self ) -> COMP1_W { COMP1_W { w : self } }
# [ doc = "Bit 2 - Comparator 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp2 ( & mut self ) -> COMP2_W { COMP2_W { w : self } }
# [ doc = "Bit 3 - Comparator 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp3 ( & mut self ) -> COMP3_W { COMP3_W { w : self } }
# [ doc = "Bit 4 - Window 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn win0 ( & mut self ) -> WIN0_W { WIN0_W { w : self } }
# [ doc = "Bit 5 - Window 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn win1 ( & mut self ) -> WIN1_W { WIN1_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `COMP0`" ] pub type COMP0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP0`" ] pub struct COMP0_W < 'a > { w : & 'a mut W , } impl < 'a > COMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `COMP1`" ] pub type COMP1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP1`" ] pub struct COMP1_W < 'a > { w : & 'a mut W , } impl < 'a > COMP1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `COMP2`" ] pub type COMP2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP2`" ] pub struct COMP2_W < 'a > { w : & 'a mut W , } impl < 'a > COMP2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `COMP3`" ] pub type COMP3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP3`" ] pub struct COMP3_W < 'a > { w : & 'a mut W , } impl < 'a > COMP3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `WIN0`" ] pub type WIN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WIN0`" ] pub struct WIN0_W < 'a > { w : & 'a mut W , } impl < 'a > WIN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `WIN1`" ] pub type WIN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WIN1`" ] pub struct WIN1_W < 'a > { w : & 'a mut W , } impl < 'a > WIN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp0 ( & self ) -> COMP0_R { COMP0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp1 ( & self ) -> COMP1_R { COMP1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp2 ( & self ) -> COMP2_R { COMP2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Comparator 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp3 ( & self ) -> COMP3_R { COMP3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Window 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn win0 ( & self ) -> WIN0_R { WIN0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Window 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn win1 ( & self ) -> WIN1_R { WIN1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Comparator 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp0 ( & mut self ) -> COMP0_W { COMP0_W { w : self } }
# [ doc = "Bit 1 - Comparator 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp1 ( & mut self ) -> COMP1_W { COMP1_W { w : self } }
# [ doc = "Bit 2 - Comparator 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp2 ( & mut self ) -> COMP2_W { COMP2_W { w : self } }
# [ doc = "Bit 3 - Comparator 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn comp3 ( & mut self ) -> COMP3_W { COMP3_W { w : self } }
# [ doc = "Bit 4 - Window 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn win0 ( & mut self ) -> WIN0_W { WIN0_W { w : self } }
# [ doc = "Bit 5 - Window 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn win1 ( & mut self ) -> WIN1_W { WIN1_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `COMP0`" ] pub type COMP0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP0`" ] pub struct COMP0_W < 'a > { w : & 'a mut W , } impl < 'a > COMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `COMP1`" ] pub type COMP1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP1`" ] pub struct COMP1_W < 'a > { w : & 'a mut W , } impl < 'a > COMP1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `COMP2`" ] pub type COMP2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP2`" ] pub struct COMP2_W < 'a > { w : & 'a mut W , } impl < 'a > COMP2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `COMP3`" ] pub type COMP3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COMP3`" ] pub struct COMP3_W < 'a > { w : & 'a mut W , } impl < 'a > COMP3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `WIN0`" ] pub type WIN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WIN0`" ] pub struct WIN0_W < 'a > { w : & 'a mut W , } impl < 'a > WIN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `WIN1`" ] pub type WIN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WIN1`" ] pub struct WIN1_W < 'a > { w : & 'a mut W , } impl < 'a > WIN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Comparator 0" ] # [ inline ( always ) ] pub fn comp0 ( & self ) -> COMP0_R { COMP0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator 1" ] # [ inline ( always ) ] pub fn comp1 ( & self ) -> COMP1_R { COMP1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator 2" ] # [ inline ( always ) ] pub fn comp2 ( & self ) -> COMP2_R { COMP2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Comparator 3" ] # [ inline ( always ) ] pub fn comp3 ( & self ) -> COMP3_R { COMP3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Window 0" ] # [ inline ( always ) ] pub fn win0 ( & self ) -> WIN0_R { WIN0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Window 1" ] # [ inline ( always ) ] pub fn win1 ( & self ) -> WIN1_R { WIN1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Comparator 0" ] # [ inline ( always ) ] pub fn comp0 ( & mut self ) -> COMP0_W { COMP0_W { w : self } }
# [ doc = "Bit 1 - Comparator 1" ] # [ inline ( always ) ] pub fn comp1 ( & mut self ) -> COMP1_W { COMP1_W { w : self } }
# [ doc = "Bit 2 - Comparator 2" ] # [ inline ( always ) ] pub fn comp2 ( & mut self ) -> COMP2_W { COMP2_W { w : self } }
# [ doc = "Bit 3 - Comparator 3" ] # [ inline ( always ) ] pub fn comp3 ( & mut self ) -> COMP3_W { COMP3_W { w : self } }
# [ doc = "Bit 4 - Window 0" ] # [ inline ( always ) ] pub fn win0 ( & mut self ) -> WIN0_W { WIN0_W { w : self } }
# [ doc = "Bit 5 - Window 1" ] # [ inline ( always ) ] pub fn win1 ( & mut self ) -> WIN1_W { WIN1_W { w : self } }
}
}
# [ doc = "Status A\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [statusa](statusa) module" ] pub type STATUSA = crate :: Reg < u8 , _STATUSA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUSA ;
# [ doc = "`read()` method returns [statusa::R](statusa::R) reader structure" ] impl crate :: Readable for STATUSA { }
# [ doc = "Status A" ] pub mod statusa {
# [ doc = "Reader of register STATUSA" ] pub type R = crate :: R < u8 , super :: STATUSA > ;
# [ doc = "Reader of field `STATE0`" ] pub type STATE0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `STATE1`" ] pub type STATE1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `STATE2`" ] pub type STATE2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `STATE3`" ] pub type STATE3_R = crate :: R < bool , bool > ;
# [ doc = "Possible values of the field `WSTATE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WSTATE0_A { # [ doc = "Signal is above window" ] ABOVE , # [ doc = "Signal is inside window" ] INSIDE , # [ doc = "Signal is below window" ] BELOW }
impl crate :: ToBits < u8 > for WSTATE0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WSTATE0_A :: ABOVE => 0 , WSTATE0_A :: INSIDE => 1 , WSTATE0_A :: BELOW => 2 } } }
# [ doc = "Reader of field `WSTATE0`" ] pub type WSTATE0_R = crate :: R < u8 , WSTATE0_A > ; impl WSTATE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , WSTATE0_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( WSTATE0_A :: ABOVE ) , 1 => Val ( WSTATE0_A :: INSIDE ) , 2 => Val ( WSTATE0_A :: BELOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `ABOVE`" ] # [ inline ( always ) ] pub fn is_above ( & self ) -> bool { * self == WSTATE0_A :: ABOVE } # [ doc = "Checks if the value of the field is `INSIDE`" ] # [ inline ( always ) ] pub fn is_inside ( & self ) -> bool { * self == WSTATE0_A :: INSIDE } # [ doc = "Checks if the value of the field is `BELOW`" ] # [ inline ( always ) ] pub fn is_below ( & self ) -> bool { * self == WSTATE0_A :: BELOW } }
# [ doc = "Possible values of the field `WSTATE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WSTATE1_A { # [ doc = "Signal is above window" ] ABOVE , # [ doc = "Signal is inside window" ] INSIDE , # [ doc = "Signal is below window" ] BELOW }
impl crate :: ToBits < u8 > for WSTATE1_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WSTATE1_A :: ABOVE => 0 , WSTATE1_A :: INSIDE => 1 , WSTATE1_A :: BELOW => 2 } } }
# [ doc = "Reader of field `WSTATE1`" ] pub type WSTATE1_R = crate :: R < u8 , WSTATE1_A > ; impl WSTATE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , WSTATE1_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( WSTATE1_A :: ABOVE ) , 1 => Val ( WSTATE1_A :: INSIDE ) , 2 => Val ( WSTATE1_A :: BELOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `ABOVE`" ] # [ inline ( always ) ] pub fn is_above ( & self ) -> bool { * self == WSTATE1_A :: ABOVE } # [ doc = "Checks if the value of the field is `INSIDE`" ] # [ inline ( always ) ] pub fn is_inside ( & self ) -> bool { * self == WSTATE1_A :: INSIDE } # [ doc = "Checks if the value of the field is `BELOW`" ] # [ inline ( always ) ] pub fn is_below ( & self ) -> bool { * self == WSTATE1_A :: BELOW } }
impl R {
# [ doc = "Bit 0 - Comparator 0 Current State" ] # [ inline ( always ) ] pub fn state0 ( & self ) -> STATE0_R { STATE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator 1 Current State" ] # [ inline ( always ) ] pub fn state1 ( & self ) -> STATE1_R { STATE1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator 2 Current State" ] # [ inline ( always ) ] pub fn state2 ( & self ) -> STATE2_R { STATE2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Comparator 3 Current State" ] # [ inline ( always ) ] pub fn state3 ( & self ) -> STATE3_R { STATE3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Window 0 Current State" ] # [ inline ( always ) ] pub fn wstate0 ( & self ) -> WSTATE0_R { WSTATE0_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 6:7 - Window 1 Current State" ] # [ inline ( always ) ] pub fn wstate1 ( & self ) -> WSTATE1_R { WSTATE1_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
}
}
# [ doc = "Status B\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [statusb](statusb) module" ] pub type STATUSB = crate :: Reg < u8 , _STATUSB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUSB ;
# [ doc = "`read()` method returns [statusb::R](statusb::R) reader structure" ] impl crate :: Readable for STATUSB { }
# [ doc = "Status B" ] pub mod statusb {
# [ doc = "Reader of register STATUSB" ] pub type R = crate :: R < u8 , super :: STATUSB > ;
# [ doc = "Reader of field `READY0`" ] pub type READY0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `READY1`" ] pub type READY1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `READY2`" ] pub type READY2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `READY3`" ] pub type READY3_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Comparator 0 Ready" ] # [ inline ( always ) ] pub fn ready0 ( & self ) -> READY0_R { READY0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Comparator 1 Ready" ] # [ inline ( always ) ] pub fn ready1 ( & self ) -> READY1_R { READY1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Comparator 2 Ready" ] # [ inline ( always ) ] pub fn ready2 ( & self ) -> READY2_R { READY2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Comparator 3 Ready" ] # [ inline ( always ) ] pub fn ready3 ( & self ) -> READY3_R { READY3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ;
# [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { }
# [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { }
# [ doc = "Debug Control" ] pub mod dbgctrl {
# [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ;
# [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ;
# [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } }
}
}
# [ doc = "Window Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [winctrl](winctrl) module" ] pub type WINCTRL = crate :: Reg < u8 , _WINCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WINCTRL ;
# [ doc = "`read()` method returns [winctrl::R](winctrl::R) reader structure" ] impl crate :: Readable for WINCTRL { }
# [ doc = "`write(|w| ..)` method takes [winctrl::W](winctrl::W) writer structure" ] impl crate :: Writable for WINCTRL { }
# [ doc = "Window Control" ] pub mod winctrl {
# [ doc = "Reader of register WINCTRL" ] pub type R = crate :: R < u8 , super :: WINCTRL > ;
# [ doc = "Writer for register WINCTRL" ] pub type W = crate :: W < u8 , super :: WINCTRL > ;
# [ doc = "Register WINCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WINCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WEN0`" ] pub type WEN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WEN0`" ] pub struct WEN0_W < 'a > { w : & 'a mut W , } impl < 'a > WEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Possible values of the field `WINTSEL0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WINTSEL0_A { # [ doc = "Interrupt on signal above window" ] ABOVE , # [ doc = "Interrupt on signal inside window" ] INSIDE , # [ doc = "Interrupt on signal below window" ] BELOW , # [ doc = "Interrupt on signal outside window" ] OUTSIDE }
impl crate :: ToBits < u8 > for WINTSEL0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WINTSEL0_A :: ABOVE => 0 , WINTSEL0_A :: INSIDE => 1 , WINTSEL0_A :: BELOW => 2 , WINTSEL0_A :: OUTSIDE => 3 } } }
# [ doc = "Reader of field `WINTSEL0`" ] pub type WINTSEL0_R = crate :: R < u8 , WINTSEL0_A > ; impl WINTSEL0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WINTSEL0_A { match self . bits { 0 => WINTSEL0_A :: ABOVE , 1 => WINTSEL0_A :: INSIDE , 2 => WINTSEL0_A :: BELOW , 3 => WINTSEL0_A :: OUTSIDE , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ABOVE`" ] # [ inline ( always ) ] pub fn is_above ( & self ) -> bool { * self == WINTSEL0_A :: ABOVE } # [ doc = "Checks if the value of the field is `INSIDE`" ] # [ inline ( always ) ] pub fn is_inside ( & self ) -> bool { * self == WINTSEL0_A :: INSIDE } # [ doc = "Checks if the value of the field is `BELOW`" ] # [ inline ( always ) ] pub fn is_below ( & self ) -> bool { * self == WINTSEL0_A :: BELOW } # [ doc = "Checks if the value of the field is `OUTSIDE`" ] # [ inline ( always ) ] pub fn is_outside ( & self ) -> bool { * self == WINTSEL0_A :: OUTSIDE } }
# [ doc = "Write proxy for field `WINTSEL0`" ] pub struct WINTSEL0_W < 'a > { w : & 'a mut W , } impl < 'a > WINTSEL0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WINTSEL0_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Interrupt on signal above window" ] # [ inline ( always ) ] pub fn above ( self ) -> & 'a mut W { self . variant ( WINTSEL0_A :: ABOVE ) } # [ doc = "Interrupt on signal inside window" ] # [ inline ( always ) ] pub fn inside ( self ) -> & 'a mut W { self . variant ( WINTSEL0_A :: INSIDE ) } # [ doc = "Interrupt on signal below window" ] # [ inline ( always ) ] pub fn below ( self ) -> & 'a mut W { self . variant ( WINTSEL0_A :: BELOW ) } # [ doc = "Interrupt on signal outside window" ] # [ inline ( always ) ] pub fn outside ( self ) -> & 'a mut W { self . variant ( WINTSEL0_A :: OUTSIDE ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 1 ) ) | ( ( ( value as u8 ) & 0x03 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WEN1`" ] pub type WEN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WEN1`" ] pub struct WEN1_W < 'a > { w : & 'a mut W , } impl < 'a > WEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Possible values of the field `WINTSEL1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WINTSEL1_A { # [ doc = "Interrupt on signal above window" ] ABOVE , # [ doc = "Interrupt on signal inside window" ] INSIDE , # [ doc = "Interrupt on signal below window" ] BELOW , # [ doc = "Interrupt on signal outside window" ] OUTSIDE }
impl crate :: ToBits < u8 > for WINTSEL1_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WINTSEL1_A :: ABOVE => 0 , WINTSEL1_A :: INSIDE => 1 , WINTSEL1_A :: BELOW => 2 , WINTSEL1_A :: OUTSIDE => 3 } } }
# [ doc = "Reader of field `WINTSEL1`" ] pub type WINTSEL1_R = crate :: R < u8 , WINTSEL1_A > ; impl WINTSEL1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WINTSEL1_A { match self . bits { 0 => WINTSEL1_A :: ABOVE , 1 => WINTSEL1_A :: INSIDE , 2 => WINTSEL1_A :: BELOW , 3 => WINTSEL1_A :: OUTSIDE , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `ABOVE`" ] # [ inline ( always ) ] pub fn is_above ( & self ) -> bool { * self == WINTSEL1_A :: ABOVE } # [ doc = "Checks if the value of the field is `INSIDE`" ] # [ inline ( always ) ] pub fn is_inside ( & self ) -> bool { * self == WINTSEL1_A :: INSIDE } # [ doc = "Checks if the value of the field is `BELOW`" ] # [ inline ( always ) ] pub fn is_below ( & self ) -> bool { * self == WINTSEL1_A :: BELOW } # [ doc = "Checks if the value of the field is `OUTSIDE`" ] # [ inline ( always ) ] pub fn is_outside ( & self ) -> bool { * self == WINTSEL1_A :: OUTSIDE } }
# [ doc = "Write proxy for field `WINTSEL1`" ] pub struct WINTSEL1_W < 'a > { w : & 'a mut W , } impl < 'a > WINTSEL1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WINTSEL1_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Interrupt on signal above window" ] # [ inline ( always ) ] pub fn above ( self ) -> & 'a mut W { self . variant ( WINTSEL1_A :: ABOVE ) } # [ doc = "Interrupt on signal inside window" ] # [ inline ( always ) ] pub fn inside ( self ) -> & 'a mut W { self . variant ( WINTSEL1_A :: INSIDE ) } # [ doc = "Interrupt on signal below window" ] # [ inline ( always ) ] pub fn below ( self ) -> & 'a mut W { self . variant ( WINTSEL1_A :: BELOW ) } # [ doc = "Interrupt on signal outside window" ] # [ inline ( always ) ] pub fn outside ( self ) -> & 'a mut W { self . variant ( WINTSEL1_A :: OUTSIDE ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 5 ) ) | ( ( ( value as u8 ) & 0x03 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Window 0 Mode Enable" ] # [ inline ( always ) ] pub fn wen0 ( & self ) -> WEN0_R { WEN0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bits 1:2 - Window 0 Interrupt Selection" ] # [ inline ( always ) ] pub fn wintsel0 ( & self ) -> WINTSEL0_R { WINTSEL0_R :: new ( ( ( self . bits >> 1 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 4 - Window 1 Mode Enable" ] # [ inline ( always ) ] pub fn wen1 ( & self ) -> WEN1_R { WEN1_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:6 - Window 1 Interrupt Selection" ] # [ inline ( always ) ] pub fn wintsel1 ( & self ) -> WINTSEL1_R { WINTSEL1_R :: new ( ( ( self . bits >> 5 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Window 0 Mode Enable" ] # [ inline ( always ) ] pub fn wen0 ( & mut self ) -> WEN0_W { WEN0_W { w : self } }
# [ doc = "Bits 1:2 - Window 0 Interrupt Selection" ] # [ inline ( always ) ] pub fn wintsel0 ( & mut self ) -> WINTSEL0_W { WINTSEL0_W { w : self } }
# [ doc = "Bit 4 - Window 1 Mode Enable" ] # [ inline ( always ) ] pub fn wen1 ( & mut self ) -> WEN1_W { WEN1_W { w : self } }
# [ doc = "Bits 5:6 - Window 1 Interrupt Selection" ] # [ inline ( always ) ] pub fn wintsel1 ( & mut self ) -> WINTSEL1_W { WINTSEL1_W { w : self } }
}
}
# [ doc = "Scaler n\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [scaler](scaler) module" ] pub type SCALER = crate :: Reg < u8 , _SCALER > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SCALER ;
# [ doc = "`read()` method returns [scaler::R](scaler::R) reader structure" ] impl crate :: Readable for SCALER { }
# [ doc = "`write(|w| ..)` method takes [scaler::W](scaler::W) writer structure" ] impl crate :: Writable for SCALER { }
# [ doc = "Scaler n" ] pub mod scaler {
# [ doc = "Reader of register SCALER[%s]" ] pub type R = crate :: R < u8 , super :: SCALER > ;
# [ doc = "Writer for register SCALER[%s]" ] pub type W = crate :: W < u8 , super :: SCALER > ;
# [ doc = "Register SCALER[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SCALER { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `VALUE`" ] pub type VALUE_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `VALUE`" ] pub struct VALUE_W < 'a > { w : & 'a mut W , } impl < 'a > VALUE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u8 ) & 0x3f ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Scaler Value" ] # [ inline ( always ) ] pub fn value ( & self ) -> VALUE_R { VALUE_R :: new ( ( self . bits & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:5 - Scaler Value" ] # [ inline ( always ) ] pub fn value ( & mut self ) -> VALUE_W { VALUE_W { w : self } }
}
}
# [ doc = "Comparator Control n\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [compctrl](compctrl) module" ] pub type COMPCTRL = crate :: Reg < u32 , _COMPCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COMPCTRL ;
# [ doc = "`read()` method returns [compctrl::R](compctrl::R) reader structure" ] impl crate :: Readable for COMPCTRL { }
# [ doc = "`write(|w| ..)` method takes [compctrl::W](compctrl::W) writer structure" ] impl crate :: Writable for COMPCTRL { }
# [ doc = "Comparator Control n" ] pub mod compctrl {
# [ doc = "Reader of register COMPCTRL[%s]" ] pub type R = crate :: R < u32 , super :: COMPCTRL > ;
# [ doc = "Writer for register COMPCTRL[%s]" ] pub type W = crate :: W < u32 , super :: COMPCTRL > ;
# [ doc = "Register COMPCTRL[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COMPCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `SINGLE`" ] pub type SINGLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SINGLE`" ] pub struct SINGLE_W < 'a > { w : & 'a mut W , } impl < 'a > SINGLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `INTSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INTSEL_A { # [ doc = "Interrupt on comparator output toggle" ] TOGGLE , # [ doc = "Interrupt on comparator output rising" ] RISING , # [ doc = "Interrupt on comparator output falling" ] FALLING , # [ doc = "Interrupt on end of comparison (single-shot mode only)" ] EOC }
impl crate :: ToBits < u8 > for INTSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { INTSEL_A :: TOGGLE => 0 , INTSEL_A :: RISING => 1 , INTSEL_A :: FALLING => 2 , INTSEL_A :: EOC => 3 } } }
# [ doc = "Reader of field `INTSEL`" ] pub type INTSEL_R = crate :: R < u8 , INTSEL_A > ; impl INTSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> INTSEL_A { match self . bits { 0 => INTSEL_A :: TOGGLE , 1 => INTSEL_A :: RISING , 2 => INTSEL_A :: FALLING , 3 => INTSEL_A :: EOC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `TOGGLE`" ] # [ inline ( always ) ] pub fn is_toggle ( & self ) -> bool { * self == INTSEL_A :: TOGGLE } # [ doc = "Checks if the value of the field is `RISING`" ] # [ inline ( always ) ] pub fn is_rising ( & self ) -> bool { * self == INTSEL_A :: RISING } # [ doc = "Checks if the value of the field is `FALLING`" ] # [ inline ( always ) ] pub fn is_falling ( & self ) -> bool { * self == INTSEL_A :: FALLING } # [ doc = "Checks if the value of the field is `EOC`" ] # [ inline ( always ) ] pub fn is_eoc ( & self ) -> bool { * self == INTSEL_A :: EOC } }
# [ doc = "Write proxy for field `INTSEL`" ] pub struct INTSEL_W < 'a > { w : & 'a mut W , } impl < 'a > INTSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : INTSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Interrupt on comparator output toggle" ] # [ inline ( always ) ] pub fn toggle ( self ) -> & 'a mut W { self . variant ( INTSEL_A :: TOGGLE ) } # [ doc = "Interrupt on comparator output rising" ] # [ inline ( always ) ] pub fn rising ( self ) -> & 'a mut W { self . variant ( INTSEL_A :: RISING ) } # [ doc = "Interrupt on comparator output falling" ] # [ inline ( always ) ] pub fn falling ( self ) -> & 'a mut W { self . variant ( INTSEL_A :: FALLING ) } # [ doc = "Interrupt on end of comparison (single-shot mode only)" ] # [ inline ( always ) ] pub fn eoc ( self ) -> & 'a mut W { self . variant ( INTSEL_A :: EOC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 3 ) ) | ( ( ( value as u32 ) & 0x03 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Possible values of the field `MUXNEG`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MUXNEG_A { # [ doc = "I/O pin 0" ] PIN0 , # [ doc = "I/O pin 1" ] PIN1 , # [ doc = "I/O pin 2" ] PIN2 , # [ doc = "I/O pin 3" ] PIN3 , # [ doc = "Ground" ] GND , # [ doc = "VDD scaler" ] VSCALE , # [ doc = "Internal bandgap voltage" ] BANDGAP , # [ doc = "DAC output" ] DAC }
impl crate :: ToBits < u8 > for MUXNEG_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MUXNEG_A :: PIN0 => 0 , MUXNEG_A :: PIN1 => 1 , MUXNEG_A :: PIN2 => 2 , MUXNEG_A :: PIN3 => 3 , MUXNEG_A :: GND => 4 , MUXNEG_A :: VSCALE => 5 , MUXNEG_A :: BANDGAP => 6 , MUXNEG_A :: DAC => 7 } } }
# [ doc = "Reader of field `MUXNEG`" ] pub type MUXNEG_R = crate :: R < u8 , MUXNEG_A > ; impl MUXNEG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MUXNEG_A { match self . bits { 0 => MUXNEG_A :: PIN0 , 1 => MUXNEG_A :: PIN1 , 2 => MUXNEG_A :: PIN2 , 3 => MUXNEG_A :: PIN3 , 4 => MUXNEG_A :: GND , 5 => MUXNEG_A :: VSCALE , 6 => MUXNEG_A :: BANDGAP , 7 => MUXNEG_A :: DAC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `PIN0`" ] # [ inline ( always ) ] pub fn is_pin0 ( & self ) -> bool { * self == MUXNEG_A :: PIN0 } # [ doc = "Checks if the value of the field is `PIN1`" ] # [ inline ( always ) ] pub fn is_pin1 ( & self ) -> bool { * self == MUXNEG_A :: PIN1 } # [ doc = "Checks if the value of the field is `PIN2`" ] # [ inline ( always ) ] pub fn is_pin2 ( & self ) -> bool { * self == MUXNEG_A :: PIN2 } # [ doc = "Checks if the value of the field is `PIN3`" ] # [ inline ( always ) ] pub fn is_pin3 ( & self ) -> bool { * self == MUXNEG_A :: PIN3 } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == MUXNEG_A :: GND } # [ doc = "Checks if the value of the field is `VSCALE`" ] # [ inline ( always ) ] pub fn is_vscale ( & self ) -> bool { * self == MUXNEG_A :: VSCALE } # [ doc = "Checks if the value of the field is `BANDGAP`" ] # [ inline ( always ) ] pub fn is_bandgap ( & self ) -> bool { * self == MUXNEG_A :: BANDGAP } # [ doc = "Checks if the value of the field is `DAC`" ] # [ inline ( always ) ] pub fn is_dac ( & self ) -> bool { * self == MUXNEG_A :: DAC } }
# [ doc = "Write proxy for field `MUXNEG`" ] pub struct MUXNEG_W < 'a > { w : & 'a mut W , } impl < 'a > MUXNEG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MUXNEG_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "I/O pin 0" ] # [ inline ( always ) ] pub fn pin0 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: PIN0 ) } # [ doc = "I/O pin 1" ] # [ inline ( always ) ] pub fn pin1 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: PIN1 ) } # [ doc = "I/O pin 2" ] # [ inline ( always ) ] pub fn pin2 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: PIN2 ) } # [ doc = "I/O pin 3" ] # [ inline ( always ) ] pub fn pin3 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: PIN3 ) } # [ doc = "Ground" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: GND ) } # [ doc = "VDD scaler" ] # [ inline ( always ) ] pub fn vscale ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: VSCALE ) } # [ doc = "Internal bandgap voltage" ] # [ inline ( always ) ] pub fn bandgap ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: BANDGAP ) } # [ doc = "DAC output" ] # [ inline ( always ) ] pub fn dac ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: DAC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u32 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Possible values of the field `MUXPOS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MUXPOS_A { # [ doc = "I/O pin 0" ] PIN0 , # [ doc = "I/O pin 1" ] PIN1 , # [ doc = "I/O pin 2" ] PIN2 , # [ doc = "I/O pin 3" ] PIN3 , # [ doc = "VDD Scaler" ] VSCALE }
impl crate :: ToBits < u8 > for MUXPOS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MUXPOS_A :: PIN0 => 0 , MUXPOS_A :: PIN1 => 1 , MUXPOS_A :: PIN2 => 2 , MUXPOS_A :: PIN3 => 3 , MUXPOS_A :: VSCALE => 4 } } }
# [ doc = "Reader of field `MUXPOS`" ] pub type MUXPOS_R = crate :: R < u8 , MUXPOS_A > ; impl MUXPOS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MUXPOS_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MUXPOS_A :: PIN0 ) , 1 => Val ( MUXPOS_A :: PIN1 ) , 2 => Val ( MUXPOS_A :: PIN2 ) , 3 => Val ( MUXPOS_A :: PIN3 ) , 4 => Val ( MUXPOS_A :: VSCALE ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PIN0`" ] # [ inline ( always ) ] pub fn is_pin0 ( & self ) -> bool { * self == MUXPOS_A :: PIN0 } # [ doc = "Checks if the value of the field is `PIN1`" ] # [ inline ( always ) ] pub fn is_pin1 ( & self ) -> bool { * self == MUXPOS_A :: PIN1 } # [ doc = "Checks if the value of the field is `PIN2`" ] # [ inline ( always ) ] pub fn is_pin2 ( & self ) -> bool { * self == MUXPOS_A :: PIN2 } # [ doc = "Checks if the value of the field is `PIN3`" ] # [ inline ( always ) ] pub fn is_pin3 ( & self ) -> bool { * self == MUXPOS_A :: PIN3 } # [ doc = "Checks if the value of the field is `VSCALE`" ] # [ inline ( always ) ] pub fn is_vscale ( & self ) -> bool { * self == MUXPOS_A :: VSCALE } }
# [ doc = "Write proxy for field `MUXPOS`" ] pub struct MUXPOS_W < 'a > { w : & 'a mut W , } impl < 'a > MUXPOS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MUXPOS_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "I/O pin 0" ] # [ inline ( always ) ] pub fn pin0 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: PIN0 ) } # [ doc = "I/O pin 1" ] # [ inline ( always ) ] pub fn pin1 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: PIN1 ) } # [ doc = "I/O pin 2" ] # [ inline ( always ) ] pub fn pin2 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: PIN2 ) } # [ doc = "I/O pin 3" ] # [ inline ( always ) ] pub fn pin3 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: PIN3 ) } # [ doc = "VDD Scaler" ] # [ inline ( always ) ] pub fn vscale ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: VSCALE ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 12 ) ) | ( ( ( value as u32 ) & 0x07 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `SWAP`" ] pub type SWAP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWAP`" ] pub struct SWAP_W < 'a > { w : & 'a mut W , } impl < 'a > SWAP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Possible values of the field `SPEED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SPEED_A { # [ doc = "Low speed" ] LOW , # [ doc = "High speed" ] HIGH }
impl crate :: ToBits < u8 > for SPEED_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SPEED_A :: LOW => 0 , SPEED_A :: HIGH => 3 } } }
# [ doc = "Reader of field `SPEED`" ] pub type SPEED_R = crate :: R < u8 , SPEED_A > ; impl SPEED_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SPEED_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SPEED_A :: LOW ) , 3 => Val ( SPEED_A :: HIGH ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == SPEED_A :: LOW } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == SPEED_A :: HIGH } }
# [ doc = "Write proxy for field `SPEED`" ] pub struct SPEED_W < 'a > { w : & 'a mut W , } impl < 'a > SPEED_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SPEED_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Low speed" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( SPEED_A :: LOW ) } # [ doc = "High speed" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( SPEED_A :: HIGH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 16 ) ) | ( ( ( value as u32 ) & 0x03 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `HYSTEN`" ] pub type HYSTEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HYSTEN`" ] pub struct HYSTEN_W < 'a > { w : & 'a mut W , } impl < 'a > HYSTEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Possible values of the field `FLEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FLEN_A { # [ doc = "No filtering" ] OFF , # [ doc = "3-bit majority function (2 of 3)" ] MAJ3 , # [ doc = "5-bit majority function (3 of 5)" ] MAJ5 }
impl crate :: ToBits < u8 > for FLEN_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { FLEN_A :: OFF => 0 , FLEN_A :: MAJ3 => 1 , FLEN_A :: MAJ5 => 2 } } }
# [ doc = "Reader of field `FLEN`" ] pub type FLEN_R = crate :: R < u8 , FLEN_A > ; impl FLEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , FLEN_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( FLEN_A :: OFF ) , 1 => Val ( FLEN_A :: MAJ3 ) , 2 => Val ( FLEN_A :: MAJ5 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == FLEN_A :: OFF } # [ doc = "Checks if the value of the field is `MAJ3`" ] # [ inline ( always ) ] pub fn is_maj3 ( & self ) -> bool { * self == FLEN_A :: MAJ3 } # [ doc = "Checks if the value of the field is `MAJ5`" ] # [ inline ( always ) ] pub fn is_maj5 ( & self ) -> bool { * self == FLEN_A :: MAJ5 } }
# [ doc = "Write proxy for field `FLEN`" ] pub struct FLEN_W < 'a > { w : & 'a mut W , } impl < 'a > FLEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FLEN_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No filtering" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( FLEN_A :: OFF ) } # [ doc = "3-bit majority function (2 of 3)" ] # [ inline ( always ) ] pub fn maj3 ( self ) -> & 'a mut W { self . variant ( FLEN_A :: MAJ3 ) } # [ doc = "5-bit majority function (3 of 5)" ] # [ inline ( always ) ] pub fn maj5 ( self ) -> & 'a mut W { self . variant ( FLEN_A :: MAJ5 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 24 ) ) | ( ( ( value as u32 ) & 0x07 ) << 24 ) ; self . w } }
# [ doc = "Possible values of the field `OUT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OUT_A { # [ doc = "The output of COMPn is not routed to the COMPn I/O port" ] OFF , # [ doc = "The asynchronous output of COMPn is routed to the COMPn I/O port" ] ASYNC , # [ doc = "The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port" ] SYNC }
impl crate :: ToBits < u8 > for OUT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { OUT_A :: OFF => 0 , OUT_A :: ASYNC => 1 , OUT_A :: SYNC => 2 } } }
# [ doc = "Reader of field `OUT`" ] pub type OUT_R = crate :: R < u8 , OUT_A > ; impl OUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , OUT_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( OUT_A :: OFF ) , 1 => Val ( OUT_A :: ASYNC ) , 2 => Val ( OUT_A :: SYNC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == OUT_A :: OFF } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == OUT_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == OUT_A :: SYNC } }
# [ doc = "Write proxy for field `OUT`" ] pub struct OUT_W < 'a > { w : & 'a mut W , } impl < 'a > OUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OUT_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "The output of COMPn is not routed to the COMPn I/O port" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( OUT_A :: OFF ) } # [ doc = "The asynchronous output of COMPn is routed to the COMPn I/O port" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( OUT_A :: ASYNC ) } # [ doc = "The synchronous output (including filtering) of COMPn is routed to the COMPn I/O port" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( OUT_A :: SYNC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 28 ) ) | ( ( ( value as u32 ) & 0x03 ) << 28 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Single-Shot Mode" ] # [ inline ( always ) ] pub fn single ( & self ) -> SINGLE_R { SINGLE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 3:4 - Interrupt Selection" ] # [ inline ( always ) ] pub fn intsel ( & self ) -> INTSEL_R { INTSEL_R :: new ( ( ( self . bits >> 3 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Negative Input Mux Selection" ] # [ inline ( always ) ] pub fn muxneg ( & self ) -> MUXNEG_R { MUXNEG_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 12:14 - Positive Input Mux Selection" ] # [ inline ( always ) ] pub fn muxpos ( & self ) -> MUXPOS_R { MUXPOS_R :: new ( ( ( self . bits >> 12 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 15 - Swap Inputs and Invert" ] # [ inline ( always ) ] pub fn swap ( & self ) -> SWAP_R { SWAP_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:17 - Speed Selection" ] # [ inline ( always ) ] pub fn speed ( & self ) -> SPEED_R { SPEED_R :: new ( ( ( self . bits >> 16 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 19 - Hysteresis Enable" ] # [ inline ( always ) ] pub fn hysten ( & self ) -> HYSTEN_R { HYSTEN_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 24:26 - Filter Length" ] # [ inline ( always ) ] pub fn flen ( & self ) -> FLEN_R { FLEN_R :: new ( ( ( self . bits >> 24 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 28:29 - Output" ] # [ inline ( always ) ] pub fn out ( & self ) -> OUT_R { OUT_R :: new ( ( ( self . bits >> 28 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 2 - Single-Shot Mode" ] # [ inline ( always ) ] pub fn single ( & mut self ) -> SINGLE_W { SINGLE_W { w : self } }
# [ doc = "Bits 3:4 - Interrupt Selection" ] # [ inline ( always ) ] pub fn intsel ( & mut self ) -> INTSEL_W { INTSEL_W { w : self } }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bits 8:10 - Negative Input Mux Selection" ] # [ inline ( always ) ] pub fn muxneg ( & mut self ) -> MUXNEG_W { MUXNEG_W { w : self } }
# [ doc = "Bits 12:14 - Positive Input Mux Selection" ] # [ inline ( always ) ] pub fn muxpos ( & mut self ) -> MUXPOS_W { MUXPOS_W { w : self } }
# [ doc = "Bit 15 - Swap Inputs and Invert" ] # [ inline ( always ) ] pub fn swap ( & mut self ) -> SWAP_W { SWAP_W { w : self } }
# [ doc = "Bits 16:17 - Speed Selection" ] # [ inline ( always ) ] pub fn speed ( & mut self ) -> SPEED_W { SPEED_W { w : self } }
# [ doc = "Bit 19 - Hysteresis Enable" ] # [ inline ( always ) ] pub fn hysten ( & mut self ) -> HYSTEN_W { HYSTEN_W { w : self } }
# [ doc = "Bits 24:26 - Filter Length" ] # [ inline ( always ) ] pub fn flen ( & mut self ) -> FLEN_W { FLEN_W { w : self } }
# [ doc = "Bits 28:29 - Output" ] # [ inline ( always ) ] pub fn out ( & mut self ) -> OUT_W { OUT_W { w : self } }
}
}
# [ doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WINCTRL`" ] pub type WINCTRL_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `COMPCTRL0`" ] pub type COMPCTRL0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `COMPCTRL1`" ] pub type COMPCTRL1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `COMPCTRL2`" ] pub type COMPCTRL2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `COMPCTRL3`" ] pub type COMPCTRL3_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Software Reset Synchronization Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable Synchronization Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - WINCTRL Synchronization Busy" ] # [ inline ( always ) ] pub fn winctrl ( & self ) -> WINCTRL_R { WINCTRL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - COMPCTRL 0 Synchronization Busy" ] # [ inline ( always ) ] pub fn compctrl0 ( & self ) -> COMPCTRL0_R { COMPCTRL0_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - COMPCTRL 1 Synchronization Busy" ] # [ inline ( always ) ] pub fn compctrl1 ( & self ) -> COMPCTRL1_R { COMPCTRL1_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - COMPCTRL 2 Synchronization Busy" ] # [ inline ( always ) ] pub fn compctrl2 ( & self ) -> COMPCTRL2_R { COMPCTRL2_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - COMPCTRL 3 Synchronization Busy" ] # [ inline ( always ) ] pub fn compctrl3 ( & self ) -> COMPCTRL3_R { COMPCTRL3_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
}
}
# [ doc = "Analog Digital Converter" ] pub struct ADC0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for ADC0 { } impl ADC0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const adc0 :: RegisterBlock { 0x4200_4400 as * const _ } } impl Deref for ADC0 { type Target = adc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * ADC0 :: ptr ( ) } } }
# [ doc = "Analog Digital Converter" ] pub mod adc0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control A" ] pub ctrla : CTRLA , # [ doc = "0x01 - Control B" ] pub ctrlb : CTRLB , # [ doc = "0x02 - Reference Control" ] pub refctrl : REFCTRL , # [ doc = "0x03 - Event Control" ] pub evctrl : EVCTRL , # [ doc = "0x04 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x05 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x06 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x07 - Sequence Status" ] pub seqstatus : SEQSTATUS , # [ doc = "0x08 - Input Control" ] pub inputctrl : INPUTCTRL , # [ doc = "0x0a - Control C" ] pub ctrlc : CTRLC , # [ doc = "0x0c - Average Control" ] pub avgctrl : AVGCTRL , # [ doc = "0x0d - Sample Time Control" ] pub sampctrl : SAMPCTRL , # [ doc = "0x0e - Window Monitor Lower Threshold" ] pub winlt : WINLT , # [ doc = "0x10 - Window Monitor Upper Threshold" ] pub winut : WINUT , # [ doc = "0x12 - Gain Correction" ] pub gaincorr : GAINCORR , # [ doc = "0x14 - Offset Correction" ] pub offsetcorr : OFFSETCORR , _reserved16 : [ u8 ; 2usize ] , # [ doc = "0x18 - Software Trigger" ] pub swtrig : SWTRIG , _reserved17 : [ u8 ; 3usize ] , # [ doc = "0x1c - Debug Control" ] pub dbgctrl : DBGCTRL , _reserved18 : [ u8 ; 3usize ] , # [ doc = "0x20 - Synchronization Busy" ] pub syncbusy : SYNCBUSY , _reserved19 : [ u8 ; 2usize ] , # [ doc = "0x24 - Result" ] pub result : RESULT , _reserved20 : [ u8 ; 2usize ] , # [ doc = "0x28 - Sequence Control" ] pub seqctrl : SEQCTRL , # [ doc = "0x2c - Calibration" ] pub calib : CALIB , }
# [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control A" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `SLAVEEN`" ] pub type SLAVEEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SLAVEEN`" ] pub struct SLAVEEN_W < 'a > { w : & 'a mut W , } impl < 'a > SLAVEEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Slave Enable" ] # [ inline ( always ) ] pub fn slaveen ( & self ) -> SLAVEEN_R { SLAVEEN_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run During Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 5 - Slave Enable" ] # [ inline ( always ) ] pub fn slaveen ( & mut self ) -> SLAVEEN_W { SLAVEEN_W { w : self } }
# [ doc = "Bit 6 - Run During Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } }
}
}
# [ doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u8 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ;
# [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { }
# [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { }
# [ doc = "Control B" ] pub mod ctrlb {
# [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u8 , super :: CTRLB > ;
# [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u8 , super :: CTRLB > ;
# [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `PRESCALER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER_A { # [ doc = "Peripheral clock divided by 2" ] DIV2 , # [ doc = "Peripheral clock divided by 4" ] DIV4 , # [ doc = "Peripheral clock divided by 8" ] DIV8 , # [ doc = "Peripheral clock divided by 16" ] DIV16 , # [ doc = "Peripheral clock divided by 32" ] DIV32 , # [ doc = "Peripheral clock divided by 64" ] DIV64 , # [ doc = "Peripheral clock divided by 128" ] DIV128 , # [ doc = "Peripheral clock divided by 256" ] DIV256 }
impl crate :: ToBits < u8 > for PRESCALER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER_A :: DIV2 => 0 , PRESCALER_A :: DIV4 => 1 , PRESCALER_A :: DIV8 => 2 , PRESCALER_A :: DIV16 => 3 , PRESCALER_A :: DIV32 => 4 , PRESCALER_A :: DIV64 => 5 , PRESCALER_A :: DIV128 => 6 , PRESCALER_A :: DIV256 => 7 } } }
# [ doc = "Reader of field `PRESCALER`" ] pub type PRESCALER_R = crate :: R < u8 , PRESCALER_A > ; impl PRESCALER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV2 , 1 => PRESCALER_A :: DIV4 , 2 => PRESCALER_A :: DIV8 , 3 => PRESCALER_A :: DIV16 , 4 => PRESCALER_A :: DIV32 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV128 , 7 => PRESCALER_A :: DIV256 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == PRESCALER_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == PRESCALER_A :: DIV128 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER_A :: DIV256 } }
# [ doc = "Write proxy for field `PRESCALER`" ] pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Peripheral clock divided by 2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV2 ) } # [ doc = "Peripheral clock divided by 4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV4 ) } # [ doc = "Peripheral clock divided by 8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV8 ) } # [ doc = "Peripheral clock divided by 16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV16 ) } # [ doc = "Peripheral clock divided by 32" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV32 ) } # [ doc = "Peripheral clock divided by 64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV64 ) } # [ doc = "Peripheral clock divided by 128" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV128 ) } # [ doc = "Peripheral clock divided by 256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV256 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u8 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Prescaler Configuration" ] # [ inline ( always ) ] pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Prescaler Configuration" ] # [ inline ( always ) ] pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } }
}
}
# [ doc = "Reference Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [refctrl](refctrl) module" ] pub type REFCTRL = crate :: Reg < u8 , _REFCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _REFCTRL ;
# [ doc = "`read()` method returns [refctrl::R](refctrl::R) reader structure" ] impl crate :: Readable for REFCTRL { }
# [ doc = "`write(|w| ..)` method takes [refctrl::W](refctrl::W) writer structure" ] impl crate :: Writable for REFCTRL { }
# [ doc = "Reference Control" ] pub mod refctrl {
# [ doc = "Reader of register REFCTRL" ] pub type R = crate :: R < u8 , super :: REFCTRL > ;
# [ doc = "Writer for register REFCTRL" ] pub type W = crate :: W < u8 , super :: REFCTRL > ;
# [ doc = "Register REFCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: REFCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `REFSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFSEL_A { # [ doc = "Internal Bandgap Reference" ] INTREF , # [ doc = "1/1.6 VDDANA" ] INTVCC0 , # [ doc = "1/2 VDDANA" ] INTVCC1 , # [ doc = "External Reference" ] AREFA , # [ doc = "DAC" ] DAC , # [ doc = "VDDANA" ] INTVCC2 }
impl crate :: ToBits < u8 > for REFSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { REFSEL_A :: INTREF => 0 , REFSEL_A :: INTVCC0 => 1 , REFSEL_A :: INTVCC1 => 2 , REFSEL_A :: AREFA => 3 , REFSEL_A :: DAC => 4 , REFSEL_A :: INTVCC2 => 5 } } }
# [ doc = "Reader of field `REFSEL`" ] pub type REFSEL_R = crate :: R < u8 , REFSEL_A > ; impl REFSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , REFSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( REFSEL_A :: INTREF ) , 1 => Val ( REFSEL_A :: INTVCC0 ) , 2 => Val ( REFSEL_A :: INTVCC1 ) , 3 => Val ( REFSEL_A :: AREFA ) , 4 => Val ( REFSEL_A :: DAC ) , 5 => Val ( REFSEL_A :: INTVCC2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `INTREF`" ] # [ inline ( always ) ] pub fn is_intref ( & self ) -> bool { * self == REFSEL_A :: INTREF } # [ doc = "Checks if the value of the field is `INTVCC0`" ] # [ inline ( always ) ] pub fn is_intvcc0 ( & self ) -> bool { * self == REFSEL_A :: INTVCC0 } # [ doc = "Checks if the value of the field is `INTVCC1`" ] # [ inline ( always ) ] pub fn is_intvcc1 ( & self ) -> bool { * self == REFSEL_A :: INTVCC1 } # [ doc = "Checks if the value of the field is `AREFA`" ] # [ inline ( always ) ] pub fn is_arefa ( & self ) -> bool { * self == REFSEL_A :: AREFA } # [ doc = "Checks if the value of the field is `DAC`" ] # [ inline ( always ) ] pub fn is_dac ( & self ) -> bool { * self == REFSEL_A :: DAC } # [ doc = "Checks if the value of the field is `INTVCC2`" ] # [ inline ( always ) ] pub fn is_intvcc2 ( & self ) -> bool { * self == REFSEL_A :: INTVCC2 } }
# [ doc = "Write proxy for field `REFSEL`" ] pub struct REFSEL_W < 'a > { w : & 'a mut W , } impl < 'a > REFSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFSEL_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Internal Bandgap Reference" ] # [ inline ( always ) ] pub fn intref ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: INTREF ) } # [ doc = "1/1.6 VDDANA" ] # [ inline ( always ) ] pub fn intvcc0 ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: INTVCC0 ) } # [ doc = "1/2 VDDANA" ] # [ inline ( always ) ] pub fn intvcc1 ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: INTVCC1 ) } # [ doc = "External Reference" ] # [ inline ( always ) ] pub fn arefa ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: AREFA ) } # [ doc = "DAC" ] # [ inline ( always ) ] pub fn dac ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: DAC ) } # [ doc = "VDDANA" ] # [ inline ( always ) ] pub fn intvcc2 ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: INTVCC2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } }
# [ doc = "Reader of field `REFCOMP`" ] pub type REFCOMP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `REFCOMP`" ] pub struct REFCOMP_W < 'a > { w : & 'a mut W , } impl < 'a > REFCOMP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Reference Selection" ] # [ inline ( always ) ] pub fn refsel ( & self ) -> REFSEL_R { REFSEL_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bit 7 - Reference Buffer Offset Compensation Enable" ] # [ inline ( always ) ] pub fn refcomp ( & self ) -> REFCOMP_R { REFCOMP_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:3 - Reference Selection" ] # [ inline ( always ) ] pub fn refsel ( & mut self ) -> REFSEL_W { REFSEL_W { w : self } }
# [ doc = "Bit 7 - Reference Buffer Offset Compensation Enable" ] # [ inline ( always ) ] pub fn refcomp ( & mut self ) -> REFCOMP_W { REFCOMP_W { w : self } }
}
}
# [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u8 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event Control" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u8 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u8 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FLUSHEI`" ] pub type FLUSHEI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FLUSHEI`" ] pub struct FLUSHEI_W < 'a > { w : & 'a mut W , } impl < 'a > FLUSHEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `STARTEI`" ] pub type STARTEI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `STARTEI`" ] pub struct STARTEI_W < 'a > { w : & 'a mut W , } impl < 'a > STARTEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `FLUSHINV`" ] pub type FLUSHINV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FLUSHINV`" ] pub struct FLUSHINV_W < 'a > { w : & 'a mut W , } impl < 'a > FLUSHINV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `STARTINV`" ] pub type STARTINV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `STARTINV`" ] pub struct STARTINV_W < 'a > { w : & 'a mut W , } impl < 'a > STARTINV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `RESRDYEO`" ] pub type RESRDYEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDYEO`" ] pub struct RESRDYEO_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDYEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `WINMONEO`" ] pub type WINMONEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMONEO`" ] pub struct WINMONEO_W < 'a > { w : & 'a mut W , } impl < 'a > WINMONEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Flush Event Input Enable" ] # [ inline ( always ) ] pub fn flushei ( & self ) -> FLUSHEI_R { FLUSHEI_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Start Conversion Event Input Enable" ] # [ inline ( always ) ] pub fn startei ( & self ) -> STARTEI_R { STARTEI_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Flush Event Invert Enable" ] # [ inline ( always ) ] pub fn flushinv ( & self ) -> FLUSHINV_R { FLUSHINV_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Start Event Invert Enable" ] # [ inline ( always ) ] pub fn startinv ( & self ) -> STARTINV_R { STARTINV_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Result Ready Event Out" ] # [ inline ( always ) ] pub fn resrdyeo ( & self ) -> RESRDYEO_R { RESRDYEO_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Window Monitor Event Out" ] # [ inline ( always ) ] pub fn winmoneo ( & self ) -> WINMONEO_R { WINMONEO_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Flush Event Input Enable" ] # [ inline ( always ) ] pub fn flushei ( & mut self ) -> FLUSHEI_W { FLUSHEI_W { w : self } }
# [ doc = "Bit 1 - Start Conversion Event Input Enable" ] # [ inline ( always ) ] pub fn startei ( & mut self ) -> STARTEI_W { STARTEI_W { w : self } }
# [ doc = "Bit 2 - Flush Event Invert Enable" ] # [ inline ( always ) ] pub fn flushinv ( & mut self ) -> FLUSHINV_W { FLUSHINV_W { w : self } }
# [ doc = "Bit 3 - Start Event Invert Enable" ] # [ inline ( always ) ] pub fn startinv ( & mut self ) -> STARTINV_W { STARTINV_W { w : self } }
# [ doc = "Bit 4 - Result Ready Event Out" ] # [ inline ( always ) ] pub fn resrdyeo ( & mut self ) -> RESRDYEO_W { RESRDYEO_W { w : self } }
# [ doc = "Bit 5 - Window Monitor Event Out" ] # [ inline ( always ) ] pub fn winmoneo ( & mut self ) -> WINMONEO_W { WINMONEO_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RESRDY`" ] pub type RESRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDY`" ] pub struct RESRDY_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVERRUN`" ] pub type OVERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVERRUN`" ] pub struct OVERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > OVERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINMON`" ] pub type WINMON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMON`" ] pub struct WINMON_W < 'a > { w : & 'a mut W , } impl < 'a > WINMON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Result Ready Interrupt Disable" ] # [ inline ( always ) ] pub fn resrdy ( & self ) -> RESRDY_R { RESRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Overrun Interrupt Disable" ] # [ inline ( always ) ] pub fn overrun ( & self ) -> OVERRUN_R { OVERRUN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor Interrupt Disable" ] # [ inline ( always ) ] pub fn winmon ( & self ) -> WINMON_R { WINMON_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Result Ready Interrupt Disable" ] # [ inline ( always ) ] pub fn resrdy ( & mut self ) -> RESRDY_W { RESRDY_W { w : self } }
# [ doc = "Bit 1 - Overrun Interrupt Disable" ] # [ inline ( always ) ] pub fn overrun ( & mut self ) -> OVERRUN_W { OVERRUN_W { w : self } }
# [ doc = "Bit 2 - Window Monitor Interrupt Disable" ] # [ inline ( always ) ] pub fn winmon ( & mut self ) -> WINMON_W { WINMON_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RESRDY`" ] pub type RESRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDY`" ] pub struct RESRDY_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVERRUN`" ] pub type OVERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVERRUN`" ] pub struct OVERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > OVERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINMON`" ] pub type WINMON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMON`" ] pub struct WINMON_W < 'a > { w : & 'a mut W , } impl < 'a > WINMON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Result Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn resrdy ( & self ) -> RESRDY_R { RESRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn overrun ( & self ) -> OVERRUN_R { OVERRUN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor Interrupt Enable" ] # [ inline ( always ) ] pub fn winmon ( & self ) -> WINMON_R { WINMON_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Result Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn resrdy ( & mut self ) -> RESRDY_W { RESRDY_W { w : self } }
# [ doc = "Bit 1 - Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn overrun ( & mut self ) -> OVERRUN_W { OVERRUN_W { w : self } }
# [ doc = "Bit 2 - Window Monitor Interrupt Enable" ] # [ inline ( always ) ] pub fn winmon ( & mut self ) -> WINMON_W { WINMON_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RESRDY`" ] pub type RESRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDY`" ] pub struct RESRDY_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVERRUN`" ] pub type OVERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVERRUN`" ] pub struct OVERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > OVERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINMON`" ] pub type WINMON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMON`" ] pub struct WINMON_W < 'a > { w : & 'a mut W , } impl < 'a > WINMON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Result Ready Interrupt Flag" ] # [ inline ( always ) ] pub fn resrdy ( & self ) -> RESRDY_R { RESRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Overrun Interrupt Flag" ] # [ inline ( always ) ] pub fn overrun ( & self ) -> OVERRUN_R { OVERRUN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor Interrupt Flag" ] # [ inline ( always ) ] pub fn winmon ( & self ) -> WINMON_R { WINMON_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Result Ready Interrupt Flag" ] # [ inline ( always ) ] pub fn resrdy ( & mut self ) -> RESRDY_W { RESRDY_W { w : self } }
# [ doc = "Bit 1 - Overrun Interrupt Flag" ] # [ inline ( always ) ] pub fn overrun ( & mut self ) -> OVERRUN_W { OVERRUN_W { w : self } }
# [ doc = "Bit 2 - Window Monitor Interrupt Flag" ] # [ inline ( always ) ] pub fn winmon ( & mut self ) -> WINMON_W { WINMON_W { w : self } }
}
}
# [ doc = "Sequence Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [seqstatus](seqstatus) module" ] pub type SEQSTATUS = crate :: Reg < u8 , _SEQSTATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SEQSTATUS ;
# [ doc = "`read()` method returns [seqstatus::R](seqstatus::R) reader structure" ] impl crate :: Readable for SEQSTATUS { }
# [ doc = "Sequence Status" ] pub mod seqstatus {
# [ doc = "Reader of register SEQSTATUS" ] pub type R = crate :: R < u8 , super :: SEQSTATUS > ;
# [ doc = "Reader of field `SEQSTATE`" ] pub type SEQSTATE_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `SEQBUSY`" ] pub type SEQBUSY_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bits 0:4 - Sequence State" ] # [ inline ( always ) ] pub fn seqstate ( & self ) -> SEQSTATE_R { SEQSTATE_R :: new ( ( self . bits & 0x1f ) as u8 ) }
# [ doc = "Bit 7 - Sequence Busy" ] # [ inline ( always ) ] pub fn seqbusy ( & self ) -> SEQBUSY_R { SEQBUSY_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Input Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [inputctrl](inputctrl) module" ] pub type INPUTCTRL = crate :: Reg < u16 , _INPUTCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INPUTCTRL ;
# [ doc = "`read()` method returns [inputctrl::R](inputctrl::R) reader structure" ] impl crate :: Readable for INPUTCTRL { }
# [ doc = "`write(|w| ..)` method takes [inputctrl::W](inputctrl::W) writer structure" ] impl crate :: Writable for INPUTCTRL { }
# [ doc = "Input Control" ] pub mod inputctrl {
# [ doc = "Reader of register INPUTCTRL" ] pub type R = crate :: R < u16 , super :: INPUTCTRL > ;
# [ doc = "Writer for register INPUTCTRL" ] pub type W = crate :: W < u16 , super :: INPUTCTRL > ;
# [ doc = "Register INPUTCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INPUTCTRL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `MUXPOS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MUXPOS_A { # [ doc = "ADC AIN0 Pin" ] AIN0 , # [ doc = "ADC AIN1 Pin" ] AIN1 , # [ doc = "ADC AIN2 Pin" ] AIN2 , # [ doc = "ADC AIN3 Pin" ] AIN3 , # [ doc = "ADC AIN4 Pin" ] AIN4 , # [ doc = "ADC AIN5 Pin" ] AIN5 , # [ doc = "ADC AIN6 Pin" ] AIN6 , # [ doc = "ADC AIN7 Pin" ] AIN7 , # [ doc = "ADC AIN8 Pin" ] AIN8 , # [ doc = "ADC AIN9 Pin" ] AIN9 , # [ doc = "ADC AIN10 Pin" ] AIN10 , # [ doc = "ADC AIN11 Pin" ] AIN11 , # [ doc = "Temperature Sensor" ] TEMP , # [ doc = "Bandgap Voltage" ] BANDGAP , # [ doc = "1/4 Scaled Core Supply" ] SCALEDCOREVCC , # [ doc = "1/4 Scaled I/O Supply" ] SCALEDIOVCC , # [ doc = "DAC Output" ] DAC }
impl crate :: ToBits < u8 > for MUXPOS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MUXPOS_A :: AIN0 => 0 , MUXPOS_A :: AIN1 => 1 , MUXPOS_A :: AIN2 => 2 , MUXPOS_A :: AIN3 => 3 , MUXPOS_A :: AIN4 => 4 , MUXPOS_A :: AIN5 => 5 , MUXPOS_A :: AIN6 => 6 , MUXPOS_A :: AIN7 => 7 , MUXPOS_A :: AIN8 => 8 , MUXPOS_A :: AIN9 => 9 , MUXPOS_A :: AIN10 => 10 , MUXPOS_A :: AIN11 => 11 , MUXPOS_A :: TEMP => 24 , MUXPOS_A :: BANDGAP => 25 , MUXPOS_A :: SCALEDCOREVCC => 26 , MUXPOS_A :: SCALEDIOVCC => 27 , MUXPOS_A :: DAC => 28 } } }
# [ doc = "Reader of field `MUXPOS`" ] pub type MUXPOS_R = crate :: R < u8 , MUXPOS_A > ; impl MUXPOS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MUXPOS_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MUXPOS_A :: AIN0 ) , 1 => Val ( MUXPOS_A :: AIN1 ) , 2 => Val ( MUXPOS_A :: AIN2 ) , 3 => Val ( MUXPOS_A :: AIN3 ) , 4 => Val ( MUXPOS_A :: AIN4 ) , 5 => Val ( MUXPOS_A :: AIN5 ) , 6 => Val ( MUXPOS_A :: AIN6 ) , 7 => Val ( MUXPOS_A :: AIN7 ) , 8 => Val ( MUXPOS_A :: AIN8 ) , 9 => Val ( MUXPOS_A :: AIN9 ) , 10 => Val ( MUXPOS_A :: AIN10 ) , 11 => Val ( MUXPOS_A :: AIN11 ) , 24 => Val ( MUXPOS_A :: TEMP ) , 25 => Val ( MUXPOS_A :: BANDGAP ) , 26 => Val ( MUXPOS_A :: SCALEDCOREVCC ) , 27 => Val ( MUXPOS_A :: SCALEDIOVCC ) , 28 => Val ( MUXPOS_A :: DAC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `AIN0`" ] # [ inline ( always ) ] pub fn is_ain0 ( & self ) -> bool { * self == MUXPOS_A :: AIN0 } # [ doc = "Checks if the value of the field is `AIN1`" ] # [ inline ( always ) ] pub fn is_ain1 ( & self ) -> bool { * self == MUXPOS_A :: AIN1 } # [ doc = "Checks if the value of the field is `AIN2`" ] # [ inline ( always ) ] pub fn is_ain2 ( & self ) -> bool { * self == MUXPOS_A :: AIN2 } # [ doc = "Checks if the value of the field is `AIN3`" ] # [ inline ( always ) ] pub fn is_ain3 ( & self ) -> bool { * self == MUXPOS_A :: AIN3 } # [ doc = "Checks if the value of the field is `AIN4`" ] # [ inline ( always ) ] pub fn is_ain4 ( & self ) -> bool { * self == MUXPOS_A :: AIN4 } # [ doc = "Checks if the value of the field is `AIN5`" ] # [ inline ( always ) ] pub fn is_ain5 ( & self ) -> bool { * self == MUXPOS_A :: AIN5 } # [ doc = "Checks if the value of the field is `AIN6`" ] # [ inline ( always ) ] pub fn is_ain6 ( & self ) -> bool { * self == MUXPOS_A :: AIN6 } # [ doc = "Checks if the value of the field is `AIN7`" ] # [ inline ( always ) ] pub fn is_ain7 ( & self ) -> bool { * self == MUXPOS_A :: AIN7 } # [ doc = "Checks if the value of the field is `AIN8`" ] # [ inline ( always ) ] pub fn is_ain8 ( & self ) -> bool { * self == MUXPOS_A :: AIN8 } # [ doc = "Checks if the value of the field is `AIN9`" ] # [ inline ( always ) ] pub fn is_ain9 ( & self ) -> bool { * self == MUXPOS_A :: AIN9 } # [ doc = "Checks if the value of the field is `AIN10`" ] # [ inline ( always ) ] pub fn is_ain10 ( & self ) -> bool { * self == MUXPOS_A :: AIN10 } # [ doc = "Checks if the value of the field is `AIN11`" ] # [ inline ( always ) ] pub fn is_ain11 ( & self ) -> bool { * self == MUXPOS_A :: AIN11 } # [ doc = "Checks if the value of the field is `TEMP`" ] # [ inline ( always ) ] pub fn is_temp ( & self ) -> bool { * self == MUXPOS_A :: TEMP } # [ doc = "Checks if the value of the field is `BANDGAP`" ] # [ inline ( always ) ] pub fn is_bandgap ( & self ) -> bool { * self == MUXPOS_A :: BANDGAP } # [ doc = "Checks if the value of the field is `SCALEDCOREVCC`" ] # [ inline ( always ) ] pub fn is_scaledcorevcc ( & self ) -> bool { * self == MUXPOS_A :: SCALEDCOREVCC } # [ doc = "Checks if the value of the field is `SCALEDIOVCC`" ] # [ inline ( always ) ] pub fn is_scalediovcc ( & self ) -> bool { * self == MUXPOS_A :: SCALEDIOVCC } # [ doc = "Checks if the value of the field is `DAC`" ] # [ inline ( always ) ] pub fn is_dac ( & self ) -> bool { * self == MUXPOS_A :: DAC } }
# [ doc = "Write proxy for field `MUXPOS`" ] pub struct MUXPOS_W < 'a > { w : & 'a mut W , } impl < 'a > MUXPOS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MUXPOS_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "ADC AIN0 Pin" ] # [ inline ( always ) ] pub fn ain0 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN0 ) } # [ doc = "ADC AIN1 Pin" ] # [ inline ( always ) ] pub fn ain1 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN1 ) } # [ doc = "ADC AIN2 Pin" ] # [ inline ( always ) ] pub fn ain2 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN2 ) } # [ doc = "ADC AIN3 Pin" ] # [ inline ( always ) ] pub fn ain3 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN3 ) } # [ doc = "ADC AIN4 Pin" ] # [ inline ( always ) ] pub fn ain4 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN4 ) } # [ doc = "ADC AIN5 Pin" ] # [ inline ( always ) ] pub fn ain5 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN5 ) } # [ doc = "ADC AIN6 Pin" ] # [ inline ( always ) ] pub fn ain6 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN6 ) } # [ doc = "ADC AIN7 Pin" ] # [ inline ( always ) ] pub fn ain7 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN7 ) } # [ doc = "ADC AIN8 Pin" ] # [ inline ( always ) ] pub fn ain8 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN8 ) } # [ doc = "ADC AIN9 Pin" ] # [ inline ( always ) ] pub fn ain9 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN9 ) } # [ doc = "ADC AIN10 Pin" ] # [ inline ( always ) ] pub fn ain10 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN10 ) } # [ doc = "ADC AIN11 Pin" ] # [ inline ( always ) ] pub fn ain11 ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: AIN11 ) } # [ doc = "Temperature Sensor" ] # [ inline ( always ) ] pub fn temp ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: TEMP ) } # [ doc = "Bandgap Voltage" ] # [ inline ( always ) ] pub fn bandgap ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: BANDGAP ) } # [ doc = "1/4 Scaled Core Supply" ] # [ inline ( always ) ] pub fn scaledcorevcc ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: SCALEDCOREVCC ) } # [ doc = "1/4 Scaled I/O Supply" ] # [ inline ( always ) ] pub fn scalediovcc ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: SCALEDIOVCC ) } # [ doc = "DAC Output" ] # [ inline ( always ) ] pub fn dac ( self ) -> & 'a mut W { self . variant ( MUXPOS_A :: DAC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u16 ) & 0x1f ) ; self . w } }
# [ doc = "Possible values of the field `MUXNEG`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MUXNEG_A { # [ doc = "ADC AIN0 Pin" ] AIN0 , # [ doc = "ADC AIN1 Pin" ] AIN1 , # [ doc = "ADC AIN2 Pin" ] AIN2 , # [ doc = "ADC AIN3 Pin" ] AIN3 , # [ doc = "ADC AIN4 Pin" ] AIN4 , # [ doc = "ADC AIN5 Pin" ] AIN5 , # [ doc = "Internal Ground" ] GND }
impl crate :: ToBits < u8 > for MUXNEG_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MUXNEG_A :: AIN0 => 0 , MUXNEG_A :: AIN1 => 1 , MUXNEG_A :: AIN2 => 2 , MUXNEG_A :: AIN3 => 3 , MUXNEG_A :: AIN4 => 4 , MUXNEG_A :: AIN5 => 5 , MUXNEG_A :: GND => 24 } } }
# [ doc = "Reader of field `MUXNEG`" ] pub type MUXNEG_R = crate :: R < u8 , MUXNEG_A > ; impl MUXNEG_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MUXNEG_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MUXNEG_A :: AIN0 ) , 1 => Val ( MUXNEG_A :: AIN1 ) , 2 => Val ( MUXNEG_A :: AIN2 ) , 3 => Val ( MUXNEG_A :: AIN3 ) , 4 => Val ( MUXNEG_A :: AIN4 ) , 5 => Val ( MUXNEG_A :: AIN5 ) , 24 => Val ( MUXNEG_A :: GND ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `AIN0`" ] # [ inline ( always ) ] pub fn is_ain0 ( & self ) -> bool { * self == MUXNEG_A :: AIN0 } # [ doc = "Checks if the value of the field is `AIN1`" ] # [ inline ( always ) ] pub fn is_ain1 ( & self ) -> bool { * self == MUXNEG_A :: AIN1 } # [ doc = "Checks if the value of the field is `AIN2`" ] # [ inline ( always ) ] pub fn is_ain2 ( & self ) -> bool { * self == MUXNEG_A :: AIN2 } # [ doc = "Checks if the value of the field is `AIN3`" ] # [ inline ( always ) ] pub fn is_ain3 ( & self ) -> bool { * self == MUXNEG_A :: AIN3 } # [ doc = "Checks if the value of the field is `AIN4`" ] # [ inline ( always ) ] pub fn is_ain4 ( & self ) -> bool { * self == MUXNEG_A :: AIN4 } # [ doc = "Checks if the value of the field is `AIN5`" ] # [ inline ( always ) ] pub fn is_ain5 ( & self ) -> bool { * self == MUXNEG_A :: AIN5 } # [ doc = "Checks if the value of the field is `GND`" ] # [ inline ( always ) ] pub fn is_gnd ( & self ) -> bool { * self == MUXNEG_A :: GND } }
# [ doc = "Write proxy for field `MUXNEG`" ] pub struct MUXNEG_W < 'a > { w : & 'a mut W , } impl < 'a > MUXNEG_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MUXNEG_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "ADC AIN0 Pin" ] # [ inline ( always ) ] pub fn ain0 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: AIN0 ) } # [ doc = "ADC AIN1 Pin" ] # [ inline ( always ) ] pub fn ain1 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: AIN1 ) } # [ doc = "ADC AIN2 Pin" ] # [ inline ( always ) ] pub fn ain2 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: AIN2 ) } # [ doc = "ADC AIN3 Pin" ] # [ inline ( always ) ] pub fn ain3 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: AIN3 ) } # [ doc = "ADC AIN4 Pin" ] # [ inline ( always ) ] pub fn ain4 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: AIN4 ) } # [ doc = "ADC AIN5 Pin" ] # [ inline ( always ) ] pub fn ain5 ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: AIN5 ) } # [ doc = "Internal Ground" ] # [ inline ( always ) ] pub fn gnd ( self ) -> & 'a mut W { self . variant ( MUXNEG_A :: GND ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 8 ) ) | ( ( ( value as u16 ) & 0x1f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:4 - Positive Mux Input Selection" ] # [ inline ( always ) ] pub fn muxpos ( & self ) -> MUXPOS_R { MUXPOS_R :: new ( ( self . bits & 0x1f ) as u8 ) }
# [ doc = "Bits 8:12 - Negative Mux Input Selection" ] # [ inline ( always ) ] pub fn muxneg ( & self ) -> MUXNEG_R { MUXNEG_R :: new ( ( ( self . bits >> 8 ) & 0x1f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:4 - Positive Mux Input Selection" ] # [ inline ( always ) ] pub fn muxpos ( & mut self ) -> MUXPOS_W { MUXPOS_W { w : self } }
# [ doc = "Bits 8:12 - Negative Mux Input Selection" ] # [ inline ( always ) ] pub fn muxneg ( & mut self ) -> MUXNEG_W { MUXNEG_W { w : self } }
}
}
# [ doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlc](ctrlc) module" ] pub type CTRLC = crate :: Reg < u16 , _CTRLC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLC ;
# [ doc = "`read()` method returns [ctrlc::R](ctrlc::R) reader structure" ] impl crate :: Readable for CTRLC { }
# [ doc = "`write(|w| ..)` method takes [ctrlc::W](ctrlc::W) writer structure" ] impl crate :: Writable for CTRLC { }
# [ doc = "Control C" ] pub mod ctrlc {
# [ doc = "Reader of register CTRLC" ] pub type R = crate :: R < u16 , super :: CTRLC > ;
# [ doc = "Writer for register CTRLC" ] pub type W = crate :: W < u16 , super :: CTRLC > ;
# [ doc = "Register CTRLC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DIFFMODE`" ] pub type DIFFMODE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DIFFMODE`" ] pub struct DIFFMODE_W < 'a > { w : & 'a mut W , } impl < 'a > DIFFMODE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `LEFTADJ`" ] pub type LEFTADJ_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LEFTADJ`" ] pub struct LEFTADJ_W < 'a > { w : & 'a mut W , } impl < 'a > LEFTADJ_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `FREERUN`" ] pub type FREERUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FREERUN`" ] pub struct FREERUN_W < 'a > { w : & 'a mut W , } impl < 'a > FREERUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CORREN`" ] pub type CORREN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CORREN`" ] pub struct CORREN_W < 'a > { w : & 'a mut W , } impl < 'a > CORREN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Possible values of the field `RESSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RESSEL_A { # [ doc = "12-bit" ] _12BIT , # [ doc = "16-bit averaging mode" ] _16BIT , # [ doc = "10-bit" ] _10BIT , # [ doc = "8-bit" ] _8BIT }
impl crate :: ToBits < u8 > for RESSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { RESSEL_A :: _12BIT => 0 , RESSEL_A :: _16BIT => 1 , RESSEL_A :: _10BIT => 2 , RESSEL_A :: _8BIT => 3 } } }
# [ doc = "Reader of field `RESSEL`" ] pub type RESSEL_R = crate :: R < u8 , RESSEL_A > ; impl RESSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RESSEL_A { match self . bits { 0 => RESSEL_A :: _12BIT , 1 => RESSEL_A :: _16BIT , 2 => RESSEL_A :: _10BIT , 3 => RESSEL_A :: _8BIT , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_12BIT`" ] # [ inline ( always ) ] pub fn is_12bit ( & self ) -> bool { * self == RESSEL_A :: _12BIT } # [ doc = "Checks if the value of the field is `_16BIT`" ] # [ inline ( always ) ] pub fn is_16bit ( & self ) -> bool { * self == RESSEL_A :: _16BIT } # [ doc = "Checks if the value of the field is `_10BIT`" ] # [ inline ( always ) ] pub fn is_10bit ( & self ) -> bool { * self == RESSEL_A :: _10BIT } # [ doc = "Checks if the value of the field is `_8BIT`" ] # [ inline ( always ) ] pub fn is_8bit ( & self ) -> bool { * self == RESSEL_A :: _8BIT } }
# [ doc = "Write proxy for field `RESSEL`" ] pub struct RESSEL_W < 'a > { w : & 'a mut W , } impl < 'a > RESSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RESSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "12-bit" ] # [ inline ( always ) ] pub fn _12bit ( self ) -> & 'a mut W { self . variant ( RESSEL_A :: _12BIT ) } # [ doc = "16-bit averaging mode" ] # [ inline ( always ) ] pub fn _16bit ( self ) -> & 'a mut W { self . variant ( RESSEL_A :: _16BIT ) } # [ doc = "10-bit" ] # [ inline ( always ) ] pub fn _10bit ( self ) -> & 'a mut W { self . variant ( RESSEL_A :: _10BIT ) } # [ doc = "8-bit" ] # [ inline ( always ) ] pub fn _8bit ( self ) -> & 'a mut W { self . variant ( RESSEL_A :: _8BIT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `R2R`" ] pub type R2R_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `R2R`" ] pub struct R2R_W < 'a > { w : & 'a mut W , } impl < 'a > R2R_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `WINMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WINMODE_A { # [ doc = "No window mode (default)" ] DISABLE , # [ doc = "RESULT > WINLT" ] MODE1 , # [ doc = "RESULT < WINUT" ] MODE2 , # [ doc = "WINLT < RESULT < WINUT" ] MODE3 , # [ doc = "!(WINLT < RESULT < WINUT)" ] MODE4 }
impl crate :: ToBits < u8 > for WINMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WINMODE_A :: DISABLE => 0 , WINMODE_A :: MODE1 => 1 , WINMODE_A :: MODE2 => 2 , WINMODE_A :: MODE3 => 3 , WINMODE_A :: MODE4 => 4 } } }
# [ doc = "Reader of field `WINMODE`" ] pub type WINMODE_R = crate :: R < u8 , WINMODE_A > ; impl WINMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , WINMODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( WINMODE_A :: DISABLE ) , 1 => Val ( WINMODE_A :: MODE1 ) , 2 => Val ( WINMODE_A :: MODE2 ) , 3 => Val ( WINMODE_A :: MODE3 ) , 4 => Val ( WINMODE_A :: MODE4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == WINMODE_A :: DISABLE } # [ doc = "Checks if the value of the field is `MODE1`" ] # [ inline ( always ) ] pub fn is_mode1 ( & self ) -> bool { * self == WINMODE_A :: MODE1 } # [ doc = "Checks if the value of the field is `MODE2`" ] # [ inline ( always ) ] pub fn is_mode2 ( & self ) -> bool { * self == WINMODE_A :: MODE2 } # [ doc = "Checks if the value of the field is `MODE3`" ] # [ inline ( always ) ] pub fn is_mode3 ( & self ) -> bool { * self == WINMODE_A :: MODE3 } # [ doc = "Checks if the value of the field is `MODE4`" ] # [ inline ( always ) ] pub fn is_mode4 ( & self ) -> bool { * self == WINMODE_A :: MODE4 } }
# [ doc = "Write proxy for field `WINMODE`" ] pub struct WINMODE_W < 'a > { w : & 'a mut W , } impl < 'a > WINMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WINMODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No window mode (default)" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: DISABLE ) } # [ doc = "RESULT > WINLT" ] # [ inline ( always ) ] pub fn mode1 ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: MODE1 ) } # [ doc = "RESULT < WINUT" ] # [ inline ( always ) ] pub fn mode2 ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: MODE2 ) } # [ doc = "WINLT < RESULT < WINUT" ] # [ inline ( always ) ] pub fn mode3 ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: MODE3 ) } # [ doc = "!(WINLT < RESULT < WINUT)" ] # [ inline ( always ) ] pub fn mode4 ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: MODE4 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Possible values of the field `DUALSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DUALSEL_A { # [ doc = "Start event or software trigger will start a conversion on both ADCs" ] BOTH , # [ doc = "START event or software trigger will alternatingly start a conversion on ADC0 and ADC1" ] INTERLEAVE }
impl crate :: ToBits < u8 > for DUALSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DUALSEL_A :: BOTH => 0 , DUALSEL_A :: INTERLEAVE => 1 } } }
# [ doc = "Reader of field `DUALSEL`" ] pub type DUALSEL_R = crate :: R < u8 , DUALSEL_A > ; impl DUALSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DUALSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DUALSEL_A :: BOTH ) , 1 => Val ( DUALSEL_A :: INTERLEAVE ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == DUALSEL_A :: BOTH } # [ doc = "Checks if the value of the field is `INTERLEAVE`" ] # [ inline ( always ) ] pub fn is_interleave ( & self ) -> bool { * self == DUALSEL_A :: INTERLEAVE } }
# [ doc = "Write proxy for field `DUALSEL`" ] pub struct DUALSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DUALSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DUALSEL_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Start event or software trigger will start a conversion on both ADCs" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( DUALSEL_A :: BOTH ) } # [ doc = "START event or software trigger will alternatingly start a conversion on ADC0 and ADC1" ] # [ inline ( always ) ] pub fn interleave ( self ) -> & 'a mut W { self . variant ( DUALSEL_A :: INTERLEAVE ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u16 ) & 0x03 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Differential Mode" ] # [ inline ( always ) ] pub fn diffmode ( & self ) -> DIFFMODE_R { DIFFMODE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Left-Adjusted Result" ] # [ inline ( always ) ] pub fn leftadj ( & self ) -> LEFTADJ_R { LEFTADJ_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Free Running Mode" ] # [ inline ( always ) ] pub fn freerun ( & self ) -> FREERUN_R { FREERUN_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Digital Correction Logic Enable" ] # [ inline ( always ) ] pub fn corren ( & self ) -> CORREN_R { CORREN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Conversion Result Resolution" ] # [ inline ( always ) ] pub fn ressel ( & self ) -> RESSEL_R { RESSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - Rail-to-Rail mode enable" ] # [ inline ( always ) ] pub fn r2r ( & self ) -> R2R_R { R2R_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Window Monitor Mode" ] # [ inline ( always ) ] pub fn winmode ( & self ) -> WINMODE_R { WINMODE_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 12:13 - Dual Mode Trigger Selection" ] # [ inline ( always ) ] pub fn dualsel ( & self ) -> DUALSEL_R { DUALSEL_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Differential Mode" ] # [ inline ( always ) ] pub fn diffmode ( & mut self ) -> DIFFMODE_W { DIFFMODE_W { w : self } }
# [ doc = "Bit 1 - Left-Adjusted Result" ] # [ inline ( always ) ] pub fn leftadj ( & mut self ) -> LEFTADJ_W { LEFTADJ_W { w : self } }
# [ doc = "Bit 2 - Free Running Mode" ] # [ inline ( always ) ] pub fn freerun ( & mut self ) -> FREERUN_W { FREERUN_W { w : self } }
# [ doc = "Bit 3 - Digital Correction Logic Enable" ] # [ inline ( always ) ] pub fn corren ( & mut self ) -> CORREN_W { CORREN_W { w : self } }
# [ doc = "Bits 4:5 - Conversion Result Resolution" ] # [ inline ( always ) ] pub fn ressel ( & mut self ) -> RESSEL_W { RESSEL_W { w : self } }
# [ doc = "Bit 7 - Rail-to-Rail mode enable" ] # [ inline ( always ) ] pub fn r2r ( & mut self ) -> R2R_W { R2R_W { w : self } }
# [ doc = "Bits 8:10 - Window Monitor Mode" ] # [ inline ( always ) ] pub fn winmode ( & mut self ) -> WINMODE_W { WINMODE_W { w : self } }
# [ doc = "Bits 12:13 - Dual Mode Trigger Selection" ] # [ inline ( always ) ] pub fn dualsel ( & mut self ) -> DUALSEL_W { DUALSEL_W { w : self } }
}
}
# [ doc = "Average Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [avgctrl](avgctrl) module" ] pub type AVGCTRL = crate :: Reg < u8 , _AVGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _AVGCTRL ;
# [ doc = "`read()` method returns [avgctrl::R](avgctrl::R) reader structure" ] impl crate :: Readable for AVGCTRL { }
# [ doc = "`write(|w| ..)` method takes [avgctrl::W](avgctrl::W) writer structure" ] impl crate :: Writable for AVGCTRL { }
# [ doc = "Average Control" ] pub mod avgctrl {
# [ doc = "Reader of register AVGCTRL" ] pub type R = crate :: R < u8 , super :: AVGCTRL > ;
# [ doc = "Writer for register AVGCTRL" ] pub type W = crate :: W < u8 , super :: AVGCTRL > ;
# [ doc = "Register AVGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: AVGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `SAMPLENUM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SAMPLENUM_A { # [ doc = "1 sample" ] _1 , # [ doc = "2 samples" ] _2 , # [ doc = "4 samples" ] _4 , # [ doc = "8 samples" ] _8 , # [ doc = "16 samples" ] _16 , # [ doc = "32 samples" ] _32 , # [ doc = "64 samples" ] _64 , # [ doc = "128 samples" ] _128 , # [ doc = "256 samples" ] _256 , # [ doc = "512 samples" ] _512 , # [ doc = "1024 samples" ] _1024 }
impl crate :: ToBits < u8 > for SAMPLENUM_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SAMPLENUM_A :: _1 => 0 , SAMPLENUM_A :: _2 => 1 , SAMPLENUM_A :: _4 => 2 , SAMPLENUM_A :: _8 => 3 , SAMPLENUM_A :: _16 => 4 , SAMPLENUM_A :: _32 => 5 , SAMPLENUM_A :: _64 => 6 , SAMPLENUM_A :: _128 => 7 , SAMPLENUM_A :: _256 => 8 , SAMPLENUM_A :: _512 => 9 , SAMPLENUM_A :: _1024 => 10 } } }
# [ doc = "Reader of field `SAMPLENUM`" ] pub type SAMPLENUM_R = crate :: R < u8 , SAMPLENUM_A > ; impl SAMPLENUM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SAMPLENUM_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SAMPLENUM_A :: _1 ) , 1 => Val ( SAMPLENUM_A :: _2 ) , 2 => Val ( SAMPLENUM_A :: _4 ) , 3 => Val ( SAMPLENUM_A :: _8 ) , 4 => Val ( SAMPLENUM_A :: _16 ) , 5 => Val ( SAMPLENUM_A :: _32 ) , 6 => Val ( SAMPLENUM_A :: _64 ) , 7 => Val ( SAMPLENUM_A :: _128 ) , 8 => Val ( SAMPLENUM_A :: _256 ) , 9 => Val ( SAMPLENUM_A :: _512 ) , 10 => Val ( SAMPLENUM_A :: _1024 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == SAMPLENUM_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == SAMPLENUM_A :: _2 } # [ doc = "Checks if the value of the field is `_4`" ] # [ inline ( always ) ] pub fn is_4 ( & self ) -> bool { * self == SAMPLENUM_A :: _4 } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == SAMPLENUM_A :: _8 } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == SAMPLENUM_A :: _16 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == SAMPLENUM_A :: _32 } # [ doc = "Checks if the value of the field is `_64`" ] # [ inline ( always ) ] pub fn is_64 ( & self ) -> bool { * self == SAMPLENUM_A :: _64 } # [ doc = "Checks if the value of the field is `_128`" ] # [ inline ( always ) ] pub fn is_128 ( & self ) -> bool { * self == SAMPLENUM_A :: _128 } # [ doc = "Checks if the value of the field is `_256`" ] # [ inline ( always ) ] pub fn is_256 ( & self ) -> bool { * self == SAMPLENUM_A :: _256 } # [ doc = "Checks if the value of the field is `_512`" ] # [ inline ( always ) ] pub fn is_512 ( & self ) -> bool { * self == SAMPLENUM_A :: _512 } # [ doc = "Checks if the value of the field is `_1024`" ] # [ inline ( always ) ] pub fn is_1024 ( & self ) -> bool { * self == SAMPLENUM_A :: _1024 } }
# [ doc = "Write proxy for field `SAMPLENUM`" ] pub struct SAMPLENUM_W < 'a > { w : & 'a mut W , } impl < 'a > SAMPLENUM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SAMPLENUM_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "1 sample" ] # [ inline ( always ) ] pub fn _1 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _1 ) } # [ doc = "2 samples" ] # [ inline ( always ) ] pub fn _2 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _2 ) } # [ doc = "4 samples" ] # [ inline ( always ) ] pub fn _4 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _4 ) } # [ doc = "8 samples" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _8 ) } # [ doc = "16 samples" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _16 ) } # [ doc = "32 samples" ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _32 ) } # [ doc = "64 samples" ] # [ inline ( always ) ] pub fn _64 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _64 ) } # [ doc = "128 samples" ] # [ inline ( always ) ] pub fn _128 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _128 ) } # [ doc = "256 samples" ] # [ inline ( always ) ] pub fn _256 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _256 ) } # [ doc = "512 samples" ] # [ inline ( always ) ] pub fn _512 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _512 ) } # [ doc = "1024 samples" ] # [ inline ( always ) ] pub fn _1024 ( self ) -> & 'a mut W { self . variant ( SAMPLENUM_A :: _1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } }
# [ doc = "Reader of field `ADJRES`" ] pub type ADJRES_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ADJRES`" ] pub struct ADJRES_W < 'a > { w : & 'a mut W , } impl < 'a > ADJRES_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u8 ) & 0x07 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Number of Samples to be Collected" ] # [ inline ( always ) ] pub fn samplenum ( & self ) -> SAMPLENUM_R { SAMPLENUM_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:6 - Adjusting Result / Division Coefficient" ] # [ inline ( always ) ] pub fn adjres ( & self ) -> ADJRES_R { ADJRES_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:3 - Number of Samples to be Collected" ] # [ inline ( always ) ] pub fn samplenum ( & mut self ) -> SAMPLENUM_W { SAMPLENUM_W { w : self } }
# [ doc = "Bits 4:6 - Adjusting Result / Division Coefficient" ] # [ inline ( always ) ] pub fn adjres ( & mut self ) -> ADJRES_W { ADJRES_W { w : self } }
}
}
# [ doc = "Sample Time Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [sampctrl](sampctrl) module" ] pub type SAMPCTRL = crate :: Reg < u8 , _SAMPCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SAMPCTRL ;
# [ doc = "`read()` method returns [sampctrl::R](sampctrl::R) reader structure" ] impl crate :: Readable for SAMPCTRL { }
# [ doc = "`write(|w| ..)` method takes [sampctrl::W](sampctrl::W) writer structure" ] impl crate :: Writable for SAMPCTRL { }
# [ doc = "Sample Time Control" ] pub mod sampctrl {
# [ doc = "Reader of register SAMPCTRL" ] pub type R = crate :: R < u8 , super :: SAMPCTRL > ;
# [ doc = "Writer for register SAMPCTRL" ] pub type W = crate :: W < u8 , super :: SAMPCTRL > ;
# [ doc = "Register SAMPCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SAMPCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SAMPLEN`" ] pub type SAMPLEN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `SAMPLEN`" ] pub struct SAMPLEN_W < 'a > { w : & 'a mut W , } impl < 'a > SAMPLEN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u8 ) & 0x3f ) ; self . w } }
# [ doc = "Reader of field `OFFCOMP`" ] pub type OFFCOMP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OFFCOMP`" ] pub struct OFFCOMP_W < 'a > { w : & 'a mut W , } impl < 'a > OFFCOMP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Sampling Time Length" ] # [ inline ( always ) ] pub fn samplen ( & self ) -> SAMPLEN_R { SAMPLEN_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bit 7 - Comparator Offset Compensation Enable" ] # [ inline ( always ) ] pub fn offcomp ( & self ) -> OFFCOMP_R { OFFCOMP_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:5 - Sampling Time Length" ] # [ inline ( always ) ] pub fn samplen ( & mut self ) -> SAMPLEN_W { SAMPLEN_W { w : self } }
# [ doc = "Bit 7 - Comparator Offset Compensation Enable" ] # [ inline ( always ) ] pub fn offcomp ( & mut self ) -> OFFCOMP_W { OFFCOMP_W { w : self } }
}
}
# [ doc = "Window Monitor Lower Threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [winlt](winlt) module" ] pub type WINLT = crate :: Reg < u16 , _WINLT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WINLT ;
# [ doc = "`read()` method returns [winlt::R](winlt::R) reader structure" ] impl crate :: Readable for WINLT { }
# [ doc = "`write(|w| ..)` method takes [winlt::W](winlt::W) writer structure" ] impl crate :: Writable for WINLT { }
# [ doc = "Window Monitor Lower Threshold" ] pub mod winlt {
# [ doc = "Reader of register WINLT" ] pub type R = crate :: R < u16 , super :: WINLT > ;
# [ doc = "Writer for register WINLT" ] pub type W = crate :: W < u16 , super :: WINLT > ;
# [ doc = "Register WINLT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WINLT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WINLT`" ] pub type WINLT_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `WINLT`" ] pub struct WINLT_W < 'a > { w : & 'a mut W , } impl < 'a > WINLT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Window Lower Threshold" ] # [ inline ( always ) ] pub fn winlt ( & self ) -> WINLT_R { WINLT_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - Window Lower Threshold" ] # [ inline ( always ) ] pub fn winlt ( & mut self ) -> WINLT_W { WINLT_W { w : self } }
}
}
# [ doc = "Window Monitor Upper Threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [winut](winut) module" ] pub type WINUT = crate :: Reg < u16 , _WINUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WINUT ;
# [ doc = "`read()` method returns [winut::R](winut::R) reader structure" ] impl crate :: Readable for WINUT { }
# [ doc = "`write(|w| ..)` method takes [winut::W](winut::W) writer structure" ] impl crate :: Writable for WINUT { }
# [ doc = "Window Monitor Upper Threshold" ] pub mod winut {
# [ doc = "Reader of register WINUT" ] pub type R = crate :: R < u16 , super :: WINUT > ;
# [ doc = "Writer for register WINUT" ] pub type W = crate :: W < u16 , super :: WINUT > ;
# [ doc = "Register WINUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WINUT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WINUT`" ] pub type WINUT_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `WINUT`" ] pub struct WINUT_W < 'a > { w : & 'a mut W , } impl < 'a > WINUT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Window Upper Threshold" ] # [ inline ( always ) ] pub fn winut ( & self ) -> WINUT_R { WINUT_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - Window Upper Threshold" ] # [ inline ( always ) ] pub fn winut ( & mut self ) -> WINUT_W { WINUT_W { w : self } }
}
}
# [ doc = "Gain Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [gaincorr](gaincorr) module" ] pub type GAINCORR = crate :: Reg < u16 , _GAINCORR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _GAINCORR ;
# [ doc = "`read()` method returns [gaincorr::R](gaincorr::R) reader structure" ] impl crate :: Readable for GAINCORR { }
# [ doc = "`write(|w| ..)` method takes [gaincorr::W](gaincorr::W) writer structure" ] impl crate :: Writable for GAINCORR { }
# [ doc = "Gain Correction" ] pub mod gaincorr {
# [ doc = "Reader of register GAINCORR" ] pub type R = crate :: R < u16 , super :: GAINCORR > ;
# [ doc = "Writer for register GAINCORR" ] pub type W = crate :: W < u16 , super :: GAINCORR > ;
# [ doc = "Register GAINCORR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: GAINCORR { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `GAINCORR`" ] pub type GAINCORR_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `GAINCORR`" ] pub struct GAINCORR_W < 'a > { w : & 'a mut W , } impl < 'a > GAINCORR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - Gain Correction Value" ] # [ inline ( always ) ] pub fn gaincorr ( & self ) -> GAINCORR_R { GAINCORR_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - Gain Correction Value" ] # [ inline ( always ) ] pub fn gaincorr ( & mut self ) -> GAINCORR_W { GAINCORR_W { w : self } }
}
}
# [ doc = "Offset Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [offsetcorr](offsetcorr) module" ] pub type OFFSETCORR = crate :: Reg < u16 , _OFFSETCORR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OFFSETCORR ;
# [ doc = "`read()` method returns [offsetcorr::R](offsetcorr::R) reader structure" ] impl crate :: Readable for OFFSETCORR { }
# [ doc = "`write(|w| ..)` method takes [offsetcorr::W](offsetcorr::W) writer structure" ] impl crate :: Writable for OFFSETCORR { }
# [ doc = "Offset Correction" ] pub mod offsetcorr {
# [ doc = "Reader of register OFFSETCORR" ] pub type R = crate :: R < u16 , super :: OFFSETCORR > ;
# [ doc = "Writer for register OFFSETCORR" ] pub type W = crate :: W < u16 , super :: OFFSETCORR > ;
# [ doc = "Register OFFSETCORR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OFFSETCORR { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OFFSETCORR`" ] pub type OFFSETCORR_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `OFFSETCORR`" ] pub struct OFFSETCORR_W < 'a > { w : & 'a mut W , } impl < 'a > OFFSETCORR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u16 ) & 0x0fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - Offset Correction Value" ] # [ inline ( always ) ] pub fn offsetcorr ( & self ) -> OFFSETCORR_R { OFFSETCORR_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:11 - Offset Correction Value" ] # [ inline ( always ) ] pub fn offsetcorr ( & mut self ) -> OFFSETCORR_W { OFFSETCORR_W { w : self } }
}
}
# [ doc = "Software Trigger\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [swtrig](swtrig) module" ] pub type SWTRIG = crate :: Reg < u8 , _SWTRIG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SWTRIG ;
# [ doc = "`read()` method returns [swtrig::R](swtrig::R) reader structure" ] impl crate :: Readable for SWTRIG { }
# [ doc = "`write(|w| ..)` method takes [swtrig::W](swtrig::W) writer structure" ] impl crate :: Writable for SWTRIG { }
# [ doc = "Software Trigger" ] pub mod swtrig {
# [ doc = "Reader of register SWTRIG" ] pub type R = crate :: R < u8 , super :: SWTRIG > ;
# [ doc = "Writer for register SWTRIG" ] pub type W = crate :: W < u8 , super :: SWTRIG > ;
# [ doc = "Register SWTRIG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SWTRIG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FLUSH`" ] pub type FLUSH_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FLUSH`" ] pub struct FLUSH_W < 'a > { w : & 'a mut W , } impl < 'a > FLUSH_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `START`" ] pub type START_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `START`" ] pub struct START_W < 'a > { w : & 'a mut W , } impl < 'a > START_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - ADC Flush" ] # [ inline ( always ) ] pub fn flush ( & self ) -> FLUSH_R { FLUSH_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Start ADC Conversion" ] # [ inline ( always ) ] pub fn start ( & self ) -> START_R { START_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - ADC Flush" ] # [ inline ( always ) ] pub fn flush ( & mut self ) -> FLUSH_W { FLUSH_W { w : self } }
# [ doc = "Bit 1 - Start ADC Conversion" ] # [ inline ( always ) ] pub fn start ( & mut self ) -> START_W { START_W { w : self } }
}
}
# [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ;
# [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { }
# [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { }
# [ doc = "Debug Control" ] pub mod dbgctrl {
# [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ;
# [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ;
# [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } }
}
}
# [ doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u16 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u16 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `INPUTCTRL`" ] pub type INPUTCTRL_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CTRLC`" ] pub type CTRLC_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `AVGCTRL`" ] pub type AVGCTRL_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SAMPCTRL`" ] pub type SAMPCTRL_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WINLT`" ] pub type WINLT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WINUT`" ] pub type WINUT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `GAINCORR`" ] pub type GAINCORR_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `OFFSETCORR`" ] pub type OFFSETCORR_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SWTRIG`" ] pub type SWTRIG_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - SWRST Synchronization Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - ENABLE Synchronization Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - INPUTCTRL Synchronization Busy" ] # [ inline ( always ) ] pub fn inputctrl ( & self ) -> INPUTCTRL_R { INPUTCTRL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - CTRLC Synchronization Busy" ] # [ inline ( always ) ] pub fn ctrlc ( & self ) -> CTRLC_R { CTRLC_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - AVGCTRL Synchronization Busy" ] # [ inline ( always ) ] pub fn avgctrl ( & self ) -> AVGCTRL_R { AVGCTRL_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - SAMPCTRL Synchronization Busy" ] # [ inline ( always ) ] pub fn sampctrl ( & self ) -> SAMPCTRL_R { SAMPCTRL_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - WINLT Synchronization Busy" ] # [ inline ( always ) ] pub fn winlt ( & self ) -> WINLT_R { WINLT_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - WINUT Synchronization Busy" ] # [ inline ( always ) ] pub fn winut ( & self ) -> WINUT_R { WINUT_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - GAINCORR Synchronization Busy" ] # [ inline ( always ) ] pub fn gaincorr ( & self ) -> GAINCORR_R { GAINCORR_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - OFFSETCTRL Synchronization Busy" ] # [ inline ( always ) ] pub fn offsetcorr ( & self ) -> OFFSETCORR_R { OFFSETCORR_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SWTRG Synchronization Busy" ] # [ inline ( always ) ] pub fn swtrig ( & self ) -> SWTRIG_R { SWTRIG_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Result\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [result](result) module" ] pub type RESULT = crate :: Reg < u16 , _RESULT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RESULT ;
# [ doc = "`read()` method returns [result::R](result::R) reader structure" ] impl crate :: Readable for RESULT { }
# [ doc = "Result" ] pub mod result {
# [ doc = "Reader of register RESULT" ] pub type R = crate :: R < u16 , super :: RESULT > ;
# [ doc = "Reader of field `RESULT`" ] pub type RESULT_R = crate :: R < u16 , u16 > ;
impl R {
# [ doc = "Bits 0:15 - Result Value" ] # [ inline ( always ) ] pub fn result ( & self ) -> RESULT_R { RESULT_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "Sequence Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [seqctrl](seqctrl) module" ] pub type SEQCTRL = crate :: Reg < u32 , _SEQCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SEQCTRL ;
# [ doc = "`read()` method returns [seqctrl::R](seqctrl::R) reader structure" ] impl crate :: Readable for SEQCTRL { }
# [ doc = "`write(|w| ..)` method takes [seqctrl::W](seqctrl::W) writer structure" ] impl crate :: Writable for SEQCTRL { }
# [ doc = "Sequence Control" ] pub mod seqctrl {
# [ doc = "Reader of register SEQCTRL" ] pub type R = crate :: R < u32 , super :: SEQCTRL > ;
# [ doc = "Writer for register SEQCTRL" ] pub type W = crate :: W < u32 , super :: SEQCTRL > ;
# [ doc = "Register SEQCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SEQCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SEQEN`" ] pub type SEQEN_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `SEQEN`" ] pub struct SEQEN_W < 'a > { w : & 'a mut W , } impl < 'a > SEQEN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - Enable Positive Input in the Sequence" ] # [ inline ( always ) ] pub fn seqen ( & self ) -> SEQEN_R { SEQEN_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - Enable Positive Input in the Sequence" ] # [ inline ( always ) ] pub fn seqen ( & mut self ) -> SEQEN_W { SEQEN_W { w : self } }
}
}
# [ doc = "Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [calib](calib) module" ] pub type CALIB = crate :: Reg < u16 , _CALIB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CALIB ;
# [ doc = "`read()` method returns [calib::R](calib::R) reader structure" ] impl crate :: Readable for CALIB { }
# [ doc = "`write(|w| ..)` method takes [calib::W](calib::W) writer structure" ] impl crate :: Writable for CALIB { }
# [ doc = "Calibration" ] pub mod calib {
# [ doc = "Reader of register CALIB" ] pub type R = crate :: R < u16 , super :: CALIB > ;
# [ doc = "Writer for register CALIB" ] pub type W = crate :: W < u16 , super :: CALIB > ;
# [ doc = "Register CALIB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CALIB { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `BIASCOMP`" ] pub type BIASCOMP_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `BIASCOMP`" ] pub struct BIASCOMP_W < 'a > { w : & 'a mut W , } impl < 'a > BIASCOMP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } }
# [ doc = "Reader of field `BIASREFBUF`" ] pub type BIASREFBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `BIASREFBUF`" ] pub struct BIASREFBUF_W < 'a > { w : & 'a mut W , } impl < 'a > BIASREFBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Bias Comparator Scaling" ] # [ inline ( always ) ] pub fn biascomp ( & self ) -> BIASCOMP_R { BIASCOMP_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bits 8:10 - Bias Reference Buffer Scaling" ] # [ inline ( always ) ] pub fn biasrefbuf ( & self ) -> BIASREFBUF_R { BIASREFBUF_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Bias Comparator Scaling" ] # [ inline ( always ) ] pub fn biascomp ( & mut self ) -> BIASCOMP_W { BIASCOMP_W { w : self } }
# [ doc = "Bits 8:10 - Bias Reference Buffer Scaling" ] # [ inline ( always ) ] pub fn biasrefbuf ( & mut self ) -> BIASREFBUF_W { BIASREFBUF_W { w : self } }
}
}
}
# [ doc = "Analog Digital Converter" ] pub struct ADC1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for ADC1 { } impl ADC1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const adc0 :: RegisterBlock { 0x4200_4800 as * const _ } } impl Deref for ADC1 { type Target = adc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * ADC1 :: ptr ( ) } } }
# [ doc = "Control Area Network" ] pub struct CAN0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for CAN0 { } impl CAN0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const can0 :: RegisterBlock { 0x4200_1c00 as * const _ } } impl Deref for CAN0 { type Target = can0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * CAN0 :: ptr ( ) } } }
# [ doc = "Control Area Network" ] pub mod can0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Core Release" ] pub crel : CREL , # [ doc = "0x04 - Endian" ] pub endn : ENDN , # [ doc = "0x08 - Message RAM Configuration" ] pub mrcfg : MRCFG , # [ doc = "0x0c - Fast Bit Timing and Prescaler" ] pub dbtp : DBTP , # [ doc = "0x10 - Test" ] pub test : TEST , # [ doc = "0x14 - RAM Watchdog" ] pub rwd : RWD , # [ doc = "0x18 - CC Control" ] pub cccr : CCCR , # [ doc = "0x1c - Nominal Bit Timing and Prescaler" ] pub nbtp : NBTP , # [ doc = "0x20 - Timestamp Counter Configuration" ] pub tscc : TSCC , # [ doc = "0x24 - Timestamp Counter Value" ] pub tscv : TSCV , # [ doc = "0x28 - Timeout Counter Configuration" ] pub tocc : TOCC , # [ doc = "0x2c - Timeout Counter Value" ] pub tocv : TOCV , _reserved12 : [ u8 ; 16usize ] , # [ doc = "0x40 - Error Counter" ] pub ecr : ECR , # [ doc = "0x44 - Protocol Status" ] pub psr : PSR , # [ doc = "0x48 - Extended ID Filter Configuration" ] pub tdcr : TDCR , _reserved15 : [ u8 ; 4usize ] , # [ doc = "0x50 - Interrupt" ] pub ir : IR , # [ doc = "0x54 - Interrupt Enable" ] pub ie : IE , # [ doc = "0x58 - Interrupt Line Select" ] pub ils : ILS , # [ doc = "0x5c - Interrupt Line Enable" ] pub ile : ILE , _reserved19 : [ u8 ; 32usize ] , # [ doc = "0x80 - Global Filter Configuration" ] pub gfc : GFC , # [ doc = "0x84 - Standard ID Filter Configuration" ] pub sidfc : SIDFC , # [ doc = "0x88 - Extended ID Filter Configuration" ] pub xidfc : XIDFC , _reserved22 : [ u8 ; 4usize ] , # [ doc = "0x90 - Extended ID AND Mask" ] pub xidam : XIDAM , # [ doc = "0x94 - High Priority Message Status" ] pub hpms : HPMS , # [ doc = "0x98 - New Data 1" ] pub ndat1 : NDAT1 , # [ doc = "0x9c - New Data 2" ] pub ndat2 : NDAT2 , # [ doc = "0xa0 - Rx FIFO 0 Configuration" ] pub rxf0c : RXF0C , # [ doc = "0xa4 - Rx FIFO 0 Status" ] pub rxf0s : RXF0S , # [ doc = "0xa8 - Rx FIFO 0 Acknowledge" ] pub rxf0a : RXF0A , # [ doc = "0xac - Rx Buffer Configuration" ] pub rxbc : RXBC , # [ doc = "0xb0 - Rx FIFO 1 Configuration" ] pub rxf1c : RXF1C , # [ doc = "0xb4 - Rx FIFO 1 Status" ] pub rxf1s : RXF1S , # [ doc = "0xb8 - Rx FIFO 1 Acknowledge" ] pub rxf1a : RXF1A , # [ doc = "0xbc - Rx Buffer / FIFO Element Size Configuration" ] pub rxesc : RXESC , # [ doc = "0xc0 - Tx Buffer Configuration" ] pub txbc : TXBC , # [ doc = "0xc4 - Tx FIFO / Queue Status" ] pub txfqs : TXFQS , # [ doc = "0xc8 - Tx Buffer Element Size Configuration" ] pub txesc : TXESC , # [ doc = "0xcc - Tx Buffer Request Pending" ] pub txbrp : TXBRP , # [ doc = "0xd0 - Tx Buffer Add Request" ] pub txbar : TXBAR , # [ doc = "0xd4 - Tx Buffer Cancellation Request" ] pub txbcr : TXBCR , # [ doc = "0xd8 - Tx Buffer Transmission Occurred" ] pub txbto : TXBTO , # [ doc = "0xdc - Tx Buffer Cancellation Finished" ] pub txbcf : TXBCF , # [ doc = "0xe0 - Tx Buffer Transmission Interrupt Enable" ] pub txbtie : TXBTIE , # [ doc = "0xe4 - Tx Buffer Cancellation Finished Interrupt Enable" ] pub txbcie : TXBCIE , _reserved44 : [ u8 ; 8usize ] , # [ doc = "0xf0 - Tx Event FIFO Configuration" ] pub txefc : TXEFC , # [ doc = "0xf4 - Tx Event FIFO Status" ] pub txefs : TXEFS , # [ doc = "0xf8 - Tx Event FIFO Acknowledge" ] pub txefa : TXEFA , }
# [ doc = "Core Release\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [crel](crel) module" ] pub type CREL = crate :: Reg < u32 , _CREL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CREL ;
# [ doc = "`read()` method returns [crel::R](crel::R) reader structure" ] impl crate :: Readable for CREL { }
# [ doc = "Core Release" ] pub mod crel {
# [ doc = "Reader of register CREL" ] pub type R = crate :: R < u32 , super :: CREL > ;
# [ doc = "Reader of field `SUBSTEP`" ] pub type SUBSTEP_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `STEP`" ] pub type STEP_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `REL`" ] pub type REL_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 20:23 - Sub-step of Core Release" ] # [ inline ( always ) ] pub fn substep ( & self ) -> SUBSTEP_R { SUBSTEP_R :: new ( ( ( self . bits >> 20 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 24:27 - Step of Core Release" ] # [ inline ( always ) ] pub fn step ( & self ) -> STEP_R { STEP_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 28:31 - Core Release" ] # [ inline ( always ) ] pub fn rel ( & self ) -> REL_R { REL_R :: new ( ( ( self . bits >> 28 ) & 0x0f ) as u8 ) }
}
}
# [ doc = "Endian\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [endn](endn) module" ] pub type ENDN = crate :: Reg < u32 , _ENDN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ENDN ;
# [ doc = "`read()` method returns [endn::R](endn::R) reader structure" ] impl crate :: Readable for ENDN { }
# [ doc = "Endian" ] pub mod endn {
# [ doc = "Reader of register ENDN" ] pub type R = crate :: R < u32 , super :: ENDN > ;
# [ doc = "Reader of field `ETV`" ] pub type ETV_R = crate :: R < u32 , u32 > ;
impl R {
# [ doc = "Bits 0:31 - Endianness Test Value" ] # [ inline ( always ) ] pub fn etv ( & self ) -> ETV_R { ETV_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
}
# [ doc = "Message RAM Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [mrcfg](mrcfg) module" ] pub type MRCFG = crate :: Reg < u32 , _MRCFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MRCFG ;
# [ doc = "`read()` method returns [mrcfg::R](mrcfg::R) reader structure" ] impl crate :: Readable for MRCFG { }
# [ doc = "`write(|w| ..)` method takes [mrcfg::W](mrcfg::W) writer structure" ] impl crate :: Writable for MRCFG { }
# [ doc = "Message RAM Configuration" ] pub mod mrcfg {
# [ doc = "Reader of register MRCFG" ] pub type R = crate :: R < u32 , super :: MRCFG > ;
# [ doc = "Writer for register MRCFG" ] pub type W = crate :: W < u32 , super :: MRCFG > ;
# [ doc = "Register MRCFG `reset()`'s with value 0x02" ] impl crate :: ResetValue for super :: MRCFG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x02 } }
# [ doc = "Possible values of the field `QOS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum QOS_A { # [ doc = "Background (no sensitive operation)" ] DISABLE , # [ doc = "Sensitive Bandwidth" ] LOW , # [ doc = "Sensitive Latency" ] MEDIUM , # [ doc = "Critical Latency" ] HIGH }
impl crate :: ToBits < u8 > for QOS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { QOS_A :: DISABLE => 0 , QOS_A :: LOW => 1 , QOS_A :: MEDIUM => 2 , QOS_A :: HIGH => 3 } } }
# [ doc = "Reader of field `QOS`" ] pub type QOS_R = crate :: R < u8 , QOS_A > ; impl QOS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> QOS_A { match self . bits { 0 => QOS_A :: DISABLE , 1 => QOS_A :: LOW , 2 => QOS_A :: MEDIUM , 3 => QOS_A :: HIGH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == QOS_A :: DISABLE } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == QOS_A :: LOW } # [ doc = "Checks if the value of the field is `MEDIUM`" ] # [ inline ( always ) ] pub fn is_medium ( & self ) -> bool { * self == QOS_A :: MEDIUM } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == QOS_A :: HIGH } }
# [ doc = "Write proxy for field `QOS`" ] pub struct QOS_W < 'a > { w : & 'a mut W , } impl < 'a > QOS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : QOS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Background (no sensitive operation)" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( QOS_A :: DISABLE ) } # [ doc = "Sensitive Bandwidth" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( QOS_A :: LOW ) } # [ doc = "Sensitive Latency" ] # [ inline ( always ) ] pub fn medium ( self ) -> & 'a mut W { self . variant ( QOS_A :: MEDIUM ) } # [ doc = "Critical Latency" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( QOS_A :: HIGH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Quality of Service" ] # [ inline ( always ) ] pub fn qos ( & self ) -> QOS_R { QOS_R :: new ( ( self . bits & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Quality of Service" ] # [ inline ( always ) ] pub fn qos ( & mut self ) -> QOS_W { QOS_W { w : self } }
}
}
# [ doc = "Fast Bit Timing and Prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbtp](dbtp) module" ] pub type DBTP = crate :: Reg < u32 , _DBTP > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBTP ;
# [ doc = "`read()` method returns [dbtp::R](dbtp::R) reader structure" ] impl crate :: Readable for DBTP { }
# [ doc = "`write(|w| ..)` method takes [dbtp::W](dbtp::W) writer structure" ] impl crate :: Writable for DBTP { }
# [ doc = "Fast Bit Timing and Prescaler" ] pub mod dbtp {
# [ doc = "Reader of register DBTP" ] pub type R = crate :: R < u32 , super :: DBTP > ;
# [ doc = "Writer for register DBTP" ] pub type W = crate :: W < u32 , super :: DBTP > ;
# [ doc = "Register DBTP `reset()`'s with value 0x0a33" ] impl crate :: ResetValue for super :: DBTP { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x0a33 } }
# [ doc = "Reader of field `DSJW`" ] pub type DSJW_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DSJW`" ] pub struct DSJW_W < 'a > { w : & 'a mut W , } impl < 'a > DSJW_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u32 ) & 0x0f ) ; self . w } }
# [ doc = "Reader of field `DTSEG2`" ] pub type DTSEG2_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DTSEG2`" ] pub struct DTSEG2_W < 'a > { w : & 'a mut W , } impl < 'a > DTSEG2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 4 ) ) | ( ( ( value as u32 ) & 0x0f ) << 4 ) ; self . w } }
# [ doc = "Reader of field `DTSEG1`" ] pub type DTSEG1_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DTSEG1`" ] pub struct DTSEG1_W < 'a > { w : & 'a mut W , } impl < 'a > DTSEG1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 8 ) ) | ( ( ( value as u32 ) & 0x1f ) << 8 ) ; self . w } }
# [ doc = "Reader of field `DBRP`" ] pub type DBRP_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DBRP`" ] pub struct DBRP_W < 'a > { w : & 'a mut W , } impl < 'a > DBRP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 16 ) ) | ( ( ( value as u32 ) & 0x1f ) << 16 ) ; self . w } }
# [ doc = "Reader of field `TDC`" ] pub type TDC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TDC`" ] pub struct TDC_W < 'a > { w : & 'a mut W , } impl < 'a > TDC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Data (Re)Synchronization Jump Width" ] # [ inline ( always ) ] pub fn dsjw ( & self ) -> DSJW_R { DSJW_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:7 - Data time segment after sample point" ] # [ inline ( always ) ] pub fn dtseg2 ( & self ) -> DTSEG2_R { DTSEG2_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 8:12 - Data time segment before sample point" ] # [ inline ( always ) ] pub fn dtseg1 ( & self ) -> DTSEG1_R { DTSEG1_R :: new ( ( ( self . bits >> 8 ) & 0x1f ) as u8 ) }
# [ doc = "Bits 16:20 - Data Baud Rate Prescaler" ] # [ inline ( always ) ] pub fn dbrp ( & self ) -> DBRP_R { DBRP_R :: new ( ( ( self . bits >> 16 ) & 0x1f ) as u8 ) }
# [ doc = "Bit 23 - Tranceiver Delay Compensation" ] # [ inline ( always ) ] pub fn tdc ( & self ) -> TDC_R { TDC_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:3 - Data (Re)Synchronization Jump Width" ] # [ inline ( always ) ] pub fn dsjw ( & mut self ) -> DSJW_W { DSJW_W { w : self } }
# [ doc = "Bits 4:7 - Data time segment after sample point" ] # [ inline ( always ) ] pub fn dtseg2 ( & mut self ) -> DTSEG2_W { DTSEG2_W { w : self } }
# [ doc = "Bits 8:12 - Data time segment before sample point" ] # [ inline ( always ) ] pub fn dtseg1 ( & mut self ) -> DTSEG1_W { DTSEG1_W { w : self } }
# [ doc = "Bits 16:20 - Data Baud Rate Prescaler" ] # [ inline ( always ) ] pub fn dbrp ( & mut self ) -> DBRP_W { DBRP_W { w : self } }
# [ doc = "Bit 23 - Tranceiver Delay Compensation" ] # [ inline ( always ) ] pub fn tdc ( & mut self ) -> TDC_W { TDC_W { w : self } }
}
}
# [ doc = "Test\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [test](test) module" ] pub type TEST = crate :: Reg < u32 , _TEST > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TEST ;
# [ doc = "`read()` method returns [test::R](test::R) reader structure" ] impl crate :: Readable for TEST { }
# [ doc = "`write(|w| ..)` method takes [test::W](test::W) writer structure" ] impl crate :: Writable for TEST { }
# [ doc = "Test" ] pub mod test {
# [ doc = "Reader of register TEST" ] pub type R = crate :: R < u32 , super :: TEST > ;
# [ doc = "Writer for register TEST" ] pub type W = crate :: W < u32 , super :: TEST > ;
# [ doc = "Register TEST `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TEST { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `LBCK`" ] pub type LBCK_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LBCK`" ] pub struct LBCK_W < 'a > { w : & 'a mut W , } impl < 'a > LBCK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Possible values of the field `TX`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TX_A { # [ doc = "TX controlled by CAN core" ] CORE , # [ doc = "TX monitoring sample point" ] SAMPLE , # [ doc = "Dominant (0) level at pin CAN_TX" ] DOMINANT , # [ doc = "Recessive (1) level at pin CAN_TX" ] RECESSIVE }
impl crate :: ToBits < u8 > for TX_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { TX_A :: CORE => 0 , TX_A :: SAMPLE => 1 , TX_A :: DOMINANT => 2 , TX_A :: RECESSIVE => 3 } } }
# [ doc = "Reader of field `TX`" ] pub type TX_R = crate :: R < u8 , TX_A > ; impl TX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TX_A { match self . bits { 0 => TX_A :: CORE , 1 => TX_A :: SAMPLE , 2 => TX_A :: DOMINANT , 3 => TX_A :: RECESSIVE , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CORE`" ] # [ inline ( always ) ] pub fn is_core ( & self ) -> bool { * self == TX_A :: CORE } # [ doc = "Checks if the value of the field is `SAMPLE`" ] # [ inline ( always ) ] pub fn is_sample ( & self ) -> bool { * self == TX_A :: SAMPLE } # [ doc = "Checks if the value of the field is `DOMINANT`" ] # [ inline ( always ) ] pub fn is_dominant ( & self ) -> bool { * self == TX_A :: DOMINANT } # [ doc = "Checks if the value of the field is `RECESSIVE`" ] # [ inline ( always ) ] pub fn is_recessive ( & self ) -> bool { * self == TX_A :: RECESSIVE } }
# [ doc = "Write proxy for field `TX`" ] pub struct TX_W < 'a > { w : & 'a mut W , } impl < 'a > TX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TX_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "TX controlled by CAN core" ] # [ inline ( always ) ] pub fn core ( self ) -> & 'a mut W { self . variant ( TX_A :: CORE ) } # [ doc = "TX monitoring sample point" ] # [ inline ( always ) ] pub fn sample ( self ) -> & 'a mut W { self . variant ( TX_A :: SAMPLE ) } # [ doc = "Dominant (0) level at pin CAN_TX" ] # [ inline ( always ) ] pub fn dominant ( self ) -> & 'a mut W { self . variant ( TX_A :: DOMINANT ) } # [ doc = "Recessive (1) level at pin CAN_TX" ] # [ inline ( always ) ] pub fn recessive ( self ) -> & 'a mut W { self . variant ( TX_A :: RECESSIVE ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 5 ) ) | ( ( ( value as u32 ) & 0x03 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `RX`" ] pub type RX_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RX`" ] pub struct RX_W < 'a > { w : & 'a mut W , } impl < 'a > RX_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 4 - Loop Back Mode" ] # [ inline ( always ) ] pub fn lbck ( & self ) -> LBCK_R { LBCK_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:6 - Control of Transmit Pin" ] # [ inline ( always ) ] pub fn tx ( & self ) -> TX_R { TX_R :: new ( ( ( self . bits >> 5 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - Receive Pin" ] # [ inline ( always ) ] pub fn rx ( & self ) -> RX_R { RX_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 4 - Loop Back Mode" ] # [ inline ( always ) ] pub fn lbck ( & mut self ) -> LBCK_W { LBCK_W { w : self } }
# [ doc = "Bits 5:6 - Control of Transmit Pin" ] # [ inline ( always ) ] pub fn tx ( & mut self ) -> TX_W { TX_W { w : self } }
# [ doc = "Bit 7 - Receive Pin" ] # [ inline ( always ) ] pub fn rx ( & mut self ) -> RX_W { RX_W { w : self } }
}
}
# [ doc = "RAM Watchdog\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rwd](rwd) module" ] pub type RWD = crate :: Reg < u32 , _RWD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RWD ;
# [ doc = "`read()` method returns [rwd::R](rwd::R) reader structure" ] impl crate :: Readable for RWD { }
# [ doc = "`write(|w| ..)` method takes [rwd::W](rwd::W) writer structure" ] impl crate :: Writable for RWD { }
# [ doc = "RAM Watchdog" ] pub mod rwd {
# [ doc = "Reader of register RWD" ] pub type R = crate :: R < u32 , super :: RWD > ;
# [ doc = "Writer for register RWD" ] pub type W = crate :: W < u32 , super :: RWD > ;
# [ doc = "Register RWD `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RWD { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WDC`" ] pub type WDC_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `WDC`" ] pub struct WDC_W < 'a > { w : & 'a mut W , } impl < 'a > WDC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u32 ) & 0xff ) ; self . w } }
# [ doc = "Reader of field `WDV`" ] pub type WDV_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `WDV`" ] pub struct WDV_W < 'a > { w : & 'a mut W , } impl < 'a > WDV_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u32 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Watchdog Configuration" ] # [ inline ( always ) ] pub fn wdc ( & self ) -> WDC_R { WDC_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bits 8:15 - Watchdog Value" ] # [ inline ( always ) ] pub fn wdv ( & self ) -> WDV_R { WDV_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Watchdog Configuration" ] # [ inline ( always ) ] pub fn wdc ( & mut self ) -> WDC_W { WDC_W { w : self } }
# [ doc = "Bits 8:15 - Watchdog Value" ] # [ inline ( always ) ] pub fn wdv ( & mut self ) -> WDV_W { WDV_W { w : self } }
}
}
# [ doc = "CC Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cccr](cccr) module" ] pub type CCCR = crate :: Reg < u32 , _CCCR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CCCR ;
# [ doc = "`read()` method returns [cccr::R](cccr::R) reader structure" ] impl crate :: Readable for CCCR { }
# [ doc = "`write(|w| ..)` method takes [cccr::W](cccr::W) writer structure" ] impl crate :: Writable for CCCR { }
# [ doc = "CC Control" ] pub mod cccr {
# [ doc = "Reader of register CCCR" ] pub type R = crate :: R < u32 , super :: CCCR > ;
# [ doc = "Writer for register CCCR" ] pub type W = crate :: W < u32 , super :: CCCR > ;
# [ doc = "Register CCCR `reset()`'s with value 0x01" ] impl crate :: ResetValue for super :: CCCR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x01 } }
# [ doc = "Reader of field `INIT`" ] pub type INIT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INIT`" ] pub struct INIT_W < 'a > { w : & 'a mut W , } impl < 'a > INIT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `CCE`" ] pub type CCE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CCE`" ] pub struct CCE_W < 'a > { w : & 'a mut W , } impl < 'a > CCE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `ASM`" ] pub type ASM_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ASM`" ] pub struct ASM_W < 'a > { w : & 'a mut W , } impl < 'a > ASM_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CSA`" ] pub type CSA_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CSA`" ] pub struct CSA_W < 'a > { w : & 'a mut W , } impl < 'a > CSA_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `CSR`" ] pub type CSR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CSR`" ] pub struct CSR_W < 'a > { w : & 'a mut W , } impl < 'a > CSR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `MON`" ] pub type MON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MON`" ] pub struct MON_W < 'a > { w : & 'a mut W , } impl < 'a > MON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `DAR`" ] pub type DAR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DAR`" ] pub struct DAR_W < 'a > { w : & 'a mut W , } impl < 'a > DAR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `TEST`" ] pub type TEST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEST`" ] pub struct TEST_W < 'a > { w : & 'a mut W , } impl < 'a > TEST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `FDOE`" ] pub type FDOE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FDOE`" ] pub struct FDOE_W < 'a > { w : & 'a mut W , } impl < 'a > FDOE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `BRSE`" ] pub type BRSE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BRSE`" ] pub struct BRSE_W < 'a > { w : & 'a mut W , } impl < 'a > BRSE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `PXHD`" ] pub type PXHD_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PXHD`" ] pub struct PXHD_W < 'a > { w : & 'a mut W , } impl < 'a > PXHD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `EFBI`" ] pub type EFBI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EFBI`" ] pub struct EFBI_W < 'a > { w : & 'a mut W , } impl < 'a > EFBI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `TXP`" ] pub type TXP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TXP`" ] pub struct TXP_W < 'a > { w : & 'a mut W , } impl < 'a > TXP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `NISO`" ] pub type NISO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NISO`" ] pub struct NISO_W < 'a > { w : & 'a mut W , } impl < 'a > NISO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Initialization" ] # [ inline ( always ) ] pub fn init ( & self ) -> INIT_R { INIT_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Configuration Change Enable" ] # [ inline ( always ) ] pub fn cce ( & self ) -> CCE_R { CCE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - ASM Restricted Operation Mode" ] # [ inline ( always ) ] pub fn asm ( & self ) -> ASM_R { ASM_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Clock Stop Acknowledge" ] # [ inline ( always ) ] pub fn csa ( & self ) -> CSA_R { CSA_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Clock Stop Request" ] # [ inline ( always ) ] pub fn csr ( & self ) -> CSR_R { CSR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Bus Monitoring Mode" ] # [ inline ( always ) ] pub fn mon ( & self ) -> MON_R { MON_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Disable Automatic Retransmission" ] # [ inline ( always ) ] pub fn dar ( & self ) -> DAR_R { DAR_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Test Mode Enable" ] # [ inline ( always ) ] pub fn test ( & self ) -> TEST_R { TEST_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - FD Operation Enable" ] # [ inline ( always ) ] pub fn fdoe ( & self ) -> FDOE_R { FDOE_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Bit Rate Switch Enable" ] # [ inline ( always ) ] pub fn brse ( & self ) -> BRSE_R { BRSE_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Protocol Exception Handling Disable" ] # [ inline ( always ) ] pub fn pxhd ( & self ) -> PXHD_R { PXHD_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Edge Filtering during Bus Integration" ] # [ inline ( always ) ] pub fn efbi ( & self ) -> EFBI_R { EFBI_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Transmit Pause" ] # [ inline ( always ) ] pub fn txp ( & self ) -> TXP_R { TXP_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Non ISO Operation" ] # [ inline ( always ) ] pub fn niso ( & self ) -> NISO_R { NISO_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Initialization" ] # [ inline ( always ) ] pub fn init ( & mut self ) -> INIT_W { INIT_W { w : self } }
# [ doc = "Bit 1 - Configuration Change Enable" ] # [ inline ( always ) ] pub fn cce ( & mut self ) -> CCE_W { CCE_W { w : self } }
# [ doc = "Bit 2 - ASM Restricted Operation Mode" ] # [ inline ( always ) ] pub fn asm ( & mut self ) -> ASM_W { ASM_W { w : self } }
# [ doc = "Bit 3 - Clock Stop Acknowledge" ] # [ inline ( always ) ] pub fn csa ( & mut self ) -> CSA_W { CSA_W { w : self } }
# [ doc = "Bit 4 - Clock Stop Request" ] # [ inline ( always ) ] pub fn csr ( & mut self ) -> CSR_W { CSR_W { w : self } }
# [ doc = "Bit 5 - Bus Monitoring Mode" ] # [ inline ( always ) ] pub fn mon ( & mut self ) -> MON_W { MON_W { w : self } }
# [ doc = "Bit 6 - Disable Automatic Retransmission" ] # [ inline ( always ) ] pub fn dar ( & mut self ) -> DAR_W { DAR_W { w : self } }
# [ doc = "Bit 7 - Test Mode Enable" ] # [ inline ( always ) ] pub fn test ( & mut self ) -> TEST_W { TEST_W { w : self } }
# [ doc = "Bit 8 - FD Operation Enable" ] # [ inline ( always ) ] pub fn fdoe ( & mut self ) -> FDOE_W { FDOE_W { w : self } }
# [ doc = "Bit 9 - Bit Rate Switch Enable" ] # [ inline ( always ) ] pub fn brse ( & mut self ) -> BRSE_W { BRSE_W { w : self } }
# [ doc = "Bit 12 - Protocol Exception Handling Disable" ] # [ inline ( always ) ] pub fn pxhd ( & mut self ) -> PXHD_W { PXHD_W { w : self } }
# [ doc = "Bit 13 - Edge Filtering during Bus Integration" ] # [ inline ( always ) ] pub fn efbi ( & mut self ) -> EFBI_W { EFBI_W { w : self } }
# [ doc = "Bit 14 - Transmit Pause" ] # [ inline ( always ) ] pub fn txp ( & mut self ) -> TXP_W { TXP_W { w : self } }
# [ doc = "Bit 15 - Non ISO Operation" ] # [ inline ( always ) ] pub fn niso ( & mut self ) -> NISO_W { NISO_W { w : self } }
}
}
# [ doc = "Nominal Bit Timing and Prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [nbtp](nbtp) module" ] pub type NBTP = crate :: Reg < u32 , _NBTP > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _NBTP ;
# [ doc = "`read()` method returns [nbtp::R](nbtp::R) reader structure" ] impl crate :: Readable for NBTP { }
# [ doc = "`write(|w| ..)` method takes [nbtp::W](nbtp::W) writer structure" ] impl crate :: Writable for NBTP { }
# [ doc = "Nominal Bit Timing and Prescaler" ] pub mod nbtp {
# [ doc = "Reader of register NBTP" ] pub type R = crate :: R < u32 , super :: NBTP > ;
# [ doc = "Writer for register NBTP" ] pub type W = crate :: W < u32 , super :: NBTP > ;
# [ doc = "Register NBTP `reset()`'s with value 0x0600_0a03" ] impl crate :: ResetValue for super :: NBTP { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x0600_0a03 } }
# [ doc = "Reader of field `NTSEG2`" ] pub type NTSEG2_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `NTSEG2`" ] pub struct NTSEG2_W < 'a > { w : & 'a mut W , } impl < 'a > NTSEG2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x7f ) | ( ( value as u32 ) & 0x7f ) ; self . w } }
# [ doc = "Reader of field `NTSEG1`" ] pub type NTSEG1_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `NTSEG1`" ] pub struct NTSEG1_W < 'a > { w : & 'a mut W , } impl < 'a > NTSEG1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u32 ) & 0xff ) << 8 ) ; self . w } }
# [ doc = "Reader of field `NBRP`" ] pub type NBRP_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `NBRP`" ] pub struct NBRP_W < 'a > { w : & 'a mut W , } impl < 'a > NBRP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 16 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 16 ) ; self . w } }
# [ doc = "Reader of field `NSJW`" ] pub type NSJW_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `NSJW`" ] pub struct NSJW_W < 'a > { w : & 'a mut W , } impl < 'a > NSJW_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x7f << 25 ) ) | ( ( ( value as u32 ) & 0x7f ) << 25 ) ; self . w } }
impl R {
# [ doc = "Bits 0:6 - Nominal Time segment after sample point" ] # [ inline ( always ) ] pub fn ntseg2 ( & self ) -> NTSEG2_R { NTSEG2_R :: new ( ( self . bits & 0x7f ) as u8 ) }
# [ doc = "Bits 8:15 - Nominal Time segment before sample point" ] # [ inline ( always ) ] pub fn ntseg1 ( & self ) -> NTSEG1_R { NTSEG1_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
# [ doc = "Bits 16:24 - Nominal Baud Rate Prescaler" ] # [ inline ( always ) ] pub fn nbrp ( & self ) -> NBRP_R { NBRP_R :: new ( ( ( self . bits >> 16 ) & 0x01ff ) as u16 ) }
# [ doc = "Bits 25:31 - Nominal (Re)Synchronization Jump Width" ] # [ inline ( always ) ] pub fn nsjw ( & self ) -> NSJW_R { NSJW_R :: new ( ( ( self . bits >> 25 ) & 0x7f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:6 - Nominal Time segment after sample point" ] # [ inline ( always ) ] pub fn ntseg2 ( & mut self ) -> NTSEG2_W { NTSEG2_W { w : self } }
# [ doc = "Bits 8:15 - Nominal Time segment before sample point" ] # [ inline ( always ) ] pub fn ntseg1 ( & mut self ) -> NTSEG1_W { NTSEG1_W { w : self } }
# [ doc = "Bits 16:24 - Nominal Baud Rate Prescaler" ] # [ inline ( always ) ] pub fn nbrp ( & mut self ) -> NBRP_W { NBRP_W { w : self } }
# [ doc = "Bits 25:31 - Nominal (Re)Synchronization Jump Width" ] # [ inline ( always ) ] pub fn nsjw ( & mut self ) -> NSJW_W { NSJW_W { w : self } }
}
}
# [ doc = "Timestamp Counter Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [tscc](tscc) module" ] pub type TSCC = crate :: Reg < u32 , _TSCC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TSCC ;
# [ doc = "`read()` method returns [tscc::R](tscc::R) reader structure" ] impl crate :: Readable for TSCC { }
# [ doc = "`write(|w| ..)` method takes [tscc::W](tscc::W) writer structure" ] impl crate :: Writable for TSCC { }
# [ doc = "Timestamp Counter Configuration" ] pub mod tscc {
# [ doc = "Reader of register TSCC" ] pub type R = crate :: R < u32 , super :: TSCC > ;
# [ doc = "Writer for register TSCC" ] pub type W = crate :: W < u32 , super :: TSCC > ;
# [ doc = "Register TSCC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TSCC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `TSS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TSS_A { # [ doc = "Timestamp counter value always 0x0000" ] ZERO , # [ doc = "Timestamp counter value incremented by TCP" ] INC , # [ doc = "External timestamp counter value used" ] EXT }
impl crate :: ToBits < u8 > for TSS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { TSS_A :: ZERO => 0 , TSS_A :: INC => 1 , TSS_A :: EXT => 2 } } }
# [ doc = "Reader of field `TSS`" ] pub type TSS_R = crate :: R < u8 , TSS_A > ; impl TSS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , TSS_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TSS_A :: ZERO ) , 1 => Val ( TSS_A :: INC ) , 2 => Val ( TSS_A :: EXT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `ZERO`" ] # [ inline ( always ) ] pub fn is_zero ( & self ) -> bool { * self == TSS_A :: ZERO } # [ doc = "Checks if the value of the field is `INC`" ] # [ inline ( always ) ] pub fn is_inc ( & self ) -> bool { * self == TSS_A :: INC } # [ doc = "Checks if the value of the field is `EXT`" ] # [ inline ( always ) ] pub fn is_ext ( & self ) -> bool { * self == TSS_A :: EXT } }
# [ doc = "Write proxy for field `TSS`" ] pub struct TSS_W < 'a > { w : & 'a mut W , } impl < 'a > TSS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TSS_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Timestamp counter value always 0x0000" ] # [ inline ( always ) ] pub fn zero ( self ) -> & 'a mut W { self . variant ( TSS_A :: ZERO ) } # [ doc = "Timestamp counter value incremented by TCP" ] # [ inline ( always ) ] pub fn inc ( self ) -> & 'a mut W { self . variant ( TSS_A :: INC ) } # [ doc = "External timestamp counter value used" ] # [ inline ( always ) ] pub fn ext ( self ) -> & 'a mut W { self . variant ( TSS_A :: EXT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `TCP`" ] pub type TCP_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `TCP`" ] pub struct TCP_W < 'a > { w : & 'a mut W , } impl < 'a > TCP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 16 ) ) | ( ( ( value as u32 ) & 0x0f ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Timestamp Select" ] # [ inline ( always ) ] pub fn tss ( & self ) -> TSS_R { TSS_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 16:19 - Timestamp Counter Prescaler" ] # [ inline ( always ) ] pub fn tcp ( & self ) -> TCP_R { TCP_R :: new ( ( ( self . bits >> 16 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Timestamp Select" ] # [ inline ( always ) ] pub fn tss ( & mut self ) -> TSS_W { TSS_W { w : self } }
# [ doc = "Bits 16:19 - Timestamp Counter Prescaler" ] # [ inline ( always ) ] pub fn tcp ( & mut self ) -> TCP_W { TCP_W { w : self } }
}
}
# [ doc = "Timestamp Counter Value\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [tscv](tscv) module" ] pub type TSCV = crate :: Reg < u32 , _TSCV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TSCV ;
# [ doc = "`read()` method returns [tscv::R](tscv::R) reader structure" ] impl crate :: Readable for TSCV { }
# [ doc = "Timestamp Counter Value" ] pub mod tscv {
# [ doc = "Reader of register TSCV" ] pub type R = crate :: R < u32 , super :: TSCV > ;
# [ doc = "Reader of field `TSC`" ] pub type TSC_R = crate :: R < u16 , u16 > ;
impl R {
# [ doc = "Bits 0:15 - Timestamp Counter" ] # [ inline ( always ) ] pub fn tsc ( & self ) -> TSC_R { TSC_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
# [ doc = "Timeout Counter Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [tocc](tocc) module" ] pub type TOCC = crate :: Reg < u32 , _TOCC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TOCC ;
# [ doc = "`read()` method returns [tocc::R](tocc::R) reader structure" ] impl crate :: Readable for TOCC { }
# [ doc = "`write(|w| ..)` method takes [tocc::W](tocc::W) writer structure" ] impl crate :: Writable for TOCC { }
# [ doc = "Timeout Counter Configuration" ] pub mod tocc {
# [ doc = "Reader of register TOCC" ] pub type R = crate :: R < u32 , super :: TOCC > ;
# [ doc = "Writer for register TOCC" ] pub type W = crate :: W < u32 , super :: TOCC > ;
# [ doc = "Register TOCC `reset()`'s with value 0xffff_0000" ] impl crate :: ResetValue for super :: TOCC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff_0000 } }
# [ doc = "Reader of field `ETOC`" ] pub type ETOC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ETOC`" ] pub struct ETOC_W < 'a > { w : & 'a mut W , } impl < 'a > ETOC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Possible values of the field `TOS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TOS_A { # [ doc = "Continuout operation" ] CONT , # [ doc = "Timeout controlled by TX Event FIFO" ] TXEF , # [ doc = "Timeout controlled by Rx FIFO 0" ] RXF0 , # [ doc = "Timeout controlled by Rx FIFO 1" ] RXF1 }
impl crate :: ToBits < u8 > for TOS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { TOS_A :: CONT => 0 , TOS_A :: TXEF => 1 , TOS_A :: RXF0 => 2 , TOS_A :: RXF1 => 3 } } }
# [ doc = "Reader of field `TOS`" ] pub type TOS_R = crate :: R < u8 , TOS_A > ; impl TOS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TOS_A { match self . bits { 0 => TOS_A :: CONT , 1 => TOS_A :: TXEF , 2 => TOS_A :: RXF0 , 3 => TOS_A :: RXF1 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CONT`" ] # [ inline ( always ) ] pub fn is_cont ( & self ) -> bool { * self == TOS_A :: CONT } # [ doc = "Checks if the value of the field is `TXEF`" ] # [ inline ( always ) ] pub fn is_txef ( & self ) -> bool { * self == TOS_A :: TXEF } # [ doc = "Checks if the value of the field is `RXF0`" ] # [ inline ( always ) ] pub fn is_rxf0 ( & self ) -> bool { * self == TOS_A :: RXF0 } # [ doc = "Checks if the value of the field is `RXF1`" ] # [ inline ( always ) ] pub fn is_rxf1 ( & self ) -> bool { * self == TOS_A :: RXF1 } }
# [ doc = "Write proxy for field `TOS`" ] pub struct TOS_W < 'a > { w : & 'a mut W , } impl < 'a > TOS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TOS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Continuout operation" ] # [ inline ( always ) ] pub fn cont ( self ) -> & 'a mut W { self . variant ( TOS_A :: CONT ) } # [ doc = "Timeout controlled by TX Event FIFO" ] # [ inline ( always ) ] pub fn txef ( self ) -> & 'a mut W { self . variant ( TOS_A :: TXEF ) } # [ doc = "Timeout controlled by Rx FIFO 0" ] # [ inline ( always ) ] pub fn rxf0 ( self ) -> & 'a mut W { self . variant ( TOS_A :: RXF0 ) } # [ doc = "Timeout controlled by Rx FIFO 1" ] # [ inline ( always ) ] pub fn rxf1 ( self ) -> & 'a mut W { self . variant ( TOS_A :: RXF1 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 1 ) ) | ( ( ( value as u32 ) & 0x03 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TOP`" ] pub type TOP_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `TOP`" ] pub struct TOP_W < 'a > { w : & 'a mut W , } impl < 'a > TOP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Enable Timeout Counter" ] # [ inline ( always ) ] pub fn etoc ( & self ) -> ETOC_R { ETOC_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bits 1:2 - Timeout Select" ] # [ inline ( always ) ] pub fn tos ( & self ) -> TOS_R { TOS_R :: new ( ( ( self . bits >> 1 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 16:31 - Timeout Period" ] # [ inline ( always ) ] pub fn top ( & self ) -> TOP_R { TOP_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bit 0 - Enable Timeout Counter" ] # [ inline ( always ) ] pub fn etoc ( & mut self ) -> ETOC_W { ETOC_W { w : self } }
# [ doc = "Bits 1:2 - Timeout Select" ] # [ inline ( always ) ] pub fn tos ( & mut self ) -> TOS_W { TOS_W { w : self } }
# [ doc = "Bits 16:31 - Timeout Period" ] # [ inline ( always ) ] pub fn top ( & mut self ) -> TOP_W { TOP_W { w : self } }
}
}
# [ doc = "Timeout Counter Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [tocv](tocv) module" ] pub type TOCV = crate :: Reg < u32 , _TOCV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TOCV ;
# [ doc = "`read()` method returns [tocv::R](tocv::R) reader structure" ] impl crate :: Readable for TOCV { }
# [ doc = "`write(|w| ..)` method takes [tocv::W](tocv::W) writer structure" ] impl crate :: Writable for TOCV { }
# [ doc = "Timeout Counter Value" ] pub mod tocv {
# [ doc = "Reader of register TOCV" ] pub type R = crate :: R < u32 , super :: TOCV > ;
# [ doc = "Writer for register TOCV" ] pub type W = crate :: W < u32 , super :: TOCV > ;
# [ doc = "Register TOCV `reset()`'s with value 0xffff" ] impl crate :: ResetValue for super :: TOCV { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff } }
# [ doc = "Reader of field `TOC`" ] pub type TOC_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `TOC`" ] pub struct TOC_W < 'a > { w : & 'a mut W , } impl < 'a > TOC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Timeout Counter" ] # [ inline ( always ) ] pub fn toc ( & self ) -> TOC_R { TOC_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - Timeout Counter" ] # [ inline ( always ) ] pub fn toc ( & mut self ) -> TOC_W { TOC_W { w : self } }
}
}
# [ doc = "Error Counter\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ecr](ecr) module" ] pub type ECR = crate :: Reg < u32 , _ECR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ECR ;
# [ doc = "`read()` method returns [ecr::R](ecr::R) reader structure" ] impl crate :: Readable for ECR { }
# [ doc = "Error Counter" ] pub mod ecr {
# [ doc = "Reader of register ECR" ] pub type R = crate :: R < u32 , super :: ECR > ;
# [ doc = "Reader of field `TEC`" ] pub type TEC_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `REC`" ] pub type REC_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `RP`" ] pub type RP_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CEL`" ] pub type CEL_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Transmit Error Counter" ] # [ inline ( always ) ] pub fn tec ( & self ) -> TEC_R { TEC_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bits 8:14 - Receive Error Counter" ] # [ inline ( always ) ] pub fn rec ( & self ) -> REC_R { REC_R :: new ( ( ( self . bits >> 8 ) & 0x7f ) as u8 ) }
# [ doc = "Bit 15 - Receive Error Passive" ] # [ inline ( always ) ] pub fn rp ( & self ) -> RP_R { RP_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:23 - CAN Error Logging" ] # [ inline ( always ) ] pub fn cel ( & self ) -> CEL_R { CEL_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) }
}
}
# [ doc = "Protocol Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [psr](psr) module" ] pub type PSR = crate :: Reg < u32 , _PSR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PSR ;
# [ doc = "`read()` method returns [psr::R](psr::R) reader structure" ] impl crate :: Readable for PSR { }
# [ doc = "Protocol Status" ] pub mod psr {
# [ doc = "Reader of register PSR" ] pub type R = crate :: R < u32 , super :: PSR > ;
# [ doc = "Possible values of the field `LEC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LEC_A { # [ doc = "No Error" ] NONE , # [ doc = "Stuff Error" ] STUFF , # [ doc = "Form Error" ] FORM , # [ doc = "Ack Error" ] ACK , # [ doc = "Bit1 Error" ] BIT1 , # [ doc = "Bit0 Error" ] BIT0 , # [ doc = "CRC Error" ] CRC , # [ doc = "No Change" ] NC }
impl crate :: ToBits < u8 > for LEC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { LEC_A :: NONE => 0 , LEC_A :: STUFF => 1 , LEC_A :: FORM => 2 , LEC_A :: ACK => 3 , LEC_A :: BIT1 => 4 , LEC_A :: BIT0 => 5 , LEC_A :: CRC => 6 , LEC_A :: NC => 7 } } }
# [ doc = "Reader of field `LEC`" ] pub type LEC_R = crate :: R < u8 , LEC_A > ; impl LEC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> LEC_A { match self . bits { 0 => LEC_A :: NONE , 1 => LEC_A :: STUFF , 2 => LEC_A :: FORM , 3 => LEC_A :: ACK , 4 => LEC_A :: BIT1 , 5 => LEC_A :: BIT0 , 6 => LEC_A :: CRC , 7 => LEC_A :: NC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == LEC_A :: NONE } # [ doc = "Checks if the value of the field is `STUFF`" ] # [ inline ( always ) ] pub fn is_stuff ( & self ) -> bool { * self == LEC_A :: STUFF } # [ doc = "Checks if the value of the field is `FORM`" ] # [ inline ( always ) ] pub fn is_form ( & self ) -> bool { * self == LEC_A :: FORM } # [ doc = "Checks if the value of the field is `ACK`" ] # [ inline ( always ) ] pub fn is_ack ( & self ) -> bool { * self == LEC_A :: ACK } # [ doc = "Checks if the value of the field is `BIT1`" ] # [ inline ( always ) ] pub fn is_bit1 ( & self ) -> bool { * self == LEC_A :: BIT1 } # [ doc = "Checks if the value of the field is `BIT0`" ] # [ inline ( always ) ] pub fn is_bit0 ( & self ) -> bool { * self == LEC_A :: BIT0 } # [ doc = "Checks if the value of the field is `CRC`" ] # [ inline ( always ) ] pub fn is_crc ( & self ) -> bool { * self == LEC_A :: CRC } # [ doc = "Checks if the value of the field is `NC`" ] # [ inline ( always ) ] pub fn is_nc ( & self ) -> bool { * self == LEC_A :: NC } }
# [ doc = "Possible values of the field `ACT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ACT_A { # [ doc = "Node is synchronizing on CAN communication" ] SYNC , # [ doc = "Node is neither receiver nor transmitter" ] IDLE , # [ doc = "Node is operating as receiver" ] RX , # [ doc = "Node is operating as transmitter" ] TX }
impl crate :: ToBits < u8 > for ACT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { ACT_A :: SYNC => 0 , ACT_A :: IDLE => 1 , ACT_A :: RX => 2 , ACT_A :: TX => 3 } } }
# [ doc = "Reader of field `ACT`" ] pub type ACT_R = crate :: R < u8 , ACT_A > ; impl ACT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ACT_A { match self . bits { 0 => ACT_A :: SYNC , 1 => ACT_A :: IDLE , 2 => ACT_A :: RX , 3 => ACT_A :: TX , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == ACT_A :: SYNC } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == ACT_A :: IDLE } # [ doc = "Checks if the value of the field is `RX`" ] # [ inline ( always ) ] pub fn is_rx ( & self ) -> bool { * self == ACT_A :: RX } # [ doc = "Checks if the value of the field is `TX`" ] # [ inline ( always ) ] pub fn is_tx ( & self ) -> bool { * self == ACT_A :: TX } }
# [ doc = "Reader of field `EP`" ] pub type EP_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `EW`" ] pub type EW_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BO`" ] pub type BO_R = crate :: R < bool , bool > ;
# [ doc = "Possible values of the field `DLEC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DLEC_A { # [ doc = "No Error" ] NONE , # [ doc = "Stuff Error" ] STUFF , # [ doc = "Form Error" ] FORM , # [ doc = "Ack Error" ] ACK , # [ doc = "Bit1 Error" ] BIT1 , # [ doc = "Bit0 Error" ] BIT0 , # [ doc = "CRC Error" ] CRC , # [ doc = "No Change" ] NC }
impl crate :: ToBits < u8 > for DLEC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DLEC_A :: NONE => 0 , DLEC_A :: STUFF => 1 , DLEC_A :: FORM => 2 , DLEC_A :: ACK => 3 , DLEC_A :: BIT1 => 4 , DLEC_A :: BIT0 => 5 , DLEC_A :: CRC => 6 , DLEC_A :: NC => 7 } } }
# [ doc = "Reader of field `DLEC`" ] pub type DLEC_R = crate :: R < u8 , DLEC_A > ; impl DLEC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DLEC_A { match self . bits { 0 => DLEC_A :: NONE , 1 => DLEC_A :: STUFF , 2 => DLEC_A :: FORM , 3 => DLEC_A :: ACK , 4 => DLEC_A :: BIT1 , 5 => DLEC_A :: BIT0 , 6 => DLEC_A :: CRC , 7 => DLEC_A :: NC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == DLEC_A :: NONE } # [ doc = "Checks if the value of the field is `STUFF`" ] # [ inline ( always ) ] pub fn is_stuff ( & self ) -> bool { * self == DLEC_A :: STUFF } # [ doc = "Checks if the value of the field is `FORM`" ] # [ inline ( always ) ] pub fn is_form ( & self ) -> bool { * self == DLEC_A :: FORM } # [ doc = "Checks if the value of the field is `ACK`" ] # [ inline ( always ) ] pub fn is_ack ( & self ) -> bool { * self == DLEC_A :: ACK } # [ doc = "Checks if the value of the field is `BIT1`" ] # [ inline ( always ) ] pub fn is_bit1 ( & self ) -> bool { * self == DLEC_A :: BIT1 } # [ doc = "Checks if the value of the field is `BIT0`" ] # [ inline ( always ) ] pub fn is_bit0 ( & self ) -> bool { * self == DLEC_A :: BIT0 } # [ doc = "Checks if the value of the field is `CRC`" ] # [ inline ( always ) ] pub fn is_crc ( & self ) -> bool { * self == DLEC_A :: CRC } # [ doc = "Checks if the value of the field is `NC`" ] # [ inline ( always ) ] pub fn is_nc ( & self ) -> bool { * self == DLEC_A :: NC } }
# [ doc = "Reader of field `RESI`" ] pub type RESI_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `RBRS`" ] pub type RBRS_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `RFDF`" ] pub type RFDF_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PXE`" ] pub type PXE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TDCV`" ] pub type TDCV_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:2 - Last Error Code" ] # [ inline ( always ) ] pub fn lec ( & self ) -> LEC_R { LEC_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bits 3:4 - Activity" ] # [ inline ( always ) ] pub fn act ( & self ) -> ACT_R { ACT_R :: new ( ( ( self . bits >> 3 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 5 - Error Passive" ] # [ inline ( always ) ] pub fn ep ( & self ) -> EP_R { EP_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Warning Status" ] # [ inline ( always ) ] pub fn ew ( & self ) -> EW_R { EW_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Bus_Off Status" ] # [ inline ( always ) ] pub fn bo ( & self ) -> BO_R { BO_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Data Phase Last Error Code" ] # [ inline ( always ) ] pub fn dlec ( & self ) -> DLEC_R { DLEC_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 11 - ESI flag of last received CAN FD Message" ] # [ inline ( always ) ] pub fn resi ( & self ) -> RESI_R { RESI_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - BRS flag of last received CAN FD Message" ] # [ inline ( always ) ] pub fn rbrs ( & self ) -> RBRS_R { RBRS_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Received a CAN FD Message" ] # [ inline ( always ) ] pub fn rfdf ( & self ) -> RFDF_R { RFDF_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Protocol Exception Event" ] # [ inline ( always ) ] pub fn pxe ( & self ) -> PXE_R { PXE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:22 - Transmitter Delay Compensation Value" ] # [ inline ( always ) ] pub fn tdcv ( & self ) -> TDCV_R { TDCV_R :: new ( ( ( self . bits >> 16 ) & 0x7f ) as u8 ) }
}
}
# [ doc = "Extended ID Filter Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [tdcr](tdcr) module" ] pub type TDCR = crate :: Reg < u32 , _TDCR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TDCR ;
# [ doc = "`read()` method returns [tdcr::R](tdcr::R) reader structure" ] impl crate :: Readable for TDCR { }
# [ doc = "`write(|w| ..)` method takes [tdcr::W](tdcr::W) writer structure" ] impl crate :: Writable for TDCR { }
# [ doc = "Extended ID Filter Configuration" ] pub mod tdcr {
# [ doc = "Reader of register TDCR" ] pub type R = crate :: R < u32 , super :: TDCR > ;
# [ doc = "Writer for register TDCR" ] pub type W = crate :: W < u32 , super :: TDCR > ;
# [ doc = "Register TDCR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TDCR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `TDCF`" ] pub type TDCF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `TDCF`" ] pub struct TDCF_W < 'a > { w : & 'a mut W , } impl < 'a > TDCF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x7f ) | ( ( value as u32 ) & 0x7f ) ; self . w } }
# [ doc = "Reader of field `TDCO`" ] pub type TDCO_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `TDCO`" ] pub struct TDCO_W < 'a > { w : & 'a mut W , } impl < 'a > TDCO_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x7f << 8 ) ) | ( ( ( value as u32 ) & 0x7f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:6 - Transmitter Delay Compensation Filter Length" ] # [ inline ( always ) ] pub fn tdcf ( & self ) -> TDCF_R { TDCF_R :: new ( ( self . bits & 0x7f ) as u8 ) }
# [ doc = "Bits 8:14 - Transmitter Delay Compensation Offset" ] # [ inline ( always ) ] pub fn tdco ( & self ) -> TDCO_R { TDCO_R :: new ( ( ( self . bits >> 8 ) & 0x7f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:6 - Transmitter Delay Compensation Filter Length" ] # [ inline ( always ) ] pub fn tdcf ( & mut self ) -> TDCF_W { TDCF_W { w : self } }
# [ doc = "Bits 8:14 - Transmitter Delay Compensation Offset" ] # [ inline ( always ) ] pub fn tdco ( & mut self ) -> TDCO_W { TDCO_W { w : self } }
}
}
# [ doc = "Interrupt\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ir](ir) module" ] pub type IR = crate :: Reg < u32 , _IR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _IR ;
# [ doc = "`read()` method returns [ir::R](ir::R) reader structure" ] impl crate :: Readable for IR { }
# [ doc = "`write(|w| ..)` method takes [ir::W](ir::W) writer structure" ] impl crate :: Writable for IR { }
# [ doc = "Interrupt" ] pub mod ir {
# [ doc = "Reader of register IR" ] pub type R = crate :: R < u32 , super :: IR > ;
# [ doc = "Writer for register IR" ] pub type W = crate :: W < u32 , super :: IR > ;
# [ doc = "Register IR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: IR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RF0N`" ] pub type RF0N_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0N`" ] pub struct RF0N_W < 'a > { w : & 'a mut W , } impl < 'a > RF0N_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `RF0W`" ] pub type RF0W_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0W`" ] pub struct RF0W_W < 'a > { w : & 'a mut W , } impl < 'a > RF0W_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RF0F`" ] pub type RF0F_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0F`" ] pub struct RF0F_W < 'a > { w : & 'a mut W , } impl < 'a > RF0F_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `RF0L`" ] pub type RF0L_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0L`" ] pub struct RF0L_W < 'a > { w : & 'a mut W , } impl < 'a > RF0L_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `RF1N`" ] pub type RF1N_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1N`" ] pub struct RF1N_W < 'a > { w : & 'a mut W , } impl < 'a > RF1N_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `RF1W`" ] pub type RF1W_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1W`" ] pub struct RF1W_W < 'a > { w : & 'a mut W , } impl < 'a > RF1W_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `RF1F`" ] pub type RF1F_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1F`" ] pub struct RF1F_W < 'a > { w : & 'a mut W , } impl < 'a > RF1F_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `RF1L`" ] pub type RF1L_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1L`" ] pub struct RF1L_W < 'a > { w : & 'a mut W , } impl < 'a > RF1L_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `HPM`" ] pub type HPM_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPM`" ] pub struct HPM_W < 'a > { w : & 'a mut W , } impl < 'a > HPM_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `TC`" ] pub type TC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC`" ] pub struct TC_W < 'a > { w : & 'a mut W , } impl < 'a > TC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `TCF`" ] pub type TCF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCF`" ] pub struct TCF_W < 'a > { w : & 'a mut W , } impl < 'a > TCF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `TFE`" ] pub type TFE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TFE`" ] pub struct TFE_W < 'a > { w : & 'a mut W , } impl < 'a > TFE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `TEFN`" ] pub type TEFN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFN`" ] pub struct TEFN_W < 'a > { w : & 'a mut W , } impl < 'a > TEFN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `TEFW`" ] pub type TEFW_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFW`" ] pub struct TEFW_W < 'a > { w : & 'a mut W , } impl < 'a > TEFW_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `TEFF`" ] pub type TEFF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFF`" ] pub struct TEFF_W < 'a > { w : & 'a mut W , } impl < 'a > TEFF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `TEFL`" ] pub type TEFL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFL`" ] pub struct TEFL_W < 'a > { w : & 'a mut W , } impl < 'a > TEFL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `TSW`" ] pub type TSW_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TSW`" ] pub struct TSW_W < 'a > { w : & 'a mut W , } impl < 'a > TSW_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `MRAF`" ] pub type MRAF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MRAF`" ] pub struct MRAF_W < 'a > { w : & 'a mut W , } impl < 'a > MRAF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `TOO`" ] pub type TOO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TOO`" ] pub struct TOO_W < 'a > { w : & 'a mut W , } impl < 'a > TOO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `DRX`" ] pub type DRX_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DRX`" ] pub struct DRX_W < 'a > { w : & 'a mut W , } impl < 'a > DRX_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `BEC`" ] pub type BEC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BEC`" ] pub struct BEC_W < 'a > { w : & 'a mut W , } impl < 'a > BEC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `BEU`" ] pub type BEU_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BEU`" ] pub struct BEU_W < 'a > { w : & 'a mut W , } impl < 'a > BEU_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `ELO`" ] pub type ELO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ELO`" ] pub struct ELO_W < 'a > { w : & 'a mut W , } impl < 'a > ELO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `EP`" ] pub type EP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EP`" ] pub struct EP_W < 'a > { w : & 'a mut W , } impl < 'a > EP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `EW`" ] pub type EW_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EW`" ] pub struct EW_W < 'a > { w : & 'a mut W , } impl < 'a > EW_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `BO`" ] pub type BO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BO`" ] pub struct BO_W < 'a > { w : & 'a mut W , } impl < 'a > BO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `WDI`" ] pub type WDI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WDI`" ] pub struct WDI_W < 'a > { w : & 'a mut W , } impl < 'a > WDI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `PEA`" ] pub type PEA_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PEA`" ] pub struct PEA_W < 'a > { w : & 'a mut W , } impl < 'a > PEA_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Reader of field `PED`" ] pub type PED_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PED`" ] pub struct PED_W < 'a > { w : & 'a mut W , } impl < 'a > PED_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `ARA`" ] pub type ARA_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ARA`" ] pub struct ARA_W < 'a > { w : & 'a mut W , } impl < 'a > ARA_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Rx FIFO 0 New Message" ] # [ inline ( always ) ] pub fn rf0n ( & self ) -> RF0N_R { RF0N_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Rx FIFO 0 Watermark Reached" ] # [ inline ( always ) ] pub fn rf0w ( & self ) -> RF0W_R { RF0W_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Rx FIFO 0 Full" ] # [ inline ( always ) ] pub fn rf0f ( & self ) -> RF0F_R { RF0F_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Rx FIFO 0 Message Lost" ] # [ inline ( always ) ] pub fn rf0l ( & self ) -> RF0L_R { RF0L_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Rx FIFO 1 New Message" ] # [ inline ( always ) ] pub fn rf1n ( & self ) -> RF1N_R { RF1N_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Rx FIFO 1 Watermark Reached" ] # [ inline ( always ) ] pub fn rf1w ( & self ) -> RF1W_R { RF1W_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Rx FIFO 1 FIFO Full" ] # [ inline ( always ) ] pub fn rf1f ( & self ) -> RF1F_R { RF1F_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Rx FIFO 1 Message Lost" ] # [ inline ( always ) ] pub fn rf1l ( & self ) -> RF1L_R { RF1L_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - High Priority Message" ] # [ inline ( always ) ] pub fn hpm ( & self ) -> HPM_R { HPM_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Timestamp Completed" ] # [ inline ( always ) ] pub fn tc ( & self ) -> TC_R { TC_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Transmission Cancellation Finished" ] # [ inline ( always ) ] pub fn tcf ( & self ) -> TCF_R { TCF_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Tx FIFO Empty" ] # [ inline ( always ) ] pub fn tfe ( & self ) -> TFE_R { TFE_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Tx Event FIFO New Entry" ] # [ inline ( always ) ] pub fn tefn ( & self ) -> TEFN_R { TEFN_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Tx Event FIFO Watermark Reached" ] # [ inline ( always ) ] pub fn tefw ( & self ) -> TEFW_R { TEFW_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Tx Event FIFO Full" ] # [ inline ( always ) ] pub fn teff ( & self ) -> TEFF_R { TEFF_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Tx Event FIFO Element Lost" ] # [ inline ( always ) ] pub fn tefl ( & self ) -> TEFL_R { TEFL_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Timestamp Wraparound" ] # [ inline ( always ) ] pub fn tsw ( & self ) -> TSW_R { TSW_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Message RAM Access Failure" ] # [ inline ( always ) ] pub fn mraf ( & self ) -> MRAF_R { MRAF_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Timeout Occurred" ] # [ inline ( always ) ] pub fn too ( & self ) -> TOO_R { TOO_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Message stored to Dedicated Rx Buffer" ] # [ inline ( always ) ] pub fn drx ( & self ) -> DRX_R { DRX_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Bit Error Corrected" ] # [ inline ( always ) ] pub fn bec ( & self ) -> BEC_R { BEC_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Bit Error Uncorrected" ] # [ inline ( always ) ] pub fn beu ( & self ) -> BEU_R { BEU_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Error Logging Overflow" ] # [ inline ( always ) ] pub fn elo ( & self ) -> ELO_R { ELO_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Error Passive" ] # [ inline ( always ) ] pub fn ep ( & self ) -> EP_R { EP_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Warning Status" ] # [ inline ( always ) ] pub fn ew ( & self ) -> EW_R { EW_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Bus_Off Status" ] # [ inline ( always ) ] pub fn bo ( & self ) -> BO_R { BO_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Watchdog Interrupt" ] # [ inline ( always ) ] pub fn wdi ( & self ) -> WDI_R { WDI_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Protocol Error in Arbitration Phase" ] # [ inline ( always ) ] pub fn pea ( & self ) -> PEA_R { PEA_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Protocol Error in Data Phase" ] # [ inline ( always ) ] pub fn ped ( & self ) -> PED_R { PED_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Access to Reserved Address" ] # [ inline ( always ) ] pub fn ara ( & self ) -> ARA_R { ARA_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Rx FIFO 0 New Message" ] # [ inline ( always ) ] pub fn rf0n ( & mut self ) -> RF0N_W { RF0N_W { w : self } }
# [ doc = "Bit 1 - Rx FIFO 0 Watermark Reached" ] # [ inline ( always ) ] pub fn rf0w ( & mut self ) -> RF0W_W { RF0W_W { w : self } }
# [ doc = "Bit 2 - Rx FIFO 0 Full" ] # [ inline ( always ) ] pub fn rf0f ( & mut self ) -> RF0F_W { RF0F_W { w : self } }
# [ doc = "Bit 3 - Rx FIFO 0 Message Lost" ] # [ inline ( always ) ] pub fn rf0l ( & mut self ) -> RF0L_W { RF0L_W { w : self } }
# [ doc = "Bit 4 - Rx FIFO 1 New Message" ] # [ inline ( always ) ] pub fn rf1n ( & mut self ) -> RF1N_W { RF1N_W { w : self } }
# [ doc = "Bit 5 - Rx FIFO 1 Watermark Reached" ] # [ inline ( always ) ] pub fn rf1w ( & mut self ) -> RF1W_W { RF1W_W { w : self } }
# [ doc = "Bit 6 - Rx FIFO 1 FIFO Full" ] # [ inline ( always ) ] pub fn rf1f ( & mut self ) -> RF1F_W { RF1F_W { w : self } }
# [ doc = "Bit 7 - Rx FIFO 1 Message Lost" ] # [ inline ( always ) ] pub fn rf1l ( & mut self ) -> RF1L_W { RF1L_W { w : self } }
# [ doc = "Bit 8 - High Priority Message" ] # [ inline ( always ) ] pub fn hpm ( & mut self ) -> HPM_W { HPM_W { w : self } }
# [ doc = "Bit 9 - Timestamp Completed" ] # [ inline ( always ) ] pub fn tc ( & mut self ) -> TC_W { TC_W { w : self } }
# [ doc = "Bit 10 - Transmission Cancellation Finished" ] # [ inline ( always ) ] pub fn tcf ( & mut self ) -> TCF_W { TCF_W { w : self } }
# [ doc = "Bit 11 - Tx FIFO Empty" ] # [ inline ( always ) ] pub fn tfe ( & mut self ) -> TFE_W { TFE_W { w : self } }
# [ doc = "Bit 12 - Tx Event FIFO New Entry" ] # [ inline ( always ) ] pub fn tefn ( & mut self ) -> TEFN_W { TEFN_W { w : self } }
# [ doc = "Bit 13 - Tx Event FIFO Watermark Reached" ] # [ inline ( always ) ] pub fn tefw ( & mut self ) -> TEFW_W { TEFW_W { w : self } }
# [ doc = "Bit 14 - Tx Event FIFO Full" ] # [ inline ( always ) ] pub fn teff ( & mut self ) -> TEFF_W { TEFF_W { w : self } }
# [ doc = "Bit 15 - Tx Event FIFO Element Lost" ] # [ inline ( always ) ] pub fn tefl ( & mut self ) -> TEFL_W { TEFL_W { w : self } }
# [ doc = "Bit 16 - Timestamp Wraparound" ] # [ inline ( always ) ] pub fn tsw ( & mut self ) -> TSW_W { TSW_W { w : self } }
# [ doc = "Bit 17 - Message RAM Access Failure" ] # [ inline ( always ) ] pub fn mraf ( & mut self ) -> MRAF_W { MRAF_W { w : self } }
# [ doc = "Bit 18 - Timeout Occurred" ] # [ inline ( always ) ] pub fn too ( & mut self ) -> TOO_W { TOO_W { w : self } }
# [ doc = "Bit 19 - Message stored to Dedicated Rx Buffer" ] # [ inline ( always ) ] pub fn drx ( & mut self ) -> DRX_W { DRX_W { w : self } }
# [ doc = "Bit 20 - Bit Error Corrected" ] # [ inline ( always ) ] pub fn bec ( & mut self ) -> BEC_W { BEC_W { w : self } }
# [ doc = "Bit 21 - Bit Error Uncorrected" ] # [ inline ( always ) ] pub fn beu ( & mut self ) -> BEU_W { BEU_W { w : self } }
# [ doc = "Bit 22 - Error Logging Overflow" ] # [ inline ( always ) ] pub fn elo ( & mut self ) -> ELO_W { ELO_W { w : self } }
# [ doc = "Bit 23 - Error Passive" ] # [ inline ( always ) ] pub fn ep ( & mut self ) -> EP_W { EP_W { w : self } }
# [ doc = "Bit 24 - Warning Status" ] # [ inline ( always ) ] pub fn ew ( & mut self ) -> EW_W { EW_W { w : self } }
# [ doc = "Bit 25 - Bus_Off Status" ] # [ inline ( always ) ] pub fn bo ( & mut self ) -> BO_W { BO_W { w : self } }
# [ doc = "Bit 26 - Watchdog Interrupt" ] # [ inline ( always ) ] pub fn wdi ( & mut self ) -> WDI_W { WDI_W { w : self } }
# [ doc = "Bit 27 - Protocol Error in Arbitration Phase" ] # [ inline ( always ) ] pub fn pea ( & mut self ) -> PEA_W { PEA_W { w : self } }
# [ doc = "Bit 28 - Protocol Error in Data Phase" ] # [ inline ( always ) ] pub fn ped ( & mut self ) -> PED_W { PED_W { w : self } }
# [ doc = "Bit 29 - Access to Reserved Address" ] # [ inline ( always ) ] pub fn ara ( & mut self ) -> ARA_W { ARA_W { w : self } }
}
}
# [ doc = "Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ie](ie) module" ] pub type IE = crate :: Reg < u32 , _IE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _IE ;
# [ doc = "`read()` method returns [ie::R](ie::R) reader structure" ] impl crate :: Readable for IE { }
# [ doc = "`write(|w| ..)` method takes [ie::W](ie::W) writer structure" ] impl crate :: Writable for IE { }
# [ doc = "Interrupt Enable" ] pub mod ie {
# [ doc = "Reader of register IE" ] pub type R = crate :: R < u32 , super :: IE > ;
# [ doc = "Writer for register IE" ] pub type W = crate :: W < u32 , super :: IE > ;
# [ doc = "Register IE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: IE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RF0NE`" ] pub type RF0NE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0NE`" ] pub struct RF0NE_W < 'a > { w : & 'a mut W , } impl < 'a > RF0NE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `RF0WE`" ] pub type RF0WE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0WE`" ] pub struct RF0WE_W < 'a > { w : & 'a mut W , } impl < 'a > RF0WE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RF0FE`" ] pub type RF0FE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0FE`" ] pub struct RF0FE_W < 'a > { w : & 'a mut W , } impl < 'a > RF0FE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `RF0LE`" ] pub type RF0LE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0LE`" ] pub struct RF0LE_W < 'a > { w : & 'a mut W , } impl < 'a > RF0LE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `RF1NE`" ] pub type RF1NE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1NE`" ] pub struct RF1NE_W < 'a > { w : & 'a mut W , } impl < 'a > RF1NE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `RF1WE`" ] pub type RF1WE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1WE`" ] pub struct RF1WE_W < 'a > { w : & 'a mut W , } impl < 'a > RF1WE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `RF1FE`" ] pub type RF1FE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1FE`" ] pub struct RF1FE_W < 'a > { w : & 'a mut W , } impl < 'a > RF1FE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `RF1LE`" ] pub type RF1LE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1LE`" ] pub struct RF1LE_W < 'a > { w : & 'a mut W , } impl < 'a > RF1LE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `HPME`" ] pub type HPME_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPME`" ] pub struct HPME_W < 'a > { w : & 'a mut W , } impl < 'a > HPME_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `TCE`" ] pub type TCE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCE`" ] pub struct TCE_W < 'a > { w : & 'a mut W , } impl < 'a > TCE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `TCFE`" ] pub type TCFE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCFE`" ] pub struct TCFE_W < 'a > { w : & 'a mut W , } impl < 'a > TCFE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `TFEE`" ] pub type TFEE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TFEE`" ] pub struct TFEE_W < 'a > { w : & 'a mut W , } impl < 'a > TFEE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `TEFNE`" ] pub type TEFNE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFNE`" ] pub struct TEFNE_W < 'a > { w : & 'a mut W , } impl < 'a > TEFNE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `TEFWE`" ] pub type TEFWE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFWE`" ] pub struct TEFWE_W < 'a > { w : & 'a mut W , } impl < 'a > TEFWE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `TEFFE`" ] pub type TEFFE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFFE`" ] pub struct TEFFE_W < 'a > { w : & 'a mut W , } impl < 'a > TEFFE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `TEFLE`" ] pub type TEFLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFLE`" ] pub struct TEFLE_W < 'a > { w : & 'a mut W , } impl < 'a > TEFLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `TSWE`" ] pub type TSWE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TSWE`" ] pub struct TSWE_W < 'a > { w : & 'a mut W , } impl < 'a > TSWE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `MRAFE`" ] pub type MRAFE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MRAFE`" ] pub struct MRAFE_W < 'a > { w : & 'a mut W , } impl < 'a > MRAFE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `TOOE`" ] pub type TOOE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TOOE`" ] pub struct TOOE_W < 'a > { w : & 'a mut W , } impl < 'a > TOOE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `DRXE`" ] pub type DRXE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DRXE`" ] pub struct DRXE_W < 'a > { w : & 'a mut W , } impl < 'a > DRXE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `BECE`" ] pub type BECE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BECE`" ] pub struct BECE_W < 'a > { w : & 'a mut W , } impl < 'a > BECE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `BEUE`" ] pub type BEUE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BEUE`" ] pub struct BEUE_W < 'a > { w : & 'a mut W , } impl < 'a > BEUE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `ELOE`" ] pub type ELOE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ELOE`" ] pub struct ELOE_W < 'a > { w : & 'a mut W , } impl < 'a > ELOE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `EPE`" ] pub type EPE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EPE`" ] pub struct EPE_W < 'a > { w : & 'a mut W , } impl < 'a > EPE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `EWE`" ] pub type EWE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EWE`" ] pub struct EWE_W < 'a > { w : & 'a mut W , } impl < 'a > EWE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `BOE`" ] pub type BOE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BOE`" ] pub struct BOE_W < 'a > { w : & 'a mut W , } impl < 'a > BOE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `WDIE`" ] pub type WDIE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WDIE`" ] pub struct WDIE_W < 'a > { w : & 'a mut W , } impl < 'a > WDIE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `PEAE`" ] pub type PEAE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PEAE`" ] pub struct PEAE_W < 'a > { w : & 'a mut W , } impl < 'a > PEAE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Reader of field `PEDE`" ] pub type PEDE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PEDE`" ] pub struct PEDE_W < 'a > { w : & 'a mut W , } impl < 'a > PEDE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `ARAE`" ] pub type ARAE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ARAE`" ] pub struct ARAE_W < 'a > { w : & 'a mut W , } impl < 'a > ARAE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Rx FIFO 0 New Message Interrupt Enable" ] # [ inline ( always ) ] pub fn rf0ne ( & self ) -> RF0NE_R { RF0NE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Rx FIFO 0 Watermark Reached Interrupt Enable" ] # [ inline ( always ) ] pub fn rf0we ( & self ) -> RF0WE_R { RF0WE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Rx FIFO 0 Full Interrupt Enable" ] # [ inline ( always ) ] pub fn rf0fe ( & self ) -> RF0FE_R { RF0FE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Rx FIFO 0 Message Lost Interrupt Enable" ] # [ inline ( always ) ] pub fn rf0le ( & self ) -> RF0LE_R { RF0LE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Rx FIFO 1 New Message Interrupt Enable" ] # [ inline ( always ) ] pub fn rf1ne ( & self ) -> RF1NE_R { RF1NE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Rx FIFO 1 Watermark Reached Interrupt Enable" ] # [ inline ( always ) ] pub fn rf1we ( & self ) -> RF1WE_R { RF1WE_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Rx FIFO 1 FIFO Full Interrupt Enable" ] # [ inline ( always ) ] pub fn rf1fe ( & self ) -> RF1FE_R { RF1FE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Rx FIFO 1 Message Lost Interrupt Enable" ] # [ inline ( always ) ] pub fn rf1le ( & self ) -> RF1LE_R { RF1LE_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - High Priority Message Interrupt Enable" ] # [ inline ( always ) ] pub fn hpme ( & self ) -> HPME_R { HPME_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Timestamp Completed Interrupt Enable" ] # [ inline ( always ) ] pub fn tce ( & self ) -> TCE_R { TCE_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Transmission Cancellation Finished Interrupt Enable" ] # [ inline ( always ) ] pub fn tcfe ( & self ) -> TCFE_R { TCFE_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Tx FIFO Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn tfee ( & self ) -> TFEE_R { TFEE_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Tx Event FIFO New Entry Interrupt Enable" ] # [ inline ( always ) ] pub fn tefne ( & self ) -> TEFNE_R { TEFNE_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Tx Event FIFO Watermark Reached Interrupt Enable" ] # [ inline ( always ) ] pub fn tefwe ( & self ) -> TEFWE_R { TEFWE_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Tx Event FIFO Full Interrupt Enable" ] # [ inline ( always ) ] pub fn teffe ( & self ) -> TEFFE_R { TEFFE_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Tx Event FIFO Element Lost Interrupt Enable" ] # [ inline ( always ) ] pub fn tefle ( & self ) -> TEFLE_R { TEFLE_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Timestamp Wraparound Interrupt Enable" ] # [ inline ( always ) ] pub fn tswe ( & self ) -> TSWE_R { TSWE_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Message RAM Access Failure Interrupt Enable" ] # [ inline ( always ) ] pub fn mrafe ( & self ) -> MRAFE_R { MRAFE_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Timeout Occurred Interrupt Enable" ] # [ inline ( always ) ] pub fn tooe ( & self ) -> TOOE_R { TOOE_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Message stored to Dedicated Rx Buffer Interrupt Enable" ] # [ inline ( always ) ] pub fn drxe ( & self ) -> DRXE_R { DRXE_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Bit Error Corrected Interrupt Enable" ] # [ inline ( always ) ] pub fn bece ( & self ) -> BECE_R { BECE_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Bit Error Uncorrected Interrupt Enable" ] # [ inline ( always ) ] pub fn beue ( & self ) -> BEUE_R { BEUE_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Error Logging Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn eloe ( & self ) -> ELOE_R { ELOE_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Error Passive Interrupt Enable" ] # [ inline ( always ) ] pub fn epe ( & self ) -> EPE_R { EPE_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Warning Status Interrupt Enable" ] # [ inline ( always ) ] pub fn ewe ( & self ) -> EWE_R { EWE_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Bus_Off Status Interrupt Enable" ] # [ inline ( always ) ] pub fn boe ( & self ) -> BOE_R { BOE_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Watchdog Interrupt Interrupt Enable" ] # [ inline ( always ) ] pub fn wdie ( & self ) -> WDIE_R { WDIE_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Protocol Error in Arbitration Phase Enable" ] # [ inline ( always ) ] pub fn peae ( & self ) -> PEAE_R { PEAE_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Protocol Error in Data Phase Enable" ] # [ inline ( always ) ] pub fn pede ( & self ) -> PEDE_R { PEDE_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Access to Reserved Address Enable" ] # [ inline ( always ) ] pub fn arae ( & self ) -> ARAE_R { ARAE_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Rx FIFO 0 New Message Interrupt Enable" ] # [ inline ( always ) ] pub fn rf0ne ( & mut self ) -> RF0NE_W { RF0NE_W { w : self } }
# [ doc = "Bit 1 - Rx FIFO 0 Watermark Reached Interrupt Enable" ] # [ inline ( always ) ] pub fn rf0we ( & mut self ) -> RF0WE_W { RF0WE_W { w : self } }
# [ doc = "Bit 2 - Rx FIFO 0 Full Interrupt Enable" ] # [ inline ( always ) ] pub fn rf0fe ( & mut self ) -> RF0FE_W { RF0FE_W { w : self } }
# [ doc = "Bit 3 - Rx FIFO 0 Message Lost Interrupt Enable" ] # [ inline ( always ) ] pub fn rf0le ( & mut self ) -> RF0LE_W { RF0LE_W { w : self } }
# [ doc = "Bit 4 - Rx FIFO 1 New Message Interrupt Enable" ] # [ inline ( always ) ] pub fn rf1ne ( & mut self ) -> RF1NE_W { RF1NE_W { w : self } }
# [ doc = "Bit 5 - Rx FIFO 1 Watermark Reached Interrupt Enable" ] # [ inline ( always ) ] pub fn rf1we ( & mut self ) -> RF1WE_W { RF1WE_W { w : self } }
# [ doc = "Bit 6 - Rx FIFO 1 FIFO Full Interrupt Enable" ] # [ inline ( always ) ] pub fn rf1fe ( & mut self ) -> RF1FE_W { RF1FE_W { w : self } }
# [ doc = "Bit 7 - Rx FIFO 1 Message Lost Interrupt Enable" ] # [ inline ( always ) ] pub fn rf1le ( & mut self ) -> RF1LE_W { RF1LE_W { w : self } }
# [ doc = "Bit 8 - High Priority Message Interrupt Enable" ] # [ inline ( always ) ] pub fn hpme ( & mut self ) -> HPME_W { HPME_W { w : self } }
# [ doc = "Bit 9 - Timestamp Completed Interrupt Enable" ] # [ inline ( always ) ] pub fn tce ( & mut self ) -> TCE_W { TCE_W { w : self } }
# [ doc = "Bit 10 - Transmission Cancellation Finished Interrupt Enable" ] # [ inline ( always ) ] pub fn tcfe ( & mut self ) -> TCFE_W { TCFE_W { w : self } }
# [ doc = "Bit 11 - Tx FIFO Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn tfee ( & mut self ) -> TFEE_W { TFEE_W { w : self } }
# [ doc = "Bit 12 - Tx Event FIFO New Entry Interrupt Enable" ] # [ inline ( always ) ] pub fn tefne ( & mut self ) -> TEFNE_W { TEFNE_W { w : self } }
# [ doc = "Bit 13 - Tx Event FIFO Watermark Reached Interrupt Enable" ] # [ inline ( always ) ] pub fn tefwe ( & mut self ) -> TEFWE_W { TEFWE_W { w : self } }
# [ doc = "Bit 14 - Tx Event FIFO Full Interrupt Enable" ] # [ inline ( always ) ] pub fn teffe ( & mut self ) -> TEFFE_W { TEFFE_W { w : self } }
# [ doc = "Bit 15 - Tx Event FIFO Element Lost Interrupt Enable" ] # [ inline ( always ) ] pub fn tefle ( & mut self ) -> TEFLE_W { TEFLE_W { w : self } }
# [ doc = "Bit 16 - Timestamp Wraparound Interrupt Enable" ] # [ inline ( always ) ] pub fn tswe ( & mut self ) -> TSWE_W { TSWE_W { w : self } }
# [ doc = "Bit 17 - Message RAM Access Failure Interrupt Enable" ] # [ inline ( always ) ] pub fn mrafe ( & mut self ) -> MRAFE_W { MRAFE_W { w : self } }
# [ doc = "Bit 18 - Timeout Occurred Interrupt Enable" ] # [ inline ( always ) ] pub fn tooe ( & mut self ) -> TOOE_W { TOOE_W { w : self } }
# [ doc = "Bit 19 - Message stored to Dedicated Rx Buffer Interrupt Enable" ] # [ inline ( always ) ] pub fn drxe ( & mut self ) -> DRXE_W { DRXE_W { w : self } }
# [ doc = "Bit 20 - Bit Error Corrected Interrupt Enable" ] # [ inline ( always ) ] pub fn bece ( & mut self ) -> BECE_W { BECE_W { w : self } }
# [ doc = "Bit 21 - Bit Error Uncorrected Interrupt Enable" ] # [ inline ( always ) ] pub fn beue ( & mut self ) -> BEUE_W { BEUE_W { w : self } }
# [ doc = "Bit 22 - Error Logging Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn eloe ( & mut self ) -> ELOE_W { ELOE_W { w : self } }
# [ doc = "Bit 23 - Error Passive Interrupt Enable" ] # [ inline ( always ) ] pub fn epe ( & mut self ) -> EPE_W { EPE_W { w : self } }
# [ doc = "Bit 24 - Warning Status Interrupt Enable" ] # [ inline ( always ) ] pub fn ewe ( & mut self ) -> EWE_W { EWE_W { w : self } }
# [ doc = "Bit 25 - Bus_Off Status Interrupt Enable" ] # [ inline ( always ) ] pub fn boe ( & mut self ) -> BOE_W { BOE_W { w : self } }
# [ doc = "Bit 26 - Watchdog Interrupt Interrupt Enable" ] # [ inline ( always ) ] pub fn wdie ( & mut self ) -> WDIE_W { WDIE_W { w : self } }
# [ doc = "Bit 27 - Protocol Error in Arbitration Phase Enable" ] # [ inline ( always ) ] pub fn peae ( & mut self ) -> PEAE_W { PEAE_W { w : self } }
# [ doc = "Bit 28 - Protocol Error in Data Phase Enable" ] # [ inline ( always ) ] pub fn pede ( & mut self ) -> PEDE_W { PEDE_W { w : self } }
# [ doc = "Bit 29 - Access to Reserved Address Enable" ] # [ inline ( always ) ] pub fn arae ( & mut self ) -> ARAE_W { ARAE_W { w : self } }
}
}
# [ doc = "Interrupt Line Select\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ils](ils) module" ] pub type ILS = crate :: Reg < u32 , _ILS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ILS ;
# [ doc = "`read()` method returns [ils::R](ils::R) reader structure" ] impl crate :: Readable for ILS { }
# [ doc = "`write(|w| ..)` method takes [ils::W](ils::W) writer structure" ] impl crate :: Writable for ILS { }
# [ doc = "Interrupt Line Select" ] pub mod ils {
# [ doc = "Reader of register ILS" ] pub type R = crate :: R < u32 , super :: ILS > ;
# [ doc = "Writer for register ILS" ] pub type W = crate :: W < u32 , super :: ILS > ;
# [ doc = "Register ILS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ILS { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RF0NL`" ] pub type RF0NL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0NL`" ] pub struct RF0NL_W < 'a > { w : & 'a mut W , } impl < 'a > RF0NL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `RF0WL`" ] pub type RF0WL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0WL`" ] pub struct RF0WL_W < 'a > { w : & 'a mut W , } impl < 'a > RF0WL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RF0FL`" ] pub type RF0FL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0FL`" ] pub struct RF0FL_W < 'a > { w : & 'a mut W , } impl < 'a > RF0FL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `RF0LL`" ] pub type RF0LL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF0LL`" ] pub struct RF0LL_W < 'a > { w : & 'a mut W , } impl < 'a > RF0LL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `RF1NL`" ] pub type RF1NL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1NL`" ] pub struct RF1NL_W < 'a > { w : & 'a mut W , } impl < 'a > RF1NL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `RF1WL`" ] pub type RF1WL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1WL`" ] pub struct RF1WL_W < 'a > { w : & 'a mut W , } impl < 'a > RF1WL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `RF1FL`" ] pub type RF1FL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1FL`" ] pub struct RF1FL_W < 'a > { w : & 'a mut W , } impl < 'a > RF1FL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `RF1LL`" ] pub type RF1LL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RF1LL`" ] pub struct RF1LL_W < 'a > { w : & 'a mut W , } impl < 'a > RF1LL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `HPML`" ] pub type HPML_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPML`" ] pub struct HPML_W < 'a > { w : & 'a mut W , } impl < 'a > HPML_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `TCL`" ] pub type TCL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCL`" ] pub struct TCL_W < 'a > { w : & 'a mut W , } impl < 'a > TCL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `TCFL`" ] pub type TCFL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCFL`" ] pub struct TCFL_W < 'a > { w : & 'a mut W , } impl < 'a > TCFL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `TFEL`" ] pub type TFEL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TFEL`" ] pub struct TFEL_W < 'a > { w : & 'a mut W , } impl < 'a > TFEL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `TEFNL`" ] pub type TEFNL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFNL`" ] pub struct TEFNL_W < 'a > { w : & 'a mut W , } impl < 'a > TEFNL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `TEFWL`" ] pub type TEFWL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFWL`" ] pub struct TEFWL_W < 'a > { w : & 'a mut W , } impl < 'a > TEFWL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `TEFFL`" ] pub type TEFFL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFFL`" ] pub struct TEFFL_W < 'a > { w : & 'a mut W , } impl < 'a > TEFFL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `TEFLL`" ] pub type TEFLL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TEFLL`" ] pub struct TEFLL_W < 'a > { w : & 'a mut W , } impl < 'a > TEFLL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `TSWL`" ] pub type TSWL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TSWL`" ] pub struct TSWL_W < 'a > { w : & 'a mut W , } impl < 'a > TSWL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `MRAFL`" ] pub type MRAFL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MRAFL`" ] pub struct MRAFL_W < 'a > { w : & 'a mut W , } impl < 'a > MRAFL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `TOOL`" ] pub type TOOL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TOOL`" ] pub struct TOOL_W < 'a > { w : & 'a mut W , } impl < 'a > TOOL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `DRXL`" ] pub type DRXL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DRXL`" ] pub struct DRXL_W < 'a > { w : & 'a mut W , } impl < 'a > DRXL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `BECL`" ] pub type BECL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BECL`" ] pub struct BECL_W < 'a > { w : & 'a mut W , } impl < 'a > BECL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `BEUL`" ] pub type BEUL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BEUL`" ] pub struct BEUL_W < 'a > { w : & 'a mut W , } impl < 'a > BEUL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `ELOL`" ] pub type ELOL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ELOL`" ] pub struct ELOL_W < 'a > { w : & 'a mut W , } impl < 'a > ELOL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `EPL`" ] pub type EPL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EPL`" ] pub struct EPL_W < 'a > { w : & 'a mut W , } impl < 'a > EPL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `EWL`" ] pub type EWL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EWL`" ] pub struct EWL_W < 'a > { w : & 'a mut W , } impl < 'a > EWL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `BOL`" ] pub type BOL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BOL`" ] pub struct BOL_W < 'a > { w : & 'a mut W , } impl < 'a > BOL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `WDIL`" ] pub type WDIL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WDIL`" ] pub struct WDIL_W < 'a > { w : & 'a mut W , } impl < 'a > WDIL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `PEAL`" ] pub type PEAL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PEAL`" ] pub struct PEAL_W < 'a > { w : & 'a mut W , } impl < 'a > PEAL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Reader of field `PEDL`" ] pub type PEDL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PEDL`" ] pub struct PEDL_W < 'a > { w : & 'a mut W , } impl < 'a > PEDL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `ARAL`" ] pub type ARAL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ARAL`" ] pub struct ARAL_W < 'a > { w : & 'a mut W , } impl < 'a > ARAL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Rx FIFO 0 New Message Interrupt Line" ] # [ inline ( always ) ] pub fn rf0nl ( & self ) -> RF0NL_R { RF0NL_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Rx FIFO 0 Watermark Reached Interrupt Line" ] # [ inline ( always ) ] pub fn rf0wl ( & self ) -> RF0WL_R { RF0WL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Rx FIFO 0 Full Interrupt Line" ] # [ inline ( always ) ] pub fn rf0fl ( & self ) -> RF0FL_R { RF0FL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Rx FIFO 0 Message Lost Interrupt Line" ] # [ inline ( always ) ] pub fn rf0ll ( & self ) -> RF0LL_R { RF0LL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Rx FIFO 1 New Message Interrupt Line" ] # [ inline ( always ) ] pub fn rf1nl ( & self ) -> RF1NL_R { RF1NL_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Rx FIFO 1 Watermark Reached Interrupt Line" ] # [ inline ( always ) ] pub fn rf1wl ( & self ) -> RF1WL_R { RF1WL_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Rx FIFO 1 FIFO Full Interrupt Line" ] # [ inline ( always ) ] pub fn rf1fl ( & self ) -> RF1FL_R { RF1FL_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Rx FIFO 1 Message Lost Interrupt Line" ] # [ inline ( always ) ] pub fn rf1ll ( & self ) -> RF1LL_R { RF1LL_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - High Priority Message Interrupt Line" ] # [ inline ( always ) ] pub fn hpml ( & self ) -> HPML_R { HPML_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Timestamp Completed Interrupt Line" ] # [ inline ( always ) ] pub fn tcl ( & self ) -> TCL_R { TCL_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Transmission Cancellation Finished Interrupt Line" ] # [ inline ( always ) ] pub fn tcfl ( & self ) -> TCFL_R { TCFL_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Tx FIFO Empty Interrupt Line" ] # [ inline ( always ) ] pub fn tfel ( & self ) -> TFEL_R { TFEL_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Tx Event FIFO New Entry Interrupt Line" ] # [ inline ( always ) ] pub fn tefnl ( & self ) -> TEFNL_R { TEFNL_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Tx Event FIFO Watermark Reached Interrupt Line" ] # [ inline ( always ) ] pub fn tefwl ( & self ) -> TEFWL_R { TEFWL_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Tx Event FIFO Full Interrupt Line" ] # [ inline ( always ) ] pub fn teffl ( & self ) -> TEFFL_R { TEFFL_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Tx Event FIFO Element Lost Interrupt Line" ] # [ inline ( always ) ] pub fn tefll ( & self ) -> TEFLL_R { TEFLL_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Timestamp Wraparound Interrupt Line" ] # [ inline ( always ) ] pub fn tswl ( & self ) -> TSWL_R { TSWL_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Message RAM Access Failure Interrupt Line" ] # [ inline ( always ) ] pub fn mrafl ( & self ) -> MRAFL_R { MRAFL_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Timeout Occurred Interrupt Line" ] # [ inline ( always ) ] pub fn tool ( & self ) -> TOOL_R { TOOL_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Message stored to Dedicated Rx Buffer Interrupt Line" ] # [ inline ( always ) ] pub fn drxl ( & self ) -> DRXL_R { DRXL_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Bit Error Corrected Interrupt Line" ] # [ inline ( always ) ] pub fn becl ( & self ) -> BECL_R { BECL_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Bit Error Uncorrected Interrupt Line" ] # [ inline ( always ) ] pub fn beul ( & self ) -> BEUL_R { BEUL_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Error Logging Overflow Interrupt Line" ] # [ inline ( always ) ] pub fn elol ( & self ) -> ELOL_R { ELOL_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Error Passive Interrupt Line" ] # [ inline ( always ) ] pub fn epl ( & self ) -> EPL_R { EPL_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Warning Status Interrupt Line" ] # [ inline ( always ) ] pub fn ewl ( & self ) -> EWL_R { EWL_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Bus_Off Status Interrupt Line" ] # [ inline ( always ) ] pub fn bol ( & self ) -> BOL_R { BOL_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Watchdog Interrupt Interrupt Line" ] # [ inline ( always ) ] pub fn wdil ( & self ) -> WDIL_R { WDIL_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Protocol Error in Arbitration Phase Line" ] # [ inline ( always ) ] pub fn peal ( & self ) -> PEAL_R { PEAL_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Protocol Error in Data Phase Line" ] # [ inline ( always ) ] pub fn pedl ( & self ) -> PEDL_R { PEDL_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Access to Reserved Address Line" ] # [ inline ( always ) ] pub fn aral ( & self ) -> ARAL_R { ARAL_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Rx FIFO 0 New Message Interrupt Line" ] # [ inline ( always ) ] pub fn rf0nl ( & mut self ) -> RF0NL_W { RF0NL_W { w : self } }
# [ doc = "Bit 1 - Rx FIFO 0 Watermark Reached Interrupt Line" ] # [ inline ( always ) ] pub fn rf0wl ( & mut self ) -> RF0WL_W { RF0WL_W { w : self } }
# [ doc = "Bit 2 - Rx FIFO 0 Full Interrupt Line" ] # [ inline ( always ) ] pub fn rf0fl ( & mut self ) -> RF0FL_W { RF0FL_W { w : self } }
# [ doc = "Bit 3 - Rx FIFO 0 Message Lost Interrupt Line" ] # [ inline ( always ) ] pub fn rf0ll ( & mut self ) -> RF0LL_W { RF0LL_W { w : self } }
# [ doc = "Bit 4 - Rx FIFO 1 New Message Interrupt Line" ] # [ inline ( always ) ] pub fn rf1nl ( & mut self ) -> RF1NL_W { RF1NL_W { w : self } }
# [ doc = "Bit 5 - Rx FIFO 1 Watermark Reached Interrupt Line" ] # [ inline ( always ) ] pub fn rf1wl ( & mut self ) -> RF1WL_W { RF1WL_W { w : self } }
# [ doc = "Bit 6 - Rx FIFO 1 FIFO Full Interrupt Line" ] # [ inline ( always ) ] pub fn rf1fl ( & mut self ) -> RF1FL_W { RF1FL_W { w : self } }
# [ doc = "Bit 7 - Rx FIFO 1 Message Lost Interrupt Line" ] # [ inline ( always ) ] pub fn rf1ll ( & mut self ) -> RF1LL_W { RF1LL_W { w : self } }
# [ doc = "Bit 8 - High Priority Message Interrupt Line" ] # [ inline ( always ) ] pub fn hpml ( & mut self ) -> HPML_W { HPML_W { w : self } }
# [ doc = "Bit 9 - Timestamp Completed Interrupt Line" ] # [ inline ( always ) ] pub fn tcl ( & mut self ) -> TCL_W { TCL_W { w : self } }
# [ doc = "Bit 10 - Transmission Cancellation Finished Interrupt Line" ] # [ inline ( always ) ] pub fn tcfl ( & mut self ) -> TCFL_W { TCFL_W { w : self } }
# [ doc = "Bit 11 - Tx FIFO Empty Interrupt Line" ] # [ inline ( always ) ] pub fn tfel ( & mut self ) -> TFEL_W { TFEL_W { w : self } }
# [ doc = "Bit 12 - Tx Event FIFO New Entry Interrupt Line" ] # [ inline ( always ) ] pub fn tefnl ( & mut self ) -> TEFNL_W { TEFNL_W { w : self } }
# [ doc = "Bit 13 - Tx Event FIFO Watermark Reached Interrupt Line" ] # [ inline ( always ) ] pub fn tefwl ( & mut self ) -> TEFWL_W { TEFWL_W { w : self } }
# [ doc = "Bit 14 - Tx Event FIFO Full Interrupt Line" ] # [ inline ( always ) ] pub fn teffl ( & mut self ) -> TEFFL_W { TEFFL_W { w : self } }
# [ doc = "Bit 15 - Tx Event FIFO Element Lost Interrupt Line" ] # [ inline ( always ) ] pub fn tefll ( & mut self ) -> TEFLL_W { TEFLL_W { w : self } }
# [ doc = "Bit 16 - Timestamp Wraparound Interrupt Line" ] # [ inline ( always ) ] pub fn tswl ( & mut self ) -> TSWL_W { TSWL_W { w : self } }
# [ doc = "Bit 17 - Message RAM Access Failure Interrupt Line" ] # [ inline ( always ) ] pub fn mrafl ( & mut self ) -> MRAFL_W { MRAFL_W { w : self } }
# [ doc = "Bit 18 - Timeout Occurred Interrupt Line" ] # [ inline ( always ) ] pub fn tool ( & mut self ) -> TOOL_W { TOOL_W { w : self } }
# [ doc = "Bit 19 - Message stored to Dedicated Rx Buffer Interrupt Line" ] # [ inline ( always ) ] pub fn drxl ( & mut self ) -> DRXL_W { DRXL_W { w : self } }
# [ doc = "Bit 20 - Bit Error Corrected Interrupt Line" ] # [ inline ( always ) ] pub fn becl ( & mut self ) -> BECL_W { BECL_W { w : self } }
# [ doc = "Bit 21 - Bit Error Uncorrected Interrupt Line" ] # [ inline ( always ) ] pub fn beul ( & mut self ) -> BEUL_W { BEUL_W { w : self } }
# [ doc = "Bit 22 - Error Logging Overflow Interrupt Line" ] # [ inline ( always ) ] pub fn elol ( & mut self ) -> ELOL_W { ELOL_W { w : self } }
# [ doc = "Bit 23 - Error Passive Interrupt Line" ] # [ inline ( always ) ] pub fn epl ( & mut self ) -> EPL_W { EPL_W { w : self } }
# [ doc = "Bit 24 - Warning Status Interrupt Line" ] # [ inline ( always ) ] pub fn ewl ( & mut self ) -> EWL_W { EWL_W { w : self } }
# [ doc = "Bit 25 - Bus_Off Status Interrupt Line" ] # [ inline ( always ) ] pub fn bol ( & mut self ) -> BOL_W { BOL_W { w : self } }
# [ doc = "Bit 26 - Watchdog Interrupt Interrupt Line" ] # [ inline ( always ) ] pub fn wdil ( & mut self ) -> WDIL_W { WDIL_W { w : self } }
# [ doc = "Bit 27 - Protocol Error in Arbitration Phase Line" ] # [ inline ( always ) ] pub fn peal ( & mut self ) -> PEAL_W { PEAL_W { w : self } }
# [ doc = "Bit 28 - Protocol Error in Data Phase Line" ] # [ inline ( always ) ] pub fn pedl ( & mut self ) -> PEDL_W { PEDL_W { w : self } }
# [ doc = "Bit 29 - Access to Reserved Address Line" ] # [ inline ( always ) ] pub fn aral ( & mut self ) -> ARAL_W { ARAL_W { w : self } }
}
}
# [ doc = "Interrupt Line Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ile](ile) module" ] pub type ILE = crate :: Reg < u32 , _ILE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ILE ;
# [ doc = "`read()` method returns [ile::R](ile::R) reader structure" ] impl crate :: Readable for ILE { }
# [ doc = "`write(|w| ..)` method takes [ile::W](ile::W) writer structure" ] impl crate :: Writable for ILE { }
# [ doc = "Interrupt Line Enable" ] pub mod ile {
# [ doc = "Reader of register ILE" ] pub type R = crate :: R < u32 , super :: ILE > ;
# [ doc = "Writer for register ILE" ] pub type W = crate :: W < u32 , super :: ILE > ;
# [ doc = "Register ILE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ILE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EINT0`" ] pub type EINT0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EINT0`" ] pub struct EINT0_W < 'a > { w : & 'a mut W , } impl < 'a > EINT0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `EINT1`" ] pub type EINT1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EINT1`" ] pub struct EINT1_W < 'a > { w : & 'a mut W , } impl < 'a > EINT1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Enable Interrupt Line 0" ] # [ inline ( always ) ] pub fn eint0 ( & self ) -> EINT0_R { EINT0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable Interrupt Line 1" ] # [ inline ( always ) ] pub fn eint1 ( & self ) -> EINT1_R { EINT1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Enable Interrupt Line 0" ] # [ inline ( always ) ] pub fn eint0 ( & mut self ) -> EINT0_W { EINT0_W { w : self } }
# [ doc = "Bit 1 - Enable Interrupt Line 1" ] # [ inline ( always ) ] pub fn eint1 ( & mut self ) -> EINT1_W { EINT1_W { w : self } }
}
}
# [ doc = "Global Filter Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [gfc](gfc) module" ] pub type GFC = crate :: Reg < u32 , _GFC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _GFC ;
# [ doc = "`read()` method returns [gfc::R](gfc::R) reader structure" ] impl crate :: Readable for GFC { }
# [ doc = "`write(|w| ..)` method takes [gfc::W](gfc::W) writer structure" ] impl crate :: Writable for GFC { }
# [ doc = "Global Filter Configuration" ] pub mod gfc {
# [ doc = "Reader of register GFC" ] pub type R = crate :: R < u32 , super :: GFC > ;
# [ doc = "Writer for register GFC" ] pub type W = crate :: W < u32 , super :: GFC > ;
# [ doc = "Register GFC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: GFC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RRFE`" ] pub type RRFE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RRFE`" ] pub struct RRFE_W < 'a > { w : & 'a mut W , } impl < 'a > RRFE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `RRFS`" ] pub type RRFS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RRFS`" ] pub struct RRFS_W < 'a > { w : & 'a mut W , } impl < 'a > RRFS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Possible values of the field `ANFE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ANFE_A { # [ doc = "Accept in Rx FIFO 0" ] RXF0 , # [ doc = "Accept in Rx FIFO 1" ] RXF1 , # [ doc = "Reject" ] REJECT }
impl crate :: ToBits < u8 > for ANFE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { ANFE_A :: RXF0 => 0 , ANFE_A :: RXF1 => 1 , ANFE_A :: REJECT => 2 } } }
# [ doc = "Reader of field `ANFE`" ] pub type ANFE_R = crate :: R < u8 , ANFE_A > ; impl ANFE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , ANFE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( ANFE_A :: RXF0 ) , 1 => Val ( ANFE_A :: RXF1 ) , 2 => Val ( ANFE_A :: REJECT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `RXF0`" ] # [ inline ( always ) ] pub fn is_rxf0 ( & self ) -> bool { * self == ANFE_A :: RXF0 } # [ doc = "Checks if the value of the field is `RXF1`" ] # [ inline ( always ) ] pub fn is_rxf1 ( & self ) -> bool { * self == ANFE_A :: RXF1 } # [ doc = "Checks if the value of the field is `REJECT`" ] # [ inline ( always ) ] pub fn is_reject ( & self ) -> bool { * self == ANFE_A :: REJECT } }
# [ doc = "Write proxy for field `ANFE`" ] pub struct ANFE_W < 'a > { w : & 'a mut W , } impl < 'a > ANFE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ANFE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Accept in Rx FIFO 0" ] # [ inline ( always ) ] pub fn rxf0 ( self ) -> & 'a mut W { self . variant ( ANFE_A :: RXF0 ) } # [ doc = "Accept in Rx FIFO 1" ] # [ inline ( always ) ] pub fn rxf1 ( self ) -> & 'a mut W { self . variant ( ANFE_A :: RXF1 ) } # [ doc = "Reject" ] # [ inline ( always ) ] pub fn reject ( self ) -> & 'a mut W { self . variant ( ANFE_A :: REJECT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u32 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `ANFS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ANFS_A { # [ doc = "Accept in Rx FIFO 0" ] RXF0 , # [ doc = "Accept in Rx FIFO 1" ] RXF1 , # [ doc = "Reject" ] REJECT }
impl crate :: ToBits < u8 > for ANFS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { ANFS_A :: RXF0 => 0 , ANFS_A :: RXF1 => 1 , ANFS_A :: REJECT => 2 } } }
# [ doc = "Reader of field `ANFS`" ] pub type ANFS_R = crate :: R < u8 , ANFS_A > ; impl ANFS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , ANFS_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( ANFS_A :: RXF0 ) , 1 => Val ( ANFS_A :: RXF1 ) , 2 => Val ( ANFS_A :: REJECT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `RXF0`" ] # [ inline ( always ) ] pub fn is_rxf0 ( & self ) -> bool { * self == ANFS_A :: RXF0 } # [ doc = "Checks if the value of the field is `RXF1`" ] # [ inline ( always ) ] pub fn is_rxf1 ( & self ) -> bool { * self == ANFS_A :: RXF1 } # [ doc = "Checks if the value of the field is `REJECT`" ] # [ inline ( always ) ] pub fn is_reject ( & self ) -> bool { * self == ANFS_A :: REJECT } }
# [ doc = "Write proxy for field `ANFS`" ] pub struct ANFS_W < 'a > { w : & 'a mut W , } impl < 'a > ANFS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ANFS_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Accept in Rx FIFO 0" ] # [ inline ( always ) ] pub fn rxf0 ( self ) -> & 'a mut W { self . variant ( ANFS_A :: RXF0 ) } # [ doc = "Accept in Rx FIFO 1" ] # [ inline ( always ) ] pub fn rxf1 ( self ) -> & 'a mut W { self . variant ( ANFS_A :: RXF1 ) } # [ doc = "Reject" ] # [ inline ( always ) ] pub fn reject ( self ) -> & 'a mut W { self . variant ( ANFS_A :: REJECT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Reject Remote Frames Extended" ] # [ inline ( always ) ] pub fn rrfe ( & self ) -> RRFE_R { RRFE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Reject Remote Frames Standard" ] # [ inline ( always ) ] pub fn rrfs ( & self ) -> RRFS_R { RRFS_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 2:3 - Accept Non-matching Frames Extended" ] # [ inline ( always ) ] pub fn anfe ( & self ) -> ANFE_R { ANFE_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Accept Non-matching Frames Standard" ] # [ inline ( always ) ] pub fn anfs ( & self ) -> ANFS_R { ANFS_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Reject Remote Frames Extended" ] # [ inline ( always ) ] pub fn rrfe ( & mut self ) -> RRFE_W { RRFE_W { w : self } }
# [ doc = "Bit 1 - Reject Remote Frames Standard" ] # [ inline ( always ) ] pub fn rrfs ( & mut self ) -> RRFS_W { RRFS_W { w : self } }
# [ doc = "Bits 2:3 - Accept Non-matching Frames Extended" ] # [ inline ( always ) ] pub fn anfe ( & mut self ) -> ANFE_W { ANFE_W { w : self } }
# [ doc = "Bits 4:5 - Accept Non-matching Frames Standard" ] # [ inline ( always ) ] pub fn anfs ( & mut self ) -> ANFS_W { ANFS_W { w : self } }
}
}
# [ doc = "Standard ID Filter Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [sidfc](sidfc) module" ] pub type SIDFC = crate :: Reg < u32 , _SIDFC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SIDFC ;
# [ doc = "`read()` method returns [sidfc::R](sidfc::R) reader structure" ] impl crate :: Readable for SIDFC { }
# [ doc = "`write(|w| ..)` method takes [sidfc::W](sidfc::W) writer structure" ] impl crate :: Writable for SIDFC { }
# [ doc = "Standard ID Filter Configuration" ] pub mod sidfc {
# [ doc = "Reader of register SIDFC" ] pub type R = crate :: R < u32 , super :: SIDFC > ;
# [ doc = "Writer for register SIDFC" ] pub type W = crate :: W < u32 , super :: SIDFC > ;
# [ doc = "Register SIDFC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SIDFC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FLSSA`" ] pub type FLSSA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `FLSSA`" ] pub struct FLSSA_W < 'a > { w : & 'a mut W , } impl < 'a > FLSSA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
# [ doc = "Reader of field `LSS`" ] pub type LSS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `LSS`" ] pub struct LSS_W < 'a > { w : & 'a mut W , } impl < 'a > LSS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Filter List Standard Start Address" ] # [ inline ( always ) ] pub fn flssa ( & self ) -> FLSSA_R { FLSSA_R :: new ( ( self . bits & 0xffff ) as u16 ) }
# [ doc = "Bits 16:23 - List Size Standard" ] # [ inline ( always ) ] pub fn lss ( & self ) -> LSS_R { LSS_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:15 - Filter List Standard Start Address" ] # [ inline ( always ) ] pub fn flssa ( & mut self ) -> FLSSA_W { FLSSA_W { w : self } }
# [ doc = "Bits 16:23 - List Size Standard" ] # [ inline ( always ) ] pub fn lss ( & mut self ) -> LSS_W { LSS_W { w : self } }
}
}
# [ doc = "Extended ID Filter Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [xidfc](xidfc) module" ] pub type XIDFC = crate :: Reg < u32 , _XIDFC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _XIDFC ;
# [ doc = "`read()` method returns [xidfc::R](xidfc::R) reader structure" ] impl crate :: Readable for XIDFC { }
# [ doc = "`write(|w| ..)` method takes [xidfc::W](xidfc::W) writer structure" ] impl crate :: Writable for XIDFC { }
# [ doc = "Extended ID Filter Configuration" ] pub mod xidfc {
# [ doc = "Reader of register XIDFC" ] pub type R = crate :: R < u32 , super :: XIDFC > ;
# [ doc = "Writer for register XIDFC" ] pub type W = crate :: W < u32 , super :: XIDFC > ;
# [ doc = "Register XIDFC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: XIDFC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FLESA`" ] pub type FLESA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `FLESA`" ] pub struct FLESA_W < 'a > { w : & 'a mut W , } impl < 'a > FLESA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
# [ doc = "Reader of field `LSE`" ] pub type LSE_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `LSE`" ] pub struct LSE_W < 'a > { w : & 'a mut W , } impl < 'a > LSE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x7f << 16 ) ) | ( ( ( value as u32 ) & 0x7f ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Filter List Extended Start Address" ] # [ inline ( always ) ] pub fn flesa ( & self ) -> FLESA_R { FLESA_R :: new ( ( self . bits & 0xffff ) as u16 ) }
# [ doc = "Bits 16:22 - List Size Extended" ] # [ inline ( always ) ] pub fn lse ( & self ) -> LSE_R { LSE_R :: new ( ( ( self . bits >> 16 ) & 0x7f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:15 - Filter List Extended Start Address" ] # [ inline ( always ) ] pub fn flesa ( & mut self ) -> FLESA_W { FLESA_W { w : self } }
# [ doc = "Bits 16:22 - List Size Extended" ] # [ inline ( always ) ] pub fn lse ( & mut self ) -> LSE_W { LSE_W { w : self } }
}
}
# [ doc = "Extended ID AND Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [xidam](xidam) module" ] pub type XIDAM = crate :: Reg < u32 , _XIDAM > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _XIDAM ;
# [ doc = "`read()` method returns [xidam::R](xidam::R) reader structure" ] impl crate :: Readable for XIDAM { }
# [ doc = "`write(|w| ..)` method takes [xidam::W](xidam::W) writer structure" ] impl crate :: Writable for XIDAM { }
# [ doc = "Extended ID AND Mask" ] pub mod xidam {
# [ doc = "Reader of register XIDAM" ] pub type R = crate :: R < u32 , super :: XIDAM > ;
# [ doc = "Writer for register XIDAM" ] pub type W = crate :: W < u32 , super :: XIDAM > ;
# [ doc = "Register XIDAM `reset()`'s with value 0x1fff_ffff" ] impl crate :: ResetValue for super :: XIDAM { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x1fff_ffff } }
# [ doc = "Reader of field `EIDM`" ] pub type EIDM_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `EIDM`" ] pub struct EIDM_W < 'a > { w : & 'a mut W , } impl < 'a > EIDM_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1fff_ffff ) | ( ( value as u32 ) & 0x1fff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:28 - Extended ID Mask" ] # [ inline ( always ) ] pub fn eidm ( & self ) -> EIDM_R { EIDM_R :: new ( ( self . bits & 0x1fff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:28 - Extended ID Mask" ] # [ inline ( always ) ] pub fn eidm ( & mut self ) -> EIDM_W { EIDM_W { w : self } }
}
}
# [ doc = "High Priority Message Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [hpms](hpms) module" ] pub type HPMS = crate :: Reg < u32 , _HPMS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _HPMS ;
# [ doc = "`read()` method returns [hpms::R](hpms::R) reader structure" ] impl crate :: Readable for HPMS { }
# [ doc = "High Priority Message Status" ] pub mod hpms {
# [ doc = "Reader of register HPMS" ] pub type R = crate :: R < u32 , super :: HPMS > ;
# [ doc = "Reader of field `BIDX`" ] pub type BIDX_R = crate :: R < u8 , u8 > ;
# [ doc = "Possible values of the field `MSI`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MSI_A { # [ doc = "No FIFO selected" ] NONE , # [ doc = "FIFO message lost" ] LOST , # [ doc = "Message stored in FIFO 0" ] FIFO0 , # [ doc = "Message stored in FIFO 1" ] FIFO1 }
impl crate :: ToBits < u8 > for MSI_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MSI_A :: NONE => 0 , MSI_A :: LOST => 1 , MSI_A :: FIFO0 => 2 , MSI_A :: FIFO1 => 3 } } }
# [ doc = "Reader of field `MSI`" ] pub type MSI_R = crate :: R < u8 , MSI_A > ; impl MSI_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> MSI_A { match self . bits { 0 => MSI_A :: NONE , 1 => MSI_A :: LOST , 2 => MSI_A :: FIFO0 , 3 => MSI_A :: FIFO1 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == MSI_A :: NONE } # [ doc = "Checks if the value of the field is `LOST`" ] # [ inline ( always ) ] pub fn is_lost ( & self ) -> bool { * self == MSI_A :: LOST } # [ doc = "Checks if the value of the field is `FIFO0`" ] # [ inline ( always ) ] pub fn is_fifo0 ( & self ) -> bool { * self == MSI_A :: FIFO0 } # [ doc = "Checks if the value of the field is `FIFO1`" ] # [ inline ( always ) ] pub fn is_fifo1 ( & self ) -> bool { * self == MSI_A :: FIFO1 } }
# [ doc = "Reader of field `FIDX`" ] pub type FIDX_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `FLST`" ] pub type FLST_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bits 0:5 - Buffer Index" ] # [ inline ( always ) ] pub fn bidx ( & self ) -> BIDX_R { BIDX_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 6:7 - Message Storage Indicator" ] # [ inline ( always ) ] pub fn msi ( & self ) -> MSI_R { MSI_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:14 - Filter Index" ] # [ inline ( always ) ] pub fn fidx ( & self ) -> FIDX_R { FIDX_R :: new ( ( ( self . bits >> 8 ) & 0x7f ) as u8 ) }
# [ doc = "Bit 15 - Filter List" ] # [ inline ( always ) ] pub fn flst ( & self ) -> FLST_R { FLST_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "New Data 1\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ndat1](ndat1) module" ] pub type NDAT1 = crate :: Reg < u32 , _NDAT1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _NDAT1 ;
# [ doc = "`read()` method returns [ndat1::R](ndat1::R) reader structure" ] impl crate :: Readable for NDAT1 { }
# [ doc = "`write(|w| ..)` method takes [ndat1::W](ndat1::W) writer structure" ] impl crate :: Writable for NDAT1 { }
# [ doc = "New Data 1" ] pub mod ndat1 {
# [ doc = "Reader of register NDAT1" ] pub type R = crate :: R < u32 , super :: NDAT1 > ;
# [ doc = "Writer for register NDAT1" ] pub type W = crate :: W < u32 , super :: NDAT1 > ;
# [ doc = "Register NDAT1 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: NDAT1 { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ND0`" ] pub type ND0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND0`" ] pub struct ND0_W < 'a > { w : & 'a mut W , } impl < 'a > ND0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ND1`" ] pub type ND1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND1`" ] pub struct ND1_W < 'a > { w : & 'a mut W , } impl < 'a > ND1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `ND2`" ] pub type ND2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND2`" ] pub struct ND2_W < 'a > { w : & 'a mut W , } impl < 'a > ND2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ND3`" ] pub type ND3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND3`" ] pub struct ND3_W < 'a > { w : & 'a mut W , } impl < 'a > ND3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `ND4`" ] pub type ND4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND4`" ] pub struct ND4_W < 'a > { w : & 'a mut W , } impl < 'a > ND4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ND5`" ] pub type ND5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND5`" ] pub struct ND5_W < 'a > { w : & 'a mut W , } impl < 'a > ND5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `ND6`" ] pub type ND6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND6`" ] pub struct ND6_W < 'a > { w : & 'a mut W , } impl < 'a > ND6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ND7`" ] pub type ND7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND7`" ] pub struct ND7_W < 'a > { w : & 'a mut W , } impl < 'a > ND7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `ND8`" ] pub type ND8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND8`" ] pub struct ND8_W < 'a > { w : & 'a mut W , } impl < 'a > ND8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ND9`" ] pub type ND9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND9`" ] pub struct ND9_W < 'a > { w : & 'a mut W , } impl < 'a > ND9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `ND10`" ] pub type ND10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND10`" ] pub struct ND10_W < 'a > { w : & 'a mut W , } impl < 'a > ND10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ND11`" ] pub type ND11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND11`" ] pub struct ND11_W < 'a > { w : & 'a mut W , } impl < 'a > ND11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `ND12`" ] pub type ND12_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND12`" ] pub struct ND12_W < 'a > { w : & 'a mut W , } impl < 'a > ND12_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ND13`" ] pub type ND13_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND13`" ] pub struct ND13_W < 'a > { w : & 'a mut W , } impl < 'a > ND13_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `ND14`" ] pub type ND14_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND14`" ] pub struct ND14_W < 'a > { w : & 'a mut W , } impl < 'a > ND14_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `ND15`" ] pub type ND15_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND15`" ] pub struct ND15_W < 'a > { w : & 'a mut W , } impl < 'a > ND15_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `ND16`" ] pub type ND16_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND16`" ] pub struct ND16_W < 'a > { w : & 'a mut W , } impl < 'a > ND16_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `ND17`" ] pub type ND17_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND17`" ] pub struct ND17_W < 'a > { w : & 'a mut W , } impl < 'a > ND17_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `ND18`" ] pub type ND18_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND18`" ] pub struct ND18_W < 'a > { w : & 'a mut W , } impl < 'a > ND18_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `ND19`" ] pub type ND19_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND19`" ] pub struct ND19_W < 'a > { w : & 'a mut W , } impl < 'a > ND19_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `ND20`" ] pub type ND20_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND20`" ] pub struct ND20_W < 'a > { w : & 'a mut W , } impl < 'a > ND20_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `ND21`" ] pub type ND21_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND21`" ] pub struct ND21_W < 'a > { w : & 'a mut W , } impl < 'a > ND21_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `ND22`" ] pub type ND22_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND22`" ] pub struct ND22_W < 'a > { w : & 'a mut W , } impl < 'a > ND22_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `ND23`" ] pub type ND23_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND23`" ] pub struct ND23_W < 'a > { w : & 'a mut W , } impl < 'a > ND23_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `ND24`" ] pub type ND24_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND24`" ] pub struct ND24_W < 'a > { w : & 'a mut W , } impl < 'a > ND24_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `ND25`" ] pub type ND25_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND25`" ] pub struct ND25_W < 'a > { w : & 'a mut W , } impl < 'a > ND25_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `ND26`" ] pub type ND26_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND26`" ] pub struct ND26_W < 'a > { w : & 'a mut W , } impl < 'a > ND26_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `ND27`" ] pub type ND27_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND27`" ] pub struct ND27_W < 'a > { w : & 'a mut W , } impl < 'a > ND27_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Reader of field `ND28`" ] pub type ND28_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND28`" ] pub struct ND28_W < 'a > { w : & 'a mut W , } impl < 'a > ND28_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `ND29`" ] pub type ND29_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND29`" ] pub struct ND29_W < 'a > { w : & 'a mut W , } impl < 'a > ND29_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } }
# [ doc = "Reader of field `ND30`" ] pub type ND30_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND30`" ] pub struct ND30_W < 'a > { w : & 'a mut W , } impl < 'a > ND30_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } }
# [ doc = "Reader of field `ND31`" ] pub type ND31_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND31`" ] pub struct ND31_W < 'a > { w : & 'a mut W , } impl < 'a > ND31_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - New Data 0" ] # [ inline ( always ) ] pub fn nd0 ( & self ) -> ND0_R { ND0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - New Data 1" ] # [ inline ( always ) ] pub fn nd1 ( & self ) -> ND1_R { ND1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - New Data 2" ] # [ inline ( always ) ] pub fn nd2 ( & self ) -> ND2_R { ND2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - New Data 3" ] # [ inline ( always ) ] pub fn nd3 ( & self ) -> ND3_R { ND3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - New Data 4" ] # [ inline ( always ) ] pub fn nd4 ( & self ) -> ND4_R { ND4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - New Data 5" ] # [ inline ( always ) ] pub fn nd5 ( & self ) -> ND5_R { ND5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - New Data 6" ] # [ inline ( always ) ] pub fn nd6 ( & self ) -> ND6_R { ND6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - New Data 7" ] # [ inline ( always ) ] pub fn nd7 ( & self ) -> ND7_R { ND7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - New Data 8" ] # [ inline ( always ) ] pub fn nd8 ( & self ) -> ND8_R { ND8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - New Data 9" ] # [ inline ( always ) ] pub fn nd9 ( & self ) -> ND9_R { ND9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - New Data 10" ] # [ inline ( always ) ] pub fn nd10 ( & self ) -> ND10_R { ND10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - New Data 11" ] # [ inline ( always ) ] pub fn nd11 ( & self ) -> ND11_R { ND11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - New Data 12" ] # [ inline ( always ) ] pub fn nd12 ( & self ) -> ND12_R { ND12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - New Data 13" ] # [ inline ( always ) ] pub fn nd13 ( & self ) -> ND13_R { ND13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - New Data 14" ] # [ inline ( always ) ] pub fn nd14 ( & self ) -> ND14_R { ND14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - New Data 15" ] # [ inline ( always ) ] pub fn nd15 ( & self ) -> ND15_R { ND15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - New Data 16" ] # [ inline ( always ) ] pub fn nd16 ( & self ) -> ND16_R { ND16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - New Data 17" ] # [ inline ( always ) ] pub fn nd17 ( & self ) -> ND17_R { ND17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - New Data 18" ] # [ inline ( always ) ] pub fn nd18 ( & self ) -> ND18_R { ND18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - New Data 19" ] # [ inline ( always ) ] pub fn nd19 ( & self ) -> ND19_R { ND19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - New Data 20" ] # [ inline ( always ) ] pub fn nd20 ( & self ) -> ND20_R { ND20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - New Data 21" ] # [ inline ( always ) ] pub fn nd21 ( & self ) -> ND21_R { ND21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - New Data 22" ] # [ inline ( always ) ] pub fn nd22 ( & self ) -> ND22_R { ND22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - New Data 23" ] # [ inline ( always ) ] pub fn nd23 ( & self ) -> ND23_R { ND23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - New Data 24" ] # [ inline ( always ) ] pub fn nd24 ( & self ) -> ND24_R { ND24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - New Data 25" ] # [ inline ( always ) ] pub fn nd25 ( & self ) -> ND25_R { ND25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - New Data 26" ] # [ inline ( always ) ] pub fn nd26 ( & self ) -> ND26_R { ND26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - New Data 27" ] # [ inline ( always ) ] pub fn nd27 ( & self ) -> ND27_R { ND27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - New Data 28" ] # [ inline ( always ) ] pub fn nd28 ( & self ) -> ND28_R { ND28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - New Data 29" ] # [ inline ( always ) ] pub fn nd29 ( & self ) -> ND29_R { ND29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 30 - New Data 30" ] # [ inline ( always ) ] pub fn nd30 ( & self ) -> ND30_R { ND30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - New Data 31" ] # [ inline ( always ) ] pub fn nd31 ( & self ) -> ND31_R { ND31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - New Data 0" ] # [ inline ( always ) ] pub fn nd0 ( & mut self ) -> ND0_W { ND0_W { w : self } }
# [ doc = "Bit 1 - New Data 1" ] # [ inline ( always ) ] pub fn nd1 ( & mut self ) -> ND1_W { ND1_W { w : self } }
# [ doc = "Bit 2 - New Data 2" ] # [ inline ( always ) ] pub fn nd2 ( & mut self ) -> ND2_W { ND2_W { w : self } }
# [ doc = "Bit 3 - New Data 3" ] # [ inline ( always ) ] pub fn nd3 ( & mut self ) -> ND3_W { ND3_W { w : self } }
# [ doc = "Bit 4 - New Data 4" ] # [ inline ( always ) ] pub fn nd4 ( & mut self ) -> ND4_W { ND4_W { w : self } }
# [ doc = "Bit 5 - New Data 5" ] # [ inline ( always ) ] pub fn nd5 ( & mut self ) -> ND5_W { ND5_W { w : self } }
# [ doc = "Bit 6 - New Data 6" ] # [ inline ( always ) ] pub fn nd6 ( & mut self ) -> ND6_W { ND6_W { w : self } }
# [ doc = "Bit 7 - New Data 7" ] # [ inline ( always ) ] pub fn nd7 ( & mut self ) -> ND7_W { ND7_W { w : self } }
# [ doc = "Bit 8 - New Data 8" ] # [ inline ( always ) ] pub fn nd8 ( & mut self ) -> ND8_W { ND8_W { w : self } }
# [ doc = "Bit 9 - New Data 9" ] # [ inline ( always ) ] pub fn nd9 ( & mut self ) -> ND9_W { ND9_W { w : self } }
# [ doc = "Bit 10 - New Data 10" ] # [ inline ( always ) ] pub fn nd10 ( & mut self ) -> ND10_W { ND10_W { w : self } }
# [ doc = "Bit 11 - New Data 11" ] # [ inline ( always ) ] pub fn nd11 ( & mut self ) -> ND11_W { ND11_W { w : self } }
# [ doc = "Bit 12 - New Data 12" ] # [ inline ( always ) ] pub fn nd12 ( & mut self ) -> ND12_W { ND12_W { w : self } }
# [ doc = "Bit 13 - New Data 13" ] # [ inline ( always ) ] pub fn nd13 ( & mut self ) -> ND13_W { ND13_W { w : self } }
# [ doc = "Bit 14 - New Data 14" ] # [ inline ( always ) ] pub fn nd14 ( & mut self ) -> ND14_W { ND14_W { w : self } }
# [ doc = "Bit 15 - New Data 15" ] # [ inline ( always ) ] pub fn nd15 ( & mut self ) -> ND15_W { ND15_W { w : self } }
# [ doc = "Bit 16 - New Data 16" ] # [ inline ( always ) ] pub fn nd16 ( & mut self ) -> ND16_W { ND16_W { w : self } }
# [ doc = "Bit 17 - New Data 17" ] # [ inline ( always ) ] pub fn nd17 ( & mut self ) -> ND17_W { ND17_W { w : self } }
# [ doc = "Bit 18 - New Data 18" ] # [ inline ( always ) ] pub fn nd18 ( & mut self ) -> ND18_W { ND18_W { w : self } }
# [ doc = "Bit 19 - New Data 19" ] # [ inline ( always ) ] pub fn nd19 ( & mut self ) -> ND19_W { ND19_W { w : self } }
# [ doc = "Bit 20 - New Data 20" ] # [ inline ( always ) ] pub fn nd20 ( & mut self ) -> ND20_W { ND20_W { w : self } }
# [ doc = "Bit 21 - New Data 21" ] # [ inline ( always ) ] pub fn nd21 ( & mut self ) -> ND21_W { ND21_W { w : self } }
# [ doc = "Bit 22 - New Data 22" ] # [ inline ( always ) ] pub fn nd22 ( & mut self ) -> ND22_W { ND22_W { w : self } }
# [ doc = "Bit 23 - New Data 23" ] # [ inline ( always ) ] pub fn nd23 ( & mut self ) -> ND23_W { ND23_W { w : self } }
# [ doc = "Bit 24 - New Data 24" ] # [ inline ( always ) ] pub fn nd24 ( & mut self ) -> ND24_W { ND24_W { w : self } }
# [ doc = "Bit 25 - New Data 25" ] # [ inline ( always ) ] pub fn nd25 ( & mut self ) -> ND25_W { ND25_W { w : self } }
# [ doc = "Bit 26 - New Data 26" ] # [ inline ( always ) ] pub fn nd26 ( & mut self ) -> ND26_W { ND26_W { w : self } }
# [ doc = "Bit 27 - New Data 27" ] # [ inline ( always ) ] pub fn nd27 ( & mut self ) -> ND27_W { ND27_W { w : self } }
# [ doc = "Bit 28 - New Data 28" ] # [ inline ( always ) ] pub fn nd28 ( & mut self ) -> ND28_W { ND28_W { w : self } }
# [ doc = "Bit 29 - New Data 29" ] # [ inline ( always ) ] pub fn nd29 ( & mut self ) -> ND29_W { ND29_W { w : self } }
# [ doc = "Bit 30 - New Data 30" ] # [ inline ( always ) ] pub fn nd30 ( & mut self ) -> ND30_W { ND30_W { w : self } }
# [ doc = "Bit 31 - New Data 31" ] # [ inline ( always ) ] pub fn nd31 ( & mut self ) -> ND31_W { ND31_W { w : self } }
}
}
# [ doc = "New Data 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ndat2](ndat2) module" ] pub type NDAT2 = crate :: Reg < u32 , _NDAT2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _NDAT2 ;
# [ doc = "`read()` method returns [ndat2::R](ndat2::R) reader structure" ] impl crate :: Readable for NDAT2 { }
# [ doc = "`write(|w| ..)` method takes [ndat2::W](ndat2::W) writer structure" ] impl crate :: Writable for NDAT2 { }
# [ doc = "New Data 2" ] pub mod ndat2 {
# [ doc = "Reader of register NDAT2" ] pub type R = crate :: R < u32 , super :: NDAT2 > ;
# [ doc = "Writer for register NDAT2" ] pub type W = crate :: W < u32 , super :: NDAT2 > ;
# [ doc = "Register NDAT2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: NDAT2 { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ND32`" ] pub type ND32_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND32`" ] pub struct ND32_W < 'a > { w : & 'a mut W , } impl < 'a > ND32_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ND33`" ] pub type ND33_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND33`" ] pub struct ND33_W < 'a > { w : & 'a mut W , } impl < 'a > ND33_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `ND34`" ] pub type ND34_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND34`" ] pub struct ND34_W < 'a > { w : & 'a mut W , } impl < 'a > ND34_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ND35`" ] pub type ND35_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND35`" ] pub struct ND35_W < 'a > { w : & 'a mut W , } impl < 'a > ND35_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `ND36`" ] pub type ND36_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND36`" ] pub struct ND36_W < 'a > { w : & 'a mut W , } impl < 'a > ND36_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ND37`" ] pub type ND37_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND37`" ] pub struct ND37_W < 'a > { w : & 'a mut W , } impl < 'a > ND37_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `ND38`" ] pub type ND38_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND38`" ] pub struct ND38_W < 'a > { w : & 'a mut W , } impl < 'a > ND38_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ND39`" ] pub type ND39_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND39`" ] pub struct ND39_W < 'a > { w : & 'a mut W , } impl < 'a > ND39_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `ND40`" ] pub type ND40_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND40`" ] pub struct ND40_W < 'a > { w : & 'a mut W , } impl < 'a > ND40_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `ND41`" ] pub type ND41_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND41`" ] pub struct ND41_W < 'a > { w : & 'a mut W , } impl < 'a > ND41_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `ND42`" ] pub type ND42_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND42`" ] pub struct ND42_W < 'a > { w : & 'a mut W , } impl < 'a > ND42_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `ND43`" ] pub type ND43_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND43`" ] pub struct ND43_W < 'a > { w : & 'a mut W , } impl < 'a > ND43_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `ND44`" ] pub type ND44_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND44`" ] pub struct ND44_W < 'a > { w : & 'a mut W , } impl < 'a > ND44_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ND45`" ] pub type ND45_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND45`" ] pub struct ND45_W < 'a > { w : & 'a mut W , } impl < 'a > ND45_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `ND46`" ] pub type ND46_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND46`" ] pub struct ND46_W < 'a > { w : & 'a mut W , } impl < 'a > ND46_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `ND47`" ] pub type ND47_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND47`" ] pub struct ND47_W < 'a > { w : & 'a mut W , } impl < 'a > ND47_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `ND48`" ] pub type ND48_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND48`" ] pub struct ND48_W < 'a > { w : & 'a mut W , } impl < 'a > ND48_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `ND49`" ] pub type ND49_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND49`" ] pub struct ND49_W < 'a > { w : & 'a mut W , } impl < 'a > ND49_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `ND50`" ] pub type ND50_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND50`" ] pub struct ND50_W < 'a > { w : & 'a mut W , } impl < 'a > ND50_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `ND51`" ] pub type ND51_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND51`" ] pub struct ND51_W < 'a > { w : & 'a mut W , } impl < 'a > ND51_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `ND52`" ] pub type ND52_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND52`" ] pub struct ND52_W < 'a > { w : & 'a mut W , } impl < 'a > ND52_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `ND53`" ] pub type ND53_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND53`" ] pub struct ND53_W < 'a > { w : & 'a mut W , } impl < 'a > ND53_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `ND54`" ] pub type ND54_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND54`" ] pub struct ND54_W < 'a > { w : & 'a mut W , } impl < 'a > ND54_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `ND55`" ] pub type ND55_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND55`" ] pub struct ND55_W < 'a > { w : & 'a mut W , } impl < 'a > ND55_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `ND56`" ] pub type ND56_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND56`" ] pub struct ND56_W < 'a > { w : & 'a mut W , } impl < 'a > ND56_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `ND57`" ] pub type ND57_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND57`" ] pub struct ND57_W < 'a > { w : & 'a mut W , } impl < 'a > ND57_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `ND58`" ] pub type ND58_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND58`" ] pub struct ND58_W < 'a > { w : & 'a mut W , } impl < 'a > ND58_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `ND59`" ] pub type ND59_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND59`" ] pub struct ND59_W < 'a > { w : & 'a mut W , } impl < 'a > ND59_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Reader of field `ND60`" ] pub type ND60_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND60`" ] pub struct ND60_W < 'a > { w : & 'a mut W , } impl < 'a > ND60_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `ND61`" ] pub type ND61_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND61`" ] pub struct ND61_W < 'a > { w : & 'a mut W , } impl < 'a > ND61_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } }
# [ doc = "Reader of field `ND62`" ] pub type ND62_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND62`" ] pub struct ND62_W < 'a > { w : & 'a mut W , } impl < 'a > ND62_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } }
# [ doc = "Reader of field `ND63`" ] pub type ND63_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ND63`" ] pub struct ND63_W < 'a > { w : & 'a mut W , } impl < 'a > ND63_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - New Data 32" ] # [ inline ( always ) ] pub fn nd32 ( & self ) -> ND32_R { ND32_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - New Data 33" ] # [ inline ( always ) ] pub fn nd33 ( & self ) -> ND33_R { ND33_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - New Data 34" ] # [ inline ( always ) ] pub fn nd34 ( & self ) -> ND34_R { ND34_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - New Data 35" ] # [ inline ( always ) ] pub fn nd35 ( & self ) -> ND35_R { ND35_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - New Data 36" ] # [ inline ( always ) ] pub fn nd36 ( & self ) -> ND36_R { ND36_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - New Data 37" ] # [ inline ( always ) ] pub fn nd37 ( & self ) -> ND37_R { ND37_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - New Data 38" ] # [ inline ( always ) ] pub fn nd38 ( & self ) -> ND38_R { ND38_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - New Data 39" ] # [ inline ( always ) ] pub fn nd39 ( & self ) -> ND39_R { ND39_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - New Data 40" ] # [ inline ( always ) ] pub fn nd40 ( & self ) -> ND40_R { ND40_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - New Data 41" ] # [ inline ( always ) ] pub fn nd41 ( & self ) -> ND41_R { ND41_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - New Data 42" ] # [ inline ( always ) ] pub fn nd42 ( & self ) -> ND42_R { ND42_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - New Data 43" ] # [ inline ( always ) ] pub fn nd43 ( & self ) -> ND43_R { ND43_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - New Data 44" ] # [ inline ( always ) ] pub fn nd44 ( & self ) -> ND44_R { ND44_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - New Data 45" ] # [ inline ( always ) ] pub fn nd45 ( & self ) -> ND45_R { ND45_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - New Data 46" ] # [ inline ( always ) ] pub fn nd46 ( & self ) -> ND46_R { ND46_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - New Data 47" ] # [ inline ( always ) ] pub fn nd47 ( & self ) -> ND47_R { ND47_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - New Data 48" ] # [ inline ( always ) ] pub fn nd48 ( & self ) -> ND48_R { ND48_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - New Data 49" ] # [ inline ( always ) ] pub fn nd49 ( & self ) -> ND49_R { ND49_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - New Data 50" ] # [ inline ( always ) ] pub fn nd50 ( & self ) -> ND50_R { ND50_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - New Data 51" ] # [ inline ( always ) ] pub fn nd51 ( & self ) -> ND51_R { ND51_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - New Data 52" ] # [ inline ( always ) ] pub fn nd52 ( & self ) -> ND52_R { ND52_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - New Data 53" ] # [ inline ( always ) ] pub fn nd53 ( & self ) -> ND53_R { ND53_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - New Data 54" ] # [ inline ( always ) ] pub fn nd54 ( & self ) -> ND54_R { ND54_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - New Data 55" ] # [ inline ( always ) ] pub fn nd55 ( & self ) -> ND55_R { ND55_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - New Data 56" ] # [ inline ( always ) ] pub fn nd56 ( & self ) -> ND56_R { ND56_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - New Data 57" ] # [ inline ( always ) ] pub fn nd57 ( & self ) -> ND57_R { ND57_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - New Data 58" ] # [ inline ( always ) ] pub fn nd58 ( & self ) -> ND58_R { ND58_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - New Data 59" ] # [ inline ( always ) ] pub fn nd59 ( & self ) -> ND59_R { ND59_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - New Data 60" ] # [ inline ( always ) ] pub fn nd60 ( & self ) -> ND60_R { ND60_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - New Data 61" ] # [ inline ( always ) ] pub fn nd61 ( & self ) -> ND61_R { ND61_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 30 - New Data 62" ] # [ inline ( always ) ] pub fn nd62 ( & self ) -> ND62_R { ND62_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - New Data 63" ] # [ inline ( always ) ] pub fn nd63 ( & self ) -> ND63_R { ND63_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - New Data 32" ] # [ inline ( always ) ] pub fn nd32 ( & mut self ) -> ND32_W { ND32_W { w : self } }
# [ doc = "Bit 1 - New Data 33" ] # [ inline ( always ) ] pub fn nd33 ( & mut self ) -> ND33_W { ND33_W { w : self } }
# [ doc = "Bit 2 - New Data 34" ] # [ inline ( always ) ] pub fn nd34 ( & mut self ) -> ND34_W { ND34_W { w : self } }
# [ doc = "Bit 3 - New Data 35" ] # [ inline ( always ) ] pub fn nd35 ( & mut self ) -> ND35_W { ND35_W { w : self } }
# [ doc = "Bit 4 - New Data 36" ] # [ inline ( always ) ] pub fn nd36 ( & mut self ) -> ND36_W { ND36_W { w : self } }
# [ doc = "Bit 5 - New Data 37" ] # [ inline ( always ) ] pub fn nd37 ( & mut self ) -> ND37_W { ND37_W { w : self } }
# [ doc = "Bit 6 - New Data 38" ] # [ inline ( always ) ] pub fn nd38 ( & mut self ) -> ND38_W { ND38_W { w : self } }
# [ doc = "Bit 7 - New Data 39" ] # [ inline ( always ) ] pub fn nd39 ( & mut self ) -> ND39_W { ND39_W { w : self } }
# [ doc = "Bit 8 - New Data 40" ] # [ inline ( always ) ] pub fn nd40 ( & mut self ) -> ND40_W { ND40_W { w : self } }
# [ doc = "Bit 9 - New Data 41" ] # [ inline ( always ) ] pub fn nd41 ( & mut self ) -> ND41_W { ND41_W { w : self } }
# [ doc = "Bit 10 - New Data 42" ] # [ inline ( always ) ] pub fn nd42 ( & mut self ) -> ND42_W { ND42_W { w : self } }
# [ doc = "Bit 11 - New Data 43" ] # [ inline ( always ) ] pub fn nd43 ( & mut self ) -> ND43_W { ND43_W { w : self } }
# [ doc = "Bit 12 - New Data 44" ] # [ inline ( always ) ] pub fn nd44 ( & mut self ) -> ND44_W { ND44_W { w : self } }
# [ doc = "Bit 13 - New Data 45" ] # [ inline ( always ) ] pub fn nd45 ( & mut self ) -> ND45_W { ND45_W { w : self } }
# [ doc = "Bit 14 - New Data 46" ] # [ inline ( always ) ] pub fn nd46 ( & mut self ) -> ND46_W { ND46_W { w : self } }
# [ doc = "Bit 15 - New Data 47" ] # [ inline ( always ) ] pub fn nd47 ( & mut self ) -> ND47_W { ND47_W { w : self } }
# [ doc = "Bit 16 - New Data 48" ] # [ inline ( always ) ] pub fn nd48 ( & mut self ) -> ND48_W { ND48_W { w : self } }
# [ doc = "Bit 17 - New Data 49" ] # [ inline ( always ) ] pub fn nd49 ( & mut self ) -> ND49_W { ND49_W { w : self } }
# [ doc = "Bit 18 - New Data 50" ] # [ inline ( always ) ] pub fn nd50 ( & mut self ) -> ND50_W { ND50_W { w : self } }
# [ doc = "Bit 19 - New Data 51" ] # [ inline ( always ) ] pub fn nd51 ( & mut self ) -> ND51_W { ND51_W { w : self } }
# [ doc = "Bit 20 - New Data 52" ] # [ inline ( always ) ] pub fn nd52 ( & mut self ) -> ND52_W { ND52_W { w : self } }
# [ doc = "Bit 21 - New Data 53" ] # [ inline ( always ) ] pub fn nd53 ( & mut self ) -> ND53_W { ND53_W { w : self } }
# [ doc = "Bit 22 - New Data 54" ] # [ inline ( always ) ] pub fn nd54 ( & mut self ) -> ND54_W { ND54_W { w : self } }
# [ doc = "Bit 23 - New Data 55" ] # [ inline ( always ) ] pub fn nd55 ( & mut self ) -> ND55_W { ND55_W { w : self } }
# [ doc = "Bit 24 - New Data 56" ] # [ inline ( always ) ] pub fn nd56 ( & mut self ) -> ND56_W { ND56_W { w : self } }
# [ doc = "Bit 25 - New Data 57" ] # [ inline ( always ) ] pub fn nd57 ( & mut self ) -> ND57_W { ND57_W { w : self } }
# [ doc = "Bit 26 - New Data 58" ] # [ inline ( always ) ] pub fn nd58 ( & mut self ) -> ND58_W { ND58_W { w : self } }
# [ doc = "Bit 27 - New Data 59" ] # [ inline ( always ) ] pub fn nd59 ( & mut self ) -> ND59_W { ND59_W { w : self } }
# [ doc = "Bit 28 - New Data 60" ] # [ inline ( always ) ] pub fn nd60 ( & mut self ) -> ND60_W { ND60_W { w : self } }
# [ doc = "Bit 29 - New Data 61" ] # [ inline ( always ) ] pub fn nd61 ( & mut self ) -> ND61_W { ND61_W { w : self } }
# [ doc = "Bit 30 - New Data 62" ] # [ inline ( always ) ] pub fn nd62 ( & mut self ) -> ND62_W { ND62_W { w : self } }
# [ doc = "Bit 31 - New Data 63" ] # [ inline ( always ) ] pub fn nd63 ( & mut self ) -> ND63_W { ND63_W { w : self } }
}
}
# [ doc = "Rx FIFO 0 Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxf0c](rxf0c) module" ] pub type RXF0C = crate :: Reg < u32 , _RXF0C > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXF0C ;
# [ doc = "`read()` method returns [rxf0c::R](rxf0c::R) reader structure" ] impl crate :: Readable for RXF0C { }
# [ doc = "`write(|w| ..)` method takes [rxf0c::W](rxf0c::W) writer structure" ] impl crate :: Writable for RXF0C { }
# [ doc = "Rx FIFO 0 Configuration" ] pub mod rxf0c {
# [ doc = "Reader of register RXF0C" ] pub type R = crate :: R < u32 , super :: RXF0C > ;
# [ doc = "Writer for register RXF0C" ] pub type W = crate :: W < u32 , super :: RXF0C > ;
# [ doc = "Register RXF0C `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RXF0C { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `F0SA`" ] pub type F0SA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `F0SA`" ] pub struct F0SA_W < 'a > { w : & 'a mut W , } impl < 'a > F0SA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
# [ doc = "Reader of field `F0S`" ] pub type F0S_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `F0S`" ] pub struct F0S_W < 'a > { w : & 'a mut W , } impl < 'a > F0S_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x7f << 16 ) ) | ( ( ( value as u32 ) & 0x7f ) << 16 ) ; self . w } }
# [ doc = "Reader of field `F0WM`" ] pub type F0WM_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `F0WM`" ] pub struct F0WM_W < 'a > { w : & 'a mut W , } impl < 'a > F0WM_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x7f << 24 ) ) | ( ( ( value as u32 ) & 0x7f ) << 24 ) ; self . w } }
# [ doc = "Reader of field `F0OM`" ] pub type F0OM_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `F0OM`" ] pub struct F0OM_W < 'a > { w : & 'a mut W , } impl < 'a > F0OM_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Rx FIFO 0 Start Address" ] # [ inline ( always ) ] pub fn f0sa ( & self ) -> F0SA_R { F0SA_R :: new ( ( self . bits & 0xffff ) as u16 ) }
# [ doc = "Bits 16:22 - Rx FIFO 0 Size" ] # [ inline ( always ) ] pub fn f0s ( & self ) -> F0S_R { F0S_R :: new ( ( ( self . bits >> 16 ) & 0x7f ) as u8 ) }
# [ doc = "Bits 24:30 - Rx FIFO 0 Watermark" ] # [ inline ( always ) ] pub fn f0wm ( & self ) -> F0WM_R { F0WM_R :: new ( ( ( self . bits >> 24 ) & 0x7f ) as u8 ) }
# [ doc = "Bit 31 - FIFO 0 Operation Mode" ] # [ inline ( always ) ] pub fn f0om ( & self ) -> F0OM_R { F0OM_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:15 - Rx FIFO 0 Start Address" ] # [ inline ( always ) ] pub fn f0sa ( & mut self ) -> F0SA_W { F0SA_W { w : self } }
# [ doc = "Bits 16:22 - Rx FIFO 0 Size" ] # [ inline ( always ) ] pub fn f0s ( & mut self ) -> F0S_W { F0S_W { w : self } }
# [ doc = "Bits 24:30 - Rx FIFO 0 Watermark" ] # [ inline ( always ) ] pub fn f0wm ( & mut self ) -> F0WM_W { F0WM_W { w : self } }
# [ doc = "Bit 31 - FIFO 0 Operation Mode" ] # [ inline ( always ) ] pub fn f0om ( & mut self ) -> F0OM_W { F0OM_W { w : self } }
}
}
# [ doc = "Rx FIFO 0 Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxf0s](rxf0s) module" ] pub type RXF0S = crate :: Reg < u32 , _RXF0S > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXF0S ;
# [ doc = "`read()` method returns [rxf0s::R](rxf0s::R) reader structure" ] impl crate :: Readable for RXF0S { }
# [ doc = "Rx FIFO 0 Status" ] pub mod rxf0s {
# [ doc = "Reader of register RXF0S" ] pub type R = crate :: R < u32 , super :: RXF0S > ;
# [ doc = "Reader of field `F0FL`" ] pub type F0FL_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `F0GI`" ] pub type F0GI_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `F0PI`" ] pub type F0PI_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `F0F`" ] pub type F0F_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `RF0L`" ] pub type RF0L_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bits 0:6 - Rx FIFO 0 Fill Level" ] # [ inline ( always ) ] pub fn f0fl ( & self ) -> F0FL_R { F0FL_R :: new ( ( self . bits & 0x7f ) as u8 ) }
# [ doc = "Bits 8:13 - Rx FIFO 0 Get Index" ] # [ inline ( always ) ] pub fn f0gi ( & self ) -> F0GI_R { F0GI_R :: new ( ( ( self . bits >> 8 ) & 0x3f ) as u8 ) }
# [ doc = "Bits 16:21 - Rx FIFO 0 Put Index" ] # [ inline ( always ) ] pub fn f0pi ( & self ) -> F0PI_R { F0PI_R :: new ( ( ( self . bits >> 16 ) & 0x3f ) as u8 ) }
# [ doc = "Bit 24 - Rx FIFO 0 Full" ] # [ inline ( always ) ] pub fn f0f ( & self ) -> F0F_R { F0F_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Rx FIFO 0 Message Lost" ] # [ inline ( always ) ] pub fn rf0l ( & self ) -> RF0L_R { RF0L_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Rx FIFO 0 Acknowledge\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxf0a](rxf0a) module" ] pub type RXF0A = crate :: Reg < u32 , _RXF0A > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXF0A ;
# [ doc = "`read()` method returns [rxf0a::R](rxf0a::R) reader structure" ] impl crate :: Readable for RXF0A { }
# [ doc = "`write(|w| ..)` method takes [rxf0a::W](rxf0a::W) writer structure" ] impl crate :: Writable for RXF0A { }
# [ doc = "Rx FIFO 0 Acknowledge" ] pub mod rxf0a {
# [ doc = "Reader of register RXF0A" ] pub type R = crate :: R < u32 , super :: RXF0A > ;
# [ doc = "Writer for register RXF0A" ] pub type W = crate :: W < u32 , super :: RXF0A > ;
# [ doc = "Register RXF0A `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RXF0A { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `F0AI`" ] pub type F0AI_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `F0AI`" ] pub struct F0AI_W < 'a > { w : & 'a mut W , } impl < 'a > F0AI_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Rx FIFO 0 Acknowledge Index" ] # [ inline ( always ) ] pub fn f0ai ( & self ) -> F0AI_R { F0AI_R :: new ( ( self . bits & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:5 - Rx FIFO 0 Acknowledge Index" ] # [ inline ( always ) ] pub fn f0ai ( & mut self ) -> F0AI_W { F0AI_W { w : self } }
}
}
# [ doc = "Rx Buffer Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxbc](rxbc) module" ] pub type RXBC = crate :: Reg < u32 , _RXBC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXBC ;
# [ doc = "`read()` method returns [rxbc::R](rxbc::R) reader structure" ] impl crate :: Readable for RXBC { }
# [ doc = "`write(|w| ..)` method takes [rxbc::W](rxbc::W) writer structure" ] impl crate :: Writable for RXBC { }
# [ doc = "Rx Buffer Configuration" ] pub mod rxbc {
# [ doc = "Reader of register RXBC" ] pub type R = crate :: R < u32 , super :: RXBC > ;
# [ doc = "Writer for register RXBC" ] pub type W = crate :: W < u32 , super :: RXBC > ;
# [ doc = "Register RXBC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RXBC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RBSA`" ] pub type RBSA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `RBSA`" ] pub struct RBSA_W < 'a > { w : & 'a mut W , } impl < 'a > RBSA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Rx Buffer Start Address" ] # [ inline ( always ) ] pub fn rbsa ( & self ) -> RBSA_R { RBSA_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - Rx Buffer Start Address" ] # [ inline ( always ) ] pub fn rbsa ( & mut self ) -> RBSA_W { RBSA_W { w : self } }
}
}
# [ doc = "Rx FIFO 1 Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxf1c](rxf1c) module" ] pub type RXF1C = crate :: Reg < u32 , _RXF1C > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXF1C ;
# [ doc = "`read()` method returns [rxf1c::R](rxf1c::R) reader structure" ] impl crate :: Readable for RXF1C { }
# [ doc = "`write(|w| ..)` method takes [rxf1c::W](rxf1c::W) writer structure" ] impl crate :: Writable for RXF1C { }
# [ doc = "Rx FIFO 1 Configuration" ] pub mod rxf1c {
# [ doc = "Reader of register RXF1C" ] pub type R = crate :: R < u32 , super :: RXF1C > ;
# [ doc = "Writer for register RXF1C" ] pub type W = crate :: W < u32 , super :: RXF1C > ;
# [ doc = "Register RXF1C `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RXF1C { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `F1SA`" ] pub type F1SA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `F1SA`" ] pub struct F1SA_W < 'a > { w : & 'a mut W , } impl < 'a > F1SA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
# [ doc = "Reader of field `F1S`" ] pub type F1S_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `F1S`" ] pub struct F1S_W < 'a > { w : & 'a mut W , } impl < 'a > F1S_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x7f << 16 ) ) | ( ( ( value as u32 ) & 0x7f ) << 16 ) ; self . w } }
# [ doc = "Reader of field `F1WM`" ] pub type F1WM_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `F1WM`" ] pub struct F1WM_W < 'a > { w : & 'a mut W , } impl < 'a > F1WM_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x7f << 24 ) ) | ( ( ( value as u32 ) & 0x7f ) << 24 ) ; self . w } }
# [ doc = "Reader of field `F1OM`" ] pub type F1OM_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `F1OM`" ] pub struct F1OM_W < 'a > { w : & 'a mut W , } impl < 'a > F1OM_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Rx FIFO 1 Start Address" ] # [ inline ( always ) ] pub fn f1sa ( & self ) -> F1SA_R { F1SA_R :: new ( ( self . bits & 0xffff ) as u16 ) }
# [ doc = "Bits 16:22 - Rx FIFO 1 Size" ] # [ inline ( always ) ] pub fn f1s ( & self ) -> F1S_R { F1S_R :: new ( ( ( self . bits >> 16 ) & 0x7f ) as u8 ) }
# [ doc = "Bits 24:30 - Rx FIFO 1 Watermark" ] # [ inline ( always ) ] pub fn f1wm ( & self ) -> F1WM_R { F1WM_R :: new ( ( ( self . bits >> 24 ) & 0x7f ) as u8 ) }
# [ doc = "Bit 31 - FIFO 1 Operation Mode" ] # [ inline ( always ) ] pub fn f1om ( & self ) -> F1OM_R { F1OM_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:15 - Rx FIFO 1 Start Address" ] # [ inline ( always ) ] pub fn f1sa ( & mut self ) -> F1SA_W { F1SA_W { w : self } }
# [ doc = "Bits 16:22 - Rx FIFO 1 Size" ] # [ inline ( always ) ] pub fn f1s ( & mut self ) -> F1S_W { F1S_W { w : self } }
# [ doc = "Bits 24:30 - Rx FIFO 1 Watermark" ] # [ inline ( always ) ] pub fn f1wm ( & mut self ) -> F1WM_W { F1WM_W { w : self } }
# [ doc = "Bit 31 - FIFO 1 Operation Mode" ] # [ inline ( always ) ] pub fn f1om ( & mut self ) -> F1OM_W { F1OM_W { w : self } }
}
}
# [ doc = "Rx FIFO 1 Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxf1s](rxf1s) module" ] pub type RXF1S = crate :: Reg < u32 , _RXF1S > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXF1S ;
# [ doc = "`read()` method returns [rxf1s::R](rxf1s::R) reader structure" ] impl crate :: Readable for RXF1S { }
# [ doc = "Rx FIFO 1 Status" ] pub mod rxf1s {
# [ doc = "Reader of register RXF1S" ] pub type R = crate :: R < u32 , super :: RXF1S > ;
# [ doc = "Reader of field `F1FL`" ] pub type F1FL_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `F1GI`" ] pub type F1GI_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `F1PI`" ] pub type F1PI_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `F1F`" ] pub type F1F_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `RF1L`" ] pub type RF1L_R = crate :: R < bool , bool > ;
# [ doc = "Possible values of the field `DMS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DMS_A { # [ doc = "Idle state" ] IDLE , # [ doc = "Debug message A received" ] DBGA , # [ doc = "Debug message A/B received" ] DBGB , # [ doc = "Debug message A/B/C received, DMA request set" ] DBGC }
impl crate :: ToBits < u8 > for DMS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DMS_A :: IDLE => 0 , DMS_A :: DBGA => 1 , DMS_A :: DBGB => 2 , DMS_A :: DBGC => 3 } } }
# [ doc = "Reader of field `DMS`" ] pub type DMS_R = crate :: R < u8 , DMS_A > ; impl DMS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DMS_A { match self . bits { 0 => DMS_A :: IDLE , 1 => DMS_A :: DBGA , 2 => DMS_A :: DBGB , 3 => DMS_A :: DBGC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `IDLE`" ] # [ inline ( always ) ] pub fn is_idle ( & self ) -> bool { * self == DMS_A :: IDLE } # [ doc = "Checks if the value of the field is `DBGA`" ] # [ inline ( always ) ] pub fn is_dbga ( & self ) -> bool { * self == DMS_A :: DBGA } # [ doc = "Checks if the value of the field is `DBGB`" ] # [ inline ( always ) ] pub fn is_dbgb ( & self ) -> bool { * self == DMS_A :: DBGB } # [ doc = "Checks if the value of the field is `DBGC`" ] # [ inline ( always ) ] pub fn is_dbgc ( & self ) -> bool { * self == DMS_A :: DBGC } }
impl R {
# [ doc = "Bits 0:6 - Rx FIFO 1 Fill Level" ] # [ inline ( always ) ] pub fn f1fl ( & self ) -> F1FL_R { F1FL_R :: new ( ( self . bits & 0x7f ) as u8 ) }
# [ doc = "Bits 8:13 - Rx FIFO 1 Get Index" ] # [ inline ( always ) ] pub fn f1gi ( & self ) -> F1GI_R { F1GI_R :: new ( ( ( self . bits >> 8 ) & 0x3f ) as u8 ) }
# [ doc = "Bits 16:21 - Rx FIFO 1 Put Index" ] # [ inline ( always ) ] pub fn f1pi ( & self ) -> F1PI_R { F1PI_R :: new ( ( ( self . bits >> 16 ) & 0x3f ) as u8 ) }
# [ doc = "Bit 24 - Rx FIFO 1 Full" ] # [ inline ( always ) ] pub fn f1f ( & self ) -> F1F_R { F1F_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Rx FIFO 1 Message Lost" ] # [ inline ( always ) ] pub fn rf1l ( & self ) -> RF1L_R { RF1L_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 30:31 - Debug Message Status" ] # [ inline ( always ) ] pub fn dms ( & self ) -> DMS_R { DMS_R :: new ( ( ( self . bits >> 30 ) & 0x03 ) as u8 ) }
}
}
# [ doc = "Rx FIFO 1 Acknowledge\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxf1a](rxf1a) module" ] pub type RXF1A = crate :: Reg < u32 , _RXF1A > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXF1A ;
# [ doc = "`read()` method returns [rxf1a::R](rxf1a::R) reader structure" ] impl crate :: Readable for RXF1A { }
# [ doc = "`write(|w| ..)` method takes [rxf1a::W](rxf1a::W) writer structure" ] impl crate :: Writable for RXF1A { }
# [ doc = "Rx FIFO 1 Acknowledge" ] pub mod rxf1a {
# [ doc = "Reader of register RXF1A" ] pub type R = crate :: R < u32 , super :: RXF1A > ;
# [ doc = "Writer for register RXF1A" ] pub type W = crate :: W < u32 , super :: RXF1A > ;
# [ doc = "Register RXF1A `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RXF1A { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `F1AI`" ] pub type F1AI_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `F1AI`" ] pub struct F1AI_W < 'a > { w : & 'a mut W , } impl < 'a > F1AI_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Rx FIFO 1 Acknowledge Index" ] # [ inline ( always ) ] pub fn f1ai ( & self ) -> F1AI_R { F1AI_R :: new ( ( self . bits & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:5 - Rx FIFO 1 Acknowledge Index" ] # [ inline ( always ) ] pub fn f1ai ( & mut self ) -> F1AI_W { F1AI_W { w : self } }
}
}
# [ doc = "Rx Buffer / FIFO Element Size Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxesc](rxesc) module" ] pub type RXESC = crate :: Reg < u32 , _RXESC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXESC ;
# [ doc = "`read()` method returns [rxesc::R](rxesc::R) reader structure" ] impl crate :: Readable for RXESC { }
# [ doc = "`write(|w| ..)` method takes [rxesc::W](rxesc::W) writer structure" ] impl crate :: Writable for RXESC { }
# [ doc = "Rx Buffer / FIFO Element Size Configuration" ] pub mod rxesc {
# [ doc = "Reader of register RXESC" ] pub type R = crate :: R < u32 , super :: RXESC > ;
# [ doc = "Writer for register RXESC" ] pub type W = crate :: W < u32 , super :: RXESC > ;
# [ doc = "Register RXESC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RXESC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `F0DS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum F0DS_A { # [ doc = "8 byte data field" ] DATA8 , # [ doc = "12 byte data field" ] DATA12 , # [ doc = "16 byte data field" ] DATA16 , # [ doc = "20 byte data field" ] DATA20 , # [ doc = "24 byte data field" ] DATA24 , # [ doc = "32 byte data field" ] DATA32 , # [ doc = "48 byte data field" ] DATA48 , # [ doc = "64 byte data field" ] DATA64 }
impl crate :: ToBits < u8 > for F0DS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { F0DS_A :: DATA8 => 0 , F0DS_A :: DATA12 => 1 , F0DS_A :: DATA16 => 2 , F0DS_A :: DATA20 => 3 , F0DS_A :: DATA24 => 4 , F0DS_A :: DATA32 => 5 , F0DS_A :: DATA48 => 6 , F0DS_A :: DATA64 => 7 } } }
# [ doc = "Reader of field `F0DS`" ] pub type F0DS_R = crate :: R < u8 , F0DS_A > ; impl F0DS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> F0DS_A { match self . bits { 0 => F0DS_A :: DATA8 , 1 => F0DS_A :: DATA12 , 2 => F0DS_A :: DATA16 , 3 => F0DS_A :: DATA20 , 4 => F0DS_A :: DATA24 , 5 => F0DS_A :: DATA32 , 6 => F0DS_A :: DATA48 , 7 => F0DS_A :: DATA64 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DATA8`" ] # [ inline ( always ) ] pub fn is_data8 ( & self ) -> bool { * self == F0DS_A :: DATA8 } # [ doc = "Checks if the value of the field is `DATA12`" ] # [ inline ( always ) ] pub fn is_data12 ( & self ) -> bool { * self == F0DS_A :: DATA12 } # [ doc = "Checks if the value of the field is `DATA16`" ] # [ inline ( always ) ] pub fn is_data16 ( & self ) -> bool { * self == F0DS_A :: DATA16 } # [ doc = "Checks if the value of the field is `DATA20`" ] # [ inline ( always ) ] pub fn is_data20 ( & self ) -> bool { * self == F0DS_A :: DATA20 } # [ doc = "Checks if the value of the field is `DATA24`" ] # [ inline ( always ) ] pub fn is_data24 ( & self ) -> bool { * self == F0DS_A :: DATA24 } # [ doc = "Checks if the value of the field is `DATA32`" ] # [ inline ( always ) ] pub fn is_data32 ( & self ) -> bool { * self == F0DS_A :: DATA32 } # [ doc = "Checks if the value of the field is `DATA48`" ] # [ inline ( always ) ] pub fn is_data48 ( & self ) -> bool { * self == F0DS_A :: DATA48 } # [ doc = "Checks if the value of the field is `DATA64`" ] # [ inline ( always ) ] pub fn is_data64 ( & self ) -> bool { * self == F0DS_A :: DATA64 } }
# [ doc = "Write proxy for field `F0DS`" ] pub struct F0DS_W < 'a > { w : & 'a mut W , } impl < 'a > F0DS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : F0DS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 byte data field" ] # [ inline ( always ) ] pub fn data8 ( self ) -> & 'a mut W { self . variant ( F0DS_A :: DATA8 ) } # [ doc = "12 byte data field" ] # [ inline ( always ) ] pub fn data12 ( self ) -> & 'a mut W { self . variant ( F0DS_A :: DATA12 ) } # [ doc = "16 byte data field" ] # [ inline ( always ) ] pub fn data16 ( self ) -> & 'a mut W { self . variant ( F0DS_A :: DATA16 ) } # [ doc = "20 byte data field" ] # [ inline ( always ) ] pub fn data20 ( self ) -> & 'a mut W { self . variant ( F0DS_A :: DATA20 ) } # [ doc = "24 byte data field" ] # [ inline ( always ) ] pub fn data24 ( self ) -> & 'a mut W { self . variant ( F0DS_A :: DATA24 ) } # [ doc = "32 byte data field" ] # [ inline ( always ) ] pub fn data32 ( self ) -> & 'a mut W { self . variant ( F0DS_A :: DATA32 ) } # [ doc = "48 byte data field" ] # [ inline ( always ) ] pub fn data48 ( self ) -> & 'a mut W { self . variant ( F0DS_A :: DATA48 ) } # [ doc = "64 byte data field" ] # [ inline ( always ) ] pub fn data64 ( self ) -> & 'a mut W { self . variant ( F0DS_A :: DATA64 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
# [ doc = "Possible values of the field `F1DS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum F1DS_A { # [ doc = "8 byte data field" ] DATA8 , # [ doc = "12 byte data field" ] DATA12 , # [ doc = "16 byte data field" ] DATA16 , # [ doc = "20 byte data field" ] DATA20 , # [ doc = "24 byte data field" ] DATA24 , # [ doc = "32 byte data field" ] DATA32 , # [ doc = "48 byte data field" ] DATA48 , # [ doc = "64 byte data field" ] DATA64 }
impl crate :: ToBits < u8 > for F1DS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { F1DS_A :: DATA8 => 0 , F1DS_A :: DATA12 => 1 , F1DS_A :: DATA16 => 2 , F1DS_A :: DATA20 => 3 , F1DS_A :: DATA24 => 4 , F1DS_A :: DATA32 => 5 , F1DS_A :: DATA48 => 6 , F1DS_A :: DATA64 => 7 } } }
# [ doc = "Reader of field `F1DS`" ] pub type F1DS_R = crate :: R < u8 , F1DS_A > ; impl F1DS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> F1DS_A { match self . bits { 0 => F1DS_A :: DATA8 , 1 => F1DS_A :: DATA12 , 2 => F1DS_A :: DATA16 , 3 => F1DS_A :: DATA20 , 4 => F1DS_A :: DATA24 , 5 => F1DS_A :: DATA32 , 6 => F1DS_A :: DATA48 , 7 => F1DS_A :: DATA64 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DATA8`" ] # [ inline ( always ) ] pub fn is_data8 ( & self ) -> bool { * self == F1DS_A :: DATA8 } # [ doc = "Checks if the value of the field is `DATA12`" ] # [ inline ( always ) ] pub fn is_data12 ( & self ) -> bool { * self == F1DS_A :: DATA12 } # [ doc = "Checks if the value of the field is `DATA16`" ] # [ inline ( always ) ] pub fn is_data16 ( & self ) -> bool { * self == F1DS_A :: DATA16 } # [ doc = "Checks if the value of the field is `DATA20`" ] # [ inline ( always ) ] pub fn is_data20 ( & self ) -> bool { * self == F1DS_A :: DATA20 } # [ doc = "Checks if the value of the field is `DATA24`" ] # [ inline ( always ) ] pub fn is_data24 ( & self ) -> bool { * self == F1DS_A :: DATA24 } # [ doc = "Checks if the value of the field is `DATA32`" ] # [ inline ( always ) ] pub fn is_data32 ( & self ) -> bool { * self == F1DS_A :: DATA32 } # [ doc = "Checks if the value of the field is `DATA48`" ] # [ inline ( always ) ] pub fn is_data48 ( & self ) -> bool { * self == F1DS_A :: DATA48 } # [ doc = "Checks if the value of the field is `DATA64`" ] # [ inline ( always ) ] pub fn is_data64 ( & self ) -> bool { * self == F1DS_A :: DATA64 } }
# [ doc = "Write proxy for field `F1DS`" ] pub struct F1DS_W < 'a > { w : & 'a mut W , } impl < 'a > F1DS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : F1DS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 byte data field" ] # [ inline ( always ) ] pub fn data8 ( self ) -> & 'a mut W { self . variant ( F1DS_A :: DATA8 ) } # [ doc = "12 byte data field" ] # [ inline ( always ) ] pub fn data12 ( self ) -> & 'a mut W { self . variant ( F1DS_A :: DATA12 ) } # [ doc = "16 byte data field" ] # [ inline ( always ) ] pub fn data16 ( self ) -> & 'a mut W { self . variant ( F1DS_A :: DATA16 ) } # [ doc = "20 byte data field" ] # [ inline ( always ) ] pub fn data20 ( self ) -> & 'a mut W { self . variant ( F1DS_A :: DATA20 ) } # [ doc = "24 byte data field" ] # [ inline ( always ) ] pub fn data24 ( self ) -> & 'a mut W { self . variant ( F1DS_A :: DATA24 ) } # [ doc = "32 byte data field" ] # [ inline ( always ) ] pub fn data32 ( self ) -> & 'a mut W { self . variant ( F1DS_A :: DATA32 ) } # [ doc = "48 byte data field" ] # [ inline ( always ) ] pub fn data48 ( self ) -> & 'a mut W { self . variant ( F1DS_A :: DATA48 ) } # [ doc = "64 byte data field" ] # [ inline ( always ) ] pub fn data64 ( self ) -> & 'a mut W { self . variant ( F1DS_A :: DATA64 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u32 ) & 0x07 ) << 4 ) ; self . w } }
# [ doc = "Possible values of the field `RBDS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RBDS_A { # [ doc = "8 byte data field" ] DATA8 , # [ doc = "12 byte data field" ] DATA12 , # [ doc = "16 byte data field" ] DATA16 , # [ doc = "20 byte data field" ] DATA20 , # [ doc = "24 byte data field" ] DATA24 , # [ doc = "32 byte data field" ] DATA32 , # [ doc = "48 byte data field" ] DATA48 , # [ doc = "64 byte data field" ] DATA64 }
impl crate :: ToBits < u8 > for RBDS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { RBDS_A :: DATA8 => 0 , RBDS_A :: DATA12 => 1 , RBDS_A :: DATA16 => 2 , RBDS_A :: DATA20 => 3 , RBDS_A :: DATA24 => 4 , RBDS_A :: DATA32 => 5 , RBDS_A :: DATA48 => 6 , RBDS_A :: DATA64 => 7 } } }
# [ doc = "Reader of field `RBDS`" ] pub type RBDS_R = crate :: R < u8 , RBDS_A > ; impl RBDS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RBDS_A { match self . bits { 0 => RBDS_A :: DATA8 , 1 => RBDS_A :: DATA12 , 2 => RBDS_A :: DATA16 , 3 => RBDS_A :: DATA20 , 4 => RBDS_A :: DATA24 , 5 => RBDS_A :: DATA32 , 6 => RBDS_A :: DATA48 , 7 => RBDS_A :: DATA64 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DATA8`" ] # [ inline ( always ) ] pub fn is_data8 ( & self ) -> bool { * self == RBDS_A :: DATA8 } # [ doc = "Checks if the value of the field is `DATA12`" ] # [ inline ( always ) ] pub fn is_data12 ( & self ) -> bool { * self == RBDS_A :: DATA12 } # [ doc = "Checks if the value of the field is `DATA16`" ] # [ inline ( always ) ] pub fn is_data16 ( & self ) -> bool { * self == RBDS_A :: DATA16 } # [ doc = "Checks if the value of the field is `DATA20`" ] # [ inline ( always ) ] pub fn is_data20 ( & self ) -> bool { * self == RBDS_A :: DATA20 } # [ doc = "Checks if the value of the field is `DATA24`" ] # [ inline ( always ) ] pub fn is_data24 ( & self ) -> bool { * self == RBDS_A :: DATA24 } # [ doc = "Checks if the value of the field is `DATA32`" ] # [ inline ( always ) ] pub fn is_data32 ( & self ) -> bool { * self == RBDS_A :: DATA32 } # [ doc = "Checks if the value of the field is `DATA48`" ] # [ inline ( always ) ] pub fn is_data48 ( & self ) -> bool { * self == RBDS_A :: DATA48 } # [ doc = "Checks if the value of the field is `DATA64`" ] # [ inline ( always ) ] pub fn is_data64 ( & self ) -> bool { * self == RBDS_A :: DATA64 } }
# [ doc = "Write proxy for field `RBDS`" ] pub struct RBDS_W < 'a > { w : & 'a mut W , } impl < 'a > RBDS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RBDS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 byte data field" ] # [ inline ( always ) ] pub fn data8 ( self ) -> & 'a mut W { self . variant ( RBDS_A :: DATA8 ) } # [ doc = "12 byte data field" ] # [ inline ( always ) ] pub fn data12 ( self ) -> & 'a mut W { self . variant ( RBDS_A :: DATA12 ) } # [ doc = "16 byte data field" ] # [ inline ( always ) ] pub fn data16 ( self ) -> & 'a mut W { self . variant ( RBDS_A :: DATA16 ) } # [ doc = "20 byte data field" ] # [ inline ( always ) ] pub fn data20 ( self ) -> & 'a mut W { self . variant ( RBDS_A :: DATA20 ) } # [ doc = "24 byte data field" ] # [ inline ( always ) ] pub fn data24 ( self ) -> & 'a mut W { self . variant ( RBDS_A :: DATA24 ) } # [ doc = "32 byte data field" ] # [ inline ( always ) ] pub fn data32 ( self ) -> & 'a mut W { self . variant ( RBDS_A :: DATA32 ) } # [ doc = "48 byte data field" ] # [ inline ( always ) ] pub fn data48 ( self ) -> & 'a mut W { self . variant ( RBDS_A :: DATA48 ) } # [ doc = "64 byte data field" ] # [ inline ( always ) ] pub fn data64 ( self ) -> & 'a mut W { self . variant ( RBDS_A :: DATA64 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u32 ) & 0x07 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Rx FIFO 0 Data Field Size" ] # [ inline ( always ) ] pub fn f0ds ( & self ) -> F0DS_R { F0DS_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bits 4:6 - Rx FIFO 1 Data Field Size" ] # [ inline ( always ) ] pub fn f1ds ( & self ) -> F1DS_R { F1DS_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 8:10 - Rx Buffer Data Field Size" ] # [ inline ( always ) ] pub fn rbds ( & self ) -> RBDS_R { RBDS_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Rx FIFO 0 Data Field Size" ] # [ inline ( always ) ] pub fn f0ds ( & mut self ) -> F0DS_W { F0DS_W { w : self } }
# [ doc = "Bits 4:6 - Rx FIFO 1 Data Field Size" ] # [ inline ( always ) ] pub fn f1ds ( & mut self ) -> F1DS_W { F1DS_W { w : self } }
# [ doc = "Bits 8:10 - Rx Buffer Data Field Size" ] # [ inline ( always ) ] pub fn rbds ( & mut self ) -> RBDS_W { RBDS_W { w : self } }
}
}
# [ doc = "Tx Buffer Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txbc](txbc) module" ] pub type TXBC = crate :: Reg < u32 , _TXBC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXBC ;
# [ doc = "`read()` method returns [txbc::R](txbc::R) reader structure" ] impl crate :: Readable for TXBC { }
# [ doc = "`write(|w| ..)` method takes [txbc::W](txbc::W) writer structure" ] impl crate :: Writable for TXBC { }
# [ doc = "Tx Buffer Configuration" ] pub mod txbc {
# [ doc = "Reader of register TXBC" ] pub type R = crate :: R < u32 , super :: TXBC > ;
# [ doc = "Writer for register TXBC" ] pub type W = crate :: W < u32 , super :: TXBC > ;
# [ doc = "Register TXBC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TXBC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `TBSA`" ] pub type TBSA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `TBSA`" ] pub struct TBSA_W < 'a > { w : & 'a mut W , } impl < 'a > TBSA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
# [ doc = "Reader of field `NDTB`" ] pub type NDTB_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `NDTB`" ] pub struct NDTB_W < 'a > { w : & 'a mut W , } impl < 'a > NDTB_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 16 ) ) | ( ( ( value as u32 ) & 0x3f ) << 16 ) ; self . w } }
# [ doc = "Reader of field `TFQS`" ] pub type TFQS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `TFQS`" ] pub struct TFQS_W < 'a > { w : & 'a mut W , } impl < 'a > TFQS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } }
# [ doc = "Reader of field `TFQM`" ] pub type TFQM_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TFQM`" ] pub struct TFQM_W < 'a > { w : & 'a mut W , } impl < 'a > TFQM_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Tx Buffers Start Address" ] # [ inline ( always ) ] pub fn tbsa ( & self ) -> TBSA_R { TBSA_R :: new ( ( self . bits & 0xffff ) as u16 ) }
# [ doc = "Bits 16:21 - Number of Dedicated Transmit Buffers" ] # [ inline ( always ) ] pub fn ndtb ( & self ) -> NDTB_R { NDTB_R :: new ( ( ( self . bits >> 16 ) & 0x3f ) as u8 ) }
# [ doc = "Bits 24:29 - Transmit FIFO/Queue Size" ] # [ inline ( always ) ] pub fn tfqs ( & self ) -> TFQS_R { TFQS_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) }
# [ doc = "Bit 30 - Tx FIFO/Queue Mode" ] # [ inline ( always ) ] pub fn tfqm ( & self ) -> TFQM_R { TFQM_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:15 - Tx Buffers Start Address" ] # [ inline ( always ) ] pub fn tbsa ( & mut self ) -> TBSA_W { TBSA_W { w : self } }
# [ doc = "Bits 16:21 - Number of Dedicated Transmit Buffers" ] # [ inline ( always ) ] pub fn ndtb ( & mut self ) -> NDTB_W { NDTB_W { w : self } }
# [ doc = "Bits 24:29 - Transmit FIFO/Queue Size" ] # [ inline ( always ) ] pub fn tfqs ( & mut self ) -> TFQS_W { TFQS_W { w : self } }
# [ doc = "Bit 30 - Tx FIFO/Queue Mode" ] # [ inline ( always ) ] pub fn tfqm ( & mut self ) -> TFQM_W { TFQM_W { w : self } }
}
}
# [ doc = "Tx FIFO / Queue Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txfqs](txfqs) module" ] pub type TXFQS = crate :: Reg < u32 , _TXFQS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXFQS ;
# [ doc = "`read()` method returns [txfqs::R](txfqs::R) reader structure" ] impl crate :: Readable for TXFQS { }
# [ doc = "Tx FIFO / Queue Status" ] pub mod txfqs {
# [ doc = "Reader of register TXFQS" ] pub type R = crate :: R < u32 , super :: TXFQS > ;
# [ doc = "Reader of field `TFFL`" ] pub type TFFL_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `TFGI`" ] pub type TFGI_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `TFQPI`" ] pub type TFQPI_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `TFQF`" ] pub type TFQF_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bits 0:5 - Tx FIFO Free Level" ] # [ inline ( always ) ] pub fn tffl ( & self ) -> TFFL_R { TFFL_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 8:12 - Tx FIFO Get Index" ] # [ inline ( always ) ] pub fn tfgi ( & self ) -> TFGI_R { TFGI_R :: new ( ( ( self . bits >> 8 ) & 0x1f ) as u8 ) }
# [ doc = "Bits 16:20 - Tx FIFO/Queue Put Index" ] # [ inline ( always ) ] pub fn tfqpi ( & self ) -> TFQPI_R { TFQPI_R :: new ( ( ( self . bits >> 16 ) & 0x1f ) as u8 ) }
# [ doc = "Bit 21 - Tx FIFO/Queue Full" ] # [ inline ( always ) ] pub fn tfqf ( & self ) -> TFQF_R { TFQF_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Tx Buffer Element Size Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txesc](txesc) module" ] pub type TXESC = crate :: Reg < u32 , _TXESC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXESC ;
# [ doc = "`read()` method returns [txesc::R](txesc::R) reader structure" ] impl crate :: Readable for TXESC { }
# [ doc = "`write(|w| ..)` method takes [txesc::W](txesc::W) writer structure" ] impl crate :: Writable for TXESC { }
# [ doc = "Tx Buffer Element Size Configuration" ] pub mod txesc {
# [ doc = "Reader of register TXESC" ] pub type R = crate :: R < u32 , super :: TXESC > ;
# [ doc = "Writer for register TXESC" ] pub type W = crate :: W < u32 , super :: TXESC > ;
# [ doc = "Register TXESC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TXESC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `TBDS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TBDS_A { # [ doc = "8 byte data field" ] DATA8 , # [ doc = "12 byte data field" ] DATA12 , # [ doc = "16 byte data field" ] DATA16 , # [ doc = "20 byte data field" ] DATA20 , # [ doc = "24 byte data field" ] DATA24 , # [ doc = "32 byte data field" ] DATA32 , # [ doc = "48 byte data field" ] DATA48 , # [ doc = "64 byte data field" ] DATA64 }
impl crate :: ToBits < u8 > for TBDS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { TBDS_A :: DATA8 => 0 , TBDS_A :: DATA12 => 1 , TBDS_A :: DATA16 => 2 , TBDS_A :: DATA20 => 3 , TBDS_A :: DATA24 => 4 , TBDS_A :: DATA32 => 5 , TBDS_A :: DATA48 => 6 , TBDS_A :: DATA64 => 7 } } }
# [ doc = "Reader of field `TBDS`" ] pub type TBDS_R = crate :: R < u8 , TBDS_A > ; impl TBDS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TBDS_A { match self . bits { 0 => TBDS_A :: DATA8 , 1 => TBDS_A :: DATA12 , 2 => TBDS_A :: DATA16 , 3 => TBDS_A :: DATA20 , 4 => TBDS_A :: DATA24 , 5 => TBDS_A :: DATA32 , 6 => TBDS_A :: DATA48 , 7 => TBDS_A :: DATA64 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DATA8`" ] # [ inline ( always ) ] pub fn is_data8 ( & self ) -> bool { * self == TBDS_A :: DATA8 } # [ doc = "Checks if the value of the field is `DATA12`" ] # [ inline ( always ) ] pub fn is_data12 ( & self ) -> bool { * self == TBDS_A :: DATA12 } # [ doc = "Checks if the value of the field is `DATA16`" ] # [ inline ( always ) ] pub fn is_data16 ( & self ) -> bool { * self == TBDS_A :: DATA16 } # [ doc = "Checks if the value of the field is `DATA20`" ] # [ inline ( always ) ] pub fn is_data20 ( & self ) -> bool { * self == TBDS_A :: DATA20 } # [ doc = "Checks if the value of the field is `DATA24`" ] # [ inline ( always ) ] pub fn is_data24 ( & self ) -> bool { * self == TBDS_A :: DATA24 } # [ doc = "Checks if the value of the field is `DATA32`" ] # [ inline ( always ) ] pub fn is_data32 ( & self ) -> bool { * self == TBDS_A :: DATA32 } # [ doc = "Checks if the value of the field is `DATA48`" ] # [ inline ( always ) ] pub fn is_data48 ( & self ) -> bool { * self == TBDS_A :: DATA48 } # [ doc = "Checks if the value of the field is `DATA64`" ] # [ inline ( always ) ] pub fn is_data64 ( & self ) -> bool { * self == TBDS_A :: DATA64 } }
# [ doc = "Write proxy for field `TBDS`" ] pub struct TBDS_W < 'a > { w : & 'a mut W , } impl < 'a > TBDS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TBDS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 byte data field" ] # [ inline ( always ) ] pub fn data8 ( self ) -> & 'a mut W { self . variant ( TBDS_A :: DATA8 ) } # [ doc = "12 byte data field" ] # [ inline ( always ) ] pub fn data12 ( self ) -> & 'a mut W { self . variant ( TBDS_A :: DATA12 ) } # [ doc = "16 byte data field" ] # [ inline ( always ) ] pub fn data16 ( self ) -> & 'a mut W { self . variant ( TBDS_A :: DATA16 ) } # [ doc = "20 byte data field" ] # [ inline ( always ) ] pub fn data20 ( self ) -> & 'a mut W { self . variant ( TBDS_A :: DATA20 ) } # [ doc = "24 byte data field" ] # [ inline ( always ) ] pub fn data24 ( self ) -> & 'a mut W { self . variant ( TBDS_A :: DATA24 ) } # [ doc = "32 byte data field" ] # [ inline ( always ) ] pub fn data32 ( self ) -> & 'a mut W { self . variant ( TBDS_A :: DATA32 ) } # [ doc = "48 byte data field" ] # [ inline ( always ) ] pub fn data48 ( self ) -> & 'a mut W { self . variant ( TBDS_A :: DATA48 ) } # [ doc = "64 byte data field" ] # [ inline ( always ) ] pub fn data64 ( self ) -> & 'a mut W { self . variant ( TBDS_A :: DATA64 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Tx Buffer Data Field Size" ] # [ inline ( always ) ] pub fn tbds ( & self ) -> TBDS_R { TBDS_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Tx Buffer Data Field Size" ] # [ inline ( always ) ] pub fn tbds ( & mut self ) -> TBDS_W { TBDS_W { w : self } }
}
}
# [ doc = "Tx Buffer Request Pending\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txbrp](txbrp) module" ] pub type TXBRP = crate :: Reg < u32 , _TXBRP > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXBRP ;
# [ doc = "`read()` method returns [txbrp::R](txbrp::R) reader structure" ] impl crate :: Readable for TXBRP { }
# [ doc = "Tx Buffer Request Pending" ] pub mod txbrp {
# [ doc = "Reader of register TXBRP" ] pub type R = crate :: R < u32 , super :: TXBRP > ;
# [ doc = "Reader of field `TRP0`" ] pub type TRP0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP1`" ] pub type TRP1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP2`" ] pub type TRP2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP3`" ] pub type TRP3_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP4`" ] pub type TRP4_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP5`" ] pub type TRP5_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP6`" ] pub type TRP6_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP7`" ] pub type TRP7_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP8`" ] pub type TRP8_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP9`" ] pub type TRP9_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP10`" ] pub type TRP10_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP11`" ] pub type TRP11_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP12`" ] pub type TRP12_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP13`" ] pub type TRP13_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP14`" ] pub type TRP14_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP15`" ] pub type TRP15_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP16`" ] pub type TRP16_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP17`" ] pub type TRP17_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP18`" ] pub type TRP18_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP19`" ] pub type TRP19_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP20`" ] pub type TRP20_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP21`" ] pub type TRP21_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP22`" ] pub type TRP22_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP23`" ] pub type TRP23_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP24`" ] pub type TRP24_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP25`" ] pub type TRP25_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP26`" ] pub type TRP26_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP27`" ] pub type TRP27_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP28`" ] pub type TRP28_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP29`" ] pub type TRP29_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP30`" ] pub type TRP30_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TRP31`" ] pub type TRP31_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Transmission Request Pending 0" ] # [ inline ( always ) ] pub fn trp0 ( & self ) -> TRP0_R { TRP0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmission Request Pending 1" ] # [ inline ( always ) ] pub fn trp1 ( & self ) -> TRP1_R { TRP1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmission Request Pending 2" ] # [ inline ( always ) ] pub fn trp2 ( & self ) -> TRP2_R { TRP2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmission Request Pending 3" ] # [ inline ( always ) ] pub fn trp3 ( & self ) -> TRP3_R { TRP3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Transmission Request Pending 4" ] # [ inline ( always ) ] pub fn trp4 ( & self ) -> TRP4_R { TRP4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Transmission Request Pending 5" ] # [ inline ( always ) ] pub fn trp5 ( & self ) -> TRP5_R { TRP5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Transmission Request Pending 6" ] # [ inline ( always ) ] pub fn trp6 ( & self ) -> TRP6_R { TRP6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Transmission Request Pending 7" ] # [ inline ( always ) ] pub fn trp7 ( & self ) -> TRP7_R { TRP7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Transmission Request Pending 8" ] # [ inline ( always ) ] pub fn trp8 ( & self ) -> TRP8_R { TRP8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Transmission Request Pending 9" ] # [ inline ( always ) ] pub fn trp9 ( & self ) -> TRP9_R { TRP9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Transmission Request Pending 10" ] # [ inline ( always ) ] pub fn trp10 ( & self ) -> TRP10_R { TRP10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Transmission Request Pending 11" ] # [ inline ( always ) ] pub fn trp11 ( & self ) -> TRP11_R { TRP11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Transmission Request Pending 12" ] # [ inline ( always ) ] pub fn trp12 ( & self ) -> TRP12_R { TRP12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Transmission Request Pending 13" ] # [ inline ( always ) ] pub fn trp13 ( & self ) -> TRP13_R { TRP13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Transmission Request Pending 14" ] # [ inline ( always ) ] pub fn trp14 ( & self ) -> TRP14_R { TRP14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Transmission Request Pending 15" ] # [ inline ( always ) ] pub fn trp15 ( & self ) -> TRP15_R { TRP15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Transmission Request Pending 16" ] # [ inline ( always ) ] pub fn trp16 ( & self ) -> TRP16_R { TRP16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Transmission Request Pending 17" ] # [ inline ( always ) ] pub fn trp17 ( & self ) -> TRP17_R { TRP17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Transmission Request Pending 18" ] # [ inline ( always ) ] pub fn trp18 ( & self ) -> TRP18_R { TRP18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Transmission Request Pending 19" ] # [ inline ( always ) ] pub fn trp19 ( & self ) -> TRP19_R { TRP19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Transmission Request Pending 20" ] # [ inline ( always ) ] pub fn trp20 ( & self ) -> TRP20_R { TRP20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Transmission Request Pending 21" ] # [ inline ( always ) ] pub fn trp21 ( & self ) -> TRP21_R { TRP21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Transmission Request Pending 22" ] # [ inline ( always ) ] pub fn trp22 ( & self ) -> TRP22_R { TRP22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Transmission Request Pending 23" ] # [ inline ( always ) ] pub fn trp23 ( & self ) -> TRP23_R { TRP23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Transmission Request Pending 24" ] # [ inline ( always ) ] pub fn trp24 ( & self ) -> TRP24_R { TRP24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Transmission Request Pending 25" ] # [ inline ( always ) ] pub fn trp25 ( & self ) -> TRP25_R { TRP25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Transmission Request Pending 26" ] # [ inline ( always ) ] pub fn trp26 ( & self ) -> TRP26_R { TRP26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Transmission Request Pending 27" ] # [ inline ( always ) ] pub fn trp27 ( & self ) -> TRP27_R { TRP27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Transmission Request Pending 28" ] # [ inline ( always ) ] pub fn trp28 ( & self ) -> TRP28_R { TRP28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Transmission Request Pending 29" ] # [ inline ( always ) ] pub fn trp29 ( & self ) -> TRP29_R { TRP29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 30 - Transmission Request Pending 30" ] # [ inline ( always ) ] pub fn trp30 ( & self ) -> TRP30_R { TRP30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - Transmission Request Pending 31" ] # [ inline ( always ) ] pub fn trp31 ( & self ) -> TRP31_R { TRP31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Tx Buffer Add Request\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txbar](txbar) module" ] pub type TXBAR = crate :: Reg < u32 , _TXBAR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXBAR ;
# [ doc = "`read()` method returns [txbar::R](txbar::R) reader structure" ] impl crate :: Readable for TXBAR { }
# [ doc = "`write(|w| ..)` method takes [txbar::W](txbar::W) writer structure" ] impl crate :: Writable for TXBAR { }
# [ doc = "Tx Buffer Add Request" ] pub mod txbar {
# [ doc = "Reader of register TXBAR" ] pub type R = crate :: R < u32 , super :: TXBAR > ;
# [ doc = "Writer for register TXBAR" ] pub type W = crate :: W < u32 , super :: TXBAR > ;
# [ doc = "Register TXBAR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TXBAR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `AR0`" ] pub type AR0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR0`" ] pub struct AR0_W < 'a > { w : & 'a mut W , } impl < 'a > AR0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `AR1`" ] pub type AR1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR1`" ] pub struct AR1_W < 'a > { w : & 'a mut W , } impl < 'a > AR1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `AR2`" ] pub type AR2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR2`" ] pub struct AR2_W < 'a > { w : & 'a mut W , } impl < 'a > AR2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `AR3`" ] pub type AR3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR3`" ] pub struct AR3_W < 'a > { w : & 'a mut W , } impl < 'a > AR3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `AR4`" ] pub type AR4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR4`" ] pub struct AR4_W < 'a > { w : & 'a mut W , } impl < 'a > AR4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `AR5`" ] pub type AR5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR5`" ] pub struct AR5_W < 'a > { w : & 'a mut W , } impl < 'a > AR5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `AR6`" ] pub type AR6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR6`" ] pub struct AR6_W < 'a > { w : & 'a mut W , } impl < 'a > AR6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `AR7`" ] pub type AR7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR7`" ] pub struct AR7_W < 'a > { w : & 'a mut W , } impl < 'a > AR7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `AR8`" ] pub type AR8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR8`" ] pub struct AR8_W < 'a > { w : & 'a mut W , } impl < 'a > AR8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `AR9`" ] pub type AR9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR9`" ] pub struct AR9_W < 'a > { w : & 'a mut W , } impl < 'a > AR9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `AR10`" ] pub type AR10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR10`" ] pub struct AR10_W < 'a > { w : & 'a mut W , } impl < 'a > AR10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `AR11`" ] pub type AR11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR11`" ] pub struct AR11_W < 'a > { w : & 'a mut W , } impl < 'a > AR11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `AR12`" ] pub type AR12_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR12`" ] pub struct AR12_W < 'a > { w : & 'a mut W , } impl < 'a > AR12_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `AR13`" ] pub type AR13_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR13`" ] pub struct AR13_W < 'a > { w : & 'a mut W , } impl < 'a > AR13_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `AR14`" ] pub type AR14_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR14`" ] pub struct AR14_W < 'a > { w : & 'a mut W , } impl < 'a > AR14_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `AR15`" ] pub type AR15_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR15`" ] pub struct AR15_W < 'a > { w : & 'a mut W , } impl < 'a > AR15_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `AR16`" ] pub type AR16_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR16`" ] pub struct AR16_W < 'a > { w : & 'a mut W , } impl < 'a > AR16_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `AR17`" ] pub type AR17_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR17`" ] pub struct AR17_W < 'a > { w : & 'a mut W , } impl < 'a > AR17_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `AR18`" ] pub type AR18_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR18`" ] pub struct AR18_W < 'a > { w : & 'a mut W , } impl < 'a > AR18_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `AR19`" ] pub type AR19_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR19`" ] pub struct AR19_W < 'a > { w : & 'a mut W , } impl < 'a > AR19_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `AR20`" ] pub type AR20_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR20`" ] pub struct AR20_W < 'a > { w : & 'a mut W , } impl < 'a > AR20_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `AR21`" ] pub type AR21_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR21`" ] pub struct AR21_W < 'a > { w : & 'a mut W , } impl < 'a > AR21_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `AR22`" ] pub type AR22_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR22`" ] pub struct AR22_W < 'a > { w : & 'a mut W , } impl < 'a > AR22_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `AR23`" ] pub type AR23_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR23`" ] pub struct AR23_W < 'a > { w : & 'a mut W , } impl < 'a > AR23_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `AR24`" ] pub type AR24_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR24`" ] pub struct AR24_W < 'a > { w : & 'a mut W , } impl < 'a > AR24_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `AR25`" ] pub type AR25_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR25`" ] pub struct AR25_W < 'a > { w : & 'a mut W , } impl < 'a > AR25_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `AR26`" ] pub type AR26_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR26`" ] pub struct AR26_W < 'a > { w : & 'a mut W , } impl < 'a > AR26_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `AR27`" ] pub type AR27_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR27`" ] pub struct AR27_W < 'a > { w : & 'a mut W , } impl < 'a > AR27_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Reader of field `AR28`" ] pub type AR28_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR28`" ] pub struct AR28_W < 'a > { w : & 'a mut W , } impl < 'a > AR28_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `AR29`" ] pub type AR29_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR29`" ] pub struct AR29_W < 'a > { w : & 'a mut W , } impl < 'a > AR29_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } }
# [ doc = "Reader of field `AR30`" ] pub type AR30_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR30`" ] pub struct AR30_W < 'a > { w : & 'a mut W , } impl < 'a > AR30_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } }
# [ doc = "Reader of field `AR31`" ] pub type AR31_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AR31`" ] pub struct AR31_W < 'a > { w : & 'a mut W , } impl < 'a > AR31_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Add Request 0" ] # [ inline ( always ) ] pub fn ar0 ( & self ) -> AR0_R { AR0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Add Request 1" ] # [ inline ( always ) ] pub fn ar1 ( & self ) -> AR1_R { AR1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Add Request 2" ] # [ inline ( always ) ] pub fn ar2 ( & self ) -> AR2_R { AR2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Add Request 3" ] # [ inline ( always ) ] pub fn ar3 ( & self ) -> AR3_R { AR3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Add Request 4" ] # [ inline ( always ) ] pub fn ar4 ( & self ) -> AR4_R { AR4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Add Request 5" ] # [ inline ( always ) ] pub fn ar5 ( & self ) -> AR5_R { AR5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Add Request 6" ] # [ inline ( always ) ] pub fn ar6 ( & self ) -> AR6_R { AR6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Add Request 7" ] # [ inline ( always ) ] pub fn ar7 ( & self ) -> AR7_R { AR7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Add Request 8" ] # [ inline ( always ) ] pub fn ar8 ( & self ) -> AR8_R { AR8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Add Request 9" ] # [ inline ( always ) ] pub fn ar9 ( & self ) -> AR9_R { AR9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Add Request 10" ] # [ inline ( always ) ] pub fn ar10 ( & self ) -> AR10_R { AR10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Add Request 11" ] # [ inline ( always ) ] pub fn ar11 ( & self ) -> AR11_R { AR11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Add Request 12" ] # [ inline ( always ) ] pub fn ar12 ( & self ) -> AR12_R { AR12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Add Request 13" ] # [ inline ( always ) ] pub fn ar13 ( & self ) -> AR13_R { AR13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Add Request 14" ] # [ inline ( always ) ] pub fn ar14 ( & self ) -> AR14_R { AR14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Add Request 15" ] # [ inline ( always ) ] pub fn ar15 ( & self ) -> AR15_R { AR15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Add Request 16" ] # [ inline ( always ) ] pub fn ar16 ( & self ) -> AR16_R { AR16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Add Request 17" ] # [ inline ( always ) ] pub fn ar17 ( & self ) -> AR17_R { AR17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Add Request 18" ] # [ inline ( always ) ] pub fn ar18 ( & self ) -> AR18_R { AR18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Add Request 19" ] # [ inline ( always ) ] pub fn ar19 ( & self ) -> AR19_R { AR19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Add Request 20" ] # [ inline ( always ) ] pub fn ar20 ( & self ) -> AR20_R { AR20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Add Request 21" ] # [ inline ( always ) ] pub fn ar21 ( & self ) -> AR21_R { AR21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Add Request 22" ] # [ inline ( always ) ] pub fn ar22 ( & self ) -> AR22_R { AR22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Add Request 23" ] # [ inline ( always ) ] pub fn ar23 ( & self ) -> AR23_R { AR23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Add Request 24" ] # [ inline ( always ) ] pub fn ar24 ( & self ) -> AR24_R { AR24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Add Request 25" ] # [ inline ( always ) ] pub fn ar25 ( & self ) -> AR25_R { AR25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Add Request 26" ] # [ inline ( always ) ] pub fn ar26 ( & self ) -> AR26_R { AR26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Add Request 27" ] # [ inline ( always ) ] pub fn ar27 ( & self ) -> AR27_R { AR27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Add Request 28" ] # [ inline ( always ) ] pub fn ar28 ( & self ) -> AR28_R { AR28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Add Request 29" ] # [ inline ( always ) ] pub fn ar29 ( & self ) -> AR29_R { AR29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 30 - Add Request 30" ] # [ inline ( always ) ] pub fn ar30 ( & self ) -> AR30_R { AR30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - Add Request 31" ] # [ inline ( always ) ] pub fn ar31 ( & self ) -> AR31_R { AR31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Add Request 0" ] # [ inline ( always ) ] pub fn ar0 ( & mut self ) -> AR0_W { AR0_W { w : self } }
# [ doc = "Bit 1 - Add Request 1" ] # [ inline ( always ) ] pub fn ar1 ( & mut self ) -> AR1_W { AR1_W { w : self } }
# [ doc = "Bit 2 - Add Request 2" ] # [ inline ( always ) ] pub fn ar2 ( & mut self ) -> AR2_W { AR2_W { w : self } }
# [ doc = "Bit 3 - Add Request 3" ] # [ inline ( always ) ] pub fn ar3 ( & mut self ) -> AR3_W { AR3_W { w : self } }
# [ doc = "Bit 4 - Add Request 4" ] # [ inline ( always ) ] pub fn ar4 ( & mut self ) -> AR4_W { AR4_W { w : self } }
# [ doc = "Bit 5 - Add Request 5" ] # [ inline ( always ) ] pub fn ar5 ( & mut self ) -> AR5_W { AR5_W { w : self } }
# [ doc = "Bit 6 - Add Request 6" ] # [ inline ( always ) ] pub fn ar6 ( & mut self ) -> AR6_W { AR6_W { w : self } }
# [ doc = "Bit 7 - Add Request 7" ] # [ inline ( always ) ] pub fn ar7 ( & mut self ) -> AR7_W { AR7_W { w : self } }
# [ doc = "Bit 8 - Add Request 8" ] # [ inline ( always ) ] pub fn ar8 ( & mut self ) -> AR8_W { AR8_W { w : self } }
# [ doc = "Bit 9 - Add Request 9" ] # [ inline ( always ) ] pub fn ar9 ( & mut self ) -> AR9_W { AR9_W { w : self } }
# [ doc = "Bit 10 - Add Request 10" ] # [ inline ( always ) ] pub fn ar10 ( & mut self ) -> AR10_W { AR10_W { w : self } }
# [ doc = "Bit 11 - Add Request 11" ] # [ inline ( always ) ] pub fn ar11 ( & mut self ) -> AR11_W { AR11_W { w : self } }
# [ doc = "Bit 12 - Add Request 12" ] # [ inline ( always ) ] pub fn ar12 ( & mut self ) -> AR12_W { AR12_W { w : self } }
# [ doc = "Bit 13 - Add Request 13" ] # [ inline ( always ) ] pub fn ar13 ( & mut self ) -> AR13_W { AR13_W { w : self } }
# [ doc = "Bit 14 - Add Request 14" ] # [ inline ( always ) ] pub fn ar14 ( & mut self ) -> AR14_W { AR14_W { w : self } }
# [ doc = "Bit 15 - Add Request 15" ] # [ inline ( always ) ] pub fn ar15 ( & mut self ) -> AR15_W { AR15_W { w : self } }
# [ doc = "Bit 16 - Add Request 16" ] # [ inline ( always ) ] pub fn ar16 ( & mut self ) -> AR16_W { AR16_W { w : self } }
# [ doc = "Bit 17 - Add Request 17" ] # [ inline ( always ) ] pub fn ar17 ( & mut self ) -> AR17_W { AR17_W { w : self } }
# [ doc = "Bit 18 - Add Request 18" ] # [ inline ( always ) ] pub fn ar18 ( & mut self ) -> AR18_W { AR18_W { w : self } }
# [ doc = "Bit 19 - Add Request 19" ] # [ inline ( always ) ] pub fn ar19 ( & mut self ) -> AR19_W { AR19_W { w : self } }
# [ doc = "Bit 20 - Add Request 20" ] # [ inline ( always ) ] pub fn ar20 ( & mut self ) -> AR20_W { AR20_W { w : self } }
# [ doc = "Bit 21 - Add Request 21" ] # [ inline ( always ) ] pub fn ar21 ( & mut self ) -> AR21_W { AR21_W { w : self } }
# [ doc = "Bit 22 - Add Request 22" ] # [ inline ( always ) ] pub fn ar22 ( & mut self ) -> AR22_W { AR22_W { w : self } }
# [ doc = "Bit 23 - Add Request 23" ] # [ inline ( always ) ] pub fn ar23 ( & mut self ) -> AR23_W { AR23_W { w : self } }
# [ doc = "Bit 24 - Add Request 24" ] # [ inline ( always ) ] pub fn ar24 ( & mut self ) -> AR24_W { AR24_W { w : self } }
# [ doc = "Bit 25 - Add Request 25" ] # [ inline ( always ) ] pub fn ar25 ( & mut self ) -> AR25_W { AR25_W { w : self } }
# [ doc = "Bit 26 - Add Request 26" ] # [ inline ( always ) ] pub fn ar26 ( & mut self ) -> AR26_W { AR26_W { w : self } }
# [ doc = "Bit 27 - Add Request 27" ] # [ inline ( always ) ] pub fn ar27 ( & mut self ) -> AR27_W { AR27_W { w : self } }
# [ doc = "Bit 28 - Add Request 28" ] # [ inline ( always ) ] pub fn ar28 ( & mut self ) -> AR28_W { AR28_W { w : self } }
# [ doc = "Bit 29 - Add Request 29" ] # [ inline ( always ) ] pub fn ar29 ( & mut self ) -> AR29_W { AR29_W { w : self } }
# [ doc = "Bit 30 - Add Request 30" ] # [ inline ( always ) ] pub fn ar30 ( & mut self ) -> AR30_W { AR30_W { w : self } }
# [ doc = "Bit 31 - Add Request 31" ] # [ inline ( always ) ] pub fn ar31 ( & mut self ) -> AR31_W { AR31_W { w : self } }
}
}
# [ doc = "Tx Buffer Cancellation Request\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txbcr](txbcr) module" ] pub type TXBCR = crate :: Reg < u32 , _TXBCR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXBCR ;
# [ doc = "`read()` method returns [txbcr::R](txbcr::R) reader structure" ] impl crate :: Readable for TXBCR { }
# [ doc = "`write(|w| ..)` method takes [txbcr::W](txbcr::W) writer structure" ] impl crate :: Writable for TXBCR { }
# [ doc = "Tx Buffer Cancellation Request" ] pub mod txbcr {
# [ doc = "Reader of register TXBCR" ] pub type R = crate :: R < u32 , super :: TXBCR > ;
# [ doc = "Writer for register TXBCR" ] pub type W = crate :: W < u32 , super :: TXBCR > ;
# [ doc = "Register TXBCR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TXBCR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CR0`" ] pub type CR0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR0`" ] pub struct CR0_W < 'a > { w : & 'a mut W , } impl < 'a > CR0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `CR1`" ] pub type CR1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR1`" ] pub struct CR1_W < 'a > { w : & 'a mut W , } impl < 'a > CR1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CR2`" ] pub type CR2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR2`" ] pub struct CR2_W < 'a > { w : & 'a mut W , } impl < 'a > CR2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CR3`" ] pub type CR3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR3`" ] pub struct CR3_W < 'a > { w : & 'a mut W , } impl < 'a > CR3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `CR4`" ] pub type CR4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR4`" ] pub struct CR4_W < 'a > { w : & 'a mut W , } impl < 'a > CR4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `CR5`" ] pub type CR5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR5`" ] pub struct CR5_W < 'a > { w : & 'a mut W , } impl < 'a > CR5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `CR6`" ] pub type CR6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR6`" ] pub struct CR6_W < 'a > { w : & 'a mut W , } impl < 'a > CR6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `CR7`" ] pub type CR7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR7`" ] pub struct CR7_W < 'a > { w : & 'a mut W , } impl < 'a > CR7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `CR8`" ] pub type CR8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR8`" ] pub struct CR8_W < 'a > { w : & 'a mut W , } impl < 'a > CR8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `CR9`" ] pub type CR9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR9`" ] pub struct CR9_W < 'a > { w : & 'a mut W , } impl < 'a > CR9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `CR10`" ] pub type CR10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR10`" ] pub struct CR10_W < 'a > { w : & 'a mut W , } impl < 'a > CR10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `CR11`" ] pub type CR11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR11`" ] pub struct CR11_W < 'a > { w : & 'a mut W , } impl < 'a > CR11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `CR12`" ] pub type CR12_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR12`" ] pub struct CR12_W < 'a > { w : & 'a mut W , } impl < 'a > CR12_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `CR13`" ] pub type CR13_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR13`" ] pub struct CR13_W < 'a > { w : & 'a mut W , } impl < 'a > CR13_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `CR14`" ] pub type CR14_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR14`" ] pub struct CR14_W < 'a > { w : & 'a mut W , } impl < 'a > CR14_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `CR15`" ] pub type CR15_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR15`" ] pub struct CR15_W < 'a > { w : & 'a mut W , } impl < 'a > CR15_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `CR16`" ] pub type CR16_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR16`" ] pub struct CR16_W < 'a > { w : & 'a mut W , } impl < 'a > CR16_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `CR17`" ] pub type CR17_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR17`" ] pub struct CR17_W < 'a > { w : & 'a mut W , } impl < 'a > CR17_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `CR18`" ] pub type CR18_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR18`" ] pub struct CR18_W < 'a > { w : & 'a mut W , } impl < 'a > CR18_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `CR19`" ] pub type CR19_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR19`" ] pub struct CR19_W < 'a > { w : & 'a mut W , } impl < 'a > CR19_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `CR20`" ] pub type CR20_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR20`" ] pub struct CR20_W < 'a > { w : & 'a mut W , } impl < 'a > CR20_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `CR21`" ] pub type CR21_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR21`" ] pub struct CR21_W < 'a > { w : & 'a mut W , } impl < 'a > CR21_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `CR22`" ] pub type CR22_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR22`" ] pub struct CR22_W < 'a > { w : & 'a mut W , } impl < 'a > CR22_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `CR23`" ] pub type CR23_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR23`" ] pub struct CR23_W < 'a > { w : & 'a mut W , } impl < 'a > CR23_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `CR24`" ] pub type CR24_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR24`" ] pub struct CR24_W < 'a > { w : & 'a mut W , } impl < 'a > CR24_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `CR25`" ] pub type CR25_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR25`" ] pub struct CR25_W < 'a > { w : & 'a mut W , } impl < 'a > CR25_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `CR26`" ] pub type CR26_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR26`" ] pub struct CR26_W < 'a > { w : & 'a mut W , } impl < 'a > CR26_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `CR27`" ] pub type CR27_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR27`" ] pub struct CR27_W < 'a > { w : & 'a mut W , } impl < 'a > CR27_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Reader of field `CR28`" ] pub type CR28_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR28`" ] pub struct CR28_W < 'a > { w : & 'a mut W , } impl < 'a > CR28_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `CR29`" ] pub type CR29_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR29`" ] pub struct CR29_W < 'a > { w : & 'a mut W , } impl < 'a > CR29_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } }
# [ doc = "Reader of field `CR30`" ] pub type CR30_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR30`" ] pub struct CR30_W < 'a > { w : & 'a mut W , } impl < 'a > CR30_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } }
# [ doc = "Reader of field `CR31`" ] pub type CR31_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CR31`" ] pub struct CR31_W < 'a > { w : & 'a mut W , } impl < 'a > CR31_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Cancellation Request 0" ] # [ inline ( always ) ] pub fn cr0 ( & self ) -> CR0_R { CR0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Cancellation Request 1" ] # [ inline ( always ) ] pub fn cr1 ( & self ) -> CR1_R { CR1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Cancellation Request 2" ] # [ inline ( always ) ] pub fn cr2 ( & self ) -> CR2_R { CR2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Cancellation Request 3" ] # [ inline ( always ) ] pub fn cr3 ( & self ) -> CR3_R { CR3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Cancellation Request 4" ] # [ inline ( always ) ] pub fn cr4 ( & self ) -> CR4_R { CR4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Cancellation Request 5" ] # [ inline ( always ) ] pub fn cr5 ( & self ) -> CR5_R { CR5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Cancellation Request 6" ] # [ inline ( always ) ] pub fn cr6 ( & self ) -> CR6_R { CR6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Cancellation Request 7" ] # [ inline ( always ) ] pub fn cr7 ( & self ) -> CR7_R { CR7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Cancellation Request 8" ] # [ inline ( always ) ] pub fn cr8 ( & self ) -> CR8_R { CR8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Cancellation Request 9" ] # [ inline ( always ) ] pub fn cr9 ( & self ) -> CR9_R { CR9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Cancellation Request 10" ] # [ inline ( always ) ] pub fn cr10 ( & self ) -> CR10_R { CR10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Cancellation Request 11" ] # [ inline ( always ) ] pub fn cr11 ( & self ) -> CR11_R { CR11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Cancellation Request 12" ] # [ inline ( always ) ] pub fn cr12 ( & self ) -> CR12_R { CR12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Cancellation Request 13" ] # [ inline ( always ) ] pub fn cr13 ( & self ) -> CR13_R { CR13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Cancellation Request 14" ] # [ inline ( always ) ] pub fn cr14 ( & self ) -> CR14_R { CR14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Cancellation Request 15" ] # [ inline ( always ) ] pub fn cr15 ( & self ) -> CR15_R { CR15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Cancellation Request 16" ] # [ inline ( always ) ] pub fn cr16 ( & self ) -> CR16_R { CR16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Cancellation Request 17" ] # [ inline ( always ) ] pub fn cr17 ( & self ) -> CR17_R { CR17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Cancellation Request 18" ] # [ inline ( always ) ] pub fn cr18 ( & self ) -> CR18_R { CR18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Cancellation Request 19" ] # [ inline ( always ) ] pub fn cr19 ( & self ) -> CR19_R { CR19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Cancellation Request 20" ] # [ inline ( always ) ] pub fn cr20 ( & self ) -> CR20_R { CR20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Cancellation Request 21" ] # [ inline ( always ) ] pub fn cr21 ( & self ) -> CR21_R { CR21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Cancellation Request 22" ] # [ inline ( always ) ] pub fn cr22 ( & self ) -> CR22_R { CR22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Cancellation Request 23" ] # [ inline ( always ) ] pub fn cr23 ( & self ) -> CR23_R { CR23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Cancellation Request 24" ] # [ inline ( always ) ] pub fn cr24 ( & self ) -> CR24_R { CR24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Cancellation Request 25" ] # [ inline ( always ) ] pub fn cr25 ( & self ) -> CR25_R { CR25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Cancellation Request 26" ] # [ inline ( always ) ] pub fn cr26 ( & self ) -> CR26_R { CR26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Cancellation Request 27" ] # [ inline ( always ) ] pub fn cr27 ( & self ) -> CR27_R { CR27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Cancellation Request 28" ] # [ inline ( always ) ] pub fn cr28 ( & self ) -> CR28_R { CR28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Cancellation Request 29" ] # [ inline ( always ) ] pub fn cr29 ( & self ) -> CR29_R { CR29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 30 - Cancellation Request 30" ] # [ inline ( always ) ] pub fn cr30 ( & self ) -> CR30_R { CR30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - Cancellation Request 31" ] # [ inline ( always ) ] pub fn cr31 ( & self ) -> CR31_R { CR31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Cancellation Request 0" ] # [ inline ( always ) ] pub fn cr0 ( & mut self ) -> CR0_W { CR0_W { w : self } }
# [ doc = "Bit 1 - Cancellation Request 1" ] # [ inline ( always ) ] pub fn cr1 ( & mut self ) -> CR1_W { CR1_W { w : self } }
# [ doc = "Bit 2 - Cancellation Request 2" ] # [ inline ( always ) ] pub fn cr2 ( & mut self ) -> CR2_W { CR2_W { w : self } }
# [ doc = "Bit 3 - Cancellation Request 3" ] # [ inline ( always ) ] pub fn cr3 ( & mut self ) -> CR3_W { CR3_W { w : self } }
# [ doc = "Bit 4 - Cancellation Request 4" ] # [ inline ( always ) ] pub fn cr4 ( & mut self ) -> CR4_W { CR4_W { w : self } }
# [ doc = "Bit 5 - Cancellation Request 5" ] # [ inline ( always ) ] pub fn cr5 ( & mut self ) -> CR5_W { CR5_W { w : self } }
# [ doc = "Bit 6 - Cancellation Request 6" ] # [ inline ( always ) ] pub fn cr6 ( & mut self ) -> CR6_W { CR6_W { w : self } }
# [ doc = "Bit 7 - Cancellation Request 7" ] # [ inline ( always ) ] pub fn cr7 ( & mut self ) -> CR7_W { CR7_W { w : self } }
# [ doc = "Bit 8 - Cancellation Request 8" ] # [ inline ( always ) ] pub fn cr8 ( & mut self ) -> CR8_W { CR8_W { w : self } }
# [ doc = "Bit 9 - Cancellation Request 9" ] # [ inline ( always ) ] pub fn cr9 ( & mut self ) -> CR9_W { CR9_W { w : self } }
# [ doc = "Bit 10 - Cancellation Request 10" ] # [ inline ( always ) ] pub fn cr10 ( & mut self ) -> CR10_W { CR10_W { w : self } }
# [ doc = "Bit 11 - Cancellation Request 11" ] # [ inline ( always ) ] pub fn cr11 ( & mut self ) -> CR11_W { CR11_W { w : self } }
# [ doc = "Bit 12 - Cancellation Request 12" ] # [ inline ( always ) ] pub fn cr12 ( & mut self ) -> CR12_W { CR12_W { w : self } }
# [ doc = "Bit 13 - Cancellation Request 13" ] # [ inline ( always ) ] pub fn cr13 ( & mut self ) -> CR13_W { CR13_W { w : self } }
# [ doc = "Bit 14 - Cancellation Request 14" ] # [ inline ( always ) ] pub fn cr14 ( & mut self ) -> CR14_W { CR14_W { w : self } }
# [ doc = "Bit 15 - Cancellation Request 15" ] # [ inline ( always ) ] pub fn cr15 ( & mut self ) -> CR15_W { CR15_W { w : self } }
# [ doc = "Bit 16 - Cancellation Request 16" ] # [ inline ( always ) ] pub fn cr16 ( & mut self ) -> CR16_W { CR16_W { w : self } }
# [ doc = "Bit 17 - Cancellation Request 17" ] # [ inline ( always ) ] pub fn cr17 ( & mut self ) -> CR17_W { CR17_W { w : self } }
# [ doc = "Bit 18 - Cancellation Request 18" ] # [ inline ( always ) ] pub fn cr18 ( & mut self ) -> CR18_W { CR18_W { w : self } }
# [ doc = "Bit 19 - Cancellation Request 19" ] # [ inline ( always ) ] pub fn cr19 ( & mut self ) -> CR19_W { CR19_W { w : self } }
# [ doc = "Bit 20 - Cancellation Request 20" ] # [ inline ( always ) ] pub fn cr20 ( & mut self ) -> CR20_W { CR20_W { w : self } }
# [ doc = "Bit 21 - Cancellation Request 21" ] # [ inline ( always ) ] pub fn cr21 ( & mut self ) -> CR21_W { CR21_W { w : self } }
# [ doc = "Bit 22 - Cancellation Request 22" ] # [ inline ( always ) ] pub fn cr22 ( & mut self ) -> CR22_W { CR22_W { w : self } }
# [ doc = "Bit 23 - Cancellation Request 23" ] # [ inline ( always ) ] pub fn cr23 ( & mut self ) -> CR23_W { CR23_W { w : self } }
# [ doc = "Bit 24 - Cancellation Request 24" ] # [ inline ( always ) ] pub fn cr24 ( & mut self ) -> CR24_W { CR24_W { w : self } }
# [ doc = "Bit 25 - Cancellation Request 25" ] # [ inline ( always ) ] pub fn cr25 ( & mut self ) -> CR25_W { CR25_W { w : self } }
# [ doc = "Bit 26 - Cancellation Request 26" ] # [ inline ( always ) ] pub fn cr26 ( & mut self ) -> CR26_W { CR26_W { w : self } }
# [ doc = "Bit 27 - Cancellation Request 27" ] # [ inline ( always ) ] pub fn cr27 ( & mut self ) -> CR27_W { CR27_W { w : self } }
# [ doc = "Bit 28 - Cancellation Request 28" ] # [ inline ( always ) ] pub fn cr28 ( & mut self ) -> CR28_W { CR28_W { w : self } }
# [ doc = "Bit 29 - Cancellation Request 29" ] # [ inline ( always ) ] pub fn cr29 ( & mut self ) -> CR29_W { CR29_W { w : self } }
# [ doc = "Bit 30 - Cancellation Request 30" ] # [ inline ( always ) ] pub fn cr30 ( & mut self ) -> CR30_W { CR30_W { w : self } }
# [ doc = "Bit 31 - Cancellation Request 31" ] # [ inline ( always ) ] pub fn cr31 ( & mut self ) -> CR31_W { CR31_W { w : self } }
}
}
# [ doc = "Tx Buffer Transmission Occurred\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txbto](txbto) module" ] pub type TXBTO = crate :: Reg < u32 , _TXBTO > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXBTO ;
# [ doc = "`read()` method returns [txbto::R](txbto::R) reader structure" ] impl crate :: Readable for TXBTO { }
# [ doc = "Tx Buffer Transmission Occurred" ] pub mod txbto {
# [ doc = "Reader of register TXBTO" ] pub type R = crate :: R < u32 , super :: TXBTO > ;
# [ doc = "Reader of field `TO0`" ] pub type TO0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO1`" ] pub type TO1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO2`" ] pub type TO2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO3`" ] pub type TO3_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO4`" ] pub type TO4_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO5`" ] pub type TO5_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO6`" ] pub type TO6_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO7`" ] pub type TO7_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO8`" ] pub type TO8_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO9`" ] pub type TO9_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO10`" ] pub type TO10_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO11`" ] pub type TO11_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO12`" ] pub type TO12_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO13`" ] pub type TO13_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO14`" ] pub type TO14_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO15`" ] pub type TO15_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO16`" ] pub type TO16_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO17`" ] pub type TO17_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO18`" ] pub type TO18_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO19`" ] pub type TO19_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO20`" ] pub type TO20_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO21`" ] pub type TO21_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO22`" ] pub type TO22_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO23`" ] pub type TO23_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO24`" ] pub type TO24_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO25`" ] pub type TO25_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO26`" ] pub type TO26_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO27`" ] pub type TO27_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO28`" ] pub type TO28_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO29`" ] pub type TO29_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO30`" ] pub type TO30_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TO31`" ] pub type TO31_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Transmission Occurred 0" ] # [ inline ( always ) ] pub fn to0 ( & self ) -> TO0_R { TO0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmission Occurred 1" ] # [ inline ( always ) ] pub fn to1 ( & self ) -> TO1_R { TO1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmission Occurred 2" ] # [ inline ( always ) ] pub fn to2 ( & self ) -> TO2_R { TO2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmission Occurred 3" ] # [ inline ( always ) ] pub fn to3 ( & self ) -> TO3_R { TO3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Transmission Occurred 4" ] # [ inline ( always ) ] pub fn to4 ( & self ) -> TO4_R { TO4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Transmission Occurred 5" ] # [ inline ( always ) ] pub fn to5 ( & self ) -> TO5_R { TO5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Transmission Occurred 6" ] # [ inline ( always ) ] pub fn to6 ( & self ) -> TO6_R { TO6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Transmission Occurred 7" ] # [ inline ( always ) ] pub fn to7 ( & self ) -> TO7_R { TO7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Transmission Occurred 8" ] # [ inline ( always ) ] pub fn to8 ( & self ) -> TO8_R { TO8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Transmission Occurred 9" ] # [ inline ( always ) ] pub fn to9 ( & self ) -> TO9_R { TO9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Transmission Occurred 10" ] # [ inline ( always ) ] pub fn to10 ( & self ) -> TO10_R { TO10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Transmission Occurred 11" ] # [ inline ( always ) ] pub fn to11 ( & self ) -> TO11_R { TO11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Transmission Occurred 12" ] # [ inline ( always ) ] pub fn to12 ( & self ) -> TO12_R { TO12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Transmission Occurred 13" ] # [ inline ( always ) ] pub fn to13 ( & self ) -> TO13_R { TO13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Transmission Occurred 14" ] # [ inline ( always ) ] pub fn to14 ( & self ) -> TO14_R { TO14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Transmission Occurred 15" ] # [ inline ( always ) ] pub fn to15 ( & self ) -> TO15_R { TO15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Transmission Occurred 16" ] # [ inline ( always ) ] pub fn to16 ( & self ) -> TO16_R { TO16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Transmission Occurred 17" ] # [ inline ( always ) ] pub fn to17 ( & self ) -> TO17_R { TO17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Transmission Occurred 18" ] # [ inline ( always ) ] pub fn to18 ( & self ) -> TO18_R { TO18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Transmission Occurred 19" ] # [ inline ( always ) ] pub fn to19 ( & self ) -> TO19_R { TO19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Transmission Occurred 20" ] # [ inline ( always ) ] pub fn to20 ( & self ) -> TO20_R { TO20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Transmission Occurred 21" ] # [ inline ( always ) ] pub fn to21 ( & self ) -> TO21_R { TO21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Transmission Occurred 22" ] # [ inline ( always ) ] pub fn to22 ( & self ) -> TO22_R { TO22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Transmission Occurred 23" ] # [ inline ( always ) ] pub fn to23 ( & self ) -> TO23_R { TO23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Transmission Occurred 24" ] # [ inline ( always ) ] pub fn to24 ( & self ) -> TO24_R { TO24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Transmission Occurred 25" ] # [ inline ( always ) ] pub fn to25 ( & self ) -> TO25_R { TO25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Transmission Occurred 26" ] # [ inline ( always ) ] pub fn to26 ( & self ) -> TO26_R { TO26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Transmission Occurred 27" ] # [ inline ( always ) ] pub fn to27 ( & self ) -> TO27_R { TO27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Transmission Occurred 28" ] # [ inline ( always ) ] pub fn to28 ( & self ) -> TO28_R { TO28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Transmission Occurred 29" ] # [ inline ( always ) ] pub fn to29 ( & self ) -> TO29_R { TO29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 30 - Transmission Occurred 30" ] # [ inline ( always ) ] pub fn to30 ( & self ) -> TO30_R { TO30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - Transmission Occurred 31" ] # [ inline ( always ) ] pub fn to31 ( & self ) -> TO31_R { TO31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Tx Buffer Cancellation Finished\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txbcf](txbcf) module" ] pub type TXBCF = crate :: Reg < u32 , _TXBCF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXBCF ;
# [ doc = "`read()` method returns [txbcf::R](txbcf::R) reader structure" ] impl crate :: Readable for TXBCF { }
# [ doc = "Tx Buffer Cancellation Finished" ] pub mod txbcf {
# [ doc = "Reader of register TXBCF" ] pub type R = crate :: R < u32 , super :: TXBCF > ;
# [ doc = "Reader of field `CF0`" ] pub type CF0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF1`" ] pub type CF1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF2`" ] pub type CF2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF3`" ] pub type CF3_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF4`" ] pub type CF4_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF5`" ] pub type CF5_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF6`" ] pub type CF6_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF7`" ] pub type CF7_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF8`" ] pub type CF8_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF9`" ] pub type CF9_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF10`" ] pub type CF10_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF11`" ] pub type CF11_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF12`" ] pub type CF12_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF13`" ] pub type CF13_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF14`" ] pub type CF14_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF15`" ] pub type CF15_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF16`" ] pub type CF16_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF17`" ] pub type CF17_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF18`" ] pub type CF18_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF19`" ] pub type CF19_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF20`" ] pub type CF20_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF21`" ] pub type CF21_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF22`" ] pub type CF22_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF23`" ] pub type CF23_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF24`" ] pub type CF24_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF25`" ] pub type CF25_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF26`" ] pub type CF26_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF27`" ] pub type CF27_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF28`" ] pub type CF28_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF29`" ] pub type CF29_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF30`" ] pub type CF30_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CF31`" ] pub type CF31_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Tx Buffer Cancellation Finished 0" ] # [ inline ( always ) ] pub fn cf0 ( & self ) -> CF0_R { CF0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Tx Buffer Cancellation Finished 1" ] # [ inline ( always ) ] pub fn cf1 ( & self ) -> CF1_R { CF1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Tx Buffer Cancellation Finished 2" ] # [ inline ( always ) ] pub fn cf2 ( & self ) -> CF2_R { CF2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Tx Buffer Cancellation Finished 3" ] # [ inline ( always ) ] pub fn cf3 ( & self ) -> CF3_R { CF3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Tx Buffer Cancellation Finished 4" ] # [ inline ( always ) ] pub fn cf4 ( & self ) -> CF4_R { CF4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Tx Buffer Cancellation Finished 5" ] # [ inline ( always ) ] pub fn cf5 ( & self ) -> CF5_R { CF5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Tx Buffer Cancellation Finished 6" ] # [ inline ( always ) ] pub fn cf6 ( & self ) -> CF6_R { CF6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Tx Buffer Cancellation Finished 7" ] # [ inline ( always ) ] pub fn cf7 ( & self ) -> CF7_R { CF7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Tx Buffer Cancellation Finished 8" ] # [ inline ( always ) ] pub fn cf8 ( & self ) -> CF8_R { CF8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Tx Buffer Cancellation Finished 9" ] # [ inline ( always ) ] pub fn cf9 ( & self ) -> CF9_R { CF9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Tx Buffer Cancellation Finished 10" ] # [ inline ( always ) ] pub fn cf10 ( & self ) -> CF10_R { CF10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Tx Buffer Cancellation Finished 11" ] # [ inline ( always ) ] pub fn cf11 ( & self ) -> CF11_R { CF11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Tx Buffer Cancellation Finished 12" ] # [ inline ( always ) ] pub fn cf12 ( & self ) -> CF12_R { CF12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Tx Buffer Cancellation Finished 13" ] # [ inline ( always ) ] pub fn cf13 ( & self ) -> CF13_R { CF13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Tx Buffer Cancellation Finished 14" ] # [ inline ( always ) ] pub fn cf14 ( & self ) -> CF14_R { CF14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Tx Buffer Cancellation Finished 15" ] # [ inline ( always ) ] pub fn cf15 ( & self ) -> CF15_R { CF15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Tx Buffer Cancellation Finished 16" ] # [ inline ( always ) ] pub fn cf16 ( & self ) -> CF16_R { CF16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Tx Buffer Cancellation Finished 17" ] # [ inline ( always ) ] pub fn cf17 ( & self ) -> CF17_R { CF17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Tx Buffer Cancellation Finished 18" ] # [ inline ( always ) ] pub fn cf18 ( & self ) -> CF18_R { CF18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Tx Buffer Cancellation Finished 19" ] # [ inline ( always ) ] pub fn cf19 ( & self ) -> CF19_R { CF19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Tx Buffer Cancellation Finished 20" ] # [ inline ( always ) ] pub fn cf20 ( & self ) -> CF20_R { CF20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Tx Buffer Cancellation Finished 21" ] # [ inline ( always ) ] pub fn cf21 ( & self ) -> CF21_R { CF21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Tx Buffer Cancellation Finished 22" ] # [ inline ( always ) ] pub fn cf22 ( & self ) -> CF22_R { CF22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Tx Buffer Cancellation Finished 23" ] # [ inline ( always ) ] pub fn cf23 ( & self ) -> CF23_R { CF23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Tx Buffer Cancellation Finished 24" ] # [ inline ( always ) ] pub fn cf24 ( & self ) -> CF24_R { CF24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Tx Buffer Cancellation Finished 25" ] # [ inline ( always ) ] pub fn cf25 ( & self ) -> CF25_R { CF25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Tx Buffer Cancellation Finished 26" ] # [ inline ( always ) ] pub fn cf26 ( & self ) -> CF26_R { CF26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Tx Buffer Cancellation Finished 27" ] # [ inline ( always ) ] pub fn cf27 ( & self ) -> CF27_R { CF27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Tx Buffer Cancellation Finished 28" ] # [ inline ( always ) ] pub fn cf28 ( & self ) -> CF28_R { CF28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Tx Buffer Cancellation Finished 29" ] # [ inline ( always ) ] pub fn cf29 ( & self ) -> CF29_R { CF29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 30 - Tx Buffer Cancellation Finished 30" ] # [ inline ( always ) ] pub fn cf30 ( & self ) -> CF30_R { CF30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - Tx Buffer Cancellation Finished 31" ] # [ inline ( always ) ] pub fn cf31 ( & self ) -> CF31_R { CF31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Tx Buffer Transmission Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txbtie](txbtie) module" ] pub type TXBTIE = crate :: Reg < u32 , _TXBTIE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXBTIE ;
# [ doc = "`read()` method returns [txbtie::R](txbtie::R) reader structure" ] impl crate :: Readable for TXBTIE { }
# [ doc = "`write(|w| ..)` method takes [txbtie::W](txbtie::W) writer structure" ] impl crate :: Writable for TXBTIE { }
# [ doc = "Tx Buffer Transmission Interrupt Enable" ] pub mod txbtie {
# [ doc = "Reader of register TXBTIE" ] pub type R = crate :: R < u32 , super :: TXBTIE > ;
# [ doc = "Writer for register TXBTIE" ] pub type W = crate :: W < u32 , super :: TXBTIE > ;
# [ doc = "Register TXBTIE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TXBTIE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `TIE0`" ] pub type TIE0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE0`" ] pub struct TIE0_W < 'a > { w : & 'a mut W , } impl < 'a > TIE0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `TIE1`" ] pub type TIE1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE1`" ] pub struct TIE1_W < 'a > { w : & 'a mut W , } impl < 'a > TIE1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TIE2`" ] pub type TIE2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE2`" ] pub struct TIE2_W < 'a > { w : & 'a mut W , } impl < 'a > TIE2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `TIE3`" ] pub type TIE3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE3`" ] pub struct TIE3_W < 'a > { w : & 'a mut W , } impl < 'a > TIE3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `TIE4`" ] pub type TIE4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE4`" ] pub struct TIE4_W < 'a > { w : & 'a mut W , } impl < 'a > TIE4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `TIE5`" ] pub type TIE5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE5`" ] pub struct TIE5_W < 'a > { w : & 'a mut W , } impl < 'a > TIE5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `TIE6`" ] pub type TIE6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE6`" ] pub struct TIE6_W < 'a > { w : & 'a mut W , } impl < 'a > TIE6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `TIE7`" ] pub type TIE7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE7`" ] pub struct TIE7_W < 'a > { w : & 'a mut W , } impl < 'a > TIE7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `TIE8`" ] pub type TIE8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE8`" ] pub struct TIE8_W < 'a > { w : & 'a mut W , } impl < 'a > TIE8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `TIE9`" ] pub type TIE9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE9`" ] pub struct TIE9_W < 'a > { w : & 'a mut W , } impl < 'a > TIE9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `TIE10`" ] pub type TIE10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE10`" ] pub struct TIE10_W < 'a > { w : & 'a mut W , } impl < 'a > TIE10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `TIE11`" ] pub type TIE11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE11`" ] pub struct TIE11_W < 'a > { w : & 'a mut W , } impl < 'a > TIE11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `TIE12`" ] pub type TIE12_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE12`" ] pub struct TIE12_W < 'a > { w : & 'a mut W , } impl < 'a > TIE12_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `TIE13`" ] pub type TIE13_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE13`" ] pub struct TIE13_W < 'a > { w : & 'a mut W , } impl < 'a > TIE13_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `TIE14`" ] pub type TIE14_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE14`" ] pub struct TIE14_W < 'a > { w : & 'a mut W , } impl < 'a > TIE14_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `TIE15`" ] pub type TIE15_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE15`" ] pub struct TIE15_W < 'a > { w : & 'a mut W , } impl < 'a > TIE15_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `TIE16`" ] pub type TIE16_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE16`" ] pub struct TIE16_W < 'a > { w : & 'a mut W , } impl < 'a > TIE16_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `TIE17`" ] pub type TIE17_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE17`" ] pub struct TIE17_W < 'a > { w : & 'a mut W , } impl < 'a > TIE17_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `TIE18`" ] pub type TIE18_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE18`" ] pub struct TIE18_W < 'a > { w : & 'a mut W , } impl < 'a > TIE18_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `TIE19`" ] pub type TIE19_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE19`" ] pub struct TIE19_W < 'a > { w : & 'a mut W , } impl < 'a > TIE19_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `TIE20`" ] pub type TIE20_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE20`" ] pub struct TIE20_W < 'a > { w : & 'a mut W , } impl < 'a > TIE20_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `TIE21`" ] pub type TIE21_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE21`" ] pub struct TIE21_W < 'a > { w : & 'a mut W , } impl < 'a > TIE21_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `TIE22`" ] pub type TIE22_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE22`" ] pub struct TIE22_W < 'a > { w : & 'a mut W , } impl < 'a > TIE22_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `TIE23`" ] pub type TIE23_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE23`" ] pub struct TIE23_W < 'a > { w : & 'a mut W , } impl < 'a > TIE23_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `TIE24`" ] pub type TIE24_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE24`" ] pub struct TIE24_W < 'a > { w : & 'a mut W , } impl < 'a > TIE24_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `TIE25`" ] pub type TIE25_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE25`" ] pub struct TIE25_W < 'a > { w : & 'a mut W , } impl < 'a > TIE25_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `TIE26`" ] pub type TIE26_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE26`" ] pub struct TIE26_W < 'a > { w : & 'a mut W , } impl < 'a > TIE26_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `TIE27`" ] pub type TIE27_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE27`" ] pub struct TIE27_W < 'a > { w : & 'a mut W , } impl < 'a > TIE27_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Reader of field `TIE28`" ] pub type TIE28_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE28`" ] pub struct TIE28_W < 'a > { w : & 'a mut W , } impl < 'a > TIE28_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `TIE29`" ] pub type TIE29_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE29`" ] pub struct TIE29_W < 'a > { w : & 'a mut W , } impl < 'a > TIE29_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } }
# [ doc = "Reader of field `TIE30`" ] pub type TIE30_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE30`" ] pub struct TIE30_W < 'a > { w : & 'a mut W , } impl < 'a > TIE30_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } }
# [ doc = "Reader of field `TIE31`" ] pub type TIE31_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TIE31`" ] pub struct TIE31_W < 'a > { w : & 'a mut W , } impl < 'a > TIE31_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Transmission Interrupt Enable 0" ] # [ inline ( always ) ] pub fn tie0 ( & self ) -> TIE0_R { TIE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Transmission Interrupt Enable 1" ] # [ inline ( always ) ] pub fn tie1 ( & self ) -> TIE1_R { TIE1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Transmission Interrupt Enable 2" ] # [ inline ( always ) ] pub fn tie2 ( & self ) -> TIE2_R { TIE2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Transmission Interrupt Enable 3" ] # [ inline ( always ) ] pub fn tie3 ( & self ) -> TIE3_R { TIE3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Transmission Interrupt Enable 4" ] # [ inline ( always ) ] pub fn tie4 ( & self ) -> TIE4_R { TIE4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Transmission Interrupt Enable 5" ] # [ inline ( always ) ] pub fn tie5 ( & self ) -> TIE5_R { TIE5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Transmission Interrupt Enable 6" ] # [ inline ( always ) ] pub fn tie6 ( & self ) -> TIE6_R { TIE6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Transmission Interrupt Enable 7" ] # [ inline ( always ) ] pub fn tie7 ( & self ) -> TIE7_R { TIE7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Transmission Interrupt Enable 8" ] # [ inline ( always ) ] pub fn tie8 ( & self ) -> TIE8_R { TIE8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Transmission Interrupt Enable 9" ] # [ inline ( always ) ] pub fn tie9 ( & self ) -> TIE9_R { TIE9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Transmission Interrupt Enable 10" ] # [ inline ( always ) ] pub fn tie10 ( & self ) -> TIE10_R { TIE10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Transmission Interrupt Enable 11" ] # [ inline ( always ) ] pub fn tie11 ( & self ) -> TIE11_R { TIE11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Transmission Interrupt Enable 12" ] # [ inline ( always ) ] pub fn tie12 ( & self ) -> TIE12_R { TIE12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Transmission Interrupt Enable 13" ] # [ inline ( always ) ] pub fn tie13 ( & self ) -> TIE13_R { TIE13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Transmission Interrupt Enable 14" ] # [ inline ( always ) ] pub fn tie14 ( & self ) -> TIE14_R { TIE14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Transmission Interrupt Enable 15" ] # [ inline ( always ) ] pub fn tie15 ( & self ) -> TIE15_R { TIE15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Transmission Interrupt Enable 16" ] # [ inline ( always ) ] pub fn tie16 ( & self ) -> TIE16_R { TIE16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Transmission Interrupt Enable 17" ] # [ inline ( always ) ] pub fn tie17 ( & self ) -> TIE17_R { TIE17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Transmission Interrupt Enable 18" ] # [ inline ( always ) ] pub fn tie18 ( & self ) -> TIE18_R { TIE18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Transmission Interrupt Enable 19" ] # [ inline ( always ) ] pub fn tie19 ( & self ) -> TIE19_R { TIE19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Transmission Interrupt Enable 20" ] # [ inline ( always ) ] pub fn tie20 ( & self ) -> TIE20_R { TIE20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Transmission Interrupt Enable 21" ] # [ inline ( always ) ] pub fn tie21 ( & self ) -> TIE21_R { TIE21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Transmission Interrupt Enable 22" ] # [ inline ( always ) ] pub fn tie22 ( & self ) -> TIE22_R { TIE22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Transmission Interrupt Enable 23" ] # [ inline ( always ) ] pub fn tie23 ( & self ) -> TIE23_R { TIE23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Transmission Interrupt Enable 24" ] # [ inline ( always ) ] pub fn tie24 ( & self ) -> TIE24_R { TIE24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Transmission Interrupt Enable 25" ] # [ inline ( always ) ] pub fn tie25 ( & self ) -> TIE25_R { TIE25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Transmission Interrupt Enable 26" ] # [ inline ( always ) ] pub fn tie26 ( & self ) -> TIE26_R { TIE26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Transmission Interrupt Enable 27" ] # [ inline ( always ) ] pub fn tie27 ( & self ) -> TIE27_R { TIE27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Transmission Interrupt Enable 28" ] # [ inline ( always ) ] pub fn tie28 ( & self ) -> TIE28_R { TIE28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Transmission Interrupt Enable 29" ] # [ inline ( always ) ] pub fn tie29 ( & self ) -> TIE29_R { TIE29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 30 - Transmission Interrupt Enable 30" ] # [ inline ( always ) ] pub fn tie30 ( & self ) -> TIE30_R { TIE30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - Transmission Interrupt Enable 31" ] # [ inline ( always ) ] pub fn tie31 ( & self ) -> TIE31_R { TIE31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Transmission Interrupt Enable 0" ] # [ inline ( always ) ] pub fn tie0 ( & mut self ) -> TIE0_W { TIE0_W { w : self } }
# [ doc = "Bit 1 - Transmission Interrupt Enable 1" ] # [ inline ( always ) ] pub fn tie1 ( & mut self ) -> TIE1_W { TIE1_W { w : self } }
# [ doc = "Bit 2 - Transmission Interrupt Enable 2" ] # [ inline ( always ) ] pub fn tie2 ( & mut self ) -> TIE2_W { TIE2_W { w : self } }
# [ doc = "Bit 3 - Transmission Interrupt Enable 3" ] # [ inline ( always ) ] pub fn tie3 ( & mut self ) -> TIE3_W { TIE3_W { w : self } }
# [ doc = "Bit 4 - Transmission Interrupt Enable 4" ] # [ inline ( always ) ] pub fn tie4 ( & mut self ) -> TIE4_W { TIE4_W { w : self } }
# [ doc = "Bit 5 - Transmission Interrupt Enable 5" ] # [ inline ( always ) ] pub fn tie5 ( & mut self ) -> TIE5_W { TIE5_W { w : self } }
# [ doc = "Bit 6 - Transmission Interrupt Enable 6" ] # [ inline ( always ) ] pub fn tie6 ( & mut self ) -> TIE6_W { TIE6_W { w : self } }
# [ doc = "Bit 7 - Transmission Interrupt Enable 7" ] # [ inline ( always ) ] pub fn tie7 ( & mut self ) -> TIE7_W { TIE7_W { w : self } }
# [ doc = "Bit 8 - Transmission Interrupt Enable 8" ] # [ inline ( always ) ] pub fn tie8 ( & mut self ) -> TIE8_W { TIE8_W { w : self } }
# [ doc = "Bit 9 - Transmission Interrupt Enable 9" ] # [ inline ( always ) ] pub fn tie9 ( & mut self ) -> TIE9_W { TIE9_W { w : self } }
# [ doc = "Bit 10 - Transmission Interrupt Enable 10" ] # [ inline ( always ) ] pub fn tie10 ( & mut self ) -> TIE10_W { TIE10_W { w : self } }
# [ doc = "Bit 11 - Transmission Interrupt Enable 11" ] # [ inline ( always ) ] pub fn tie11 ( & mut self ) -> TIE11_W { TIE11_W { w : self } }
# [ doc = "Bit 12 - Transmission Interrupt Enable 12" ] # [ inline ( always ) ] pub fn tie12 ( & mut self ) -> TIE12_W { TIE12_W { w : self } }
# [ doc = "Bit 13 - Transmission Interrupt Enable 13" ] # [ inline ( always ) ] pub fn tie13 ( & mut self ) -> TIE13_W { TIE13_W { w : self } }
# [ doc = "Bit 14 - Transmission Interrupt Enable 14" ] # [ inline ( always ) ] pub fn tie14 ( & mut self ) -> TIE14_W { TIE14_W { w : self } }
# [ doc = "Bit 15 - Transmission Interrupt Enable 15" ] # [ inline ( always ) ] pub fn tie15 ( & mut self ) -> TIE15_W { TIE15_W { w : self } }
# [ doc = "Bit 16 - Transmission Interrupt Enable 16" ] # [ inline ( always ) ] pub fn tie16 ( & mut self ) -> TIE16_W { TIE16_W { w : self } }
# [ doc = "Bit 17 - Transmission Interrupt Enable 17" ] # [ inline ( always ) ] pub fn tie17 ( & mut self ) -> TIE17_W { TIE17_W { w : self } }
# [ doc = "Bit 18 - Transmission Interrupt Enable 18" ] # [ inline ( always ) ] pub fn tie18 ( & mut self ) -> TIE18_W { TIE18_W { w : self } }
# [ doc = "Bit 19 - Transmission Interrupt Enable 19" ] # [ inline ( always ) ] pub fn tie19 ( & mut self ) -> TIE19_W { TIE19_W { w : self } }
# [ doc = "Bit 20 - Transmission Interrupt Enable 20" ] # [ inline ( always ) ] pub fn tie20 ( & mut self ) -> TIE20_W { TIE20_W { w : self } }
# [ doc = "Bit 21 - Transmission Interrupt Enable 21" ] # [ inline ( always ) ] pub fn tie21 ( & mut self ) -> TIE21_W { TIE21_W { w : self } }
# [ doc = "Bit 22 - Transmission Interrupt Enable 22" ] # [ inline ( always ) ] pub fn tie22 ( & mut self ) -> TIE22_W { TIE22_W { w : self } }
# [ doc = "Bit 23 - Transmission Interrupt Enable 23" ] # [ inline ( always ) ] pub fn tie23 ( & mut self ) -> TIE23_W { TIE23_W { w : self } }
# [ doc = "Bit 24 - Transmission Interrupt Enable 24" ] # [ inline ( always ) ] pub fn tie24 ( & mut self ) -> TIE24_W { TIE24_W { w : self } }
# [ doc = "Bit 25 - Transmission Interrupt Enable 25" ] # [ inline ( always ) ] pub fn tie25 ( & mut self ) -> TIE25_W { TIE25_W { w : self } }
# [ doc = "Bit 26 - Transmission Interrupt Enable 26" ] # [ inline ( always ) ] pub fn tie26 ( & mut self ) -> TIE26_W { TIE26_W { w : self } }
# [ doc = "Bit 27 - Transmission Interrupt Enable 27" ] # [ inline ( always ) ] pub fn tie27 ( & mut self ) -> TIE27_W { TIE27_W { w : self } }
# [ doc = "Bit 28 - Transmission Interrupt Enable 28" ] # [ inline ( always ) ] pub fn tie28 ( & mut self ) -> TIE28_W { TIE28_W { w : self } }
# [ doc = "Bit 29 - Transmission Interrupt Enable 29" ] # [ inline ( always ) ] pub fn tie29 ( & mut self ) -> TIE29_W { TIE29_W { w : self } }
# [ doc = "Bit 30 - Transmission Interrupt Enable 30" ] # [ inline ( always ) ] pub fn tie30 ( & mut self ) -> TIE30_W { TIE30_W { w : self } }
# [ doc = "Bit 31 - Transmission Interrupt Enable 31" ] # [ inline ( always ) ] pub fn tie31 ( & mut self ) -> TIE31_W { TIE31_W { w : self } }
}
}
# [ doc = "Tx Buffer Cancellation Finished Interrupt Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txbcie](txbcie) module" ] pub type TXBCIE = crate :: Reg < u32 , _TXBCIE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXBCIE ;
# [ doc = "`read()` method returns [txbcie::R](txbcie::R) reader structure" ] impl crate :: Readable for TXBCIE { }
# [ doc = "`write(|w| ..)` method takes [txbcie::W](txbcie::W) writer structure" ] impl crate :: Writable for TXBCIE { }
# [ doc = "Tx Buffer Cancellation Finished Interrupt Enable" ] pub mod txbcie {
# [ doc = "Reader of register TXBCIE" ] pub type R = crate :: R < u32 , super :: TXBCIE > ;
# [ doc = "Writer for register TXBCIE" ] pub type W = crate :: W < u32 , super :: TXBCIE > ;
# [ doc = "Register TXBCIE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TXBCIE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CFIE0`" ] pub type CFIE0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE0`" ] pub struct CFIE0_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `CFIE1`" ] pub type CFIE1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE1`" ] pub struct CFIE1_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CFIE2`" ] pub type CFIE2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE2`" ] pub struct CFIE2_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CFIE3`" ] pub type CFIE3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE3`" ] pub struct CFIE3_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `CFIE4`" ] pub type CFIE4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE4`" ] pub struct CFIE4_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `CFIE5`" ] pub type CFIE5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE5`" ] pub struct CFIE5_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `CFIE6`" ] pub type CFIE6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE6`" ] pub struct CFIE6_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `CFIE7`" ] pub type CFIE7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE7`" ] pub struct CFIE7_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `CFIE8`" ] pub type CFIE8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE8`" ] pub struct CFIE8_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `CFIE9`" ] pub type CFIE9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE9`" ] pub struct CFIE9_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `CFIE10`" ] pub type CFIE10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE10`" ] pub struct CFIE10_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `CFIE11`" ] pub type CFIE11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE11`" ] pub struct CFIE11_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `CFIE12`" ] pub type CFIE12_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE12`" ] pub struct CFIE12_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE12_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `CFIE13`" ] pub type CFIE13_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE13`" ] pub struct CFIE13_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE13_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `CFIE14`" ] pub type CFIE14_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE14`" ] pub struct CFIE14_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE14_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `CFIE15`" ] pub type CFIE15_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE15`" ] pub struct CFIE15_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE15_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `CFIE16`" ] pub type CFIE16_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE16`" ] pub struct CFIE16_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE16_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `CFIE17`" ] pub type CFIE17_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE17`" ] pub struct CFIE17_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE17_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `CFIE18`" ] pub type CFIE18_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE18`" ] pub struct CFIE18_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE18_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `CFIE19`" ] pub type CFIE19_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE19`" ] pub struct CFIE19_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE19_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `CFIE20`" ] pub type CFIE20_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE20`" ] pub struct CFIE20_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE20_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `CFIE21`" ] pub type CFIE21_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE21`" ] pub struct CFIE21_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE21_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `CFIE22`" ] pub type CFIE22_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE22`" ] pub struct CFIE22_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE22_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `CFIE23`" ] pub type CFIE23_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE23`" ] pub struct CFIE23_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE23_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `CFIE24`" ] pub type CFIE24_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE24`" ] pub struct CFIE24_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE24_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `CFIE25`" ] pub type CFIE25_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE25`" ] pub struct CFIE25_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE25_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `CFIE26`" ] pub type CFIE26_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE26`" ] pub struct CFIE26_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE26_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `CFIE27`" ] pub type CFIE27_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE27`" ] pub struct CFIE27_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE27_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Reader of field `CFIE28`" ] pub type CFIE28_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE28`" ] pub struct CFIE28_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE28_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `CFIE29`" ] pub type CFIE29_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE29`" ] pub struct CFIE29_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE29_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } }
# [ doc = "Reader of field `CFIE30`" ] pub type CFIE30_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE30`" ] pub struct CFIE30_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE30_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } }
# [ doc = "Reader of field `CFIE31`" ] pub type CFIE31_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFIE31`" ] pub struct CFIE31_W < 'a > { w : & 'a mut W , } impl < 'a > CFIE31_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Cancellation Finished Interrupt Enable 0" ] # [ inline ( always ) ] pub fn cfie0 ( & self ) -> CFIE0_R { CFIE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Cancellation Finished Interrupt Enable 1" ] # [ inline ( always ) ] pub fn cfie1 ( & self ) -> CFIE1_R { CFIE1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Cancellation Finished Interrupt Enable 2" ] # [ inline ( always ) ] pub fn cfie2 ( & self ) -> CFIE2_R { CFIE2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Cancellation Finished Interrupt Enable 3" ] # [ inline ( always ) ] pub fn cfie3 ( & self ) -> CFIE3_R { CFIE3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Cancellation Finished Interrupt Enable 4" ] # [ inline ( always ) ] pub fn cfie4 ( & self ) -> CFIE4_R { CFIE4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Cancellation Finished Interrupt Enable 5" ] # [ inline ( always ) ] pub fn cfie5 ( & self ) -> CFIE5_R { CFIE5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Cancellation Finished Interrupt Enable 6" ] # [ inline ( always ) ] pub fn cfie6 ( & self ) -> CFIE6_R { CFIE6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Cancellation Finished Interrupt Enable 7" ] # [ inline ( always ) ] pub fn cfie7 ( & self ) -> CFIE7_R { CFIE7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Cancellation Finished Interrupt Enable 8" ] # [ inline ( always ) ] pub fn cfie8 ( & self ) -> CFIE8_R { CFIE8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Cancellation Finished Interrupt Enable 9" ] # [ inline ( always ) ] pub fn cfie9 ( & self ) -> CFIE9_R { CFIE9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Cancellation Finished Interrupt Enable 10" ] # [ inline ( always ) ] pub fn cfie10 ( & self ) -> CFIE10_R { CFIE10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Cancellation Finished Interrupt Enable 11" ] # [ inline ( always ) ] pub fn cfie11 ( & self ) -> CFIE11_R { CFIE11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Cancellation Finished Interrupt Enable 12" ] # [ inline ( always ) ] pub fn cfie12 ( & self ) -> CFIE12_R { CFIE12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Cancellation Finished Interrupt Enable 13" ] # [ inline ( always ) ] pub fn cfie13 ( & self ) -> CFIE13_R { CFIE13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Cancellation Finished Interrupt Enable 14" ] # [ inline ( always ) ] pub fn cfie14 ( & self ) -> CFIE14_R { CFIE14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Cancellation Finished Interrupt Enable 15" ] # [ inline ( always ) ] pub fn cfie15 ( & self ) -> CFIE15_R { CFIE15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Cancellation Finished Interrupt Enable 16" ] # [ inline ( always ) ] pub fn cfie16 ( & self ) -> CFIE16_R { CFIE16_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Cancellation Finished Interrupt Enable 17" ] # [ inline ( always ) ] pub fn cfie17 ( & self ) -> CFIE17_R { CFIE17_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Cancellation Finished Interrupt Enable 18" ] # [ inline ( always ) ] pub fn cfie18 ( & self ) -> CFIE18_R { CFIE18_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Cancellation Finished Interrupt Enable 19" ] # [ inline ( always ) ] pub fn cfie19 ( & self ) -> CFIE19_R { CFIE19_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Cancellation Finished Interrupt Enable 20" ] # [ inline ( always ) ] pub fn cfie20 ( & self ) -> CFIE20_R { CFIE20_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Cancellation Finished Interrupt Enable 21" ] # [ inline ( always ) ] pub fn cfie21 ( & self ) -> CFIE21_R { CFIE21_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Cancellation Finished Interrupt Enable 22" ] # [ inline ( always ) ] pub fn cfie22 ( & self ) -> CFIE22_R { CFIE22_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Cancellation Finished Interrupt Enable 23" ] # [ inline ( always ) ] pub fn cfie23 ( & self ) -> CFIE23_R { CFIE23_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Cancellation Finished Interrupt Enable 24" ] # [ inline ( always ) ] pub fn cfie24 ( & self ) -> CFIE24_R { CFIE24_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Cancellation Finished Interrupt Enable 25" ] # [ inline ( always ) ] pub fn cfie25 ( & self ) -> CFIE25_R { CFIE25_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Cancellation Finished Interrupt Enable 26" ] # [ inline ( always ) ] pub fn cfie26 ( & self ) -> CFIE26_R { CFIE26_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Cancellation Finished Interrupt Enable 27" ] # [ inline ( always ) ] pub fn cfie27 ( & self ) -> CFIE27_R { CFIE27_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - Cancellation Finished Interrupt Enable 28" ] # [ inline ( always ) ] pub fn cfie28 ( & self ) -> CFIE28_R { CFIE28_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 29 - Cancellation Finished Interrupt Enable 29" ] # [ inline ( always ) ] pub fn cfie29 ( & self ) -> CFIE29_R { CFIE29_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 30 - Cancellation Finished Interrupt Enable 30" ] # [ inline ( always ) ] pub fn cfie30 ( & self ) -> CFIE30_R { CFIE30_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - Cancellation Finished Interrupt Enable 31" ] # [ inline ( always ) ] pub fn cfie31 ( & self ) -> CFIE31_R { CFIE31_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Cancellation Finished Interrupt Enable 0" ] # [ inline ( always ) ] pub fn cfie0 ( & mut self ) -> CFIE0_W { CFIE0_W { w : self } }
# [ doc = "Bit 1 - Cancellation Finished Interrupt Enable 1" ] # [ inline ( always ) ] pub fn cfie1 ( & mut self ) -> CFIE1_W { CFIE1_W { w : self } }
# [ doc = "Bit 2 - Cancellation Finished Interrupt Enable 2" ] # [ inline ( always ) ] pub fn cfie2 ( & mut self ) -> CFIE2_W { CFIE2_W { w : self } }
# [ doc = "Bit 3 - Cancellation Finished Interrupt Enable 3" ] # [ inline ( always ) ] pub fn cfie3 ( & mut self ) -> CFIE3_W { CFIE3_W { w : self } }
# [ doc = "Bit 4 - Cancellation Finished Interrupt Enable 4" ] # [ inline ( always ) ] pub fn cfie4 ( & mut self ) -> CFIE4_W { CFIE4_W { w : self } }
# [ doc = "Bit 5 - Cancellation Finished Interrupt Enable 5" ] # [ inline ( always ) ] pub fn cfie5 ( & mut self ) -> CFIE5_W { CFIE5_W { w : self } }
# [ doc = "Bit 6 - Cancellation Finished Interrupt Enable 6" ] # [ inline ( always ) ] pub fn cfie6 ( & mut self ) -> CFIE6_W { CFIE6_W { w : self } }
# [ doc = "Bit 7 - Cancellation Finished Interrupt Enable 7" ] # [ inline ( always ) ] pub fn cfie7 ( & mut self ) -> CFIE7_W { CFIE7_W { w : self } }
# [ doc = "Bit 8 - Cancellation Finished Interrupt Enable 8" ] # [ inline ( always ) ] pub fn cfie8 ( & mut self ) -> CFIE8_W { CFIE8_W { w : self } }
# [ doc = "Bit 9 - Cancellation Finished Interrupt Enable 9" ] # [ inline ( always ) ] pub fn cfie9 ( & mut self ) -> CFIE9_W { CFIE9_W { w : self } }
# [ doc = "Bit 10 - Cancellation Finished Interrupt Enable 10" ] # [ inline ( always ) ] pub fn cfie10 ( & mut self ) -> CFIE10_W { CFIE10_W { w : self } }
# [ doc = "Bit 11 - Cancellation Finished Interrupt Enable 11" ] # [ inline ( always ) ] pub fn cfie11 ( & mut self ) -> CFIE11_W { CFIE11_W { w : self } }
# [ doc = "Bit 12 - Cancellation Finished Interrupt Enable 12" ] # [ inline ( always ) ] pub fn cfie12 ( & mut self ) -> CFIE12_W { CFIE12_W { w : self } }
# [ doc = "Bit 13 - Cancellation Finished Interrupt Enable 13" ] # [ inline ( always ) ] pub fn cfie13 ( & mut self ) -> CFIE13_W { CFIE13_W { w : self } }
# [ doc = "Bit 14 - Cancellation Finished Interrupt Enable 14" ] # [ inline ( always ) ] pub fn cfie14 ( & mut self ) -> CFIE14_W { CFIE14_W { w : self } }
# [ doc = "Bit 15 - Cancellation Finished Interrupt Enable 15" ] # [ inline ( always ) ] pub fn cfie15 ( & mut self ) -> CFIE15_W { CFIE15_W { w : self } }
# [ doc = "Bit 16 - Cancellation Finished Interrupt Enable 16" ] # [ inline ( always ) ] pub fn cfie16 ( & mut self ) -> CFIE16_W { CFIE16_W { w : self } }
# [ doc = "Bit 17 - Cancellation Finished Interrupt Enable 17" ] # [ inline ( always ) ] pub fn cfie17 ( & mut self ) -> CFIE17_W { CFIE17_W { w : self } }
# [ doc = "Bit 18 - Cancellation Finished Interrupt Enable 18" ] # [ inline ( always ) ] pub fn cfie18 ( & mut self ) -> CFIE18_W { CFIE18_W { w : self } }
# [ doc = "Bit 19 - Cancellation Finished Interrupt Enable 19" ] # [ inline ( always ) ] pub fn cfie19 ( & mut self ) -> CFIE19_W { CFIE19_W { w : self } }
# [ doc = "Bit 20 - Cancellation Finished Interrupt Enable 20" ] # [ inline ( always ) ] pub fn cfie20 ( & mut self ) -> CFIE20_W { CFIE20_W { w : self } }
# [ doc = "Bit 21 - Cancellation Finished Interrupt Enable 21" ] # [ inline ( always ) ] pub fn cfie21 ( & mut self ) -> CFIE21_W { CFIE21_W { w : self } }
# [ doc = "Bit 22 - Cancellation Finished Interrupt Enable 22" ] # [ inline ( always ) ] pub fn cfie22 ( & mut self ) -> CFIE22_W { CFIE22_W { w : self } }
# [ doc = "Bit 23 - Cancellation Finished Interrupt Enable 23" ] # [ inline ( always ) ] pub fn cfie23 ( & mut self ) -> CFIE23_W { CFIE23_W { w : self } }
# [ doc = "Bit 24 - Cancellation Finished Interrupt Enable 24" ] # [ inline ( always ) ] pub fn cfie24 ( & mut self ) -> CFIE24_W { CFIE24_W { w : self } }
# [ doc = "Bit 25 - Cancellation Finished Interrupt Enable 25" ] # [ inline ( always ) ] pub fn cfie25 ( & mut self ) -> CFIE25_W { CFIE25_W { w : self } }
# [ doc = "Bit 26 - Cancellation Finished Interrupt Enable 26" ] # [ inline ( always ) ] pub fn cfie26 ( & mut self ) -> CFIE26_W { CFIE26_W { w : self } }
# [ doc = "Bit 27 - Cancellation Finished Interrupt Enable 27" ] # [ inline ( always ) ] pub fn cfie27 ( & mut self ) -> CFIE27_W { CFIE27_W { w : self } }
# [ doc = "Bit 28 - Cancellation Finished Interrupt Enable 28" ] # [ inline ( always ) ] pub fn cfie28 ( & mut self ) -> CFIE28_W { CFIE28_W { w : self } }
# [ doc = "Bit 29 - Cancellation Finished Interrupt Enable 29" ] # [ inline ( always ) ] pub fn cfie29 ( & mut self ) -> CFIE29_W { CFIE29_W { w : self } }
# [ doc = "Bit 30 - Cancellation Finished Interrupt Enable 30" ] # [ inline ( always ) ] pub fn cfie30 ( & mut self ) -> CFIE30_W { CFIE30_W { w : self } }
# [ doc = "Bit 31 - Cancellation Finished Interrupt Enable 31" ] # [ inline ( always ) ] pub fn cfie31 ( & mut self ) -> CFIE31_W { CFIE31_W { w : self } }
}
}
# [ doc = "Tx Event FIFO Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txefc](txefc) module" ] pub type TXEFC = crate :: Reg < u32 , _TXEFC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXEFC ;
# [ doc = "`read()` method returns [txefc::R](txefc::R) reader structure" ] impl crate :: Readable for TXEFC { }
# [ doc = "`write(|w| ..)` method takes [txefc::W](txefc::W) writer structure" ] impl crate :: Writable for TXEFC { }
# [ doc = "Tx Event FIFO Configuration" ] pub mod txefc {
# [ doc = "Reader of register TXEFC" ] pub type R = crate :: R < u32 , super :: TXEFC > ;
# [ doc = "Writer for register TXEFC" ] pub type W = crate :: W < u32 , super :: TXEFC > ;
# [ doc = "Register TXEFC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TXEFC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EFSA`" ] pub type EFSA_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `EFSA`" ] pub struct EFSA_W < 'a > { w : & 'a mut W , } impl < 'a > EFSA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
# [ doc = "Reader of field `EFS`" ] pub type EFS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `EFS`" ] pub struct EFS_W < 'a > { w : & 'a mut W , } impl < 'a > EFS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 16 ) ) | ( ( ( value as u32 ) & 0x3f ) << 16 ) ; self . w } }
# [ doc = "Reader of field `EFWM`" ] pub type EFWM_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `EFWM`" ] pub struct EFWM_W < 'a > { w : & 'a mut W , } impl < 'a > EFWM_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 24 ) ) | ( ( ( value as u32 ) & 0x3f ) << 24 ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Event FIFO Start Address" ] # [ inline ( always ) ] pub fn efsa ( & self ) -> EFSA_R { EFSA_R :: new ( ( self . bits & 0xffff ) as u16 ) }
# [ doc = "Bits 16:21 - Event FIFO Size" ] # [ inline ( always ) ] pub fn efs ( & self ) -> EFS_R { EFS_R :: new ( ( ( self . bits >> 16 ) & 0x3f ) as u8 ) }
# [ doc = "Bits 24:29 - Event FIFO Watermark" ] # [ inline ( always ) ] pub fn efwm ( & self ) -> EFWM_R { EFWM_R :: new ( ( ( self . bits >> 24 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:15 - Event FIFO Start Address" ] # [ inline ( always ) ] pub fn efsa ( & mut self ) -> EFSA_W { EFSA_W { w : self } }
# [ doc = "Bits 16:21 - Event FIFO Size" ] # [ inline ( always ) ] pub fn efs ( & mut self ) -> EFS_W { EFS_W { w : self } }
# [ doc = "Bits 24:29 - Event FIFO Watermark" ] # [ inline ( always ) ] pub fn efwm ( & mut self ) -> EFWM_W { EFWM_W { w : self } }
}
}
# [ doc = "Tx Event FIFO Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txefs](txefs) module" ] pub type TXEFS = crate :: Reg < u32 , _TXEFS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXEFS ;
# [ doc = "`read()` method returns [txefs::R](txefs::R) reader structure" ] impl crate :: Readable for TXEFS { }
# [ doc = "Tx Event FIFO Status" ] pub mod txefs {
# [ doc = "Reader of register TXEFS" ] pub type R = crate :: R < u32 , super :: TXEFS > ;
# [ doc = "Reader of field `EFFL`" ] pub type EFFL_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `EFGI`" ] pub type EFGI_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `EFPI`" ] pub type EFPI_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `EFF`" ] pub type EFF_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TEFL`" ] pub type TEFL_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bits 0:5 - Event FIFO Fill Level" ] # [ inline ( always ) ] pub fn effl ( & self ) -> EFFL_R { EFFL_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 8:12 - Event FIFO Get Index" ] # [ inline ( always ) ] pub fn efgi ( & self ) -> EFGI_R { EFGI_R :: new ( ( ( self . bits >> 8 ) & 0x1f ) as u8 ) }
# [ doc = "Bits 16:20 - Event FIFO Put Index" ] # [ inline ( always ) ] pub fn efpi ( & self ) -> EFPI_R { EFPI_R :: new ( ( ( self . bits >> 16 ) & 0x1f ) as u8 ) }
# [ doc = "Bit 24 - Event FIFO Full" ] # [ inline ( always ) ] pub fn eff ( & self ) -> EFF_R { EFF_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Tx Event FIFO Element Lost" ] # [ inline ( always ) ] pub fn tefl ( & self ) -> TEFL_R { TEFL_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Tx Event FIFO Acknowledge\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [txefa](txefa) module" ] pub type TXEFA = crate :: Reg < u32 , _TXEFA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _TXEFA ;
# [ doc = "`read()` method returns [txefa::R](txefa::R) reader structure" ] impl crate :: Readable for TXEFA { }
# [ doc = "`write(|w| ..)` method takes [txefa::W](txefa::W) writer structure" ] impl crate :: Writable for TXEFA { }
# [ doc = "Tx Event FIFO Acknowledge" ] pub mod txefa {
# [ doc = "Reader of register TXEFA" ] pub type R = crate :: R < u32 , super :: TXEFA > ;
# [ doc = "Writer for register TXEFA" ] pub type W = crate :: W < u32 , super :: TXEFA > ;
# [ doc = "Register TXEFA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: TXEFA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EFAI`" ] pub type EFAI_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `EFAI`" ] pub struct EFAI_W < 'a > { w : & 'a mut W , } impl < 'a > EFAI_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u32 ) & 0x1f ) ; self . w } }
impl R {
# [ doc = "Bits 0:4 - Event FIFO Acknowledge Index" ] # [ inline ( always ) ] pub fn efai ( & self ) -> EFAI_R { EFAI_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:4 - Event FIFO Acknowledge Index" ] # [ inline ( always ) ] pub fn efai ( & mut self ) -> EFAI_W { EFAI_W { w : self } }
}
}
}
# [ doc = "Control Area Network" ] pub struct CAN1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for CAN1 { } impl CAN1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const can0 :: RegisterBlock { 0x4200_2000 as * const _ } } impl Deref for CAN1 { type Target = can0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * CAN1 :: ptr ( ) } } }
# [ doc = "Configurable Custom Logic" ] pub struct CCL { _marker : PhantomData < * const ( ) > } unsafe impl Send for CCL { } impl CCL { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const ccl :: RegisterBlock { 0x4200_5c00 as * const _ } } impl Deref for CCL { type Target = ccl :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * CCL :: ptr ( ) } } }
# [ doc = "Configurable Custom Logic" ] pub mod ccl {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control" ] pub ctrl : CTRL , _reserved1 : [ u8 ; 3usize ] , # [ doc = "0x04 - SEQ Control x" ] pub seqctrl : [ SEQCTRL ; 2 ] , _reserved2 : [ u8 ; 2usize ] , # [ doc = "0x08 - LUT Control x" ] pub lutctrl : [ LUTCTRL ; 4 ] , }
# [ doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrl](ctrl) module" ] pub type CTRL = crate :: Reg < u8 , _CTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRL ;
# [ doc = "`read()` method returns [ctrl::R](ctrl::R) reader structure" ] impl crate :: Readable for CTRL { }
# [ doc = "`write(|w| ..)` method takes [ctrl::W](ctrl::W) writer structure" ] impl crate :: Writable for CTRL { }
# [ doc = "Control" ] pub mod ctrl {
# [ doc = "Reader of register CTRL" ] pub type R = crate :: R < u8 , super :: CTRL > ;
# [ doc = "Writer for register CTRL" ] pub type W = crate :: W < u8 , super :: CTRL > ;
# [ doc = "Register CTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
}
}
# [ doc = "SEQ Control x\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [seqctrl](seqctrl) module" ] pub type SEQCTRL = crate :: Reg < u8 , _SEQCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SEQCTRL ;
# [ doc = "`read()` method returns [seqctrl::R](seqctrl::R) reader structure" ] impl crate :: Readable for SEQCTRL { }
# [ doc = "`write(|w| ..)` method takes [seqctrl::W](seqctrl::W) writer structure" ] impl crate :: Writable for SEQCTRL { }
# [ doc = "SEQ Control x" ] pub mod seqctrl {
# [ doc = "Reader of register SEQCTRL[%s]" ] pub type R = crate :: R < u8 , super :: SEQCTRL > ;
# [ doc = "Writer for register SEQCTRL[%s]" ] pub type W = crate :: W < u8 , super :: SEQCTRL > ;
# [ doc = "Register SEQCTRL[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SEQCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `SEQSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SEQSEL_A { # [ doc = "Sequential logic is disabled" ] DISABLE , # [ doc = "D flip flop" ] DFF , # [ doc = "JK flip flop" ] JK , # [ doc = "D latch" ] LATCH , # [ doc = "RS latch" ] RS }
impl crate :: ToBits < u8 > for SEQSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SEQSEL_A :: DISABLE => 0 , SEQSEL_A :: DFF => 1 , SEQSEL_A :: JK => 2 , SEQSEL_A :: LATCH => 3 , SEQSEL_A :: RS => 4 } } }
# [ doc = "Reader of field `SEQSEL`" ] pub type SEQSEL_R = crate :: R < u8 , SEQSEL_A > ; impl SEQSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SEQSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SEQSEL_A :: DISABLE ) , 1 => Val ( SEQSEL_A :: DFF ) , 2 => Val ( SEQSEL_A :: JK ) , 3 => Val ( SEQSEL_A :: LATCH ) , 4 => Val ( SEQSEL_A :: RS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == SEQSEL_A :: DISABLE } # [ doc = "Checks if the value of the field is `DFF`" ] # [ inline ( always ) ] pub fn is_dff ( & self ) -> bool { * self == SEQSEL_A :: DFF } # [ doc = "Checks if the value of the field is `JK`" ] # [ inline ( always ) ] pub fn is_jk ( & self ) -> bool { * self == SEQSEL_A :: JK } # [ doc = "Checks if the value of the field is `LATCH`" ] # [ inline ( always ) ] pub fn is_latch ( & self ) -> bool { * self == SEQSEL_A :: LATCH } # [ doc = "Checks if the value of the field is `RS`" ] # [ inline ( always ) ] pub fn is_rs ( & self ) -> bool { * self == SEQSEL_A :: RS } }
# [ doc = "Write proxy for field `SEQSEL`" ] pub struct SEQSEL_W < 'a > { w : & 'a mut W , } impl < 'a > SEQSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SEQSEL_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Sequential logic is disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( SEQSEL_A :: DISABLE ) } # [ doc = "D flip flop" ] # [ inline ( always ) ] pub fn dff ( self ) -> & 'a mut W { self . variant ( SEQSEL_A :: DFF ) } # [ doc = "JK flip flop" ] # [ inline ( always ) ] pub fn jk ( self ) -> & 'a mut W { self . variant ( SEQSEL_A :: JK ) } # [ doc = "D latch" ] # [ inline ( always ) ] pub fn latch ( self ) -> & 'a mut W { self . variant ( SEQSEL_A :: LATCH ) } # [ doc = "RS latch" ] # [ inline ( always ) ] pub fn rs ( self ) -> & 'a mut W { self . variant ( SEQSEL_A :: RS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Sequential Selection" ] # [ inline ( always ) ] pub fn seqsel ( & self ) -> SEQSEL_R { SEQSEL_R :: new ( ( self . bits & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:3 - Sequential Selection" ] # [ inline ( always ) ] pub fn seqsel ( & mut self ) -> SEQSEL_W { SEQSEL_W { w : self } }
}
}
# [ doc = "LUT Control x\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [lutctrl](lutctrl) module" ] pub type LUTCTRL = crate :: Reg < u32 , _LUTCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _LUTCTRL ;
# [ doc = "`read()` method returns [lutctrl::R](lutctrl::R) reader structure" ] impl crate :: Readable for LUTCTRL { }
# [ doc = "`write(|w| ..)` method takes [lutctrl::W](lutctrl::W) writer structure" ] impl crate :: Writable for LUTCTRL { }
# [ doc = "LUT Control x" ] pub mod lutctrl {
# [ doc = "Reader of register LUTCTRL[%s]" ] pub type R = crate :: R < u32 , super :: LUTCTRL > ;
# [ doc = "Writer for register LUTCTRL[%s]" ] pub type W = crate :: W < u32 , super :: LUTCTRL > ;
# [ doc = "Register LUTCTRL[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: LUTCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Possible values of the field `FILTSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTSEL_A { # [ doc = "Filter disabled" ] DISABLE , # [ doc = "Synchronizer enabled" ] SYNCH , # [ doc = "Filter enabled" ] FILTER }
impl crate :: ToBits < u8 > for FILTSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { FILTSEL_A :: DISABLE => 0 , FILTSEL_A :: SYNCH => 1 , FILTSEL_A :: FILTER => 2 } } }
# [ doc = "Reader of field `FILTSEL`" ] pub type FILTSEL_R = crate :: R < u8 , FILTSEL_A > ; impl FILTSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , FILTSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( FILTSEL_A :: DISABLE ) , 1 => Val ( FILTSEL_A :: SYNCH ) , 2 => Val ( FILTSEL_A :: FILTER ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == FILTSEL_A :: DISABLE } # [ doc = "Checks if the value of the field is `SYNCH`" ] # [ inline ( always ) ] pub fn is_synch ( & self ) -> bool { * self == FILTSEL_A :: SYNCH } # [ doc = "Checks if the value of the field is `FILTER`" ] # [ inline ( always ) ] pub fn is_filter ( & self ) -> bool { * self == FILTSEL_A :: FILTER } }
# [ doc = "Write proxy for field `FILTSEL`" ] pub struct FILTSEL_W < 'a > { w : & 'a mut W , } impl < 'a > FILTSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FILTSEL_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Filter disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( FILTSEL_A :: DISABLE ) } # [ doc = "Synchronizer enabled" ] # [ inline ( always ) ] pub fn synch ( self ) -> & 'a mut W { self . variant ( FILTSEL_A :: SYNCH ) } # [ doc = "Filter enabled" ] # [ inline ( always ) ] pub fn filter ( self ) -> & 'a mut W { self . variant ( FILTSEL_A :: FILTER ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `EDGESEL`" ] pub type EDGESEL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EDGESEL`" ] pub struct EDGESEL_W < 'a > { w : & 'a mut W , } impl < 'a > EDGESEL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `INSEL0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INSEL0_A { # [ doc = "Masked input" ] MASK , # [ doc = "Feedback input source" ] FEEDBACK , # [ doc = "Linked LUT input source" ] LINK , # [ doc = "Event in put source" ] EVENT , # [ doc = "I/O pin input source" ] IO , # [ doc = "AC input source" ] AC , # [ doc = "TC input source" ] TC , # [ doc = "Alternate TC input source" ] ALTTC , # [ doc = "TCC input source" ] TCC , # [ doc = "SERCOM inout source" ] SERCOM , # [ doc = "Alternate 2 TC input source" ] ALT2TC , # [ doc = "ASYNC EVENT input source. The EVENT input will bypass edge detection logic." ] ASYNCEVENT }
impl crate :: ToBits < u8 > for INSEL0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { INSEL0_A :: MASK => 0 , INSEL0_A :: FEEDBACK => 1 , INSEL0_A :: LINK => 2 , INSEL0_A :: EVENT => 3 , INSEL0_A :: IO => 4 , INSEL0_A :: AC => 5 , INSEL0_A :: TC => 6 , INSEL0_A :: ALTTC => 7 , INSEL0_A :: TCC => 8 , INSEL0_A :: SERCOM => 9 , INSEL0_A :: ALT2TC => 10 , INSEL0_A :: ASYNCEVENT => 11 } } }
# [ doc = "Reader of field `INSEL0`" ] pub type INSEL0_R = crate :: R < u8 , INSEL0_A > ; impl INSEL0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , INSEL0_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( INSEL0_A :: MASK ) , 1 => Val ( INSEL0_A :: FEEDBACK ) , 2 => Val ( INSEL0_A :: LINK ) , 3 => Val ( INSEL0_A :: EVENT ) , 4 => Val ( INSEL0_A :: IO ) , 5 => Val ( INSEL0_A :: AC ) , 6 => Val ( INSEL0_A :: TC ) , 7 => Val ( INSEL0_A :: ALTTC ) , 8 => Val ( INSEL0_A :: TCC ) , 9 => Val ( INSEL0_A :: SERCOM ) , 10 => Val ( INSEL0_A :: ALT2TC ) , 11 => Val ( INSEL0_A :: ASYNCEVENT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `MASK`" ] # [ inline ( always ) ] pub fn is_mask ( & self ) -> bool { * self == INSEL0_A :: MASK } # [ doc = "Checks if the value of the field is `FEEDBACK`" ] # [ inline ( always ) ] pub fn is_feedback ( & self ) -> bool { * self == INSEL0_A :: FEEDBACK } # [ doc = "Checks if the value of the field is `LINK`" ] # [ inline ( always ) ] pub fn is_link ( & self ) -> bool { * self == INSEL0_A :: LINK } # [ doc = "Checks if the value of the field is `EVENT`" ] # [ inline ( always ) ] pub fn is_event ( & self ) -> bool { * self == INSEL0_A :: EVENT } # [ doc = "Checks if the value of the field is `IO`" ] # [ inline ( always ) ] pub fn is_io ( & self ) -> bool { * self == INSEL0_A :: IO } # [ doc = "Checks if the value of the field is `AC`" ] # [ inline ( always ) ] pub fn is_ac ( & self ) -> bool { * self == INSEL0_A :: AC } # [ doc = "Checks if the value of the field is `TC`" ] # [ inline ( always ) ] pub fn is_tc ( & self ) -> bool { * self == INSEL0_A :: TC } # [ doc = "Checks if the value of the field is `ALTTC`" ] # [ inline ( always ) ] pub fn is_alttc ( & self ) -> bool { * self == INSEL0_A :: ALTTC } # [ doc = "Checks if the value of the field is `TCC`" ] # [ inline ( always ) ] pub fn is_tcc ( & self ) -> bool { * self == INSEL0_A :: TCC } # [ doc = "Checks if the value of the field is `SERCOM`" ] # [ inline ( always ) ] pub fn is_sercom ( & self ) -> bool { * self == INSEL0_A :: SERCOM } # [ doc = "Checks if the value of the field is `ALT2TC`" ] # [ inline ( always ) ] pub fn is_alt2tc ( & self ) -> bool { * self == INSEL0_A :: ALT2TC } # [ doc = "Checks if the value of the field is `ASYNCEVENT`" ] # [ inline ( always ) ] pub fn is_asyncevent ( & self ) -> bool { * self == INSEL0_A :: ASYNCEVENT } }
# [ doc = "Write proxy for field `INSEL0`" ] pub struct INSEL0_W < 'a > { w : & 'a mut W , } impl < 'a > INSEL0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : INSEL0_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Masked input" ] # [ inline ( always ) ] pub fn mask ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: MASK ) } # [ doc = "Feedback input source" ] # [ inline ( always ) ] pub fn feedback ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: FEEDBACK ) } # [ doc = "Linked LUT input source" ] # [ inline ( always ) ] pub fn link ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: LINK ) } # [ doc = "Event in put source" ] # [ inline ( always ) ] pub fn event ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: EVENT ) } # [ doc = "I/O pin input source" ] # [ inline ( always ) ] pub fn io ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: IO ) } # [ doc = "AC input source" ] # [ inline ( always ) ] pub fn ac ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: AC ) } # [ doc = "TC input source" ] # [ inline ( always ) ] pub fn tc ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: TC ) } # [ doc = "Alternate TC input source" ] # [ inline ( always ) ] pub fn alttc ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: ALTTC ) } # [ doc = "TCC input source" ] # [ inline ( always ) ] pub fn tcc ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: TCC ) } # [ doc = "SERCOM inout source" ] # [ inline ( always ) ] pub fn sercom ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: SERCOM ) } # [ doc = "Alternate 2 TC input source" ] # [ inline ( always ) ] pub fn alt2tc ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: ALT2TC ) } # [ doc = "ASYNC EVENT input source. The EVENT input will bypass edge detection logic." ] # [ inline ( always ) ] pub fn asyncevent ( self ) -> & 'a mut W { self . variant ( INSEL0_A :: ASYNCEVENT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u32 ) & 0x0f ) << 8 ) ; self . w } }
# [ doc = "Reader of field `INSEL1`" ] pub type INSEL1_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `INSEL1`" ] pub struct INSEL1_W < 'a > { w : & 'a mut W , } impl < 'a > INSEL1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 12 ) ) | ( ( ( value as u32 ) & 0x0f ) << 12 ) ; self . w } }
# [ doc = "Reader of field `INSEL2`" ] pub type INSEL2_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `INSEL2`" ] pub struct INSEL2_W < 'a > { w : & 'a mut W , } impl < 'a > INSEL2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 16 ) ) | ( ( ( value as u32 ) & 0x0f ) << 16 ) ; self . w } }
# [ doc = "Reader of field `INVEI`" ] pub type INVEI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEI`" ] pub struct INVEI_W < 'a > { w : & 'a mut W , } impl < 'a > INVEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `LUTEI`" ] pub type LUTEI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LUTEI`" ] pub struct LUTEI_W < 'a > { w : & 'a mut W , } impl < 'a > LUTEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `LUTEO`" ] pub type LUTEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LUTEO`" ] pub struct LUTEO_W < 'a > { w : & 'a mut W , } impl < 'a > LUTEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `TRUTH`" ] pub type TRUTH_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `TRUTH`" ] pub struct TRUTH_W < 'a > { w : & 'a mut W , } impl < 'a > TRUTH_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 24 ) ) | ( ( ( value as u32 ) & 0xff ) << 24 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - LUT Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Filter Selection" ] # [ inline ( always ) ] pub fn filtsel ( & self ) -> FILTSEL_R { FILTSEL_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - Edge Selection" ] # [ inline ( always ) ] pub fn edgesel ( & self ) -> EDGESEL_R { EDGESEL_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:11 - Input Selection 0" ] # [ inline ( always ) ] pub fn insel0 ( & self ) -> INSEL0_R { INSEL0_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 12:15 - Input Selection 1" ] # [ inline ( always ) ] pub fn insel1 ( & self ) -> INSEL1_R { INSEL1_R :: new ( ( ( self . bits >> 12 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 16:19 - Input Selection 2" ] # [ inline ( always ) ] pub fn insel2 ( & self ) -> INSEL2_R { INSEL2_R :: new ( ( ( self . bits >> 16 ) & 0x0f ) as u8 ) }
# [ doc = "Bit 20 - Input Event Invert" ] # [ inline ( always ) ] pub fn invei ( & self ) -> INVEI_R { INVEI_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Event Input Enable" ] # [ inline ( always ) ] pub fn lutei ( & self ) -> LUTEI_R { LUTEI_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Event Output Enable" ] # [ inline ( always ) ] pub fn luteo ( & self ) -> LUTEO_R { LUTEO_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 24:31 - Truth Value" ] # [ inline ( always ) ] pub fn truth ( & self ) -> TRUTH_R { TRUTH_R :: new ( ( ( self . bits >> 24 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bit 1 - LUT Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bits 4:5 - Filter Selection" ] # [ inline ( always ) ] pub fn filtsel ( & mut self ) -> FILTSEL_W { FILTSEL_W { w : self } }
# [ doc = "Bit 7 - Edge Selection" ] # [ inline ( always ) ] pub fn edgesel ( & mut self ) -> EDGESEL_W { EDGESEL_W { w : self } }
# [ doc = "Bits 8:11 - Input Selection 0" ] # [ inline ( always ) ] pub fn insel0 ( & mut self ) -> INSEL0_W { INSEL0_W { w : self } }
# [ doc = "Bits 12:15 - Input Selection 1" ] # [ inline ( always ) ] pub fn insel1 ( & mut self ) -> INSEL1_W { INSEL1_W { w : self } }
# [ doc = "Bits 16:19 - Input Selection 2" ] # [ inline ( always ) ] pub fn insel2 ( & mut self ) -> INSEL2_W { INSEL2_W { w : self } }
# [ doc = "Bit 20 - Input Event Invert" ] # [ inline ( always ) ] pub fn invei ( & mut self ) -> INVEI_W { INVEI_W { w : self } }
# [ doc = "Bit 21 - Event Input Enable" ] # [ inline ( always ) ] pub fn lutei ( & mut self ) -> LUTEI_W { LUTEI_W { w : self } }
# [ doc = "Bit 22 - Event Output Enable" ] # [ inline ( always ) ] pub fn luteo ( & mut self ) -> LUTEO_W { LUTEO_W { w : self } }
# [ doc = "Bits 24:31 - Truth Value" ] # [ inline ( always ) ] pub fn truth ( & mut self ) -> TRUTH_W { TRUTH_W { w : self } }
}
}
}
# [ doc = "Digital Analog Converter" ] pub struct DAC { _marker : PhantomData < * const ( ) > } unsafe impl Send for DAC { } impl DAC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const dac :: RegisterBlock { 0x4200_5400 as * const _ } } impl Deref for DAC { type Target = dac :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * DAC :: ptr ( ) } } }
# [ doc = "Digital Analog Converter" ] pub mod dac {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control A" ] pub ctrla : CTRLA , # [ doc = "0x01 - Control B" ] pub ctrlb : CTRLB , # [ doc = "0x02 - Event Control" ] pub evctrl : EVCTRL , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x04 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x05 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x06 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x07 - Status" ] pub status : STATUS , # [ doc = "0x08 - Data" ] pub data : DATA , _reserved8 : [ u8 ; 2usize ] , # [ doc = "0x0c - Data Buffer" ] pub databuf : DATABUF , _reserved9 : [ u8 ; 2usize ] , # [ doc = "0x10 - Synchronization Busy" ] pub syncbusy : SYNCBUSY , # [ doc = "0x14 - Debug Control" ] pub dbgctrl : DBGCTRL , }
# [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control A" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
}
}
# [ doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u8 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ;
# [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { }
# [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { }
# [ doc = "Control B" ] pub mod ctrlb {
# [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u8 , super :: CTRLB > ;
# [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u8 , super :: CTRLB > ;
# [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EOEN`" ] pub type EOEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EOEN`" ] pub struct EOEN_W < 'a > { w : & 'a mut W , } impl < 'a > EOEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `IOEN`" ] pub type IOEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `IOEN`" ] pub struct IOEN_W < 'a > { w : & 'a mut W , } impl < 'a > IOEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `LEFTADJ`" ] pub type LEFTADJ_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LEFTADJ`" ] pub struct LEFTADJ_W < 'a > { w : & 'a mut W , } impl < 'a > LEFTADJ_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `VPD`" ] pub type VPD_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `VPD`" ] pub struct VPD_W < 'a > { w : & 'a mut W , } impl < 'a > VPD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `DITHER`" ] pub type DITHER_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DITHER`" ] pub struct DITHER_W < 'a > { w : & 'a mut W , } impl < 'a > DITHER_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Possible values of the field `REFSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFSEL_A { # [ doc = "Internal 1.0V reference" ] INT1V , # [ doc = "AVCC" ] AVCC , # [ doc = "External reference" ] VREFP }
impl crate :: ToBits < u8 > for REFSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { REFSEL_A :: INT1V => 0 , REFSEL_A :: AVCC => 1 , REFSEL_A :: VREFP => 2 } } }
# [ doc = "Reader of field `REFSEL`" ] pub type REFSEL_R = crate :: R < u8 , REFSEL_A > ; impl REFSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , REFSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( REFSEL_A :: INT1V ) , 1 => Val ( REFSEL_A :: AVCC ) , 2 => Val ( REFSEL_A :: VREFP ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `INT1V`" ] # [ inline ( always ) ] pub fn is_int1v ( & self ) -> bool { * self == REFSEL_A :: INT1V } # [ doc = "Checks if the value of the field is `AVCC`" ] # [ inline ( always ) ] pub fn is_avcc ( & self ) -> bool { * self == REFSEL_A :: AVCC } # [ doc = "Checks if the value of the field is `VREFP`" ] # [ inline ( always ) ] pub fn is_vrefp ( & self ) -> bool { * self == REFSEL_A :: VREFP } }
# [ doc = "Write proxy for field `REFSEL`" ] pub struct REFSEL_W < 'a > { w : & 'a mut W , } impl < 'a > REFSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFSEL_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Internal 1.0V reference" ] # [ inline ( always ) ] pub fn int1v ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: INT1V ) } # [ doc = "AVCC" ] # [ inline ( always ) ] pub fn avcc ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: AVCC ) } # [ doc = "External reference" ] # [ inline ( always ) ] pub fn vrefp ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: VREFP ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u8 ) & 0x03 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - External Output Enable" ] # [ inline ( always ) ] pub fn eoen ( & self ) -> EOEN_R { EOEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Internal Output Enable" ] # [ inline ( always ) ] pub fn ioen ( & self ) -> IOEN_R { IOEN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Left Adjusted Data" ] # [ inline ( always ) ] pub fn leftadj ( & self ) -> LEFTADJ_R { LEFTADJ_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Voltage Pump Disable" ] # [ inline ( always ) ] pub fn vpd ( & self ) -> VPD_R { VPD_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Dither Enable" ] # [ inline ( always ) ] pub fn dither ( & self ) -> DITHER_R { DITHER_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 6:7 - Reference Selection" ] # [ inline ( always ) ] pub fn refsel ( & self ) -> REFSEL_R { REFSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - External Output Enable" ] # [ inline ( always ) ] pub fn eoen ( & mut self ) -> EOEN_W { EOEN_W { w : self } }
# [ doc = "Bit 1 - Internal Output Enable" ] # [ inline ( always ) ] pub fn ioen ( & mut self ) -> IOEN_W { IOEN_W { w : self } }
# [ doc = "Bit 2 - Left Adjusted Data" ] # [ inline ( always ) ] pub fn leftadj ( & mut self ) -> LEFTADJ_W { LEFTADJ_W { w : self } }
# [ doc = "Bit 3 - Voltage Pump Disable" ] # [ inline ( always ) ] pub fn vpd ( & mut self ) -> VPD_W { VPD_W { w : self } }
# [ doc = "Bit 5 - Dither Enable" ] # [ inline ( always ) ] pub fn dither ( & mut self ) -> DITHER_W { DITHER_W { w : self } }
# [ doc = "Bits 6:7 - Reference Selection" ] # [ inline ( always ) ] pub fn refsel ( & mut self ) -> REFSEL_W { REFSEL_W { w : self } }
}
}
# [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u8 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event Control" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u8 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u8 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `STARTEI`" ] pub type STARTEI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `STARTEI`" ] pub struct STARTEI_W < 'a > { w : & 'a mut W , } impl < 'a > STARTEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `EMPTYEO`" ] pub type EMPTYEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EMPTYEO`" ] pub struct EMPTYEO_W < 'a > { w : & 'a mut W , } impl < 'a > EMPTYEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `INVEI`" ] pub type INVEI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEI`" ] pub struct INVEI_W < 'a > { w : & 'a mut W , } impl < 'a > INVEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Start Conversion Event Input" ] # [ inline ( always ) ] pub fn startei ( & self ) -> STARTEI_R { STARTEI_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Data Buffer Empty Event Output" ] # [ inline ( always ) ] pub fn emptyeo ( & self ) -> EMPTYEO_R { EMPTYEO_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Invert Event Input" ] # [ inline ( always ) ] pub fn invei ( & self ) -> INVEI_R { INVEI_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Start Conversion Event Input" ] # [ inline ( always ) ] pub fn startei ( & mut self ) -> STARTEI_W { STARTEI_W { w : self } }
# [ doc = "Bit 1 - Data Buffer Empty Event Output" ] # [ inline ( always ) ] pub fn emptyeo ( & mut self ) -> EMPTYEO_W { EMPTYEO_W { w : self } }
# [ doc = "Bit 2 - Invert Event Input" ] # [ inline ( always ) ] pub fn invei ( & mut self ) -> INVEI_W { INVEI_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UNDERRUN`" ] pub type UNDERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `UNDERRUN`" ] pub struct UNDERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > UNDERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `EMPTY`" ] pub type EMPTY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EMPTY`" ] pub struct EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > EMPTY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Underrun Interrupt Enable" ] # [ inline ( always ) ] pub fn underrun ( & self ) -> UNDERRUN_R { UNDERRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Data Buffer Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn empty ( & self ) -> EMPTY_R { EMPTY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Underrun Interrupt Enable" ] # [ inline ( always ) ] pub fn underrun ( & mut self ) -> UNDERRUN_W { UNDERRUN_W { w : self } }
# [ doc = "Bit 1 - Data Buffer Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn empty ( & mut self ) -> EMPTY_W { EMPTY_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UNDERRUN`" ] pub type UNDERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `UNDERRUN`" ] pub struct UNDERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > UNDERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `EMPTY`" ] pub type EMPTY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EMPTY`" ] pub struct EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > EMPTY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Underrun Interrupt Enable" ] # [ inline ( always ) ] pub fn underrun ( & self ) -> UNDERRUN_R { UNDERRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Data Buffer Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn empty ( & self ) -> EMPTY_R { EMPTY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Underrun Interrupt Enable" ] # [ inline ( always ) ] pub fn underrun ( & mut self ) -> UNDERRUN_W { UNDERRUN_W { w : self } }
# [ doc = "Bit 1 - Data Buffer Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn empty ( & mut self ) -> EMPTY_W { EMPTY_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `UNDERRUN`" ] pub type UNDERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `UNDERRUN`" ] pub struct UNDERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > UNDERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `EMPTY`" ] pub type EMPTY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EMPTY`" ] pub struct EMPTY_W < 'a > { w : & 'a mut W , } impl < 'a > EMPTY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Underrun" ] # [ inline ( always ) ] pub fn underrun ( & self ) -> UNDERRUN_R { UNDERRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Data Buffer Empty" ] # [ inline ( always ) ] pub fn empty ( & self ) -> EMPTY_R { EMPTY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Underrun" ] # [ inline ( always ) ] pub fn underrun ( & mut self ) -> UNDERRUN_W { UNDERRUN_W { w : self } }
# [ doc = "Bit 1 - Data Buffer Empty" ] # [ inline ( always ) ] pub fn empty ( & mut self ) -> EMPTY_W { EMPTY_W { w : self } }
}
}
# [ doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u8 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ;
# [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { }
# [ doc = "Status" ] pub mod status {
# [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u8 , super :: STATUS > ;
# [ doc = "Reader of field `READY`" ] pub type READY_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Ready" ] # [ inline ( always ) ] pub fn ready ( & self ) -> READY_R { READY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
}
# [ doc = "Data\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [data](data) module" ] pub type DATA = crate :: Reg < u16 , _DATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DATA ;
# [ doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure" ] impl crate :: Writable for DATA { }
# [ doc = "Data" ] pub mod data {
# [ doc = "Writer for register DATA" ] pub type W = crate :: W < u16 , super :: DATA > ;
# [ doc = "Register DATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DATA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Write proxy for field `DATA`" ] pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } }
impl W {
# [ doc = "Bits 0:15 - Data value to be converted" ] # [ inline ( always ) ] pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } }
}
}
# [ doc = "Data Buffer\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [databuf](databuf) module" ] pub type DATABUF = crate :: Reg < u16 , _DATABUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DATABUF ;
# [ doc = "`write(|w| ..)` method takes [databuf::W](databuf::W) writer structure" ] impl crate :: Writable for DATABUF { }
# [ doc = "Data Buffer" ] pub mod databuf {
# [ doc = "Writer for register DATABUF" ] pub type W = crate :: W < u16 , super :: DATABUF > ;
# [ doc = "Register DATABUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DATABUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Write proxy for field `DATABUF`" ] pub struct DATABUF_W < 'a > { w : & 'a mut W , } impl < 'a > DATABUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } }
impl W {
# [ doc = "Bits 0:15 - Data Buffer" ] # [ inline ( always ) ] pub fn databuf ( & mut self ) -> DATABUF_W { DATABUF_W { w : self } }
}
}
# [ doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DATA`" ] pub type DATA_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DATABUF`" ] pub type DATABUF_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Data" ] # [ inline ( always ) ] pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Data Buffer" ] # [ inline ( always ) ] pub fn databuf ( & self ) -> DATABUF_R { DATABUF_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ;
# [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { }
# [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { }
# [ doc = "Debug Control" ] pub mod dbgctrl {
# [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ;
# [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ;
# [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } }
}
}
}
# [ doc = "Divide and Square Root Accelerator" ] pub struct DIVAS { _marker : PhantomData < * const ( ) > } unsafe impl Send for DIVAS { } impl DIVAS { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const divas :: RegisterBlock { 0x4800_0000 as * const _ } } impl Deref for DIVAS { type Target = divas :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * DIVAS :: ptr ( ) } } }
# [ doc = "Divide and Square Root Accelerator" ] pub mod divas {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control" ] pub ctrla : CTRLA , _reserved1 : [ u8 ; 3usize ] , # [ doc = "0x04 - Status" ] pub status : STATUS , _reserved2 : [ u8 ; 3usize ] , # [ doc = "0x08 - Dividend" ] pub dividend : DIVIDEND , # [ doc = "0x0c - Divisor" ] pub divisor : DIVISOR , # [ doc = "0x10 - Result" ] pub result : RESULT , # [ doc = "0x14 - Remainder" ] pub rem : REM , # [ doc = "0x18 - Square Root Input" ] pub sqrnum : SQRNUM , }
# [ doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SIGNED`" ] pub type SIGNED_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SIGNED`" ] pub struct SIGNED_W < 'a > { w : & 'a mut W , } impl < 'a > SIGNED_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `DLZ`" ] pub type DLZ_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DLZ`" ] pub struct DLZ_W < 'a > { w : & 'a mut W , } impl < 'a > DLZ_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Signed" ] # [ inline ( always ) ] pub fn signed ( & self ) -> SIGNED_R { SIGNED_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Disable Leading Zero Optimization" ] # [ inline ( always ) ] pub fn dlz ( & self ) -> DLZ_R { DLZ_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Signed" ] # [ inline ( always ) ] pub fn signed ( & mut self ) -> SIGNED_W { SIGNED_W { w : self } }
# [ doc = "Bit 1 - Disable Leading Zero Optimization" ] # [ inline ( always ) ] pub fn dlz ( & mut self ) -> DLZ_W { DLZ_W { w : self } }
}
}
# [ doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u8 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ;
# [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { }
# [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { }
# [ doc = "Status" ] pub mod status {
# [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u8 , super :: STATUS > ;
# [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u8 , super :: STATUS > ;
# [ doc = "Register STATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUS { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `BUSY`" ] pub type BUSY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BUSY`" ] pub struct BUSY_W < 'a > { w : & 'a mut W , } impl < 'a > BUSY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `DBZ`" ] pub type DBZ_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DBZ`" ] pub struct DBZ_W < 'a > { w : & 'a mut W , } impl < 'a > DBZ_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - DIVAS Accelerator Busy" ] # [ inline ( always ) ] pub fn busy ( & self ) -> BUSY_R { BUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Writing a one to this bit clears DBZ to zero" ] # [ inline ( always ) ] pub fn dbz ( & self ) -> DBZ_R { DBZ_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - DIVAS Accelerator Busy" ] # [ inline ( always ) ] pub fn busy ( & mut self ) -> BUSY_W { BUSY_W { w : self } }
# [ doc = "Bit 1 - Writing a one to this bit clears DBZ to zero" ] # [ inline ( always ) ] pub fn dbz ( & mut self ) -> DBZ_W { DBZ_W { w : self } }
}
}
# [ doc = "Dividend\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dividend](dividend) module" ] pub type DIVIDEND = crate :: Reg < u32 , _DIVIDEND > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DIVIDEND ;
# [ doc = "`read()` method returns [dividend::R](dividend::R) reader structure" ] impl crate :: Readable for DIVIDEND { }
# [ doc = "`write(|w| ..)` method takes [dividend::W](dividend::W) writer structure" ] impl crate :: Writable for DIVIDEND { }
# [ doc = "Dividend" ] pub mod dividend {
# [ doc = "Reader of register DIVIDEND" ] pub type R = crate :: R < u32 , super :: DIVIDEND > ;
# [ doc = "Writer for register DIVIDEND" ] pub type W = crate :: W < u32 , super :: DIVIDEND > ;
# [ doc = "Register DIVIDEND `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DIVIDEND { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DIVIDEND`" ] pub type DIVIDEND_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `DIVIDEND`" ] pub struct DIVIDEND_W < 'a > { w : & 'a mut W , } impl < 'a > DIVIDEND_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - DIVIDEND" ] # [ inline ( always ) ] pub fn dividend ( & self ) -> DIVIDEND_R { DIVIDEND_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - DIVIDEND" ] # [ inline ( always ) ] pub fn dividend ( & mut self ) -> DIVIDEND_W { DIVIDEND_W { w : self } }
}
}
# [ doc = "Divisor\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [divisor](divisor) module" ] pub type DIVISOR = crate :: Reg < u32 , _DIVISOR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DIVISOR ;
# [ doc = "`read()` method returns [divisor::R](divisor::R) reader structure" ] impl crate :: Readable for DIVISOR { }
# [ doc = "`write(|w| ..)` method takes [divisor::W](divisor::W) writer structure" ] impl crate :: Writable for DIVISOR { }
# [ doc = "Divisor" ] pub mod divisor {
# [ doc = "Reader of register DIVISOR" ] pub type R = crate :: R < u32 , super :: DIVISOR > ;
# [ doc = "Writer for register DIVISOR" ] pub type W = crate :: W < u32 , super :: DIVISOR > ;
# [ doc = "Register DIVISOR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DIVISOR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DIVISOR`" ] pub type DIVISOR_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `DIVISOR`" ] pub struct DIVISOR_W < 'a > { w : & 'a mut W , } impl < 'a > DIVISOR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - DIVISOR" ] # [ inline ( always ) ] pub fn divisor ( & self ) -> DIVISOR_R { DIVISOR_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - DIVISOR" ] # [ inline ( always ) ] pub fn divisor ( & mut self ) -> DIVISOR_W { DIVISOR_W { w : self } }
}
}
# [ doc = "Result\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [result](result) module" ] pub type RESULT = crate :: Reg < u32 , _RESULT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RESULT ;
# [ doc = "`read()` method returns [result::R](result::R) reader structure" ] impl crate :: Readable for RESULT { }
# [ doc = "Result" ] pub mod result {
# [ doc = "Reader of register RESULT" ] pub type R = crate :: R < u32 , super :: RESULT > ;
# [ doc = "Reader of field `RESULT`" ] pub type RESULT_R = crate :: R < u32 , u32 > ;
impl R {
# [ doc = "Bits 0:31 - RESULT" ] # [ inline ( always ) ] pub fn result ( & self ) -> RESULT_R { RESULT_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
}
# [ doc = "Remainder\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rem](rem) module" ] pub type REM = crate :: Reg < u32 , _REM > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _REM ;
# [ doc = "`read()` method returns [rem::R](rem::R) reader structure" ] impl crate :: Readable for REM { }
# [ doc = "Remainder" ] pub mod rem {
# [ doc = "Reader of register REM" ] pub type R = crate :: R < u32 , super :: REM > ;
# [ doc = "Reader of field `REM`" ] pub type REM_R = crate :: R < u32 , u32 > ;
impl R {
# [ doc = "Bits 0:31 - REM" ] # [ inline ( always ) ] pub fn rem ( & self ) -> REM_R { REM_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
}
# [ doc = "Square Root Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [sqrnum](sqrnum) module" ] pub type SQRNUM = crate :: Reg < u32 , _SQRNUM > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SQRNUM ;
# [ doc = "`read()` method returns [sqrnum::R](sqrnum::R) reader structure" ] impl crate :: Readable for SQRNUM { }
# [ doc = "`write(|w| ..)` method takes [sqrnum::W](sqrnum::W) writer structure" ] impl crate :: Writable for SQRNUM { }
# [ doc = "Square Root Input" ] pub mod sqrnum {
# [ doc = "Reader of register SQRNUM" ] pub type R = crate :: R < u32 , super :: SQRNUM > ;
# [ doc = "Writer for register SQRNUM" ] pub type W = crate :: W < u32 , super :: SQRNUM > ;
# [ doc = "Register SQRNUM `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SQRNUM { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SQRNUM`" ] pub type SQRNUM_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `SQRNUM`" ] pub struct SQRNUM_W < 'a > { w : & 'a mut W , } impl < 'a > SQRNUM_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - Square Root Input" ] # [ inline ( always ) ] pub fn sqrnum ( & self ) -> SQRNUM_R { SQRNUM_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - Square Root Input" ] # [ inline ( always ) ] pub fn sqrnum ( & mut self ) -> SQRNUM_W { SQRNUM_W { w : self } }
}
}
}
# [ doc = "Direct Memory Access Controller" ] pub struct DMAC { _marker : PhantomData < * const ( ) > } unsafe impl Send for DMAC { } impl DMAC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const dmac :: RegisterBlock { 0x4100_6000 as * const _ } } impl Deref for DMAC { type Target = dmac :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * DMAC :: ptr ( ) } } }
# [ doc = "Direct Memory Access Controller" ] pub mod dmac {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control" ] pub ctrl : CTRL , # [ doc = "0x02 - CRC Control" ] pub crcctrl : CRCCTRL , # [ doc = "0x04 - CRC Data Input" ] pub crcdatain : CRCDATAIN , # [ doc = "0x08 - CRC Checksum" ] pub crcchksum : CRCCHKSUM , # [ doc = "0x0c - CRC Status" ] pub crcstatus : CRCSTATUS , # [ doc = "0x0d - Debug Control" ] pub dbgctrl : DBGCTRL , # [ doc = "0x0e - QOS Control" ] pub qosctrl : QOSCTRL , _reserved7 : [ u8 ; 1usize ] , # [ doc = "0x10 - Software Trigger Control" ] pub swtrigctrl : SWTRIGCTRL , # [ doc = "0x14 - Priority Control 0" ] pub prictrl0 : PRICTRL0 , _reserved9 : [ u8 ; 8usize ] , # [ doc = "0x20 - Interrupt Pending" ] pub intpend : INTPEND , _reserved10 : [ u8 ; 2usize ] , # [ doc = "0x24 - Interrupt Status" ] pub intstatus : INTSTATUS , # [ doc = "0x28 - Busy Channels" ] pub busych : BUSYCH , # [ doc = "0x2c - Pending Channels" ] pub pendch : PENDCH , # [ doc = "0x30 - Active Channel and Levels" ] pub active : ACTIVE , # [ doc = "0x34 - Descriptor Memory Section Base Address" ] pub baseaddr : BASEADDR , # [ doc = "0x38 - Write-Back Memory Section Base Address" ] pub wrbaddr : WRBADDR , _reserved16 : [ u8 ; 3usize ] , # [ doc = "0x3f - Channel ID" ] pub chid : CHID , # [ doc = "0x40 - Channel Control A" ] pub chctrla : CHCTRLA , _reserved18 : [ u8 ; 3usize ] , # [ doc = "0x44 - Channel Control B" ] pub chctrlb : CHCTRLB , _reserved19 : [ u8 ; 4usize ] , # [ doc = "0x4c - Channel Interrupt Enable Clear" ] pub chintenclr : CHINTENCLR , # [ doc = "0x4d - Channel Interrupt Enable Set" ] pub chintenset : CHINTENSET , # [ doc = "0x4e - Channel Interrupt Flag Status and Clear" ] pub chintflag : CHINTFLAG , # [ doc = "0x4f - Channel Status" ] pub chstatus : CHSTATUS , }
# [ doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrl](ctrl) module" ] pub type CTRL = crate :: Reg < u16 , _CTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRL ;
# [ doc = "`read()` method returns [ctrl::R](ctrl::R) reader structure" ] impl crate :: Readable for CTRL { }
# [ doc = "`write(|w| ..)` method takes [ctrl::W](ctrl::W) writer structure" ] impl crate :: Writable for CTRL { }
# [ doc = "Control" ] pub mod ctrl {
# [ doc = "Reader of register CTRL" ] pub type R = crate :: R < u16 , super :: CTRL > ;
# [ doc = "Writer for register CTRL" ] pub type W = crate :: W < u16 , super :: CTRL > ;
# [ doc = "Register CTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `DMAENABLE`" ] pub type DMAENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DMAENABLE`" ] pub struct DMAENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > DMAENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CRCENABLE`" ] pub type CRCENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CRCENABLE`" ] pub struct CRCENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > CRCENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `LVLEN0`" ] pub type LVLEN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LVLEN0`" ] pub struct LVLEN0_W < 'a > { w : & 'a mut W , } impl < 'a > LVLEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `LVLEN1`" ] pub type LVLEN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LVLEN1`" ] pub struct LVLEN1_W < 'a > { w : & 'a mut W , } impl < 'a > LVLEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `LVLEN2`" ] pub type LVLEN2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LVLEN2`" ] pub struct LVLEN2_W < 'a > { w : & 'a mut W , } impl < 'a > LVLEN2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `LVLEN3`" ] pub type LVLEN3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LVLEN3`" ] pub struct LVLEN3_W < 'a > { w : & 'a mut W , } impl < 'a > LVLEN3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - DMA Enable" ] # [ inline ( always ) ] pub fn dmaenable ( & self ) -> DMAENABLE_R { DMAENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - CRC Enable" ] # [ inline ( always ) ] pub fn crcenable ( & self ) -> CRCENABLE_R { CRCENABLE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Priority Level 0 Enable" ] # [ inline ( always ) ] pub fn lvlen0 ( & self ) -> LVLEN0_R { LVLEN0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Priority Level 1 Enable" ] # [ inline ( always ) ] pub fn lvlen1 ( & self ) -> LVLEN1_R { LVLEN1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Priority Level 2 Enable" ] # [ inline ( always ) ] pub fn lvlen2 ( & self ) -> LVLEN2_R { LVLEN2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Priority Level 3 Enable" ] # [ inline ( always ) ] pub fn lvlen3 ( & self ) -> LVLEN3_R { LVLEN3_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - DMA Enable" ] # [ inline ( always ) ] pub fn dmaenable ( & mut self ) -> DMAENABLE_W { DMAENABLE_W { w : self } }
# [ doc = "Bit 2 - CRC Enable" ] # [ inline ( always ) ] pub fn crcenable ( & mut self ) -> CRCENABLE_W { CRCENABLE_W { w : self } }
# [ doc = "Bit 8 - Priority Level 0 Enable" ] # [ inline ( always ) ] pub fn lvlen0 ( & mut self ) -> LVLEN0_W { LVLEN0_W { w : self } }
# [ doc = "Bit 9 - Priority Level 1 Enable" ] # [ inline ( always ) ] pub fn lvlen1 ( & mut self ) -> LVLEN1_W { LVLEN1_W { w : self } }
# [ doc = "Bit 10 - Priority Level 2 Enable" ] # [ inline ( always ) ] pub fn lvlen2 ( & mut self ) -> LVLEN2_W { LVLEN2_W { w : self } }
# [ doc = "Bit 11 - Priority Level 3 Enable" ] # [ inline ( always ) ] pub fn lvlen3 ( & mut self ) -> LVLEN3_W { LVLEN3_W { w : self } }
}
}
# [ doc = "CRC Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [crcctrl](crcctrl) module" ] pub type CRCCTRL = crate :: Reg < u16 , _CRCCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CRCCTRL ;
# [ doc = "`read()` method returns [crcctrl::R](crcctrl::R) reader structure" ] impl crate :: Readable for CRCCTRL { }
# [ doc = "`write(|w| ..)` method takes [crcctrl::W](crcctrl::W) writer structure" ] impl crate :: Writable for CRCCTRL { }
# [ doc = "CRC Control" ] pub mod crcctrl {
# [ doc = "Reader of register CRCCTRL" ] pub type R = crate :: R < u16 , super :: CRCCTRL > ;
# [ doc = "Writer for register CRCCTRL" ] pub type W = crate :: W < u16 , super :: CRCCTRL > ;
# [ doc = "Register CRCCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CRCCTRL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `CRCBEATSIZE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CRCBEATSIZE_A { # [ doc = "8-bit bus transfer" ] BYTE , # [ doc = "16-bit bus transfer" ] HWORD , # [ doc = "32-bit bus transfer" ] WORD }
impl crate :: ToBits < u8 > for CRCBEATSIZE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CRCBEATSIZE_A :: BYTE => 0 , CRCBEATSIZE_A :: HWORD => 1 , CRCBEATSIZE_A :: WORD => 2 } } }
# [ doc = "Reader of field `CRCBEATSIZE`" ] pub type CRCBEATSIZE_R = crate :: R < u8 , CRCBEATSIZE_A > ; impl CRCBEATSIZE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CRCBEATSIZE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CRCBEATSIZE_A :: BYTE ) , 1 => Val ( CRCBEATSIZE_A :: HWORD ) , 2 => Val ( CRCBEATSIZE_A :: WORD ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `BYTE`" ] # [ inline ( always ) ] pub fn is_byte ( & self ) -> bool { * self == CRCBEATSIZE_A :: BYTE } # [ doc = "Checks if the value of the field is `HWORD`" ] # [ inline ( always ) ] pub fn is_hword ( & self ) -> bool { * self == CRCBEATSIZE_A :: HWORD } # [ doc = "Checks if the value of the field is `WORD`" ] # [ inline ( always ) ] pub fn is_word ( & self ) -> bool { * self == CRCBEATSIZE_A :: WORD } }
# [ doc = "Write proxy for field `CRCBEATSIZE`" ] pub struct CRCBEATSIZE_W < 'a > { w : & 'a mut W , } impl < 'a > CRCBEATSIZE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CRCBEATSIZE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "8-bit bus transfer" ] # [ inline ( always ) ] pub fn byte ( self ) -> & 'a mut W { self . variant ( CRCBEATSIZE_A :: BYTE ) } # [ doc = "16-bit bus transfer" ] # [ inline ( always ) ] pub fn hword ( self ) -> & 'a mut W { self . variant ( CRCBEATSIZE_A :: HWORD ) } # [ doc = "32-bit bus transfer" ] # [ inline ( always ) ] pub fn word ( self ) -> & 'a mut W { self . variant ( CRCBEATSIZE_A :: WORD ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u16 ) & 0x03 ) ; self . w } }
# [ doc = "Possible values of the field `CRCPOLY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CRCPOLY_A { # [ doc = "CRC-16 (CRC-CCITT)" ] CRC16 , # [ doc = "CRC32 (IEEE 802.3)" ] CRC32 }
impl crate :: ToBits < u8 > for CRCPOLY_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CRCPOLY_A :: CRC16 => 0 , CRCPOLY_A :: CRC32 => 1 } } }
# [ doc = "Reader of field `CRCPOLY`" ] pub type CRCPOLY_R = crate :: R < u8 , CRCPOLY_A > ; impl CRCPOLY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CRCPOLY_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CRCPOLY_A :: CRC16 ) , 1 => Val ( CRCPOLY_A :: CRC32 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `CRC16`" ] # [ inline ( always ) ] pub fn is_crc16 ( & self ) -> bool { * self == CRCPOLY_A :: CRC16 } # [ doc = "Checks if the value of the field is `CRC32`" ] # [ inline ( always ) ] pub fn is_crc32 ( & self ) -> bool { * self == CRCPOLY_A :: CRC32 } }
# [ doc = "Write proxy for field `CRCPOLY`" ] pub struct CRCPOLY_W < 'a > { w : & 'a mut W , } impl < 'a > CRCPOLY_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CRCPOLY_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CRC-16 (CRC-CCITT)" ] # [ inline ( always ) ] pub fn crc16 ( self ) -> & 'a mut W { self . variant ( CRCPOLY_A :: CRC16 ) } # [ doc = "CRC32 (IEEE 802.3)" ] # [ inline ( always ) ] pub fn crc32 ( self ) -> & 'a mut W { self . variant ( CRCPOLY_A :: CRC32 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `CRCSRC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CRCSRC_A { # [ doc = "No action" ] NOACT , # [ doc = "I/O interface" ] IO }
impl crate :: ToBits < u8 > for CRCSRC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CRCSRC_A :: NOACT => 0 , CRCSRC_A :: IO => 1 } } }
# [ doc = "Reader of field `CRCSRC`" ] pub type CRCSRC_R = crate :: R < u8 , CRCSRC_A > ; impl CRCSRC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CRCSRC_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CRCSRC_A :: NOACT ) , 1 => Val ( CRCSRC_A :: IO ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NOACT`" ] # [ inline ( always ) ] pub fn is_noact ( & self ) -> bool { * self == CRCSRC_A :: NOACT } # [ doc = "Checks if the value of the field is `IO`" ] # [ inline ( always ) ] pub fn is_io ( & self ) -> bool { * self == CRCSRC_A :: IO } }
# [ doc = "Write proxy for field `CRCSRC`" ] pub struct CRCSRC_W < 'a > { w : & 'a mut W , } impl < 'a > CRCSRC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CRCSRC_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn noact ( self ) -> & 'a mut W { self . variant ( CRCSRC_A :: NOACT ) } # [ doc = "I/O interface" ] # [ inline ( always ) ] pub fn io ( self ) -> & 'a mut W { self . variant ( CRCSRC_A :: IO ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 8 ) ) | ( ( ( value as u16 ) & 0x3f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - CRC Beat Size" ] # [ inline ( always ) ] pub fn crcbeatsize ( & self ) -> CRCBEATSIZE_R { CRCBEATSIZE_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - CRC Polynomial Type" ] # [ inline ( always ) ] pub fn crcpoly ( & self ) -> CRCPOLY_R { CRCPOLY_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:13 - CRC Input Source" ] # [ inline ( always ) ] pub fn crcsrc ( & self ) -> CRCSRC_R { CRCSRC_R :: new ( ( ( self . bits >> 8 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - CRC Beat Size" ] # [ inline ( always ) ] pub fn crcbeatsize ( & mut self ) -> CRCBEATSIZE_W { CRCBEATSIZE_W { w : self } }
# [ doc = "Bits 2:3 - CRC Polynomial Type" ] # [ inline ( always ) ] pub fn crcpoly ( & mut self ) -> CRCPOLY_W { CRCPOLY_W { w : self } }
# [ doc = "Bits 8:13 - CRC Input Source" ] # [ inline ( always ) ] pub fn crcsrc ( & mut self ) -> CRCSRC_W { CRCSRC_W { w : self } }
}
}
# [ doc = "CRC Data Input\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [crcdatain](crcdatain) module" ] pub type CRCDATAIN = crate :: Reg < u32 , _CRCDATAIN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CRCDATAIN ;
# [ doc = "`read()` method returns [crcdatain::R](crcdatain::R) reader structure" ] impl crate :: Readable for CRCDATAIN { }
# [ doc = "`write(|w| ..)` method takes [crcdatain::W](crcdatain::W) writer structure" ] impl crate :: Writable for CRCDATAIN { }
# [ doc = "CRC Data Input" ] pub mod crcdatain {
# [ doc = "Reader of register CRCDATAIN" ] pub type R = crate :: R < u32 , super :: CRCDATAIN > ;
# [ doc = "Writer for register CRCDATAIN" ] pub type W = crate :: W < u32 , super :: CRCDATAIN > ;
# [ doc = "Register CRCDATAIN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CRCDATAIN { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CRCDATAIN`" ] pub type CRCDATAIN_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CRCDATAIN`" ] pub struct CRCDATAIN_W < 'a > { w : & 'a mut W , } impl < 'a > CRCDATAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - CRC Data Input" ] # [ inline ( always ) ] pub fn crcdatain ( & self ) -> CRCDATAIN_R { CRCDATAIN_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - CRC Data Input" ] # [ inline ( always ) ] pub fn crcdatain ( & mut self ) -> CRCDATAIN_W { CRCDATAIN_W { w : self } }
}
}
# [ doc = "CRC Checksum\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [crcchksum](crcchksum) module" ] pub type CRCCHKSUM = crate :: Reg < u32 , _CRCCHKSUM > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CRCCHKSUM ;
# [ doc = "`read()` method returns [crcchksum::R](crcchksum::R) reader structure" ] impl crate :: Readable for CRCCHKSUM { }
# [ doc = "`write(|w| ..)` method takes [crcchksum::W](crcchksum::W) writer structure" ] impl crate :: Writable for CRCCHKSUM { }
# [ doc = "CRC Checksum" ] pub mod crcchksum {
# [ doc = "Reader of register CRCCHKSUM" ] pub type R = crate :: R < u32 , super :: CRCCHKSUM > ;
# [ doc = "Writer for register CRCCHKSUM" ] pub type W = crate :: W < u32 , super :: CRCCHKSUM > ;
# [ doc = "Register CRCCHKSUM `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CRCCHKSUM { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CRCCHKSUM`" ] pub type CRCCHKSUM_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CRCCHKSUM`" ] pub struct CRCCHKSUM_W < 'a > { w : & 'a mut W , } impl < 'a > CRCCHKSUM_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - CRC Checksum" ] # [ inline ( always ) ] pub fn crcchksum ( & self ) -> CRCCHKSUM_R { CRCCHKSUM_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - CRC Checksum" ] # [ inline ( always ) ] pub fn crcchksum ( & mut self ) -> CRCCHKSUM_W { CRCCHKSUM_W { w : self } }
}
}
# [ doc = "CRC Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [crcstatus](crcstatus) module" ] pub type CRCSTATUS = crate :: Reg < u8 , _CRCSTATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CRCSTATUS ;
# [ doc = "`read()` method returns [crcstatus::R](crcstatus::R) reader structure" ] impl crate :: Readable for CRCSTATUS { }
# [ doc = "`write(|w| ..)` method takes [crcstatus::W](crcstatus::W) writer structure" ] impl crate :: Writable for CRCSTATUS { }
# [ doc = "CRC Status" ] pub mod crcstatus {
# [ doc = "Reader of register CRCSTATUS" ] pub type R = crate :: R < u8 , super :: CRCSTATUS > ;
# [ doc = "Writer for register CRCSTATUS" ] pub type W = crate :: W < u8 , super :: CRCSTATUS > ;
# [ doc = "Register CRCSTATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CRCSTATUS { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CRCBUSY`" ] pub type CRCBUSY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CRCBUSY`" ] pub struct CRCBUSY_W < 'a > { w : & 'a mut W , } impl < 'a > CRCBUSY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `CRCZERO`" ] pub type CRCZERO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CRCZERO`" ] pub struct CRCZERO_W < 'a > { w : & 'a mut W , } impl < 'a > CRCZERO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - CRC Module Busy" ] # [ inline ( always ) ] pub fn crcbusy ( & self ) -> CRCBUSY_R { CRCBUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - CRC Zero" ] # [ inline ( always ) ] pub fn crczero ( & self ) -> CRCZERO_R { CRCZERO_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - CRC Module Busy" ] # [ inline ( always ) ] pub fn crcbusy ( & mut self ) -> CRCBUSY_W { CRCBUSY_W { w : self } }
# [ doc = "Bit 1 - CRC Zero" ] # [ inline ( always ) ] pub fn crczero ( & mut self ) -> CRCZERO_W { CRCZERO_W { w : self } }
}
}
# [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ;
# [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { }
# [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { }
# [ doc = "Debug Control" ] pub mod dbgctrl {
# [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ;
# [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ;
# [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } }
}
}
# [ doc = "QOS Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [qosctrl](qosctrl) module" ] pub type QOSCTRL = crate :: Reg < u8 , _QOSCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _QOSCTRL ;
# [ doc = "`read()` method returns [qosctrl::R](qosctrl::R) reader structure" ] impl crate :: Readable for QOSCTRL { }
# [ doc = "`write(|w| ..)` method takes [qosctrl::W](qosctrl::W) writer structure" ] impl crate :: Writable for QOSCTRL { }
# [ doc = "QOS Control" ] pub mod qosctrl {
# [ doc = "Reader of register QOSCTRL" ] pub type R = crate :: R < u8 , super :: QOSCTRL > ;
# [ doc = "Writer for register QOSCTRL" ] pub type W = crate :: W < u8 , super :: QOSCTRL > ;
# [ doc = "Register QOSCTRL `reset()`'s with value 0x2a" ] impl crate :: ResetValue for super :: QOSCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x2a } }
# [ doc = "Possible values of the field `WRBQOS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WRBQOS_A { # [ doc = "Background (no sensitive operation)" ] DISABLE , # [ doc = "Sensitive Bandwidth" ] LOW , # [ doc = "Sensitive Latency" ] MEDIUM , # [ doc = "Critical Latency" ] HIGH }
impl crate :: ToBits < u8 > for WRBQOS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WRBQOS_A :: DISABLE => 0 , WRBQOS_A :: LOW => 1 , WRBQOS_A :: MEDIUM => 2 , WRBQOS_A :: HIGH => 3 } } }
# [ doc = "Reader of field `WRBQOS`" ] pub type WRBQOS_R = crate :: R < u8 , WRBQOS_A > ; impl WRBQOS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WRBQOS_A { match self . bits { 0 => WRBQOS_A :: DISABLE , 1 => WRBQOS_A :: LOW , 2 => WRBQOS_A :: MEDIUM , 3 => WRBQOS_A :: HIGH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == WRBQOS_A :: DISABLE } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == WRBQOS_A :: LOW } # [ doc = "Checks if the value of the field is `MEDIUM`" ] # [ inline ( always ) ] pub fn is_medium ( & self ) -> bool { * self == WRBQOS_A :: MEDIUM } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == WRBQOS_A :: HIGH } }
# [ doc = "Write proxy for field `WRBQOS`" ] pub struct WRBQOS_W < 'a > { w : & 'a mut W , } impl < 'a > WRBQOS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WRBQOS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Background (no sensitive operation)" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( WRBQOS_A :: DISABLE ) } # [ doc = "Sensitive Bandwidth" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( WRBQOS_A :: LOW ) } # [ doc = "Sensitive Latency" ] # [ inline ( always ) ] pub fn medium ( self ) -> & 'a mut W { self . variant ( WRBQOS_A :: MEDIUM ) } # [ doc = "Critical Latency" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( WRBQOS_A :: HIGH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u8 ) & 0x03 ) ; self . w } }
# [ doc = "Possible values of the field `FQOS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FQOS_A { # [ doc = "Background (no sensitive operation)" ] DISABLE , # [ doc = "Sensitive Bandwidth" ] LOW , # [ doc = "Sensitive Latency" ] MEDIUM , # [ doc = "Critical Latency" ] HIGH }
impl crate :: ToBits < u8 > for FQOS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { FQOS_A :: DISABLE => 0 , FQOS_A :: LOW => 1 , FQOS_A :: MEDIUM => 2 , FQOS_A :: HIGH => 3 } } }
# [ doc = "Reader of field `FQOS`" ] pub type FQOS_R = crate :: R < u8 , FQOS_A > ; impl FQOS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FQOS_A { match self . bits { 0 => FQOS_A :: DISABLE , 1 => FQOS_A :: LOW , 2 => FQOS_A :: MEDIUM , 3 => FQOS_A :: HIGH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == FQOS_A :: DISABLE } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == FQOS_A :: LOW } # [ doc = "Checks if the value of the field is `MEDIUM`" ] # [ inline ( always ) ] pub fn is_medium ( & self ) -> bool { * self == FQOS_A :: MEDIUM } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == FQOS_A :: HIGH } }
# [ doc = "Write proxy for field `FQOS`" ] pub struct FQOS_W < 'a > { w : & 'a mut W , } impl < 'a > FQOS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FQOS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Background (no sensitive operation)" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( FQOS_A :: DISABLE ) } # [ doc = "Sensitive Bandwidth" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( FQOS_A :: LOW ) } # [ doc = "Sensitive Latency" ] # [ inline ( always ) ] pub fn medium ( self ) -> & 'a mut W { self . variant ( FQOS_A :: MEDIUM ) } # [ doc = "Critical Latency" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( FQOS_A :: HIGH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u8 ) & 0x03 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `DQOS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DQOS_A { # [ doc = "Background (no sensitive operation)" ] DISABLE , # [ doc = "Sensitive Bandwidth" ] LOW , # [ doc = "Sensitive Latency" ] MEDIUM , # [ doc = "Critical Latency" ] HIGH }
impl crate :: ToBits < u8 > for DQOS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DQOS_A :: DISABLE => 0 , DQOS_A :: LOW => 1 , DQOS_A :: MEDIUM => 2 , DQOS_A :: HIGH => 3 } } }
# [ doc = "Reader of field `DQOS`" ] pub type DQOS_R = crate :: R < u8 , DQOS_A > ; impl DQOS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DQOS_A { match self . bits { 0 => DQOS_A :: DISABLE , 1 => DQOS_A :: LOW , 2 => DQOS_A :: MEDIUM , 3 => DQOS_A :: HIGH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == DQOS_A :: DISABLE } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == DQOS_A :: LOW } # [ doc = "Checks if the value of the field is `MEDIUM`" ] # [ inline ( always ) ] pub fn is_medium ( & self ) -> bool { * self == DQOS_A :: MEDIUM } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == DQOS_A :: HIGH } }
# [ doc = "Write proxy for field `DQOS`" ] pub struct DQOS_W < 'a > { w : & 'a mut W , } impl < 'a > DQOS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DQOS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Background (no sensitive operation)" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( DQOS_A :: DISABLE ) } # [ doc = "Sensitive Bandwidth" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( DQOS_A :: LOW ) } # [ doc = "Sensitive Latency" ] # [ inline ( always ) ] pub fn medium ( self ) -> & 'a mut W { self . variant ( DQOS_A :: MEDIUM ) } # [ doc = "Critical Latency" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( DQOS_A :: HIGH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u8 ) & 0x03 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Write-Back Quality of Service" ] # [ inline ( always ) ] pub fn wrbqos ( & self ) -> WRBQOS_R { WRBQOS_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:3 - Fetch Quality of Service" ] # [ inline ( always ) ] pub fn fqos ( & self ) -> FQOS_R { FQOS_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Data Transfer Quality of Service" ] # [ inline ( always ) ] pub fn dqos ( & self ) -> DQOS_R { DQOS_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Write-Back Quality of Service" ] # [ inline ( always ) ] pub fn wrbqos ( & mut self ) -> WRBQOS_W { WRBQOS_W { w : self } }
# [ doc = "Bits 2:3 - Fetch Quality of Service" ] # [ inline ( always ) ] pub fn fqos ( & mut self ) -> FQOS_W { FQOS_W { w : self } }
# [ doc = "Bits 4:5 - Data Transfer Quality of Service" ] # [ inline ( always ) ] pub fn dqos ( & mut self ) -> DQOS_W { DQOS_W { w : self } }
}
}
# [ doc = "Software Trigger Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [swtrigctrl](swtrigctrl) module" ] pub type SWTRIGCTRL = crate :: Reg < u32 , _SWTRIGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SWTRIGCTRL ;
# [ doc = "`read()` method returns [swtrigctrl::R](swtrigctrl::R) reader structure" ] impl crate :: Readable for SWTRIGCTRL { }
# [ doc = "`write(|w| ..)` method takes [swtrigctrl::W](swtrigctrl::W) writer structure" ] impl crate :: Writable for SWTRIGCTRL { }
# [ doc = "Software Trigger Control" ] pub mod swtrigctrl {
# [ doc = "Reader of register SWTRIGCTRL" ] pub type R = crate :: R < u32 , super :: SWTRIGCTRL > ;
# [ doc = "Writer for register SWTRIGCTRL" ] pub type W = crate :: W < u32 , super :: SWTRIGCTRL > ;
# [ doc = "Register SWTRIGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SWTRIGCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWTRIG0`" ] pub type SWTRIG0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG0`" ] pub struct SWTRIG0_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG1`" ] pub type SWTRIG1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG1`" ] pub struct SWTRIG1_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG2`" ] pub type SWTRIG2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG2`" ] pub struct SWTRIG2_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG3`" ] pub type SWTRIG3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG3`" ] pub struct SWTRIG3_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG4`" ] pub type SWTRIG4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG4`" ] pub struct SWTRIG4_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG5`" ] pub type SWTRIG5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG5`" ] pub struct SWTRIG5_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG6`" ] pub type SWTRIG6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG6`" ] pub struct SWTRIG6_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG7`" ] pub type SWTRIG7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG7`" ] pub struct SWTRIG7_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG8`" ] pub type SWTRIG8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG8`" ] pub struct SWTRIG8_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG9`" ] pub type SWTRIG9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG9`" ] pub struct SWTRIG9_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG10`" ] pub type SWTRIG10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG10`" ] pub struct SWTRIG10_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `SWTRIG11`" ] pub type SWTRIG11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWTRIG11`" ] pub struct SWTRIG11_W < 'a > { w : & 'a mut W , } impl < 'a > SWTRIG11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Channel 0 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig0 ( & self ) -> SWTRIG0_R { SWTRIG0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel 1 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig1 ( & self ) -> SWTRIG1_R { SWTRIG1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel 2 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig2 ( & self ) -> SWTRIG2_R { SWTRIG2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Channel 3 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig3 ( & self ) -> SWTRIG3_R { SWTRIG3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Channel 4 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig4 ( & self ) -> SWTRIG4_R { SWTRIG4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Channel 5 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig5 ( & self ) -> SWTRIG5_R { SWTRIG5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Channel 6 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig6 ( & self ) -> SWTRIG6_R { SWTRIG6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Channel 7 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig7 ( & self ) -> SWTRIG7_R { SWTRIG7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Channel 8 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig8 ( & self ) -> SWTRIG8_R { SWTRIG8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Channel 9 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig9 ( & self ) -> SWTRIG9_R { SWTRIG9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Channel 10 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig10 ( & self ) -> SWTRIG10_R { SWTRIG10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Channel 11 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig11 ( & self ) -> SWTRIG11_R { SWTRIG11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Channel 0 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig0 ( & mut self ) -> SWTRIG0_W { SWTRIG0_W { w : self } }
# [ doc = "Bit 1 - Channel 1 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig1 ( & mut self ) -> SWTRIG1_W { SWTRIG1_W { w : self } }
# [ doc = "Bit 2 - Channel 2 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig2 ( & mut self ) -> SWTRIG2_W { SWTRIG2_W { w : self } }
# [ doc = "Bit 3 - Channel 3 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig3 ( & mut self ) -> SWTRIG3_W { SWTRIG3_W { w : self } }
# [ doc = "Bit 4 - Channel 4 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig4 ( & mut self ) -> SWTRIG4_W { SWTRIG4_W { w : self } }
# [ doc = "Bit 5 - Channel 5 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig5 ( & mut self ) -> SWTRIG5_W { SWTRIG5_W { w : self } }
# [ doc = "Bit 6 - Channel 6 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig6 ( & mut self ) -> SWTRIG6_W { SWTRIG6_W { w : self } }
# [ doc = "Bit 7 - Channel 7 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig7 ( & mut self ) -> SWTRIG7_W { SWTRIG7_W { w : self } }
# [ doc = "Bit 8 - Channel 8 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig8 ( & mut self ) -> SWTRIG8_W { SWTRIG8_W { w : self } }
# [ doc = "Bit 9 - Channel 9 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig9 ( & mut self ) -> SWTRIG9_W { SWTRIG9_W { w : self } }
# [ doc = "Bit 10 - Channel 10 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig10 ( & mut self ) -> SWTRIG10_W { SWTRIG10_W { w : self } }
# [ doc = "Bit 11 - Channel 11 Software Trigger" ] # [ inline ( always ) ] pub fn swtrig11 ( & mut self ) -> SWTRIG11_W { SWTRIG11_W { w : self } }
}
}
# [ doc = "Priority Control 0\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [prictrl0](prictrl0) module" ] pub type PRICTRL0 = crate :: Reg < u32 , _PRICTRL0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PRICTRL0 ;
# [ doc = "`read()` method returns [prictrl0::R](prictrl0::R) reader structure" ] impl crate :: Readable for PRICTRL0 { }
# [ doc = "`write(|w| ..)` method takes [prictrl0::W](prictrl0::W) writer structure" ] impl crate :: Writable for PRICTRL0 { }
# [ doc = "Priority Control 0" ] pub mod prictrl0 {
# [ doc = "Reader of register PRICTRL0" ] pub type R = crate :: R < u32 , super :: PRICTRL0 > ;
# [ doc = "Writer for register PRICTRL0" ] pub type W = crate :: W < u32 , super :: PRICTRL0 > ;
# [ doc = "Register PRICTRL0 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PRICTRL0 { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `LVLPRI0`" ] pub type LVLPRI0_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `LVLPRI0`" ] pub struct LVLPRI0_W < 'a > { w : & 'a mut W , } impl < 'a > LVLPRI0_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u32 ) & 0x0f ) ; self . w } }
# [ doc = "Possible values of the field `RRLVLEN0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RRLVLEN0_A { # [ doc = "Static arbitration scheme for channels with level 3 priority" ] STATIC_LVL , # [ doc = "Round-robin arbitration scheme for channels with level 3 priority" ] ROUND_ROBIN_LVL }
impl crate :: ToBits < bool > for RRLVLEN0_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RRLVLEN0_A :: STATIC_LVL => false , RRLVLEN0_A :: ROUND_ROBIN_LVL => true } } }
# [ doc = "Reader of field `RRLVLEN0`" ] pub type RRLVLEN0_R = crate :: R < bool , RRLVLEN0_A > ; impl RRLVLEN0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RRLVLEN0_A { match self . bits { false => RRLVLEN0_A :: STATIC_LVL , true => RRLVLEN0_A :: ROUND_ROBIN_LVL } } # [ doc = "Checks if the value of the field is `STATIC_LVL`" ] # [ inline ( always ) ] pub fn is_static_lvl ( & self ) -> bool { * self == RRLVLEN0_A :: STATIC_LVL } # [ doc = "Checks if the value of the field is `ROUND_ROBIN_LVL`" ] # [ inline ( always ) ] pub fn is_round_robin_lvl ( & self ) -> bool { * self == RRLVLEN0_A :: ROUND_ROBIN_LVL } }
# [ doc = "Write proxy for field `RRLVLEN0`" ] pub struct RRLVLEN0_W < 'a > { w : & 'a mut W , } impl < 'a > RRLVLEN0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RRLVLEN0_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Static arbitration scheme for channels with level 3 priority" ] # [ inline ( always ) ] pub fn static_lvl ( self ) -> & 'a mut W { self . variant ( RRLVLEN0_A :: STATIC_LVL ) } # [ doc = "Round-robin arbitration scheme for channels with level 3 priority" ] # [ inline ( always ) ] pub fn round_robin_lvl ( self ) -> & 'a mut W { self . variant ( RRLVLEN0_A :: ROUND_ROBIN_LVL ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `LVLPRI1`" ] pub type LVLPRI1_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `LVLPRI1`" ] pub struct LVLPRI1_W < 'a > { w : & 'a mut W , } impl < 'a > LVLPRI1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u32 ) & 0x0f ) << 8 ) ; self . w } }
# [ doc = "Reader of field `RRLVLEN1`" ] pub type RRLVLEN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RRLVLEN1`" ] pub struct RRLVLEN1_W < 'a > { w : & 'a mut W , } impl < 'a > RRLVLEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `LVLPRI2`" ] pub type LVLPRI2_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `LVLPRI2`" ] pub struct LVLPRI2_W < 'a > { w : & 'a mut W , } impl < 'a > LVLPRI2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 16 ) ) | ( ( ( value as u32 ) & 0x0f ) << 16 ) ; self . w } }
# [ doc = "Reader of field `RRLVLEN2`" ] pub type RRLVLEN2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RRLVLEN2`" ] pub struct RRLVLEN2_W < 'a > { w : & 'a mut W , } impl < 'a > RRLVLEN2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `LVLPRI3`" ] pub type LVLPRI3_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `LVLPRI3`" ] pub struct LVLPRI3_W < 'a > { w : & 'a mut W , } impl < 'a > LVLPRI3_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } }
# [ doc = "Reader of field `RRLVLEN3`" ] pub type RRLVLEN3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RRLVLEN3`" ] pub struct RRLVLEN3_W < 'a > { w : & 'a mut W , } impl < 'a > RRLVLEN3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Level 0 Channel Priority Number" ] # [ inline ( always ) ] pub fn lvlpri0 ( & self ) -> LVLPRI0_R { LVLPRI0_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bit 7 - Level 0 Round-Robin Scheduling Enable" ] # [ inline ( always ) ] pub fn rrlvlen0 ( & self ) -> RRLVLEN0_R { RRLVLEN0_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:11 - Level 1 Channel Priority Number" ] # [ inline ( always ) ] pub fn lvlpri1 ( & self ) -> LVLPRI1_R { LVLPRI1_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) }
# [ doc = "Bit 15 - Level 1 Round-Robin Scheduling Enable" ] # [ inline ( always ) ] pub fn rrlvlen1 ( & self ) -> RRLVLEN1_R { RRLVLEN1_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:19 - Level 2 Channel Priority Number" ] # [ inline ( always ) ] pub fn lvlpri2 ( & self ) -> LVLPRI2_R { LVLPRI2_R :: new ( ( ( self . bits >> 16 ) & 0x0f ) as u8 ) }
# [ doc = "Bit 23 - Level 2 Round-Robin Scheduling Enable" ] # [ inline ( always ) ] pub fn rrlvlen2 ( & self ) -> RRLVLEN2_R { RRLVLEN2_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 24:27 - Level 3 Channel Priority Number" ] # [ inline ( always ) ] pub fn lvlpri3 ( & self ) -> LVLPRI3_R { LVLPRI3_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) }
# [ doc = "Bit 31 - Level 3 Round-Robin Scheduling Enable" ] # [ inline ( always ) ] pub fn rrlvlen3 ( & self ) -> RRLVLEN3_R { RRLVLEN3_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:3 - Level 0 Channel Priority Number" ] # [ inline ( always ) ] pub fn lvlpri0 ( & mut self ) -> LVLPRI0_W { LVLPRI0_W { w : self } }
# [ doc = "Bit 7 - Level 0 Round-Robin Scheduling Enable" ] # [ inline ( always ) ] pub fn rrlvlen0 ( & mut self ) -> RRLVLEN0_W { RRLVLEN0_W { w : self } }
# [ doc = "Bits 8:11 - Level 1 Channel Priority Number" ] # [ inline ( always ) ] pub fn lvlpri1 ( & mut self ) -> LVLPRI1_W { LVLPRI1_W { w : self } }
# [ doc = "Bit 15 - Level 1 Round-Robin Scheduling Enable" ] # [ inline ( always ) ] pub fn rrlvlen1 ( & mut self ) -> RRLVLEN1_W { RRLVLEN1_W { w : self } }
# [ doc = "Bits 16:19 - Level 2 Channel Priority Number" ] # [ inline ( always ) ] pub fn lvlpri2 ( & mut self ) -> LVLPRI2_W { LVLPRI2_W { w : self } }
# [ doc = "Bit 23 - Level 2 Round-Robin Scheduling Enable" ] # [ inline ( always ) ] pub fn rrlvlen2 ( & mut self ) -> RRLVLEN2_W { RRLVLEN2_W { w : self } }
# [ doc = "Bits 24:27 - Level 3 Channel Priority Number" ] # [ inline ( always ) ] pub fn lvlpri3 ( & mut self ) -> LVLPRI3_W { LVLPRI3_W { w : self } }
# [ doc = "Bit 31 - Level 3 Round-Robin Scheduling Enable" ] # [ inline ( always ) ] pub fn rrlvlen3 ( & mut self ) -> RRLVLEN3_W { RRLVLEN3_W { w : self } }
}
}
# [ doc = "Interrupt Pending\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intpend](intpend) module" ] pub type INTPEND = crate :: Reg < u16 , _INTPEND > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTPEND ;
# [ doc = "`read()` method returns [intpend::R](intpend::R) reader structure" ] impl crate :: Readable for INTPEND { }
# [ doc = "`write(|w| ..)` method takes [intpend::W](intpend::W) writer structure" ] impl crate :: Writable for INTPEND { }
# [ doc = "Interrupt Pending" ] pub mod intpend {
# [ doc = "Reader of register INTPEND" ] pub type R = crate :: R < u16 , super :: INTPEND > ;
# [ doc = "Writer for register INTPEND" ] pub type W = crate :: W < u16 , super :: INTPEND > ;
# [ doc = "Register INTPEND `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTPEND { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u16 ) & 0x0f ) ; self . w } }
# [ doc = "Reader of field `TERR`" ] pub type TERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TERR`" ] pub struct TERR_W < 'a > { w : & 'a mut W , } impl < 'a > TERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `TCMPL`" ] pub type TCMPL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCMPL`" ] pub struct TCMPL_W < 'a > { w : & 'a mut W , } impl < 'a > TCMPL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `SUSP`" ] pub type SUSP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SUSP`" ] pub struct SUSP_W < 'a > { w : & 'a mut W , } impl < 'a > SUSP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `FERR`" ] pub type FERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FERR`" ] pub struct FERR_W < 'a > { w : & 'a mut W , } impl < 'a > FERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `BUSY`" ] pub type BUSY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BUSY`" ] pub struct BUSY_W < 'a > { w : & 'a mut W , } impl < 'a > BUSY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `PEND`" ] pub type PEND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PEND`" ] pub struct PEND_W < 'a > { w : & 'a mut W , } impl < 'a > PEND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Channel ID" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bit 8 - Transfer Error" ] # [ inline ( always ) ] pub fn terr ( & self ) -> TERR_R { TERR_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Transfer Complete" ] # [ inline ( always ) ] pub fn tcmpl ( & self ) -> TCMPL_R { TCMPL_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Channel Suspend" ] # [ inline ( always ) ] pub fn susp ( & self ) -> SUSP_R { SUSP_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Fetch Error" ] # [ inline ( always ) ] pub fn ferr ( & self ) -> FERR_R { FERR_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Busy" ] # [ inline ( always ) ] pub fn busy ( & self ) -> BUSY_R { BUSY_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Pending" ] # [ inline ( always ) ] pub fn pend ( & self ) -> PEND_R { PEND_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:3 - Channel ID" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
# [ doc = "Bit 8 - Transfer Error" ] # [ inline ( always ) ] pub fn terr ( & mut self ) -> TERR_W { TERR_W { w : self } }
# [ doc = "Bit 9 - Transfer Complete" ] # [ inline ( always ) ] pub fn tcmpl ( & mut self ) -> TCMPL_W { TCMPL_W { w : self } }
# [ doc = "Bit 10 - Channel Suspend" ] # [ inline ( always ) ] pub fn susp ( & mut self ) -> SUSP_W { SUSP_W { w : self } }
# [ doc = "Bit 13 - Fetch Error" ] # [ inline ( always ) ] pub fn ferr ( & mut self ) -> FERR_W { FERR_W { w : self } }
# [ doc = "Bit 14 - Busy" ] # [ inline ( always ) ] pub fn busy ( & mut self ) -> BUSY_W { BUSY_W { w : self } }
# [ doc = "Bit 15 - Pending" ] # [ inline ( always ) ] pub fn pend ( & mut self ) -> PEND_W { PEND_W { w : self } }
}
}
# [ doc = "Interrupt Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intstatus](intstatus) module" ] pub type INTSTATUS = crate :: Reg < u32 , _INTSTATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTSTATUS ;
# [ doc = "`read()` method returns [intstatus::R](intstatus::R) reader structure" ] impl crate :: Readable for INTSTATUS { }
# [ doc = "Interrupt Status" ] pub mod intstatus {
# [ doc = "Reader of register INTSTATUS" ] pub type R = crate :: R < u32 , super :: INTSTATUS > ;
# [ doc = "Reader of field `CHINT0`" ] pub type CHINT0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT1`" ] pub type CHINT1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT2`" ] pub type CHINT2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT3`" ] pub type CHINT3_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT4`" ] pub type CHINT4_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT5`" ] pub type CHINT5_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT6`" ] pub type CHINT6_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT7`" ] pub type CHINT7_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT8`" ] pub type CHINT8_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT9`" ] pub type CHINT9_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT10`" ] pub type CHINT10_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHINT11`" ] pub type CHINT11_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Channel 0 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint0 ( & self ) -> CHINT0_R { CHINT0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel 1 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint1 ( & self ) -> CHINT1_R { CHINT1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel 2 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint2 ( & self ) -> CHINT2_R { CHINT2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Channel 3 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint3 ( & self ) -> CHINT3_R { CHINT3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Channel 4 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint4 ( & self ) -> CHINT4_R { CHINT4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Channel 5 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint5 ( & self ) -> CHINT5_R { CHINT5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Channel 6 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint6 ( & self ) -> CHINT6_R { CHINT6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Channel 7 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint7 ( & self ) -> CHINT7_R { CHINT7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Channel 8 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint8 ( & self ) -> CHINT8_R { CHINT8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Channel 9 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint9 ( & self ) -> CHINT9_R { CHINT9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Channel 10 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint10 ( & self ) -> CHINT10_R { CHINT10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Channel 11 Pending Interrupt" ] # [ inline ( always ) ] pub fn chint11 ( & self ) -> CHINT11_R { CHINT11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Busy Channels\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [busych](busych) module" ] pub type BUSYCH = crate :: Reg < u32 , _BUSYCH > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BUSYCH ;
# [ doc = "`read()` method returns [busych::R](busych::R) reader structure" ] impl crate :: Readable for BUSYCH { }
# [ doc = "Busy Channels" ] pub mod busych {
# [ doc = "Reader of register BUSYCH" ] pub type R = crate :: R < u32 , super :: BUSYCH > ;
# [ doc = "Reader of field `BUSYCH0`" ] pub type BUSYCH0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH1`" ] pub type BUSYCH1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH2`" ] pub type BUSYCH2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH3`" ] pub type BUSYCH3_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH4`" ] pub type BUSYCH4_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH5`" ] pub type BUSYCH5_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH6`" ] pub type BUSYCH6_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH7`" ] pub type BUSYCH7_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH8`" ] pub type BUSYCH8_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH9`" ] pub type BUSYCH9_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH10`" ] pub type BUSYCH10_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSYCH11`" ] pub type BUSYCH11_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Busy Channel 0" ] # [ inline ( always ) ] pub fn busych0 ( & self ) -> BUSYCH0_R { BUSYCH0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Busy Channel 1" ] # [ inline ( always ) ] pub fn busych1 ( & self ) -> BUSYCH1_R { BUSYCH1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Busy Channel 2" ] # [ inline ( always ) ] pub fn busych2 ( & self ) -> BUSYCH2_R { BUSYCH2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Busy Channel 3" ] # [ inline ( always ) ] pub fn busych3 ( & self ) -> BUSYCH3_R { BUSYCH3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Busy Channel 4" ] # [ inline ( always ) ] pub fn busych4 ( & self ) -> BUSYCH4_R { BUSYCH4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Busy Channel 5" ] # [ inline ( always ) ] pub fn busych5 ( & self ) -> BUSYCH5_R { BUSYCH5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Busy Channel 6" ] # [ inline ( always ) ] pub fn busych6 ( & self ) -> BUSYCH6_R { BUSYCH6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Busy Channel 7" ] # [ inline ( always ) ] pub fn busych7 ( & self ) -> BUSYCH7_R { BUSYCH7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Busy Channel 8" ] # [ inline ( always ) ] pub fn busych8 ( & self ) -> BUSYCH8_R { BUSYCH8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Busy Channel 9" ] # [ inline ( always ) ] pub fn busych9 ( & self ) -> BUSYCH9_R { BUSYCH9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Busy Channel 10" ] # [ inline ( always ) ] pub fn busych10 ( & self ) -> BUSYCH10_R { BUSYCH10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Busy Channel 11" ] # [ inline ( always ) ] pub fn busych11 ( & self ) -> BUSYCH11_R { BUSYCH11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Pending Channels\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pendch](pendch) module" ] pub type PENDCH = crate :: Reg < u32 , _PENDCH > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PENDCH ;
# [ doc = "`read()` method returns [pendch::R](pendch::R) reader structure" ] impl crate :: Readable for PENDCH { }
# [ doc = "Pending Channels" ] pub mod pendch {
# [ doc = "Reader of register PENDCH" ] pub type R = crate :: R < u32 , super :: PENDCH > ;
# [ doc = "Reader of field `PENDCH0`" ] pub type PENDCH0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH1`" ] pub type PENDCH1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH2`" ] pub type PENDCH2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH3`" ] pub type PENDCH3_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH4`" ] pub type PENDCH4_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH5`" ] pub type PENDCH5_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH6`" ] pub type PENDCH6_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH7`" ] pub type PENDCH7_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH8`" ] pub type PENDCH8_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH9`" ] pub type PENDCH9_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH10`" ] pub type PENDCH10_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PENDCH11`" ] pub type PENDCH11_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Pending Channel 0" ] # [ inline ( always ) ] pub fn pendch0 ( & self ) -> PENDCH0_R { PENDCH0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Pending Channel 1" ] # [ inline ( always ) ] pub fn pendch1 ( & self ) -> PENDCH1_R { PENDCH1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Pending Channel 2" ] # [ inline ( always ) ] pub fn pendch2 ( & self ) -> PENDCH2_R { PENDCH2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Pending Channel 3" ] # [ inline ( always ) ] pub fn pendch3 ( & self ) -> PENDCH3_R { PENDCH3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Pending Channel 4" ] # [ inline ( always ) ] pub fn pendch4 ( & self ) -> PENDCH4_R { PENDCH4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Pending Channel 5" ] # [ inline ( always ) ] pub fn pendch5 ( & self ) -> PENDCH5_R { PENDCH5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Pending Channel 6" ] # [ inline ( always ) ] pub fn pendch6 ( & self ) -> PENDCH6_R { PENDCH6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Pending Channel 7" ] # [ inline ( always ) ] pub fn pendch7 ( & self ) -> PENDCH7_R { PENDCH7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Pending Channel 8" ] # [ inline ( always ) ] pub fn pendch8 ( & self ) -> PENDCH8_R { PENDCH8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Pending Channel 9" ] # [ inline ( always ) ] pub fn pendch9 ( & self ) -> PENDCH9_R { PENDCH9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Pending Channel 10" ] # [ inline ( always ) ] pub fn pendch10 ( & self ) -> PENDCH10_R { PENDCH10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Pending Channel 11" ] # [ inline ( always ) ] pub fn pendch11 ( & self ) -> PENDCH11_R { PENDCH11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Active Channel and Levels\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [active](active) module" ] pub type ACTIVE = crate :: Reg < u32 , _ACTIVE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ACTIVE ;
# [ doc = "`read()` method returns [active::R](active::R) reader structure" ] impl crate :: Readable for ACTIVE { }
# [ doc = "Active Channel and Levels" ] pub mod active {
# [ doc = "Reader of register ACTIVE" ] pub type R = crate :: R < u32 , super :: ACTIVE > ;
# [ doc = "Reader of field `LVLEX0`" ] pub type LVLEX0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `LVLEX1`" ] pub type LVLEX1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `LVLEX2`" ] pub type LVLEX2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `LVLEX3`" ] pub type LVLEX3_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `ABUSY`" ] pub type ABUSY_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BTCNT`" ] pub type BTCNT_R = crate :: R < u16 , u16 > ;
impl R {
# [ doc = "Bit 0 - Level 0 Channel Trigger Request Executing" ] # [ inline ( always ) ] pub fn lvlex0 ( & self ) -> LVLEX0_R { LVLEX0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Level 1 Channel Trigger Request Executing" ] # [ inline ( always ) ] pub fn lvlex1 ( & self ) -> LVLEX1_R { LVLEX1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Level 2 Channel Trigger Request Executing" ] # [ inline ( always ) ] pub fn lvlex2 ( & self ) -> LVLEX2_R { LVLEX2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Level 3 Channel Trigger Request Executing" ] # [ inline ( always ) ] pub fn lvlex3 ( & self ) -> LVLEX3_R { LVLEX3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:12 - Active Channel ID" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( ( self . bits >> 8 ) & 0x1f ) as u8 ) }
# [ doc = "Bit 15 - Active Channel Busy" ] # [ inline ( always ) ] pub fn abusy ( & self ) -> ABUSY_R { ABUSY_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:31 - Active Channel Block Transfer Count" ] # [ inline ( always ) ] pub fn btcnt ( & self ) -> BTCNT_R { BTCNT_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) }
}
}
# [ doc = "Descriptor Memory Section Base Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baseaddr](baseaddr) module" ] pub type BASEADDR = crate :: Reg < u32 , _BASEADDR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BASEADDR ;
# [ doc = "`read()` method returns [baseaddr::R](baseaddr::R) reader structure" ] impl crate :: Readable for BASEADDR { }
# [ doc = "`write(|w| ..)` method takes [baseaddr::W](baseaddr::W) writer structure" ] impl crate :: Writable for BASEADDR { }
# [ doc = "Descriptor Memory Section Base Address" ] pub mod baseaddr {
# [ doc = "Reader of register BASEADDR" ] pub type R = crate :: R < u32 , super :: BASEADDR > ;
# [ doc = "Writer for register BASEADDR" ] pub type W = crate :: W < u32 , super :: BASEADDR > ;
# [ doc = "Register BASEADDR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BASEADDR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `BASEADDR`" ] pub type BASEADDR_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `BASEADDR`" ] pub struct BASEADDR_W < 'a > { w : & 'a mut W , } impl < 'a > BASEADDR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - Descriptor Memory Base Address" ] # [ inline ( always ) ] pub fn baseaddr ( & self ) -> BASEADDR_R { BASEADDR_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - Descriptor Memory Base Address" ] # [ inline ( always ) ] pub fn baseaddr ( & mut self ) -> BASEADDR_W { BASEADDR_W { w : self } }
}
}
# [ doc = "Write-Back Memory Section Base Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [wrbaddr](wrbaddr) module" ] pub type WRBADDR = crate :: Reg < u32 , _WRBADDR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WRBADDR ;
# [ doc = "`read()` method returns [wrbaddr::R](wrbaddr::R) reader structure" ] impl crate :: Readable for WRBADDR { }
# [ doc = "`write(|w| ..)` method takes [wrbaddr::W](wrbaddr::W) writer structure" ] impl crate :: Writable for WRBADDR { }
# [ doc = "Write-Back Memory Section Base Address" ] pub mod wrbaddr {
# [ doc = "Reader of register WRBADDR" ] pub type R = crate :: R < u32 , super :: WRBADDR > ;
# [ doc = "Writer for register WRBADDR" ] pub type W = crate :: W < u32 , super :: WRBADDR > ;
# [ doc = "Register WRBADDR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WRBADDR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WRBADDR`" ] pub type WRBADDR_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `WRBADDR`" ] pub struct WRBADDR_W < 'a > { w : & 'a mut W , } impl < 'a > WRBADDR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - Write-Back Memory Base Address" ] # [ inline ( always ) ] pub fn wrbaddr ( & self ) -> WRBADDR_R { WRBADDR_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - Write-Back Memory Base Address" ] # [ inline ( always ) ] pub fn wrbaddr ( & mut self ) -> WRBADDR_W { WRBADDR_W { w : self } }
}
}
# [ doc = "Channel ID\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [chid](chid) module" ] pub type CHID = crate :: Reg < u8 , _CHID > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CHID ;
# [ doc = "`read()` method returns [chid::R](chid::R) reader structure" ] impl crate :: Readable for CHID { }
# [ doc = "`write(|w| ..)` method takes [chid::W](chid::W) writer structure" ] impl crate :: Writable for CHID { }
# [ doc = "Channel ID" ] pub mod chid {
# [ doc = "Reader of register CHID" ] pub type R = crate :: R < u8 , super :: CHID > ;
# [ doc = "Writer for register CHID" ] pub type W = crate :: W < u8 , super :: CHID > ;
# [ doc = "Register CHID `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CHID { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ID`" ] pub type ID_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `ID`" ] pub struct ID_W < 'a > { w : & 'a mut W , } impl < 'a > ID_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Channel ID" ] # [ inline ( always ) ] pub fn id ( & self ) -> ID_R { ID_R :: new ( ( self . bits & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:3 - Channel ID" ] # [ inline ( always ) ] pub fn id ( & mut self ) -> ID_W { ID_W { w : self } }
}
}
# [ doc = "Channel Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [chctrla](chctrla) module" ] pub type CHCTRLA = crate :: Reg < u8 , _CHCTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CHCTRLA ;
# [ doc = "`read()` method returns [chctrla::R](chctrla::R) reader structure" ] impl crate :: Readable for CHCTRLA { }
# [ doc = "`write(|w| ..)` method takes [chctrla::W](chctrla::W) writer structure" ] impl crate :: Writable for CHCTRLA { }
# [ doc = "Channel Control A" ] pub mod chctrla {
# [ doc = "Reader of register CHCTRLA" ] pub type R = crate :: R < u8 , super :: CHCTRLA > ;
# [ doc = "Writer for register CHCTRLA" ] pub type W = crate :: W < u8 , super :: CHCTRLA > ;
# [ doc = "Register CHCTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CHCTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Channel Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Channel run in standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Channel Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Channel Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 6 - Channel run in standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
}
}
# [ doc = "Channel Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [chctrlb](chctrlb) module" ] pub type CHCTRLB = crate :: Reg < u32 , _CHCTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CHCTRLB ;
# [ doc = "`read()` method returns [chctrlb::R](chctrlb::R) reader structure" ] impl crate :: Readable for CHCTRLB { }
# [ doc = "`write(|w| ..)` method takes [chctrlb::W](chctrlb::W) writer structure" ] impl crate :: Writable for CHCTRLB { }
# [ doc = "Channel Control B" ] pub mod chctrlb {
# [ doc = "Reader of register CHCTRLB" ] pub type R = crate :: R < u32 , super :: CHCTRLB > ;
# [ doc = "Writer for register CHCTRLB" ] pub type W = crate :: W < u32 , super :: CHCTRLB > ;
# [ doc = "Register CHCTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CHCTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `EVACT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EVACT_A { # [ doc = "No action" ] NOACT , # [ doc = "Transfer and periodic transfer trigger" ] TRIG , # [ doc = "Conditional transfer trigger" ] CTRIG , # [ doc = "Conditional block transfer" ] CBLOCK , # [ doc = "Channel suspend operation" ] SUSPEND , # [ doc = "Channel resume operation" ] RESUME , # [ doc = "Skip next block suspend action" ] SSKIP }
impl crate :: ToBits < u8 > for EVACT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { EVACT_A :: NOACT => 0 , EVACT_A :: TRIG => 1 , EVACT_A :: CTRIG => 2 , EVACT_A :: CBLOCK => 3 , EVACT_A :: SUSPEND => 4 , EVACT_A :: RESUME => 5 , EVACT_A :: SSKIP => 6 } } }
# [ doc = "Reader of field `EVACT`" ] pub type EVACT_R = crate :: R < u8 , EVACT_A > ; impl EVACT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , EVACT_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( EVACT_A :: NOACT ) , 1 => Val ( EVACT_A :: TRIG ) , 2 => Val ( EVACT_A :: CTRIG ) , 3 => Val ( EVACT_A :: CBLOCK ) , 4 => Val ( EVACT_A :: SUSPEND ) , 5 => Val ( EVACT_A :: RESUME ) , 6 => Val ( EVACT_A :: SSKIP ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NOACT`" ] # [ inline ( always ) ] pub fn is_noact ( & self ) -> bool { * self == EVACT_A :: NOACT } # [ doc = "Checks if the value of the field is `TRIG`" ] # [ inline ( always ) ] pub fn is_trig ( & self ) -> bool { * self == EVACT_A :: TRIG } # [ doc = "Checks if the value of the field is `CTRIG`" ] # [ inline ( always ) ] pub fn is_ctrig ( & self ) -> bool { * self == EVACT_A :: CTRIG } # [ doc = "Checks if the value of the field is `CBLOCK`" ] # [ inline ( always ) ] pub fn is_cblock ( & self ) -> bool { * self == EVACT_A :: CBLOCK } # [ doc = "Checks if the value of the field is `SUSPEND`" ] # [ inline ( always ) ] pub fn is_suspend ( & self ) -> bool { * self == EVACT_A :: SUSPEND } # [ doc = "Checks if the value of the field is `RESUME`" ] # [ inline ( always ) ] pub fn is_resume ( & self ) -> bool { * self == EVACT_A :: RESUME } # [ doc = "Checks if the value of the field is `SSKIP`" ] # [ inline ( always ) ] pub fn is_sskip ( & self ) -> bool { * self == EVACT_A :: SSKIP } }
# [ doc = "Write proxy for field `EVACT`" ] pub struct EVACT_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EVACT_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn noact ( self ) -> & 'a mut W { self . variant ( EVACT_A :: NOACT ) } # [ doc = "Transfer and periodic transfer trigger" ] # [ inline ( always ) ] pub fn trig ( self ) -> & 'a mut W { self . variant ( EVACT_A :: TRIG ) } # [ doc = "Conditional transfer trigger" ] # [ inline ( always ) ] pub fn ctrig ( self ) -> & 'a mut W { self . variant ( EVACT_A :: CTRIG ) } # [ doc = "Conditional block transfer" ] # [ inline ( always ) ] pub fn cblock ( self ) -> & 'a mut W { self . variant ( EVACT_A :: CBLOCK ) } # [ doc = "Channel suspend operation" ] # [ inline ( always ) ] pub fn suspend ( self ) -> & 'a mut W { self . variant ( EVACT_A :: SUSPEND ) } # [ doc = "Channel resume operation" ] # [ inline ( always ) ] pub fn resume ( self ) -> & 'a mut W { self . variant ( EVACT_A :: RESUME ) } # [ doc = "Skip next block suspend action" ] # [ inline ( always ) ] pub fn sskip ( self ) -> & 'a mut W { self . variant ( EVACT_A :: SSKIP ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
# [ doc = "Reader of field `EVIE`" ] pub type EVIE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVIE`" ] pub struct EVIE_W < 'a > { w : & 'a mut W , } impl < 'a > EVIE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `EVOE`" ] pub type EVOE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVOE`" ] pub struct EVOE_W < 'a > { w : & 'a mut W , } impl < 'a > EVOE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Possible values of the field `LVL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LVL_A { # [ doc = "Channel Priority Level 0" ] LVL0 , # [ doc = "Channel Priority Level 1" ] LVL1 , # [ doc = "Channel Priority Level 2" ] LVL2 , # [ doc = "Channel Priority Level 3" ] LVL3 }
impl crate :: ToBits < u8 > for LVL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { LVL_A :: LVL0 => 0 , LVL_A :: LVL1 => 1 , LVL_A :: LVL2 => 2 , LVL_A :: LVL3 => 3 } } }
# [ doc = "Reader of field `LVL`" ] pub type LVL_R = crate :: R < u8 , LVL_A > ; impl LVL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> LVL_A { match self . bits { 0 => LVL_A :: LVL0 , 1 => LVL_A :: LVL1 , 2 => LVL_A :: LVL2 , 3 => LVL_A :: LVL3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `LVL0`" ] # [ inline ( always ) ] pub fn is_lvl0 ( & self ) -> bool { * self == LVL_A :: LVL0 } # [ doc = "Checks if the value of the field is `LVL1`" ] # [ inline ( always ) ] pub fn is_lvl1 ( & self ) -> bool { * self == LVL_A :: LVL1 } # [ doc = "Checks if the value of the field is `LVL2`" ] # [ inline ( always ) ] pub fn is_lvl2 ( & self ) -> bool { * self == LVL_A :: LVL2 } # [ doc = "Checks if the value of the field is `LVL3`" ] # [ inline ( always ) ] pub fn is_lvl3 ( & self ) -> bool { * self == LVL_A :: LVL3 } }
# [ doc = "Write proxy for field `LVL`" ] pub struct LVL_W < 'a > { w : & 'a mut W , } impl < 'a > LVL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : LVL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Channel Priority Level 0" ] # [ inline ( always ) ] pub fn lvl0 ( self ) -> & 'a mut W { self . variant ( LVL_A :: LVL0 ) } # [ doc = "Channel Priority Level 1" ] # [ inline ( always ) ] pub fn lvl1 ( self ) -> & 'a mut W { self . variant ( LVL_A :: LVL1 ) } # [ doc = "Channel Priority Level 2" ] # [ inline ( always ) ] pub fn lvl2 ( self ) -> & 'a mut W { self . variant ( LVL_A :: LVL2 ) } # [ doc = "Channel Priority Level 3" ] # [ inline ( always ) ] pub fn lvl3 ( self ) -> & 'a mut W { self . variant ( LVL_A :: LVL3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 5 ) ) | ( ( ( value as u32 ) & 0x03 ) << 5 ) ; self . w } }
# [ doc = "Possible values of the field `TRIGSRC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TRIGSRC_A { # [ doc = "Only software/event triggers" ] DISABLE , # [ doc = "TSENS Result Ready Trigger" ] TSENS , # [ doc = "SERCOM0 RX Trigger" ] SERCOM0_RX , # [ doc = "SERCOM0 TX Trigger" ] SERCOM0_TX , # [ doc = "SERCOM1 RX Trigger" ] SERCOM1_RX , # [ doc = "SERCOM1 TX Trigger" ] SERCOM1_TX , # [ doc = "SERCOM2 RX Trigger" ] SERCOM2_RX , # [ doc = "SERCOM2 TX Trigger" ] SERCOM2_TX , # [ doc = "SERCOM3 RX Trigger" ] SERCOM3_RX , # [ doc = "SERCOM3 TX Trigger" ] SERCOM3_TX , # [ doc = "SERCOM4 RX Trigger" ] SERCOM4_RX , # [ doc = "SERCOM4 TX Trigger" ] SERCOM4_TX , # [ doc = "SERCOM5 RX Trigger" ] SERCOM5_RX , # [ doc = "SERCOM5 TX Trigger" ] SERCOM5_TX , # [ doc = "CAN0 Debug Trigger Reserved" ] CAN0_DEBUG , # [ doc = "CAN1 Debug Trigger Reserved" ] CAN1_DEBUG , # [ doc = "TCC0 Overflow Trigger" ] TCC0_OVF , # [ doc = "TCC0 Match/Compare 0 Trigger" ] TCC0_MC0 , # [ doc = "TCC0 Match/Compare 1 Trigger" ] TCC0_MC1 , # [ doc = "TCC0 Match/Compare 2 Trigger" ] TCC0_MC2 , # [ doc = "TCC0 Match/Compare 3 Trigger" ] TCC0_MC3 , # [ doc = "TCC1 Overflow Trigger" ] TCC1_OVF , # [ doc = "TCC1 Match/Compare 0 Trigger" ] TCC1_MC0 , # [ doc = "TCC1 Match/Compare 1 Trigger" ] TCC1_MC1 , # [ doc = "TCC2 Overflow Trigger" ] TCC2_OVF , # [ doc = "TCC2 Match/Compare 0 Trigger" ] TCC2_MC0 , # [ doc = "TCC2 Match/Compare 1 Trigger" ] TCC2_MC1 , # [ doc = "TC0 Overflow Trigger" ] TC0_OVF , # [ doc = "TC0 Match/Compare 0 Trigger" ] TC0_MC0 , # [ doc = "TC0 Match/Compare 1 Trigger" ] TC0_MC1 , # [ doc = "TC1 Overflow Trigger" ] TC1_OVF , # [ doc = "TC1 Match/Compare 0 Trigger" ] TC1_MC0 , # [ doc = "TC1 Match/Compare 1 Trigger" ] TC1_MC1 , # [ doc = "TC2 Overflow Trigger" ] TC2_OVF , # [ doc = "TC2 Match/Compare 0 Trigger" ] TC2_MC0 , # [ doc = "TC2 Match/Compare 1 Trigger" ] TC2_MC1 , # [ doc = "TC3 Overflow Trigger" ] TC3_OVF , # [ doc = "TC3 Match/Compare 0 Trigger" ] TC3_MC0 , # [ doc = "TC3 Match/Compare 1 Trigger" ] TC3_MC1 , # [ doc = "TC4 Overflow Trigger" ] TC4_OVF , # [ doc = "TC4 Match/Compare 0 Trigger" ] TC4_MC0 , # [ doc = "TC4 Match/Compare 1 Trigger" ] TC4_MC1 , # [ doc = "ADC0 Result Ready Trigger" ] ADC0_RESRDY , # [ doc = "ADC1 Result Ready Trigger" ] ADC1_RESRDY , # [ doc = "SDADC Result Ready Trigger" ] SDADC_RESRDY , # [ doc = "DAC Empty Trigger" ] DAC_EMPTY , # [ doc = "PTC End of Conversion Trigger" ] PTC_EOC , # [ doc = "PTC Window Compare Trigger" ] PTC_WCOMP , # [ doc = "PTC Sequence Trigger" ] PTC_SEQ , # [ doc = "SERCOM6 RX Trigger" ] SERCOM6_RX , # [ doc = "SERCOM6 TX Trigger" ] SERCOM6_TX , # [ doc = "SERCOM7 RX Trigger" ] SERCOM7_RX , # [ doc = "SERCOM7 TX Trigger" ] SERCOM7_TX , # [ doc = "TC5 Overflow Trigger" ] TC5_OVF , # [ doc = "TC5 Match/Compare 0 Trigger" ] TC5_MC0 , # [ doc = "TC5 Match/Compare 1 Trigger" ] TC5_MC1 , # [ doc = "TC6 Overflow Trigger" ] TC6_OVF , # [ doc = "TC6 Match/Compare 0 Trigger" ] TC6_MC0 , # [ doc = "TC6 Match/Compare 1 Trigger" ] TC6_MC1 , # [ doc = "TC7 Overflow Trigger" ] TC7_OVF , # [ doc = "TC7 Match/Compare 0 Trigger" ] TC7_MC0 , # [ doc = "TC7 Match/Compare 1 Trigger" ] TC7_MC1 }
impl crate :: ToBits < u8 > for TRIGSRC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { TRIGSRC_A :: DISABLE => 0 , TRIGSRC_A :: TSENS => 1 , TRIGSRC_A :: SERCOM0_RX => 2 , TRIGSRC_A :: SERCOM0_TX => 3 , TRIGSRC_A :: SERCOM1_RX => 4 , TRIGSRC_A :: SERCOM1_TX => 5 , TRIGSRC_A :: SERCOM2_RX => 6 , TRIGSRC_A :: SERCOM2_TX => 7 , TRIGSRC_A :: SERCOM3_RX => 8 , TRIGSRC_A :: SERCOM3_TX => 9 , TRIGSRC_A :: SERCOM4_RX => 10 , TRIGSRC_A :: SERCOM4_TX => 11 , TRIGSRC_A :: SERCOM5_RX => 12 , TRIGSRC_A :: SERCOM5_TX => 13 , TRIGSRC_A :: CAN0_DEBUG => 14 , TRIGSRC_A :: CAN1_DEBUG => 15 , TRIGSRC_A :: TCC0_OVF => 16 , TRIGSRC_A :: TCC0_MC0 => 17 , TRIGSRC_A :: TCC0_MC1 => 18 , TRIGSRC_A :: TCC0_MC2 => 19 , TRIGSRC_A :: TCC0_MC3 => 20 , TRIGSRC_A :: TCC1_OVF => 21 , TRIGSRC_A :: TCC1_MC0 => 22 , TRIGSRC_A :: TCC1_MC1 => 23 , TRIGSRC_A :: TCC2_OVF => 24 , TRIGSRC_A :: TCC2_MC0 => 25 , TRIGSRC_A :: TCC2_MC1 => 26 , TRIGSRC_A :: TC0_OVF => 27 , TRIGSRC_A :: TC0_MC0 => 28 , TRIGSRC_A :: TC0_MC1 => 29 , TRIGSRC_A :: TC1_OVF => 30 , TRIGSRC_A :: TC1_MC0 => 31 , TRIGSRC_A :: TC1_MC1 => 32 , TRIGSRC_A :: TC2_OVF => 33 , TRIGSRC_A :: TC2_MC0 => 34 , TRIGSRC_A :: TC2_MC1 => 35 , TRIGSRC_A :: TC3_OVF => 36 , TRIGSRC_A :: TC3_MC0 => 37 , TRIGSRC_A :: TC3_MC1 => 38 , TRIGSRC_A :: TC4_OVF => 39 , TRIGSRC_A :: TC4_MC0 => 40 , TRIGSRC_A :: TC4_MC1 => 41 , TRIGSRC_A :: ADC0_RESRDY => 42 , TRIGSRC_A :: ADC1_RESRDY => 43 , TRIGSRC_A :: SDADC_RESRDY => 44 , TRIGSRC_A :: DAC_EMPTY => 45 , TRIGSRC_A :: PTC_EOC => 46 , TRIGSRC_A :: PTC_WCOMP => 47 , TRIGSRC_A :: PTC_SEQ => 48 , TRIGSRC_A :: SERCOM6_RX => 49 , TRIGSRC_A :: SERCOM6_TX => 50 , TRIGSRC_A :: SERCOM7_RX => 51 , TRIGSRC_A :: SERCOM7_TX => 52 , TRIGSRC_A :: TC5_OVF => 53 , TRIGSRC_A :: TC5_MC0 => 54 , TRIGSRC_A :: TC5_MC1 => 55 , TRIGSRC_A :: TC6_OVF => 56 , TRIGSRC_A :: TC6_MC0 => 57 , TRIGSRC_A :: TC6_MC1 => 58 , TRIGSRC_A :: TC7_OVF => 59 , TRIGSRC_A :: TC7_MC0 => 60 , TRIGSRC_A :: TC7_MC1 => 61 } } }
# [ doc = "Reader of field `TRIGSRC`" ] pub type TRIGSRC_R = crate :: R < u8 , TRIGSRC_A > ; impl TRIGSRC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , TRIGSRC_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TRIGSRC_A :: DISABLE ) , 1 => Val ( TRIGSRC_A :: TSENS ) , 2 => Val ( TRIGSRC_A :: SERCOM0_RX ) , 3 => Val ( TRIGSRC_A :: SERCOM0_TX ) , 4 => Val ( TRIGSRC_A :: SERCOM1_RX ) , 5 => Val ( TRIGSRC_A :: SERCOM1_TX ) , 6 => Val ( TRIGSRC_A :: SERCOM2_RX ) , 7 => Val ( TRIGSRC_A :: SERCOM2_TX ) , 8 => Val ( TRIGSRC_A :: SERCOM3_RX ) , 9 => Val ( TRIGSRC_A :: SERCOM3_TX ) , 10 => Val ( TRIGSRC_A :: SERCOM4_RX ) , 11 => Val ( TRIGSRC_A :: SERCOM4_TX ) , 12 => Val ( TRIGSRC_A :: SERCOM5_RX ) , 13 => Val ( TRIGSRC_A :: SERCOM5_TX ) , 14 => Val ( TRIGSRC_A :: CAN0_DEBUG ) , 15 => Val ( TRIGSRC_A :: CAN1_DEBUG ) , 16 => Val ( TRIGSRC_A :: TCC0_OVF ) , 17 => Val ( TRIGSRC_A :: TCC0_MC0 ) , 18 => Val ( TRIGSRC_A :: TCC0_MC1 ) , 19 => Val ( TRIGSRC_A :: TCC0_MC2 ) , 20 => Val ( TRIGSRC_A :: TCC0_MC3 ) , 21 => Val ( TRIGSRC_A :: TCC1_OVF ) , 22 => Val ( TRIGSRC_A :: TCC1_MC0 ) , 23 => Val ( TRIGSRC_A :: TCC1_MC1 ) , 24 => Val ( TRIGSRC_A :: TCC2_OVF ) , 25 => Val ( TRIGSRC_A :: TCC2_MC0 ) , 26 => Val ( TRIGSRC_A :: TCC2_MC1 ) , 27 => Val ( TRIGSRC_A :: TC0_OVF ) , 28 => Val ( TRIGSRC_A :: TC0_MC0 ) , 29 => Val ( TRIGSRC_A :: TC0_MC1 ) , 30 => Val ( TRIGSRC_A :: TC1_OVF ) , 31 => Val ( TRIGSRC_A :: TC1_MC0 ) , 32 => Val ( TRIGSRC_A :: TC1_MC1 ) , 33 => Val ( TRIGSRC_A :: TC2_OVF ) , 34 => Val ( TRIGSRC_A :: TC2_MC0 ) , 35 => Val ( TRIGSRC_A :: TC2_MC1 ) , 36 => Val ( TRIGSRC_A :: TC3_OVF ) , 37 => Val ( TRIGSRC_A :: TC3_MC0 ) , 38 => Val ( TRIGSRC_A :: TC3_MC1 ) , 39 => Val ( TRIGSRC_A :: TC4_OVF ) , 40 => Val ( TRIGSRC_A :: TC4_MC0 ) , 41 => Val ( TRIGSRC_A :: TC4_MC1 ) , 42 => Val ( TRIGSRC_A :: ADC0_RESRDY ) , 43 => Val ( TRIGSRC_A :: ADC1_RESRDY ) , 44 => Val ( TRIGSRC_A :: SDADC_RESRDY ) , 45 => Val ( TRIGSRC_A :: DAC_EMPTY ) , 46 => Val ( TRIGSRC_A :: PTC_EOC ) , 47 => Val ( TRIGSRC_A :: PTC_WCOMP ) , 48 => Val ( TRIGSRC_A :: PTC_SEQ ) , 49 => Val ( TRIGSRC_A :: SERCOM6_RX ) , 50 => Val ( TRIGSRC_A :: SERCOM6_TX ) , 51 => Val ( TRIGSRC_A :: SERCOM7_RX ) , 52 => Val ( TRIGSRC_A :: SERCOM7_TX ) , 53 => Val ( TRIGSRC_A :: TC5_OVF ) , 54 => Val ( TRIGSRC_A :: TC5_MC0 ) , 55 => Val ( TRIGSRC_A :: TC5_MC1 ) , 56 => Val ( TRIGSRC_A :: TC6_OVF ) , 57 => Val ( TRIGSRC_A :: TC6_MC0 ) , 58 => Val ( TRIGSRC_A :: TC6_MC1 ) , 59 => Val ( TRIGSRC_A :: TC7_OVF ) , 60 => Val ( TRIGSRC_A :: TC7_MC0 ) , 61 => Val ( TRIGSRC_A :: TC7_MC1 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == TRIGSRC_A :: DISABLE } # [ doc = "Checks if the value of the field is `TSENS`" ] # [ inline ( always ) ] pub fn is_tsens ( & self ) -> bool { * self == TRIGSRC_A :: TSENS } # [ doc = "Checks if the value of the field is `SERCOM0_RX`" ] # [ inline ( always ) ] pub fn is_sercom0_rx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM0_RX } # [ doc = "Checks if the value of the field is `SERCOM0_TX`" ] # [ inline ( always ) ] pub fn is_sercom0_tx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM0_TX } # [ doc = "Checks if the value of the field is `SERCOM1_RX`" ] # [ inline ( always ) ] pub fn is_sercom1_rx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM1_RX } # [ doc = "Checks if the value of the field is `SERCOM1_TX`" ] # [ inline ( always ) ] pub fn is_sercom1_tx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM1_TX } # [ doc = "Checks if the value of the field is `SERCOM2_RX`" ] # [ inline ( always ) ] pub fn is_sercom2_rx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM2_RX } # [ doc = "Checks if the value of the field is `SERCOM2_TX`" ] # [ inline ( always ) ] pub fn is_sercom2_tx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM2_TX } # [ doc = "Checks if the value of the field is `SERCOM3_RX`" ] # [ inline ( always ) ] pub fn is_sercom3_rx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM3_RX } # [ doc = "Checks if the value of the field is `SERCOM3_TX`" ] # [ inline ( always ) ] pub fn is_sercom3_tx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM3_TX } # [ doc = "Checks if the value of the field is `SERCOM4_RX`" ] # [ inline ( always ) ] pub fn is_sercom4_rx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM4_RX } # [ doc = "Checks if the value of the field is `SERCOM4_TX`" ] # [ inline ( always ) ] pub fn is_sercom4_tx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM4_TX } # [ doc = "Checks if the value of the field is `SERCOM5_RX`" ] # [ inline ( always ) ] pub fn is_sercom5_rx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM5_RX } # [ doc = "Checks if the value of the field is `SERCOM5_TX`" ] # [ inline ( always ) ] pub fn is_sercom5_tx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM5_TX } # [ doc = "Checks if the value of the field is `CAN0_DEBUG`" ] # [ inline ( always ) ] pub fn is_can0_debug ( & self ) -> bool { * self == TRIGSRC_A :: CAN0_DEBUG } # [ doc = "Checks if the value of the field is `CAN1_DEBUG`" ] # [ inline ( always ) ] pub fn is_can1_debug ( & self ) -> bool { * self == TRIGSRC_A :: CAN1_DEBUG } # [ doc = "Checks if the value of the field is `TCC0_OVF`" ] # [ inline ( always ) ] pub fn is_tcc0_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TCC0_OVF } # [ doc = "Checks if the value of the field is `TCC0_MC0`" ] # [ inline ( always ) ] pub fn is_tcc0_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TCC0_MC0 } # [ doc = "Checks if the value of the field is `TCC0_MC1`" ] # [ inline ( always ) ] pub fn is_tcc0_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TCC0_MC1 } # [ doc = "Checks if the value of the field is `TCC0_MC2`" ] # [ inline ( always ) ] pub fn is_tcc0_mc2 ( & self ) -> bool { * self == TRIGSRC_A :: TCC0_MC2 } # [ doc = "Checks if the value of the field is `TCC0_MC3`" ] # [ inline ( always ) ] pub fn is_tcc0_mc3 ( & self ) -> bool { * self == TRIGSRC_A :: TCC0_MC3 } # [ doc = "Checks if the value of the field is `TCC1_OVF`" ] # [ inline ( always ) ] pub fn is_tcc1_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TCC1_OVF } # [ doc = "Checks if the value of the field is `TCC1_MC0`" ] # [ inline ( always ) ] pub fn is_tcc1_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TCC1_MC0 } # [ doc = "Checks if the value of the field is `TCC1_MC1`" ] # [ inline ( always ) ] pub fn is_tcc1_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TCC1_MC1 } # [ doc = "Checks if the value of the field is `TCC2_OVF`" ] # [ inline ( always ) ] pub fn is_tcc2_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TCC2_OVF } # [ doc = "Checks if the value of the field is `TCC2_MC0`" ] # [ inline ( always ) ] pub fn is_tcc2_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TCC2_MC0 } # [ doc = "Checks if the value of the field is `TCC2_MC1`" ] # [ inline ( always ) ] pub fn is_tcc2_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TCC2_MC1 } # [ doc = "Checks if the value of the field is `TC0_OVF`" ] # [ inline ( always ) ] pub fn is_tc0_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TC0_OVF } # [ doc = "Checks if the value of the field is `TC0_MC0`" ] # [ inline ( always ) ] pub fn is_tc0_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TC0_MC0 } # [ doc = "Checks if the value of the field is `TC0_MC1`" ] # [ inline ( always ) ] pub fn is_tc0_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TC0_MC1 } # [ doc = "Checks if the value of the field is `TC1_OVF`" ] # [ inline ( always ) ] pub fn is_tc1_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TC1_OVF } # [ doc = "Checks if the value of the field is `TC1_MC0`" ] # [ inline ( always ) ] pub fn is_tc1_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TC1_MC0 } # [ doc = "Checks if the value of the field is `TC1_MC1`" ] # [ inline ( always ) ] pub fn is_tc1_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TC1_MC1 } # [ doc = "Checks if the value of the field is `TC2_OVF`" ] # [ inline ( always ) ] pub fn is_tc2_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TC2_OVF } # [ doc = "Checks if the value of the field is `TC2_MC0`" ] # [ inline ( always ) ] pub fn is_tc2_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TC2_MC0 } # [ doc = "Checks if the value of the field is `TC2_MC1`" ] # [ inline ( always ) ] pub fn is_tc2_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TC2_MC1 } # [ doc = "Checks if the value of the field is `TC3_OVF`" ] # [ inline ( always ) ] pub fn is_tc3_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TC3_OVF } # [ doc = "Checks if the value of the field is `TC3_MC0`" ] # [ inline ( always ) ] pub fn is_tc3_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TC3_MC0 } # [ doc = "Checks if the value of the field is `TC3_MC1`" ] # [ inline ( always ) ] pub fn is_tc3_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TC3_MC1 } # [ doc = "Checks if the value of the field is `TC4_OVF`" ] # [ inline ( always ) ] pub fn is_tc4_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TC4_OVF } # [ doc = "Checks if the value of the field is `TC4_MC0`" ] # [ inline ( always ) ] pub fn is_tc4_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TC4_MC0 } # [ doc = "Checks if the value of the field is `TC4_MC1`" ] # [ inline ( always ) ] pub fn is_tc4_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TC4_MC1 } # [ doc = "Checks if the value of the field is `ADC0_RESRDY`" ] # [ inline ( always ) ] pub fn is_adc0_resrdy ( & self ) -> bool { * self == TRIGSRC_A :: ADC0_RESRDY } # [ doc = "Checks if the value of the field is `ADC1_RESRDY`" ] # [ inline ( always ) ] pub fn is_adc1_resrdy ( & self ) -> bool { * self == TRIGSRC_A :: ADC1_RESRDY } # [ doc = "Checks if the value of the field is `SDADC_RESRDY`" ] # [ inline ( always ) ] pub fn is_sdadc_resrdy ( & self ) -> bool { * self == TRIGSRC_A :: SDADC_RESRDY } # [ doc = "Checks if the value of the field is `DAC_EMPTY`" ] # [ inline ( always ) ] pub fn is_dac_empty ( & self ) -> bool { * self == TRIGSRC_A :: DAC_EMPTY } # [ doc = "Checks if the value of the field is `PTC_EOC`" ] # [ inline ( always ) ] pub fn is_ptc_eoc ( & self ) -> bool { * self == TRIGSRC_A :: PTC_EOC } # [ doc = "Checks if the value of the field is `PTC_WCOMP`" ] # [ inline ( always ) ] pub fn is_ptc_wcomp ( & self ) -> bool { * self == TRIGSRC_A :: PTC_WCOMP } # [ doc = "Checks if the value of the field is `PTC_SEQ`" ] # [ inline ( always ) ] pub fn is_ptc_seq ( & self ) -> bool { * self == TRIGSRC_A :: PTC_SEQ } # [ doc = "Checks if the value of the field is `SERCOM6_RX`" ] # [ inline ( always ) ] pub fn is_sercom6_rx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM6_RX } # [ doc = "Checks if the value of the field is `SERCOM6_TX`" ] # [ inline ( always ) ] pub fn is_sercom6_tx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM6_TX } # [ doc = "Checks if the value of the field is `SERCOM7_RX`" ] # [ inline ( always ) ] pub fn is_sercom7_rx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM7_RX } # [ doc = "Checks if the value of the field is `SERCOM7_TX`" ] # [ inline ( always ) ] pub fn is_sercom7_tx ( & self ) -> bool { * self == TRIGSRC_A :: SERCOM7_TX } # [ doc = "Checks if the value of the field is `TC5_OVF`" ] # [ inline ( always ) ] pub fn is_tc5_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TC5_OVF } # [ doc = "Checks if the value of the field is `TC5_MC0`" ] # [ inline ( always ) ] pub fn is_tc5_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TC5_MC0 } # [ doc = "Checks if the value of the field is `TC5_MC1`" ] # [ inline ( always ) ] pub fn is_tc5_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TC5_MC1 } # [ doc = "Checks if the value of the field is `TC6_OVF`" ] # [ inline ( always ) ] pub fn is_tc6_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TC6_OVF } # [ doc = "Checks if the value of the field is `TC6_MC0`" ] # [ inline ( always ) ] pub fn is_tc6_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TC6_MC0 } # [ doc = "Checks if the value of the field is `TC6_MC1`" ] # [ inline ( always ) ] pub fn is_tc6_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TC6_MC1 } # [ doc = "Checks if the value of the field is `TC7_OVF`" ] # [ inline ( always ) ] pub fn is_tc7_ovf ( & self ) -> bool { * self == TRIGSRC_A :: TC7_OVF } # [ doc = "Checks if the value of the field is `TC7_MC0`" ] # [ inline ( always ) ] pub fn is_tc7_mc0 ( & self ) -> bool { * self == TRIGSRC_A :: TC7_MC0 } # [ doc = "Checks if the value of the field is `TC7_MC1`" ] # [ inline ( always ) ] pub fn is_tc7_mc1 ( & self ) -> bool { * self == TRIGSRC_A :: TC7_MC1 } }
# [ doc = "Write proxy for field `TRIGSRC`" ] pub struct TRIGSRC_W < 'a > { w : & 'a mut W , } impl < 'a > TRIGSRC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TRIGSRC_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Only software/event triggers" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: DISABLE ) } # [ doc = "TSENS Result Ready Trigger" ] # [ inline ( always ) ] pub fn tsens ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TSENS ) } # [ doc = "SERCOM0 RX Trigger" ] # [ inline ( always ) ] pub fn sercom0_rx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM0_RX ) } # [ doc = "SERCOM0 TX Trigger" ] # [ inline ( always ) ] pub fn sercom0_tx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM0_TX ) } # [ doc = "SERCOM1 RX Trigger" ] # [ inline ( always ) ] pub fn sercom1_rx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM1_RX ) } # [ doc = "SERCOM1 TX Trigger" ] # [ inline ( always ) ] pub fn sercom1_tx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM1_TX ) } # [ doc = "SERCOM2 RX Trigger" ] # [ inline ( always ) ] pub fn sercom2_rx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM2_RX ) } # [ doc = "SERCOM2 TX Trigger" ] # [ inline ( always ) ] pub fn sercom2_tx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM2_TX ) } # [ doc = "SERCOM3 RX Trigger" ] # [ inline ( always ) ] pub fn sercom3_rx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM3_RX ) } # [ doc = "SERCOM3 TX Trigger" ] # [ inline ( always ) ] pub fn sercom3_tx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM3_TX ) } # [ doc = "SERCOM4 RX Trigger" ] # [ inline ( always ) ] pub fn sercom4_rx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM4_RX ) } # [ doc = "SERCOM4 TX Trigger" ] # [ inline ( always ) ] pub fn sercom4_tx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM4_TX ) } # [ doc = "SERCOM5 RX Trigger" ] # [ inline ( always ) ] pub fn sercom5_rx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM5_RX ) } # [ doc = "SERCOM5 TX Trigger" ] # [ inline ( always ) ] pub fn sercom5_tx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM5_TX ) } # [ doc = "CAN0 Debug Trigger Reserved" ] # [ inline ( always ) ] pub fn can0_debug ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: CAN0_DEBUG ) } # [ doc = "CAN1 Debug Trigger Reserved" ] # [ inline ( always ) ] pub fn can1_debug ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: CAN1_DEBUG ) } # [ doc = "TCC0 Overflow Trigger" ] # [ inline ( always ) ] pub fn tcc0_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC0_OVF ) } # [ doc = "TCC0 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tcc0_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC0_MC0 ) } # [ doc = "TCC0 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tcc0_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC0_MC1 ) } # [ doc = "TCC0 Match/Compare 2 Trigger" ] # [ inline ( always ) ] pub fn tcc0_mc2 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC0_MC2 ) } # [ doc = "TCC0 Match/Compare 3 Trigger" ] # [ inline ( always ) ] pub fn tcc0_mc3 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC0_MC3 ) } # [ doc = "TCC1 Overflow Trigger" ] # [ inline ( always ) ] pub fn tcc1_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC1_OVF ) } # [ doc = "TCC1 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tcc1_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC1_MC0 ) } # [ doc = "TCC1 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tcc1_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC1_MC1 ) } # [ doc = "TCC2 Overflow Trigger" ] # [ inline ( always ) ] pub fn tcc2_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC2_OVF ) } # [ doc = "TCC2 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tcc2_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC2_MC0 ) } # [ doc = "TCC2 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tcc2_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TCC2_MC1 ) } # [ doc = "TC0 Overflow Trigger" ] # [ inline ( always ) ] pub fn tc0_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC0_OVF ) } # [ doc = "TC0 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tc0_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC0_MC0 ) } # [ doc = "TC0 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tc0_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC0_MC1 ) } # [ doc = "TC1 Overflow Trigger" ] # [ inline ( always ) ] pub fn tc1_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC1_OVF ) } # [ doc = "TC1 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tc1_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC1_MC0 ) } # [ doc = "TC1 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tc1_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC1_MC1 ) } # [ doc = "TC2 Overflow Trigger" ] # [ inline ( always ) ] pub fn tc2_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC2_OVF ) } # [ doc = "TC2 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tc2_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC2_MC0 ) } # [ doc = "TC2 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tc2_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC2_MC1 ) } # [ doc = "TC3 Overflow Trigger" ] # [ inline ( always ) ] pub fn tc3_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC3_OVF ) } # [ doc = "TC3 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tc3_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC3_MC0 ) } # [ doc = "TC3 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tc3_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC3_MC1 ) } # [ doc = "TC4 Overflow Trigger" ] # [ inline ( always ) ] pub fn tc4_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC4_OVF ) } # [ doc = "TC4 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tc4_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC4_MC0 ) } # [ doc = "TC4 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tc4_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC4_MC1 ) } # [ doc = "ADC0 Result Ready Trigger" ] # [ inline ( always ) ] pub fn adc0_resrdy ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: ADC0_RESRDY ) } # [ doc = "ADC1 Result Ready Trigger" ] # [ inline ( always ) ] pub fn adc1_resrdy ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: ADC1_RESRDY ) } # [ doc = "SDADC Result Ready Trigger" ] # [ inline ( always ) ] pub fn sdadc_resrdy ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SDADC_RESRDY ) } # [ doc = "DAC Empty Trigger" ] # [ inline ( always ) ] pub fn dac_empty ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: DAC_EMPTY ) } # [ doc = "PTC End of Conversion Trigger" ] # [ inline ( always ) ] pub fn ptc_eoc ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: PTC_EOC ) } # [ doc = "PTC Window Compare Trigger" ] # [ inline ( always ) ] pub fn ptc_wcomp ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: PTC_WCOMP ) } # [ doc = "PTC Sequence Trigger" ] # [ inline ( always ) ] pub fn ptc_seq ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: PTC_SEQ ) } # [ doc = "SERCOM6 RX Trigger" ] # [ inline ( always ) ] pub fn sercom6_rx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM6_RX ) } # [ doc = "SERCOM6 TX Trigger" ] # [ inline ( always ) ] pub fn sercom6_tx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM6_TX ) } # [ doc = "SERCOM7 RX Trigger" ] # [ inline ( always ) ] pub fn sercom7_rx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM7_RX ) } # [ doc = "SERCOM7 TX Trigger" ] # [ inline ( always ) ] pub fn sercom7_tx ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: SERCOM7_TX ) } # [ doc = "TC5 Overflow Trigger" ] # [ inline ( always ) ] pub fn tc5_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC5_OVF ) } # [ doc = "TC5 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tc5_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC5_MC0 ) } # [ doc = "TC5 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tc5_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC5_MC1 ) } # [ doc = "TC6 Overflow Trigger" ] # [ inline ( always ) ] pub fn tc6_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC6_OVF ) } # [ doc = "TC6 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tc6_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC6_MC0 ) } # [ doc = "TC6 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tc6_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC6_MC1 ) } # [ doc = "TC7 Overflow Trigger" ] # [ inline ( always ) ] pub fn tc7_ovf ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC7_OVF ) } # [ doc = "TC7 Match/Compare 0 Trigger" ] # [ inline ( always ) ] pub fn tc7_mc0 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC7_MC0 ) } # [ doc = "TC7 Match/Compare 1 Trigger" ] # [ inline ( always ) ] pub fn tc7_mc1 ( self ) -> & 'a mut W { self . variant ( TRIGSRC_A :: TC7_MC1 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 8 ) ) | ( ( ( value as u32 ) & 0x3f ) << 8 ) ; self . w } }
# [ doc = "Possible values of the field `TRIGACT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TRIGACT_A { # [ doc = "One trigger required for each block transfer" ] BLOCK , # [ doc = "One trigger required for each beat transfer" ] BEAT , # [ doc = "One trigger required for each transaction" ] TRANSACTION }
impl crate :: ToBits < u8 > for TRIGACT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { TRIGACT_A :: BLOCK => 0 , TRIGACT_A :: BEAT => 2 , TRIGACT_A :: TRANSACTION => 3 } } }
# [ doc = "Reader of field `TRIGACT`" ] pub type TRIGACT_R = crate :: R < u8 , TRIGACT_A > ; impl TRIGACT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , TRIGACT_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TRIGACT_A :: BLOCK ) , 2 => Val ( TRIGACT_A :: BEAT ) , 3 => Val ( TRIGACT_A :: TRANSACTION ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `BLOCK`" ] # [ inline ( always ) ] pub fn is_block ( & self ) -> bool { * self == TRIGACT_A :: BLOCK } # [ doc = "Checks if the value of the field is `BEAT`" ] # [ inline ( always ) ] pub fn is_beat ( & self ) -> bool { * self == TRIGACT_A :: BEAT } # [ doc = "Checks if the value of the field is `TRANSACTION`" ] # [ inline ( always ) ] pub fn is_transaction ( & self ) -> bool { * self == TRIGACT_A :: TRANSACTION } }
# [ doc = "Write proxy for field `TRIGACT`" ] pub struct TRIGACT_W < 'a > { w : & 'a mut W , } impl < 'a > TRIGACT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TRIGACT_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "One trigger required for each block transfer" ] # [ inline ( always ) ] pub fn block ( self ) -> & 'a mut W { self . variant ( TRIGACT_A :: BLOCK ) } # [ doc = "One trigger required for each beat transfer" ] # [ inline ( always ) ] pub fn beat ( self ) -> & 'a mut W { self . variant ( TRIGACT_A :: BEAT ) } # [ doc = "One trigger required for each transaction" ] # [ inline ( always ) ] pub fn transaction ( self ) -> & 'a mut W { self . variant ( TRIGACT_A :: TRANSACTION ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 22 ) ) | ( ( ( value as u32 ) & 0x03 ) << 22 ) ; self . w } }
# [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "No action" ] NOACT , # [ doc = "Channel suspend operation" ] SUSPEND , # [ doc = "Channel resume operation" ] RESUME }
impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: NOACT => 0 , CMD_A :: SUSPEND => 1 , CMD_A :: RESUME => 2 } } }
# [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CMD_A :: NOACT ) , 1 => Val ( CMD_A :: SUSPEND ) , 2 => Val ( CMD_A :: RESUME ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NOACT`" ] # [ inline ( always ) ] pub fn is_noact ( & self ) -> bool { * self == CMD_A :: NOACT } # [ doc = "Checks if the value of the field is `SUSPEND`" ] # [ inline ( always ) ] pub fn is_suspend ( & self ) -> bool { * self == CMD_A :: SUSPEND } # [ doc = "Checks if the value of the field is `RESUME`" ] # [ inline ( always ) ] pub fn is_resume ( & self ) -> bool { * self == CMD_A :: RESUME } }
# [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn noact ( self ) -> & 'a mut W { self . variant ( CMD_A :: NOACT ) } # [ doc = "Channel suspend operation" ] # [ inline ( always ) ] pub fn suspend ( self ) -> & 'a mut W { self . variant ( CMD_A :: SUSPEND ) } # [ doc = "Channel resume operation" ] # [ inline ( always ) ] pub fn resume ( self ) -> & 'a mut W { self . variant ( CMD_A :: RESUME ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 24 ) ) | ( ( ( value as u32 ) & 0x03 ) << 24 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Event Input Action" ] # [ inline ( always ) ] pub fn evact ( & self ) -> EVACT_R { EVACT_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bit 3 - Channel Event Input Enable" ] # [ inline ( always ) ] pub fn evie ( & self ) -> EVIE_R { EVIE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Channel Event Output Enable" ] # [ inline ( always ) ] pub fn evoe ( & self ) -> EVOE_R { EVOE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:6 - Channel Arbitration Level" ] # [ inline ( always ) ] pub fn lvl ( & self ) -> LVL_R { LVL_R :: new ( ( ( self . bits >> 5 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:13 - Trigger Source" ] # [ inline ( always ) ] pub fn trigsrc ( & self ) -> TRIGSRC_R { TRIGSRC_R :: new ( ( ( self . bits >> 8 ) & 0x3f ) as u8 ) }
# [ doc = "Bits 22:23 - Trigger Action" ] # [ inline ( always ) ] pub fn trigact ( & self ) -> TRIGACT_R { TRIGACT_R :: new ( ( ( self . bits >> 22 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 24:25 - Software Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 24 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Event Input Action" ] # [ inline ( always ) ] pub fn evact ( & mut self ) -> EVACT_W { EVACT_W { w : self } }
# [ doc = "Bit 3 - Channel Event Input Enable" ] # [ inline ( always ) ] pub fn evie ( & mut self ) -> EVIE_W { EVIE_W { w : self } }
# [ doc = "Bit 4 - Channel Event Output Enable" ] # [ inline ( always ) ] pub fn evoe ( & mut self ) -> EVOE_W { EVOE_W { w : self } }
# [ doc = "Bits 5:6 - Channel Arbitration Level" ] # [ inline ( always ) ] pub fn lvl ( & mut self ) -> LVL_W { LVL_W { w : self } }
# [ doc = "Bits 8:13 - Trigger Source" ] # [ inline ( always ) ] pub fn trigsrc ( & mut self ) -> TRIGSRC_W { TRIGSRC_W { w : self } }
# [ doc = "Bits 22:23 - Trigger Action" ] # [ inline ( always ) ] pub fn trigact ( & mut self ) -> TRIGACT_W { TRIGACT_W { w : self } }
# [ doc = "Bits 24:25 - Software Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } }
}
}
# [ doc = "Channel Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [chintenclr](chintenclr) module" ] pub type CHINTENCLR = crate :: Reg < u8 , _CHINTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CHINTENCLR ;
# [ doc = "`read()` method returns [chintenclr::R](chintenclr::R) reader structure" ] impl crate :: Readable for CHINTENCLR { }
# [ doc = "`write(|w| ..)` method takes [chintenclr::W](chintenclr::W) writer structure" ] impl crate :: Writable for CHINTENCLR { }
# [ doc = "Channel Interrupt Enable Clear" ] pub mod chintenclr {
# [ doc = "Reader of register CHINTENCLR" ] pub type R = crate :: R < u8 , super :: CHINTENCLR > ;
# [ doc = "Writer for register CHINTENCLR" ] pub type W = crate :: W < u8 , super :: CHINTENCLR > ;
# [ doc = "Register CHINTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CHINTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `TERR`" ] pub type TERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TERR`" ] pub struct TERR_W < 'a > { w : & 'a mut W , } impl < 'a > TERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `TCMPL`" ] pub type TCMPL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCMPL`" ] pub struct TCMPL_W < 'a > { w : & 'a mut W , } impl < 'a > TCMPL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `SUSP`" ] pub type SUSP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SUSP`" ] pub struct SUSP_W < 'a > { w : & 'a mut W , } impl < 'a > SUSP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Channel Transfer Error Interrupt Enable" ] # [ inline ( always ) ] pub fn terr ( & self ) -> TERR_R { TERR_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel Transfer Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn tcmpl ( & self ) -> TCMPL_R { TCMPL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel Suspend Interrupt Enable" ] # [ inline ( always ) ] pub fn susp ( & self ) -> SUSP_R { SUSP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Channel Transfer Error Interrupt Enable" ] # [ inline ( always ) ] pub fn terr ( & mut self ) -> TERR_W { TERR_W { w : self } }
# [ doc = "Bit 1 - Channel Transfer Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn tcmpl ( & mut self ) -> TCMPL_W { TCMPL_W { w : self } }
# [ doc = "Bit 2 - Channel Suspend Interrupt Enable" ] # [ inline ( always ) ] pub fn susp ( & mut self ) -> SUSP_W { SUSP_W { w : self } }
}
}
# [ doc = "Channel Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [chintenset](chintenset) module" ] pub type CHINTENSET = crate :: Reg < u8 , _CHINTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CHINTENSET ;
# [ doc = "`read()` method returns [chintenset::R](chintenset::R) reader structure" ] impl crate :: Readable for CHINTENSET { }
# [ doc = "`write(|w| ..)` method takes [chintenset::W](chintenset::W) writer structure" ] impl crate :: Writable for CHINTENSET { }
# [ doc = "Channel Interrupt Enable Set" ] pub mod chintenset {
# [ doc = "Reader of register CHINTENSET" ] pub type R = crate :: R < u8 , super :: CHINTENSET > ;
# [ doc = "Writer for register CHINTENSET" ] pub type W = crate :: W < u8 , super :: CHINTENSET > ;
# [ doc = "Register CHINTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CHINTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `TERR`" ] pub type TERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TERR`" ] pub struct TERR_W < 'a > { w : & 'a mut W , } impl < 'a > TERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `TCMPL`" ] pub type TCMPL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCMPL`" ] pub struct TCMPL_W < 'a > { w : & 'a mut W , } impl < 'a > TCMPL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `SUSP`" ] pub type SUSP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SUSP`" ] pub struct SUSP_W < 'a > { w : & 'a mut W , } impl < 'a > SUSP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Channel Transfer Error Interrupt Enable" ] # [ inline ( always ) ] pub fn terr ( & self ) -> TERR_R { TERR_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel Transfer Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn tcmpl ( & self ) -> TCMPL_R { TCMPL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel Suspend Interrupt Enable" ] # [ inline ( always ) ] pub fn susp ( & self ) -> SUSP_R { SUSP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Channel Transfer Error Interrupt Enable" ] # [ inline ( always ) ] pub fn terr ( & mut self ) -> TERR_W { TERR_W { w : self } }
# [ doc = "Bit 1 - Channel Transfer Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn tcmpl ( & mut self ) -> TCMPL_W { TCMPL_W { w : self } }
# [ doc = "Bit 2 - Channel Suspend Interrupt Enable" ] # [ inline ( always ) ] pub fn susp ( & mut self ) -> SUSP_W { SUSP_W { w : self } }
}
}
# [ doc = "Channel Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [chintflag](chintflag) module" ] pub type CHINTFLAG = crate :: Reg < u8 , _CHINTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CHINTFLAG ;
# [ doc = "`read()` method returns [chintflag::R](chintflag::R) reader structure" ] impl crate :: Readable for CHINTFLAG { }
# [ doc = "`write(|w| ..)` method takes [chintflag::W](chintflag::W) writer structure" ] impl crate :: Writable for CHINTFLAG { }
# [ doc = "Channel Interrupt Flag Status and Clear" ] pub mod chintflag {
# [ doc = "Reader of register CHINTFLAG" ] pub type R = crate :: R < u8 , super :: CHINTFLAG > ;
# [ doc = "Writer for register CHINTFLAG" ] pub type W = crate :: W < u8 , super :: CHINTFLAG > ;
# [ doc = "Register CHINTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CHINTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `TERR`" ] pub type TERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TERR`" ] pub struct TERR_W < 'a > { w : & 'a mut W , } impl < 'a > TERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `TCMPL`" ] pub type TCMPL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCMPL`" ] pub struct TCMPL_W < 'a > { w : & 'a mut W , } impl < 'a > TCMPL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `SUSP`" ] pub type SUSP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SUSP`" ] pub struct SUSP_W < 'a > { w : & 'a mut W , } impl < 'a > SUSP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Channel Transfer Error" ] # [ inline ( always ) ] pub fn terr ( & self ) -> TERR_R { TERR_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel Transfer Complete" ] # [ inline ( always ) ] pub fn tcmpl ( & self ) -> TCMPL_R { TCMPL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel Suspend" ] # [ inline ( always ) ] pub fn susp ( & self ) -> SUSP_R { SUSP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Channel Transfer Error" ] # [ inline ( always ) ] pub fn terr ( & mut self ) -> TERR_W { TERR_W { w : self } }
# [ doc = "Bit 1 - Channel Transfer Complete" ] # [ inline ( always ) ] pub fn tcmpl ( & mut self ) -> TCMPL_W { TCMPL_W { w : self } }
# [ doc = "Bit 2 - Channel Suspend" ] # [ inline ( always ) ] pub fn susp ( & mut self ) -> SUSP_W { SUSP_W { w : self } }
}
}
# [ doc = "Channel Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [chstatus](chstatus) module" ] pub type CHSTATUS = crate :: Reg < u8 , _CHSTATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CHSTATUS ;
# [ doc = "`read()` method returns [chstatus::R](chstatus::R) reader structure" ] impl crate :: Readable for CHSTATUS { }
# [ doc = "Channel Status" ] pub mod chstatus {
# [ doc = "Reader of register CHSTATUS" ] pub type R = crate :: R < u8 , super :: CHSTATUS > ;
# [ doc = "Reader of field `PEND`" ] pub type PEND_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BUSY`" ] pub type BUSY_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `FERR`" ] pub type FERR_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Channel Pending" ] # [ inline ( always ) ] pub fn pend ( & self ) -> PEND_R { PEND_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel Busy" ] # [ inline ( always ) ] pub fn busy ( & self ) -> BUSY_R { BUSY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel Fetch Error" ] # [ inline ( always ) ] pub fn ferr ( & self ) -> FERR_R { FERR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
}
}
# [ doc = "Device Service Unit" ] pub struct DSU { _marker : PhantomData < * const ( ) > } unsafe impl Send for DSU { } impl DSU { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const dsu :: RegisterBlock { 0x4100_2000 as * const _ } } impl Deref for DSU { type Target = dsu :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * DSU :: ptr ( ) } } }
# [ doc = "Device Service Unit" ] pub mod dsu {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control" ] pub ctrl : CTRL , # [ doc = "0x01 - Status A" ] pub statusa : STATUSA , # [ doc = "0x02 - Status B" ] pub statusb : STATUSB , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x04 - Address" ] pub addr : ADDR , # [ doc = "0x08 - Length" ] pub length : LENGTH , # [ doc = "0x0c - Data" ] pub data : DATA , # [ doc = "0x10 - Debug Communication Channel n" ] pub dcc : [ DCC ; 2 ] , # [ doc = "0x18 - Device Identification" ] pub did : DID , _reserved8 : [ u8 ; 212usize ] , # [ doc = "0xf0 - Device Configuration" ] pub dcfg : [ DCFG ; 2 ] , _reserved9 : [ u8 ; 3848usize ] , # [ doc = "0x1000 - CoreSight ROM Table Entry 0" ] pub entry0 : ENTRY0 , # [ doc = "0x1004 - CoreSight ROM Table Entry 1" ] pub entry1 : ENTRY1 , # [ doc = "0x1008 - CoreSight ROM Table End" ] pub end : END , _reserved12 : [ u8 ; 4032usize ] , # [ doc = "0x1fcc - CoreSight ROM Table Memory Type" ] pub memtype : MEMTYPE , # [ doc = "0x1fd0 - Peripheral Identification 4" ] pub pid4 : PID4 , # [ doc = "0x1fd4 - Peripheral Identification 5" ] pub pid5 : PID5 , # [ doc = "0x1fd8 - Peripheral Identification 6" ] pub pid6 : PID6 , # [ doc = "0x1fdc - Peripheral Identification 7" ] pub pid7 : PID7 , # [ doc = "0x1fe0 - Peripheral Identification 0" ] pub pid0 : PID0 , # [ doc = "0x1fe4 - Peripheral Identification 1" ] pub pid1 : PID1 , # [ doc = "0x1fe8 - Peripheral Identification 2" ] pub pid2 : PID2 , # [ doc = "0x1fec - Peripheral Identification 3" ] pub pid3 : PID3 , # [ doc = "0x1ff0 - Component Identification 0" ] pub cid0 : CID0 , # [ doc = "0x1ff4 - Component Identification 1" ] pub cid1 : CID1 , # [ doc = "0x1ff8 - Component Identification 2" ] pub cid2 : CID2 , # [ doc = "0x1ffc - Component Identification 3" ] pub cid3 : CID3 , }
# [ doc = "Control\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrl](ctrl) module" ] pub type CTRL = crate :: Reg < u8 , _CTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRL ;
# [ doc = "`write(|w| ..)` method takes [ctrl::W](ctrl::W) writer structure" ] impl crate :: Writable for CTRL { }
# [ doc = "Control" ] pub mod ctrl {
# [ doc = "Writer for register CTRL" ] pub type W = crate :: W < u8 , super :: CTRL > ;
# [ doc = "Register CTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Write proxy for field `CRC`" ] pub struct CRC_W < 'a > { w : & 'a mut W , } impl < 'a > CRC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Write proxy for field `MBIST`" ] pub struct MBIST_W < 'a > { w : & 'a mut W , } impl < 'a > MBIST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Write proxy for field `CE`" ] pub struct CE_W < 'a > { w : & 'a mut W , } impl < 'a > CE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Write proxy for field `ARR`" ] pub struct ARR_W < 'a > { w : & 'a mut W , } impl < 'a > ARR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Write proxy for field `SMSA`" ] pub struct SMSA_W < 'a > { w : & 'a mut W , } impl < 'a > SMSA_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 2 - 32-bit Cyclic Redundancy Code" ] # [ inline ( always ) ] pub fn crc ( & mut self ) -> CRC_W { CRC_W { w : self } }
# [ doc = "Bit 3 - Memory built-in self-test" ] # [ inline ( always ) ] pub fn mbist ( & mut self ) -> MBIST_W { MBIST_W { w : self } }
# [ doc = "Bit 4 - Chip-Erase" ] # [ inline ( always ) ] pub fn ce ( & mut self ) -> CE_W { CE_W { w : self } }
# [ doc = "Bit 6 - Auxiliary Row Read" ] # [ inline ( always ) ] pub fn arr ( & mut self ) -> ARR_W { ARR_W { w : self } }
# [ doc = "Bit 7 - Start Memory Stream Access" ] # [ inline ( always ) ] pub fn smsa ( & mut self ) -> SMSA_W { SMSA_W { w : self } }
}
}
# [ doc = "Status A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [statusa](statusa) module" ] pub type STATUSA = crate :: Reg < u8 , _STATUSA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUSA ;
# [ doc = "`read()` method returns [statusa::R](statusa::R) reader structure" ] impl crate :: Readable for STATUSA { }
# [ doc = "`write(|w| ..)` method takes [statusa::W](statusa::W) writer structure" ] impl crate :: Writable for STATUSA { }
# [ doc = "Status A" ] pub mod statusa {
# [ doc = "Reader of register STATUSA" ] pub type R = crate :: R < u8 , super :: STATUSA > ;
# [ doc = "Writer for register STATUSA" ] pub type W = crate :: W < u8 , super :: STATUSA > ;
# [ doc = "Register STATUSA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUSA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DONE`" ] pub type DONE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DONE`" ] pub struct DONE_W < 'a > { w : & 'a mut W , } impl < 'a > DONE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `CRSTEXT`" ] pub type CRSTEXT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CRSTEXT`" ] pub struct CRSTEXT_W < 'a > { w : & 'a mut W , } impl < 'a > CRSTEXT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `BERR`" ] pub type BERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BERR`" ] pub struct BERR_W < 'a > { w : & 'a mut W , } impl < 'a > BERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `FAIL`" ] pub type FAIL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAIL`" ] pub struct FAIL_W < 'a > { w : & 'a mut W , } impl < 'a > FAIL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `PERR`" ] pub type PERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PERR`" ] pub struct PERR_W < 'a > { w : & 'a mut W , } impl < 'a > PERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Done" ] # [ inline ( always ) ] pub fn done ( & self ) -> DONE_R { DONE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - CPU Reset Phase Extension" ] # [ inline ( always ) ] pub fn crstext ( & self ) -> CRSTEXT_R { CRSTEXT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Bus Error" ] # [ inline ( always ) ] pub fn berr ( & self ) -> BERR_R { BERR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Failure" ] # [ inline ( always ) ] pub fn fail ( & self ) -> FAIL_R { FAIL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Protection Error" ] # [ inline ( always ) ] pub fn perr ( & self ) -> PERR_R { PERR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Done" ] # [ inline ( always ) ] pub fn done ( & mut self ) -> DONE_W { DONE_W { w : self } }
# [ doc = "Bit 1 - CPU Reset Phase Extension" ] # [ inline ( always ) ] pub fn crstext ( & mut self ) -> CRSTEXT_W { CRSTEXT_W { w : self } }
# [ doc = "Bit 2 - Bus Error" ] # [ inline ( always ) ] pub fn berr ( & mut self ) -> BERR_W { BERR_W { w : self } }
# [ doc = "Bit 3 - Failure" ] # [ inline ( always ) ] pub fn fail ( & mut self ) -> FAIL_W { FAIL_W { w : self } }
# [ doc = "Bit 4 - Protection Error" ] # [ inline ( always ) ] pub fn perr ( & mut self ) -> PERR_W { PERR_W { w : self } }
}
}
# [ doc = "Status B\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [statusb](statusb) module" ] pub type STATUSB = crate :: Reg < u8 , _STATUSB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUSB ;
# [ doc = "`read()` method returns [statusb::R](statusb::R) reader structure" ] impl crate :: Readable for STATUSB { }
# [ doc = "Status B" ] pub mod statusb {
# [ doc = "Reader of register STATUSB" ] pub type R = crate :: R < u8 , super :: STATUSB > ;
# [ doc = "Reader of field `PROT`" ] pub type PROT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DBGPRES`" ] pub type DBGPRES_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DCCD0`" ] pub type DCCD0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DCCD1`" ] pub type DCCD1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `HPE`" ] pub type HPE_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Protected" ] # [ inline ( always ) ] pub fn prot ( & self ) -> PROT_R { PROT_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Debugger Present" ] # [ inline ( always ) ] pub fn dbgpres ( & self ) -> DBGPRES_R { DBGPRES_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Debug Communication Channel 0 Dirty" ] # [ inline ( always ) ] pub fn dccd0 ( & self ) -> DCCD0_R { DCCD0_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Debug Communication Channel 1 Dirty" ] # [ inline ( always ) ] pub fn dccd1 ( & self ) -> DCCD1_R { DCCD1_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Hot-Plugging Enable" ] # [ inline ( always ) ] pub fn hpe ( & self ) -> HPE_R { HPE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [addr](addr) module" ] pub type ADDR = crate :: Reg < u32 , _ADDR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADDR ;
# [ doc = "`read()` method returns [addr::R](addr::R) reader structure" ] impl crate :: Readable for ADDR { }
# [ doc = "`write(|w| ..)` method takes [addr::W](addr::W) writer structure" ] impl crate :: Writable for ADDR { }
# [ doc = "Address" ] pub mod addr {
# [ doc = "Reader of register ADDR" ] pub type R = crate :: R < u32 , super :: ADDR > ;
# [ doc = "Writer for register ADDR" ] pub type W = crate :: W < u32 , super :: ADDR > ;
# [ doc = "Register ADDR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADDR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `AMOD`" ] pub type AMOD_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `AMOD`" ] pub struct AMOD_W < 'a > { w : & 'a mut W , } impl < 'a > AMOD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `ADDR`" ] pub type ADDR_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `ADDR`" ] pub struct ADDR_W < 'a > { w : & 'a mut W , } impl < 'a > ADDR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3fff_ffff << 2 ) ) | ( ( ( value as u32 ) & 0x3fff_ffff ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Access Mode" ] # [ inline ( always ) ] pub fn amod ( & self ) -> AMOD_R { AMOD_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 2:31 - Address" ] # [ inline ( always ) ] pub fn addr ( & self ) -> ADDR_R { ADDR_R :: new ( ( ( self . bits >> 2 ) & 0x3fff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:1 - Access Mode" ] # [ inline ( always ) ] pub fn amod ( & mut self ) -> AMOD_W { AMOD_W { w : self } }
# [ doc = "Bits 2:31 - Address" ] # [ inline ( always ) ] pub fn addr ( & mut self ) -> ADDR_W { ADDR_W { w : self } }
}
}
# [ doc = "Length\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [length](length) module" ] pub type LENGTH = crate :: Reg < u32 , _LENGTH > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _LENGTH ;
# [ doc = "`read()` method returns [length::R](length::R) reader structure" ] impl crate :: Readable for LENGTH { }
# [ doc = "`write(|w| ..)` method takes [length::W](length::W) writer structure" ] impl crate :: Writable for LENGTH { }
# [ doc = "Length" ] pub mod length {
# [ doc = "Reader of register LENGTH" ] pub type R = crate :: R < u32 , super :: LENGTH > ;
# [ doc = "Writer for register LENGTH" ] pub type W = crate :: W < u32 , super :: LENGTH > ;
# [ doc = "Register LENGTH `reset()`'s with value 0" ] impl crate :: ResetValue for super :: LENGTH { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `LENGTH`" ] pub type LENGTH_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `LENGTH`" ] pub struct LENGTH_W < 'a > { w : & 'a mut W , } impl < 'a > LENGTH_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3fff_ffff << 2 ) ) | ( ( ( value as u32 ) & 0x3fff_ffff ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bits 2:31 - Length" ] # [ inline ( always ) ] pub fn length ( & self ) -> LENGTH_R { LENGTH_R :: new ( ( ( self . bits >> 2 ) & 0x3fff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 2:31 - Length" ] # [ inline ( always ) ] pub fn length ( & mut self ) -> LENGTH_W { LENGTH_W { w : self } }
}
}
# [ doc = "Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [data](data) module" ] pub type DATA = crate :: Reg < u32 , _DATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DATA ;
# [ doc = "`read()` method returns [data::R](data::R) reader structure" ] impl crate :: Readable for DATA { }
# [ doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure" ] impl crate :: Writable for DATA { }
# [ doc = "Data" ] pub mod data {
# [ doc = "Reader of register DATA" ] pub type R = crate :: R < u32 , super :: DATA > ;
# [ doc = "Writer for register DATA" ] pub type W = crate :: W < u32 , super :: DATA > ;
# [ doc = "Register DATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DATA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DATA`" ] pub type DATA_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `DATA`" ] pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - Data" ] # [ inline ( always ) ] pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - Data" ] # [ inline ( always ) ] pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } }
}
}
# [ doc = "Debug Communication Channel n\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dcc](dcc) module" ] pub type DCC = crate :: Reg < u32 , _DCC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DCC ;
# [ doc = "`read()` method returns [dcc::R](dcc::R) reader structure" ] impl crate :: Readable for DCC { }
# [ doc = "`write(|w| ..)` method takes [dcc::W](dcc::W) writer structure" ] impl crate :: Writable for DCC { }
# [ doc = "Debug Communication Channel n" ] pub mod dcc {
# [ doc = "Reader of register DCC[%s]" ] pub type R = crate :: R < u32 , super :: DCC > ;
# [ doc = "Writer for register DCC[%s]" ] pub type W = crate :: W < u32 , super :: DCC > ;
# [ doc = "Register DCC[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DCC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DATA`" ] pub type DATA_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `DATA`" ] pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - Data" ] # [ inline ( always ) ] pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - Data" ] # [ inline ( always ) ] pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } }
}
}
# [ doc = "Device Identification\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [did](did) module" ] pub type DID = crate :: Reg < u32 , _DID > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DID ;
# [ doc = "`read()` method returns [did::R](did::R) reader structure" ] impl crate :: Readable for DID { }
# [ doc = "Device Identification" ] pub mod did {
# [ doc = "Reader of register DID" ] pub type R = crate :: R < u32 , super :: DID > ;
# [ doc = "Reader of field `DEVSEL`" ] pub type DEVSEL_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `REVISION`" ] pub type REVISION_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `DIE`" ] pub type DIE_R = crate :: R < u8 , u8 > ;
# [ doc = "Possible values of the field `SERIES`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SERIES_A { # [ doc = "Cortex-M0+ processor, basic feature set" ] _0 , # [ doc = "Cortex-M0+ processor, USB" ] _1 }
impl crate :: ToBits < u8 > for SERIES_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SERIES_A :: _0 => 0 , SERIES_A :: _1 => 1 } } }
# [ doc = "Reader of field `SERIES`" ] pub type SERIES_R = crate :: R < u8 , SERIES_A > ; impl SERIES_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SERIES_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SERIES_A :: _0 ) , 1 => Val ( SERIES_A :: _1 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_0`" ] # [ inline ( always ) ] pub fn is_0 ( & self ) -> bool { * self == SERIES_A :: _0 } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == SERIES_A :: _1 } }
# [ doc = "Possible values of the field `FAMILY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FAMILY_A { # [ doc = "General purpose microcontroller" ] _0 , # [ doc = "PicoPower" ] _1 , # [ doc = "5V Industrial" ] _2 }
impl crate :: ToBits < u8 > for FAMILY_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { FAMILY_A :: _0 => 0 , FAMILY_A :: _1 => 1 , FAMILY_A :: _2 => 2 } } }
# [ doc = "Reader of field `FAMILY`" ] pub type FAMILY_R = crate :: R < u8 , FAMILY_A > ; impl FAMILY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , FAMILY_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( FAMILY_A :: _0 ) , 1 => Val ( FAMILY_A :: _1 ) , 2 => Val ( FAMILY_A :: _2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_0`" ] # [ inline ( always ) ] pub fn is_0 ( & self ) -> bool { * self == FAMILY_A :: _0 } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == FAMILY_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == FAMILY_A :: _2 } }
# [ doc = "Possible values of the field `PROCESSOR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PROCESSOR_A { # [ doc = "Cortex-M0" ] _0 , # [ doc = "Cortex-M0+" ] _1 , # [ doc = "Cortex-M3" ] _2 , # [ doc = "Cortex-M4" ] _3 }
impl crate :: ToBits < u8 > for PROCESSOR_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PROCESSOR_A :: _0 => 0 , PROCESSOR_A :: _1 => 1 , PROCESSOR_A :: _2 => 2 , PROCESSOR_A :: _3 => 3 } } }
# [ doc = "Reader of field `PROCESSOR`" ] pub type PROCESSOR_R = crate :: R < u8 , PROCESSOR_A > ; impl PROCESSOR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PROCESSOR_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PROCESSOR_A :: _0 ) , 1 => Val ( PROCESSOR_A :: _1 ) , 2 => Val ( PROCESSOR_A :: _2 ) , 3 => Val ( PROCESSOR_A :: _3 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_0`" ] # [ inline ( always ) ] pub fn is_0 ( & self ) -> bool { * self == PROCESSOR_A :: _0 } # [ doc = "Checks if the value of the field is `_1`" ] # [ inline ( always ) ] pub fn is_1 ( & self ) -> bool { * self == PROCESSOR_A :: _1 } # [ doc = "Checks if the value of the field is `_2`" ] # [ inline ( always ) ] pub fn is_2 ( & self ) -> bool { * self == PROCESSOR_A :: _2 } # [ doc = "Checks if the value of the field is `_3`" ] # [ inline ( always ) ] pub fn is_3 ( & self ) -> bool { * self == PROCESSOR_A :: _3 } }
impl R {
# [ doc = "Bits 0:7 - Device Select" ] # [ inline ( always ) ] pub fn devsel ( & self ) -> DEVSEL_R { DEVSEL_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bits 8:11 - Revision Number" ] # [ inline ( always ) ] pub fn revision ( & self ) -> REVISION_R { REVISION_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 12:15 - Die Number" ] # [ inline ( always ) ] pub fn die ( & self ) -> DIE_R { DIE_R :: new ( ( ( self . bits >> 12 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 16:21 - Series" ] # [ inline ( always ) ] pub fn series ( & self ) -> SERIES_R { SERIES_R :: new ( ( ( self . bits >> 16 ) & 0x3f ) as u8 ) }
# [ doc = "Bits 23:27 - Family" ] # [ inline ( always ) ] pub fn family ( & self ) -> FAMILY_R { FAMILY_R :: new ( ( ( self . bits >> 23 ) & 0x1f ) as u8 ) }
# [ doc = "Bits 28:31 - Processor" ] # [ inline ( always ) ] pub fn processor ( & self ) -> PROCESSOR_R { PROCESSOR_R :: new ( ( ( self . bits >> 28 ) & 0x0f ) as u8 ) }
}
}
# [ doc = "Device Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dcfg](dcfg) module" ] pub type DCFG = crate :: Reg < u32 , _DCFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DCFG ;
# [ doc = "`read()` method returns [dcfg::R](dcfg::R) reader structure" ] impl crate :: Readable for DCFG { }
# [ doc = "`write(|w| ..)` method takes [dcfg::W](dcfg::W) writer structure" ] impl crate :: Writable for DCFG { }
# [ doc = "Device Configuration" ] pub mod dcfg {
# [ doc = "Reader of register DCFG[%s]" ] pub type R = crate :: R < u32 , super :: DCFG > ;
# [ doc = "Writer for register DCFG[%s]" ] pub type W = crate :: W < u32 , super :: DCFG > ;
# [ doc = "Register DCFG[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DCFG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DCFG`" ] pub type DCFG_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `DCFG`" ] pub struct DCFG_W < 'a > { w : & 'a mut W , } impl < 'a > DCFG_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - Device Configuration" ] # [ inline ( always ) ] pub fn dcfg ( & self ) -> DCFG_R { DCFG_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - Device Configuration" ] # [ inline ( always ) ] pub fn dcfg ( & mut self ) -> DCFG_W { DCFG_W { w : self } }
}
}
# [ doc = "CoreSight ROM Table Entry 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [entry0](entry0) module" ] pub type ENTRY0 = crate :: Reg < u32 , _ENTRY0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ENTRY0 ;
# [ doc = "`read()` method returns [entry0::R](entry0::R) reader structure" ] impl crate :: Readable for ENTRY0 { }
# [ doc = "CoreSight ROM Table Entry 0" ] pub mod entry0 {
# [ doc = "Reader of register ENTRY0" ] pub type R = crate :: R < u32 , super :: ENTRY0 > ;
# [ doc = "Reader of field `EPRES`" ] pub type EPRES_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `FMT`" ] pub type FMT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ADDOFF`" ] pub type ADDOFF_R = crate :: R < u32 , u32 > ;
impl R {
# [ doc = "Bit 0 - Entry Present" ] # [ inline ( always ) ] pub fn epres ( & self ) -> EPRES_R { EPRES_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Format" ] # [ inline ( always ) ] pub fn fmt ( & self ) -> FMT_R { FMT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:31 - Address Offset" ] # [ inline ( always ) ] pub fn addoff ( & self ) -> ADDOFF_R { ADDOFF_R :: new ( ( ( self . bits >> 12 ) & 0x000f_ffff ) as u32 ) }
}
}
# [ doc = "CoreSight ROM Table Entry 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [entry1](entry1) module" ] pub type ENTRY1 = crate :: Reg < u32 , _ENTRY1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ENTRY1 ;
# [ doc = "`read()` method returns [entry1::R](entry1::R) reader structure" ] impl crate :: Readable for ENTRY1 { }
# [ doc = "CoreSight ROM Table Entry 1" ] pub mod entry1 {
# [ doc = "Reader of register ENTRY1" ] pub type R = crate :: R < u32 , super :: ENTRY1 > ;
impl R {
}
}
# [ doc = "CoreSight ROM Table End\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [end](end) module" ] pub type END = crate :: Reg < u32 , _END > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _END ;
# [ doc = "`read()` method returns [end::R](end::R) reader structure" ] impl crate :: Readable for END { }
# [ doc = "CoreSight ROM Table End" ] pub mod end {
# [ doc = "Reader of register END" ] pub type R = crate :: R < u32 , super :: END > ;
# [ doc = "Reader of field `END`" ] pub type END_R = crate :: R < u32 , u32 > ;
impl R {
# [ doc = "Bits 0:31 - End Marker" ] # [ inline ( always ) ] pub fn end ( & self ) -> END_R { END_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
}
# [ doc = "CoreSight ROM Table Memory Type\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [memtype](memtype) module" ] pub type MEMTYPE = crate :: Reg < u32 , _MEMTYPE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MEMTYPE ;
# [ doc = "`read()` method returns [memtype::R](memtype::R) reader structure" ] impl crate :: Readable for MEMTYPE { }
# [ doc = "CoreSight ROM Table Memory Type" ] pub mod memtype {
# [ doc = "Reader of register MEMTYPE" ] pub type R = crate :: R < u32 , super :: MEMTYPE > ;
# [ doc = "Reader of field `SMEMP`" ] pub type SMEMP_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - System Memory Present" ] # [ inline ( always ) ] pub fn smemp ( & self ) -> SMEMP_R { SMEMP_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
}
# [ doc = "Peripheral Identification 4\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid4](pid4) module" ] pub type PID4 = crate :: Reg < u32 , _PID4 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID4 ;
# [ doc = "`read()` method returns [pid4::R](pid4::R) reader structure" ] impl crate :: Readable for PID4 { }
# [ doc = "Peripheral Identification 4" ] pub mod pid4 {
# [ doc = "Reader of register PID4" ] pub type R = crate :: R < u32 , super :: PID4 > ;
# [ doc = "Reader of field `JEPCC`" ] pub type JEPCC_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `FKBC`" ] pub type FKBC_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:3 - JEP-106 Continuation Code" ] # [ inline ( always ) ] pub fn jepcc ( & self ) -> JEPCC_R { JEPCC_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:7 - 4KB count" ] # [ inline ( always ) ] pub fn fkbc ( & self ) -> FKBC_R { FKBC_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
}
}
# [ doc = "Peripheral Identification 5\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid5](pid5) module" ] pub type PID5 = crate :: Reg < u32 , _PID5 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID5 ;
# [ doc = "`read()` method returns [pid5::R](pid5::R) reader structure" ] impl crate :: Readable for PID5 { }
# [ doc = "Peripheral Identification 5" ] pub mod pid5 {
# [ doc = "Reader of register PID5" ] pub type R = crate :: R < u32 , super :: PID5 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 6\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid6](pid6) module" ] pub type PID6 = crate :: Reg < u32 , _PID6 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID6 ;
# [ doc = "`read()` method returns [pid6::R](pid6::R) reader structure" ] impl crate :: Readable for PID6 { }
# [ doc = "Peripheral Identification 6" ] pub mod pid6 {
# [ doc = "Reader of register PID6" ] pub type R = crate :: R < u32 , super :: PID6 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 7\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid7](pid7) module" ] pub type PID7 = crate :: Reg < u32 , _PID7 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID7 ;
# [ doc = "`read()` method returns [pid7::R](pid7::R) reader structure" ] impl crate :: Readable for PID7 { }
# [ doc = "Peripheral Identification 7" ] pub mod pid7 {
# [ doc = "Reader of register PID7" ] pub type R = crate :: R < u32 , super :: PID7 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid0](pid0) module" ] pub type PID0 = crate :: Reg < u32 , _PID0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID0 ;
# [ doc = "`read()` method returns [pid0::R](pid0::R) reader structure" ] impl crate :: Readable for PID0 { }
# [ doc = "Peripheral Identification 0" ] pub mod pid0 {
# [ doc = "Reader of register PID0" ] pub type R = crate :: R < u32 , super :: PID0 > ;
# [ doc = "Reader of field `PARTNBL`" ] pub type PARTNBL_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Part Number Low" ] # [ inline ( always ) ] pub fn partnbl ( & self ) -> PARTNBL_R { PARTNBL_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "Peripheral Identification 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid1](pid1) module" ] pub type PID1 = crate :: Reg < u32 , _PID1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID1 ;
# [ doc = "`read()` method returns [pid1::R](pid1::R) reader structure" ] impl crate :: Readable for PID1 { }
# [ doc = "Peripheral Identification 1" ] pub mod pid1 {
# [ doc = "Reader of register PID1" ] pub type R = crate :: R < u32 , super :: PID1 > ;
# [ doc = "Reader of field `PARTNBH`" ] pub type PARTNBH_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `JEPIDCL`" ] pub type JEPIDCL_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:3 - Part Number High" ] # [ inline ( always ) ] pub fn partnbh ( & self ) -> PARTNBH_R { PARTNBH_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:7 - Low part of the JEP-106 Identity Code" ] # [ inline ( always ) ] pub fn jepidcl ( & self ) -> JEPIDCL_R { JEPIDCL_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
}
}
# [ doc = "Peripheral Identification 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid2](pid2) module" ] pub type PID2 = crate :: Reg < u32 , _PID2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID2 ;
# [ doc = "`read()` method returns [pid2::R](pid2::R) reader structure" ] impl crate :: Readable for PID2 { }
# [ doc = "Peripheral Identification 2" ] pub mod pid2 {
# [ doc = "Reader of register PID2" ] pub type R = crate :: R < u32 , super :: PID2 > ;
# [ doc = "Reader of field `JEPIDCH`" ] pub type JEPIDCH_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `JEPU`" ] pub type JEPU_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `REVISION`" ] pub type REVISION_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:2 - JEP-106 Identity Code High" ] # [ inline ( always ) ] pub fn jepidch ( & self ) -> JEPIDCH_R { JEPIDCH_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bit 3 - JEP-106 Identity Code is used" ] # [ inline ( always ) ] pub fn jepu ( & self ) -> JEPU_R { JEPU_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:7 - Revision Number" ] # [ inline ( always ) ] pub fn revision ( & self ) -> REVISION_R { REVISION_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
}
}
# [ doc = "Peripheral Identification 3\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid3](pid3) module" ] pub type PID3 = crate :: Reg < u32 , _PID3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID3 ;
# [ doc = "`read()` method returns [pid3::R](pid3::R) reader structure" ] impl crate :: Readable for PID3 { }
# [ doc = "Peripheral Identification 3" ] pub mod pid3 {
# [ doc = "Reader of register PID3" ] pub type R = crate :: R < u32 , super :: PID3 > ;
# [ doc = "Reader of field `CUSMOD`" ] pub type CUSMOD_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `REVAND`" ] pub type REVAND_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:3 - ARM CUSMOD" ] # [ inline ( always ) ] pub fn cusmod ( & self ) -> CUSMOD_R { CUSMOD_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:7 - Revision Number" ] # [ inline ( always ) ] pub fn revand ( & self ) -> REVAND_R { REVAND_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
}
}
# [ doc = "Component Identification 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cid0](cid0) module" ] pub type CID0 = crate :: Reg < u32 , _CID0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CID0 ;
# [ doc = "`read()` method returns [cid0::R](cid0::R) reader structure" ] impl crate :: Readable for CID0 { }
# [ doc = "Component Identification 0" ] pub mod cid0 {
# [ doc = "Reader of register CID0" ] pub type R = crate :: R < u32 , super :: CID0 > ;
# [ doc = "Reader of field `PREAMBLEB0`" ] pub type PREAMBLEB0_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Preamble Byte 0" ] # [ inline ( always ) ] pub fn preambleb0 ( & self ) -> PREAMBLEB0_R { PREAMBLEB0_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "Component Identification 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cid1](cid1) module" ] pub type CID1 = crate :: Reg < u32 , _CID1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CID1 ;
# [ doc = "`read()` method returns [cid1::R](cid1::R) reader structure" ] impl crate :: Readable for CID1 { }
# [ doc = "Component Identification 1" ] pub mod cid1 {
# [ doc = "Reader of register CID1" ] pub type R = crate :: R < u32 , super :: CID1 > ;
# [ doc = "Reader of field `PREAMBLE`" ] pub type PREAMBLE_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `CCLASS`" ] pub type CCLASS_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:3 - Preamble" ] # [ inline ( always ) ] pub fn preamble ( & self ) -> PREAMBLE_R { PREAMBLE_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:7 - Component Class" ] # [ inline ( always ) ] pub fn cclass ( & self ) -> CCLASS_R { CCLASS_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
}
}
# [ doc = "Component Identification 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cid2](cid2) module" ] pub type CID2 = crate :: Reg < u32 , _CID2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CID2 ;
# [ doc = "`read()` method returns [cid2::R](cid2::R) reader structure" ] impl crate :: Readable for CID2 { }
# [ doc = "Component Identification 2" ] pub mod cid2 {
# [ doc = "Reader of register CID2" ] pub type R = crate :: R < u32 , super :: CID2 > ;
# [ doc = "Reader of field `PREAMBLEB2`" ] pub type PREAMBLEB2_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Preamble Byte 2" ] # [ inline ( always ) ] pub fn preambleb2 ( & self ) -> PREAMBLEB2_R { PREAMBLEB2_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
# [ doc = "Component Identification 3\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cid3](cid3) module" ] pub type CID3 = crate :: Reg < u32 , _CID3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CID3 ;
# [ doc = "`read()` method returns [cid3::R](cid3::R) reader structure" ] impl crate :: Readable for CID3 { }
# [ doc = "Component Identification 3" ] pub mod cid3 {
# [ doc = "Reader of register CID3" ] pub type R = crate :: R < u32 , super :: CID3 > ;
# [ doc = "Reader of field `PREAMBLEB3`" ] pub type PREAMBLEB3_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:7 - Preamble Byte 3" ] # [ inline ( always ) ] pub fn preambleb3 ( & self ) -> PREAMBLEB3_R { PREAMBLEB3_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
}
}
# [ doc = "External Interrupt Controller" ] pub struct EIC { _marker : PhantomData < * const ( ) > } unsafe impl Send for EIC { } impl EIC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const eic :: RegisterBlock { 0x4000_2800 as * const _ } } impl Deref for EIC { type Target = eic :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * EIC :: ptr ( ) } } }
# [ doc = "External Interrupt Controller" ] pub mod eic {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control A" ] pub ctrla : CTRLA , # [ doc = "0x01 - Non-Maskable Interrupt Control" ] pub nmictrl : NMICTRL , # [ doc = "0x02 - Non-Maskable Interrupt Flag Status and Clear" ] pub nmiflag : NMIFLAG , # [ doc = "0x04 - Synchronization Busy" ] pub syncbusy : SYNCBUSY , # [ doc = "0x08 - Event Control" ] pub evctrl : EVCTRL , # [ doc = "0x0c - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x10 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x14 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x18 - External Interrupt Asynchronous Mode" ] pub asynch : ASYNCH , # [ doc = "0x1c - External Interrupt Sense Configuration" ] pub config : [ CONFIG ; 2 ] , _reserved10 : [ u8 ; 12usize ] , # [ doc = "0x30 - Debouncer Enable" ] pub debouncen : DEBOUNCEN , # [ doc = "0x34 - Debouncer Prescaler" ] pub dprescaler : DPRESCALER , # [ doc = "0x38 - Pin State" ] pub pinstate : PINSTATE , }
# [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control A" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Possible values of the field `CKSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CKSEL_A { # [ doc = "Clocked by GCLK" ] CLK_GCLK , # [ doc = "Clocked by ULP32K" ] CLK_ULP32K }
impl crate :: ToBits < bool > for CKSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CKSEL_A :: CLK_GCLK => false , CKSEL_A :: CLK_ULP32K => true } } }
# [ doc = "Reader of field `CKSEL`" ] pub type CKSEL_R = crate :: R < bool , CKSEL_A > ; impl CKSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CKSEL_A { match self . bits { false => CKSEL_A :: CLK_GCLK , true => CKSEL_A :: CLK_ULP32K } } # [ doc = "Checks if the value of the field is `CLK_GCLK`" ] # [ inline ( always ) ] pub fn is_clk_gclk ( & self ) -> bool { * self == CKSEL_A :: CLK_GCLK } # [ doc = "Checks if the value of the field is `CLK_ULP32K`" ] # [ inline ( always ) ] pub fn is_clk_ulp32k ( & self ) -> bool { * self == CKSEL_A :: CLK_ULP32K } }
# [ doc = "Write proxy for field `CKSEL`" ] pub struct CKSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CKSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CKSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clocked by GCLK" ] # [ inline ( always ) ] pub fn clk_gclk ( self ) -> & 'a mut W { self . variant ( CKSEL_A :: CLK_GCLK ) } # [ doc = "Clocked by ULP32K" ] # [ inline ( always ) ] pub fn clk_ulp32k ( self ) -> & 'a mut W { self . variant ( CKSEL_A :: CLK_ULP32K ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Clock Selection" ] # [ inline ( always ) ] pub fn cksel ( & self ) -> CKSEL_R { CKSEL_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 4 - Clock Selection" ] # [ inline ( always ) ] pub fn cksel ( & mut self ) -> CKSEL_W { CKSEL_W { w : self } }
}
}
# [ doc = "Non-Maskable Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [nmictrl](nmictrl) module" ] pub type NMICTRL = crate :: Reg < u8 , _NMICTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _NMICTRL ;
# [ doc = "`read()` method returns [nmictrl::R](nmictrl::R) reader structure" ] impl crate :: Readable for NMICTRL { }
# [ doc = "`write(|w| ..)` method takes [nmictrl::W](nmictrl::W) writer structure" ] impl crate :: Writable for NMICTRL { }
# [ doc = "Non-Maskable Interrupt Control" ] pub mod nmictrl {
# [ doc = "Reader of register NMICTRL" ] pub type R = crate :: R < u8 , super :: NMICTRL > ;
# [ doc = "Writer for register NMICTRL" ] pub type W = crate :: W < u8 , super :: NMICTRL > ;
# [ doc = "Register NMICTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: NMICTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `NMISENSE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMISENSE_A { # [ doc = "No detection" ] NONE , # [ doc = "Rising-edge detection" ] RISE , # [ doc = "Falling-edge detection" ] FALL , # [ doc = "Both-edges detection" ] BOTH , # [ doc = "High-level detection" ] HIGH , # [ doc = "Low-level detection" ] LOW }
impl crate :: ToBits < u8 > for NMISENSE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { NMISENSE_A :: NONE => 0 , NMISENSE_A :: RISE => 1 , NMISENSE_A :: FALL => 2 , NMISENSE_A :: BOTH => 3 , NMISENSE_A :: HIGH => 4 , NMISENSE_A :: LOW => 5 } } }
# [ doc = "Reader of field `NMISENSE`" ] pub type NMISENSE_R = crate :: R < u8 , NMISENSE_A > ; impl NMISENSE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , NMISENSE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( NMISENSE_A :: NONE ) , 1 => Val ( NMISENSE_A :: RISE ) , 2 => Val ( NMISENSE_A :: FALL ) , 3 => Val ( NMISENSE_A :: BOTH ) , 4 => Val ( NMISENSE_A :: HIGH ) , 5 => Val ( NMISENSE_A :: LOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == NMISENSE_A :: NONE } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == NMISENSE_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == NMISENSE_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == NMISENSE_A :: BOTH } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == NMISENSE_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == NMISENSE_A :: LOW } }
# [ doc = "Write proxy for field `NMISENSE`" ] pub struct NMISENSE_W < 'a > { w : & 'a mut W , } impl < 'a > NMISENSE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMISENSE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No detection" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( NMISENSE_A :: NONE ) } # [ doc = "Rising-edge detection" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( NMISENSE_A :: RISE ) } # [ doc = "Falling-edge detection" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( NMISENSE_A :: FALL ) } # [ doc = "Both-edges detection" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( NMISENSE_A :: BOTH ) } # [ doc = "High-level detection" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( NMISENSE_A :: HIGH ) } # [ doc = "Low-level detection" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( NMISENSE_A :: LOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u8 ) & 0x07 ) ; self . w } }
# [ doc = "Reader of field `NMIFILTEN`" ] pub type NMIFILTEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NMIFILTEN`" ] pub struct NMIFILTEN_W < 'a > { w : & 'a mut W , } impl < 'a > NMIFILTEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Possible values of the field `NMIASYNCH`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMIASYNCH_A { # [ doc = "Edge detection is clock synchronously operated" ] SYNC , # [ doc = "Edge detection is clock asynchronously operated" ] ASYNC }
impl crate :: ToBits < bool > for NMIASYNCH_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { NMIASYNCH_A :: SYNC => false , NMIASYNCH_A :: ASYNC => true } } }
# [ doc = "Reader of field `NMIASYNCH`" ] pub type NMIASYNCH_R = crate :: R < bool , NMIASYNCH_A > ; impl NMIASYNCH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMIASYNCH_A { match self . bits { false => NMIASYNCH_A :: SYNC , true => NMIASYNCH_A :: ASYNC } } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == NMIASYNCH_A :: SYNC } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == NMIASYNCH_A :: ASYNC } }
# [ doc = "Write proxy for field `NMIASYNCH`" ] pub struct NMIASYNCH_W < 'a > { w : & 'a mut W , } impl < 'a > NMIASYNCH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMIASYNCH_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Edge detection is clock synchronously operated" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( NMIASYNCH_A :: SYNC ) } # [ doc = "Edge detection is clock asynchronously operated" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( NMIASYNCH_A :: ASYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Non-Maskable Interrupt Sense Configuration" ] # [ inline ( always ) ] pub fn nmisense ( & self ) -> NMISENSE_R { NMISENSE_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bit 3 - Non-Maskable Interrupt Filter Enable" ] # [ inline ( always ) ] pub fn nmifilten ( & self ) -> NMIFILTEN_R { NMIFILTEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Asynchronous Edge Detection Mode" ] # [ inline ( always ) ] pub fn nmiasynch ( & self ) -> NMIASYNCH_R { NMIASYNCH_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:2 - Non-Maskable Interrupt Sense Configuration" ] # [ inline ( always ) ] pub fn nmisense ( & mut self ) -> NMISENSE_W { NMISENSE_W { w : self } }
# [ doc = "Bit 3 - Non-Maskable Interrupt Filter Enable" ] # [ inline ( always ) ] pub fn nmifilten ( & mut self ) -> NMIFILTEN_W { NMIFILTEN_W { w : self } }
# [ doc = "Bit 4 - Asynchronous Edge Detection Mode" ] # [ inline ( always ) ] pub fn nmiasynch ( & mut self ) -> NMIASYNCH_W { NMIASYNCH_W { w : self } }
}
}
# [ doc = "Non-Maskable Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [nmiflag](nmiflag) module" ] pub type NMIFLAG = crate :: Reg < u16 , _NMIFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _NMIFLAG ;
# [ doc = "`read()` method returns [nmiflag::R](nmiflag::R) reader structure" ] impl crate :: Readable for NMIFLAG { }
# [ doc = "`write(|w| ..)` method takes [nmiflag::W](nmiflag::W) writer structure" ] impl crate :: Writable for NMIFLAG { }
# [ doc = "Non-Maskable Interrupt Flag Status and Clear" ] pub mod nmiflag {
# [ doc = "Reader of register NMIFLAG" ] pub type R = crate :: R < u16 , super :: NMIFLAG > ;
# [ doc = "Writer for register NMIFLAG" ] pub type W = crate :: W < u16 , super :: NMIFLAG > ;
# [ doc = "Register NMIFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: NMIFLAG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `NMI`" ] pub type NMI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NMI`" ] pub struct NMI_W < 'a > { w : & 'a mut W , } impl < 'a > NMI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Non-Maskable Interrupt" ] # [ inline ( always ) ] pub fn nmi ( & self ) -> NMI_R { NMI_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Non-Maskable Interrupt" ] # [ inline ( always ) ] pub fn nmi ( & mut self ) -> NMI_W { NMI_W { w : self } }
}
}
# [ doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Software Reset Synchronization Busy Status" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable Synchronization Busy Status" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u32 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event Control" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u32 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u32 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EXTINTEO`" ] pub type EXTINTEO_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `EXTINTEO`" ] pub struct EXTINTEO_W < 'a > { w : & 'a mut W , } impl < 'a > EXTINTEO_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - External Interrupt Event Output Enable" ] # [ inline ( always ) ] pub fn extinteo ( & self ) -> EXTINTEO_R { EXTINTEO_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - External Interrupt Event Output Enable" ] # [ inline ( always ) ] pub fn extinteo ( & mut self ) -> EXTINTEO_W { EXTINTEO_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u32 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u32 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u32 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EXTINT`" ] pub type EXTINT_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `EXTINT`" ] pub struct EXTINT_W < 'a > { w : & 'a mut W , } impl < 'a > EXTINT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - External Interrupt Enable" ] # [ inline ( always ) ] pub fn extint ( & self ) -> EXTINT_R { EXTINT_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - External Interrupt Enable" ] # [ inline ( always ) ] pub fn extint ( & mut self ) -> EXTINT_W { EXTINT_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u32 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u32 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u32 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EXTINT`" ] pub type EXTINT_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `EXTINT`" ] pub struct EXTINT_W < 'a > { w : & 'a mut W , } impl < 'a > EXTINT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - External Interrupt Enable" ] # [ inline ( always ) ] pub fn extint ( & self ) -> EXTINT_R { EXTINT_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - External Interrupt Enable" ] # [ inline ( always ) ] pub fn extint ( & mut self ) -> EXTINT_W { EXTINT_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u32 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u32 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u32 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EXTINT`" ] pub type EXTINT_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `EXTINT`" ] pub struct EXTINT_W < 'a > { w : & 'a mut W , } impl < 'a > EXTINT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - External Interrupt" ] # [ inline ( always ) ] pub fn extint ( & self ) -> EXTINT_R { EXTINT_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - External Interrupt" ] # [ inline ( always ) ] pub fn extint ( & mut self ) -> EXTINT_W { EXTINT_W { w : self } }
}
}
# [ doc = "External Interrupt Asynchronous Mode\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [asynch](asynch) module" ] pub type ASYNCH = crate :: Reg < u32 , _ASYNCH > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ASYNCH ;
# [ doc = "`read()` method returns [asynch::R](asynch::R) reader structure" ] impl crate :: Readable for ASYNCH { }
# [ doc = "`write(|w| ..)` method takes [asynch::W](asynch::W) writer structure" ] impl crate :: Writable for ASYNCH { }
# [ doc = "External Interrupt Asynchronous Mode" ] pub mod asynch {
# [ doc = "Reader of register ASYNCH" ] pub type R = crate :: R < u32 , super :: ASYNCH > ;
# [ doc = "Writer for register ASYNCH" ] pub type W = crate :: W < u32 , super :: ASYNCH > ;
# [ doc = "Register ASYNCH `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ASYNCH { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `ASYNCH`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ASYNCH_A { # [ doc = "Edge detection is clock synchronously operated" ] SYNC , # [ doc = "Edge detection is clock asynchronously operated" ] ASYNC }
impl crate :: ToBits < u16 > for ASYNCH_A { # [ inline ( always ) ] fn _bits ( & self ) -> u16 { match * self { ASYNCH_A :: SYNC => 0 , ASYNCH_A :: ASYNC => 1 } } }
# [ doc = "Reader of field `ASYNCH`" ] pub type ASYNCH_R = crate :: R < u16 , ASYNCH_A > ; impl ASYNCH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u16 , ASYNCH_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( ASYNCH_A :: SYNC ) , 1 => Val ( ASYNCH_A :: ASYNC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == ASYNCH_A :: SYNC } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == ASYNCH_A :: ASYNC } }
# [ doc = "Write proxy for field `ASYNCH`" ] pub struct ASYNCH_W < 'a > { w : & 'a mut W , } impl < 'a > ASYNCH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ASYNCH_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Edge detection is clock synchronously operated" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( ASYNCH_A :: SYNC ) } # [ doc = "Edge detection is clock asynchronously operated" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( ASYNCH_A :: ASYNC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Asynchronous Edge Detection Mode" ] # [ inline ( always ) ] pub fn asynch ( & self ) -> ASYNCH_R { ASYNCH_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - Asynchronous Edge Detection Mode" ] # [ inline ( always ) ] pub fn asynch ( & mut self ) -> ASYNCH_W { ASYNCH_W { w : self } }
}
}
# [ doc = "External Interrupt Sense Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [config](config) module" ] pub type CONFIG = crate :: Reg < u32 , _CONFIG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CONFIG ;
# [ doc = "`read()` method returns [config::R](config::R) reader structure" ] impl crate :: Readable for CONFIG { }
# [ doc = "`write(|w| ..)` method takes [config::W](config::W) writer structure" ] impl crate :: Writable for CONFIG { }
# [ doc = "External Interrupt Sense Configuration" ] pub mod config {
# [ doc = "Reader of register CONFIG[%s]" ] pub type R = crate :: R < u32 , super :: CONFIG > ;
# [ doc = "Writer for register CONFIG[%s]" ] pub type W = crate :: W < u32 , super :: CONFIG > ;
# [ doc = "Register CONFIG[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CONFIG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `SENSE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SENSE0_A { # [ doc = "No detection" ] NONE , # [ doc = "Rising edge detection" ] RISE , # [ doc = "Falling edge detection" ] FALL , # [ doc = "Both edges detection" ] BOTH , # [ doc = "High level detection" ] HIGH , # [ doc = "Low level detection" ] LOW }
impl crate :: ToBits < u8 > for SENSE0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SENSE0_A :: NONE => 0 , SENSE0_A :: RISE => 1 , SENSE0_A :: FALL => 2 , SENSE0_A :: BOTH => 3 , SENSE0_A :: HIGH => 4 , SENSE0_A :: LOW => 5 } } }
# [ doc = "Reader of field `SENSE0`" ] pub type SENSE0_R = crate :: R < u8 , SENSE0_A > ; impl SENSE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SENSE0_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SENSE0_A :: NONE ) , 1 => Val ( SENSE0_A :: RISE ) , 2 => Val ( SENSE0_A :: FALL ) , 3 => Val ( SENSE0_A :: BOTH ) , 4 => Val ( SENSE0_A :: HIGH ) , 5 => Val ( SENSE0_A :: LOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SENSE0_A :: NONE } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == SENSE0_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == SENSE0_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == SENSE0_A :: BOTH } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == SENSE0_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == SENSE0_A :: LOW } }
# [ doc = "Write proxy for field `SENSE0`" ] pub struct SENSE0_W < 'a > { w : & 'a mut W , } impl < 'a > SENSE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SENSE0_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No detection" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( SENSE0_A :: NONE ) } # [ doc = "Rising edge detection" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( SENSE0_A :: RISE ) } # [ doc = "Falling edge detection" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( SENSE0_A :: FALL ) } # [ doc = "Both edges detection" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( SENSE0_A :: BOTH ) } # [ doc = "High level detection" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( SENSE0_A :: HIGH ) } # [ doc = "Low level detection" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( SENSE0_A :: LOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
# [ doc = "Reader of field `FILTEN0`" ] pub type FILTEN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FILTEN0`" ] pub struct FILTEN0_W < 'a > { w : & 'a mut W , } impl < 'a > FILTEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Possible values of the field `SENSE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SENSE1_A { # [ doc = "No detection" ] NONE , # [ doc = "Rising edge detection" ] RISE , # [ doc = "Falling edge detection" ] FALL , # [ doc = "Both edges detection" ] BOTH , # [ doc = "High level detection" ] HIGH , # [ doc = "Low level detection" ] LOW }
impl crate :: ToBits < u8 > for SENSE1_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SENSE1_A :: NONE => 0 , SENSE1_A :: RISE => 1 , SENSE1_A :: FALL => 2 , SENSE1_A :: BOTH => 3 , SENSE1_A :: HIGH => 4 , SENSE1_A :: LOW => 5 } } }
# [ doc = "Reader of field `SENSE1`" ] pub type SENSE1_R = crate :: R < u8 , SENSE1_A > ; impl SENSE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SENSE1_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SENSE1_A :: NONE ) , 1 => Val ( SENSE1_A :: RISE ) , 2 => Val ( SENSE1_A :: FALL ) , 3 => Val ( SENSE1_A :: BOTH ) , 4 => Val ( SENSE1_A :: HIGH ) , 5 => Val ( SENSE1_A :: LOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SENSE1_A :: NONE } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == SENSE1_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == SENSE1_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == SENSE1_A :: BOTH } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == SENSE1_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == SENSE1_A :: LOW } }
# [ doc = "Write proxy for field `SENSE1`" ] pub struct SENSE1_W < 'a > { w : & 'a mut W , } impl < 'a > SENSE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SENSE1_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No detection" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( SENSE1_A :: NONE ) } # [ doc = "Rising edge detection" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( SENSE1_A :: RISE ) } # [ doc = "Falling edge detection" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( SENSE1_A :: FALL ) } # [ doc = "Both edges detection" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( SENSE1_A :: BOTH ) } # [ doc = "High level detection" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( SENSE1_A :: HIGH ) } # [ doc = "Low level detection" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( SENSE1_A :: LOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u32 ) & 0x07 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `FILTEN1`" ] pub type FILTEN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FILTEN1`" ] pub struct FILTEN1_W < 'a > { w : & 'a mut W , } impl < 'a > FILTEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `SENSE2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SENSE2_A { # [ doc = "No detection" ] NONE , # [ doc = "Rising edge detection" ] RISE , # [ doc = "Falling edge detection" ] FALL , # [ doc = "Both edges detection" ] BOTH , # [ doc = "High level detection" ] HIGH , # [ doc = "Low level detection" ] LOW }
impl crate :: ToBits < u8 > for SENSE2_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SENSE2_A :: NONE => 0 , SENSE2_A :: RISE => 1 , SENSE2_A :: FALL => 2 , SENSE2_A :: BOTH => 3 , SENSE2_A :: HIGH => 4 , SENSE2_A :: LOW => 5 } } }
# [ doc = "Reader of field `SENSE2`" ] pub type SENSE2_R = crate :: R < u8 , SENSE2_A > ; impl SENSE2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SENSE2_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SENSE2_A :: NONE ) , 1 => Val ( SENSE2_A :: RISE ) , 2 => Val ( SENSE2_A :: FALL ) , 3 => Val ( SENSE2_A :: BOTH ) , 4 => Val ( SENSE2_A :: HIGH ) , 5 => Val ( SENSE2_A :: LOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SENSE2_A :: NONE } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == SENSE2_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == SENSE2_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == SENSE2_A :: BOTH } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == SENSE2_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == SENSE2_A :: LOW } }
# [ doc = "Write proxy for field `SENSE2`" ] pub struct SENSE2_W < 'a > { w : & 'a mut W , } impl < 'a > SENSE2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SENSE2_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No detection" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( SENSE2_A :: NONE ) } # [ doc = "Rising edge detection" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( SENSE2_A :: RISE ) } # [ doc = "Falling edge detection" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( SENSE2_A :: FALL ) } # [ doc = "Both edges detection" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( SENSE2_A :: BOTH ) } # [ doc = "High level detection" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( SENSE2_A :: HIGH ) } # [ doc = "Low level detection" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( SENSE2_A :: LOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u32 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `FILTEN2`" ] pub type FILTEN2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FILTEN2`" ] pub struct FILTEN2_W < 'a > { w : & 'a mut W , } impl < 'a > FILTEN2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Possible values of the field `SENSE3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SENSE3_A { # [ doc = "No detection" ] NONE , # [ doc = "Rising edge detection" ] RISE , # [ doc = "Falling edge detection" ] FALL , # [ doc = "Both edges detection" ] BOTH , # [ doc = "High level detection" ] HIGH , # [ doc = "Low level detection" ] LOW }
impl crate :: ToBits < u8 > for SENSE3_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SENSE3_A :: NONE => 0 , SENSE3_A :: RISE => 1 , SENSE3_A :: FALL => 2 , SENSE3_A :: BOTH => 3 , SENSE3_A :: HIGH => 4 , SENSE3_A :: LOW => 5 } } }
# [ doc = "Reader of field `SENSE3`" ] pub type SENSE3_R = crate :: R < u8 , SENSE3_A > ; impl SENSE3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SENSE3_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SENSE3_A :: NONE ) , 1 => Val ( SENSE3_A :: RISE ) , 2 => Val ( SENSE3_A :: FALL ) , 3 => Val ( SENSE3_A :: BOTH ) , 4 => Val ( SENSE3_A :: HIGH ) , 5 => Val ( SENSE3_A :: LOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SENSE3_A :: NONE } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == SENSE3_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == SENSE3_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == SENSE3_A :: BOTH } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == SENSE3_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == SENSE3_A :: LOW } }
# [ doc = "Write proxy for field `SENSE3`" ] pub struct SENSE3_W < 'a > { w : & 'a mut W , } impl < 'a > SENSE3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SENSE3_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No detection" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( SENSE3_A :: NONE ) } # [ doc = "Rising edge detection" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( SENSE3_A :: RISE ) } # [ doc = "Falling edge detection" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( SENSE3_A :: FALL ) } # [ doc = "Both edges detection" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( SENSE3_A :: BOTH ) } # [ doc = "High level detection" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( SENSE3_A :: HIGH ) } # [ doc = "Low level detection" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( SENSE3_A :: LOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 12 ) ) | ( ( ( value as u32 ) & 0x07 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `FILTEN3`" ] pub type FILTEN3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FILTEN3`" ] pub struct FILTEN3_W < 'a > { w : & 'a mut W , } impl < 'a > FILTEN3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Possible values of the field `SENSE4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SENSE4_A { # [ doc = "No detection" ] NONE , # [ doc = "Rising edge detection" ] RISE , # [ doc = "Falling edge detection" ] FALL , # [ doc = "Both edges detection" ] BOTH , # [ doc = "High level detection" ] HIGH , # [ doc = "Low level detection" ] LOW }
impl crate :: ToBits < u8 > for SENSE4_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SENSE4_A :: NONE => 0 , SENSE4_A :: RISE => 1 , SENSE4_A :: FALL => 2 , SENSE4_A :: BOTH => 3 , SENSE4_A :: HIGH => 4 , SENSE4_A :: LOW => 5 } } }
# [ doc = "Reader of field `SENSE4`" ] pub type SENSE4_R = crate :: R < u8 , SENSE4_A > ; impl SENSE4_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SENSE4_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SENSE4_A :: NONE ) , 1 => Val ( SENSE4_A :: RISE ) , 2 => Val ( SENSE4_A :: FALL ) , 3 => Val ( SENSE4_A :: BOTH ) , 4 => Val ( SENSE4_A :: HIGH ) , 5 => Val ( SENSE4_A :: LOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SENSE4_A :: NONE } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == SENSE4_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == SENSE4_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == SENSE4_A :: BOTH } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == SENSE4_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == SENSE4_A :: LOW } }
# [ doc = "Write proxy for field `SENSE4`" ] pub struct SENSE4_W < 'a > { w : & 'a mut W , } impl < 'a > SENSE4_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SENSE4_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No detection" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( SENSE4_A :: NONE ) } # [ doc = "Rising edge detection" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( SENSE4_A :: RISE ) } # [ doc = "Falling edge detection" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( SENSE4_A :: FALL ) } # [ doc = "Both edges detection" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( SENSE4_A :: BOTH ) } # [ doc = "High level detection" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( SENSE4_A :: HIGH ) } # [ doc = "Low level detection" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( SENSE4_A :: LOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 16 ) ) | ( ( ( value as u32 ) & 0x07 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `FILTEN4`" ] pub type FILTEN4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FILTEN4`" ] pub struct FILTEN4_W < 'a > { w : & 'a mut W , } impl < 'a > FILTEN4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Possible values of the field `SENSE5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SENSE5_A { # [ doc = "No detection" ] NONE , # [ doc = "Rising edge detection" ] RISE , # [ doc = "Falling edge detection" ] FALL , # [ doc = "Both edges detection" ] BOTH , # [ doc = "High level detection" ] HIGH , # [ doc = "Low level detection" ] LOW }
impl crate :: ToBits < u8 > for SENSE5_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SENSE5_A :: NONE => 0 , SENSE5_A :: RISE => 1 , SENSE5_A :: FALL => 2 , SENSE5_A :: BOTH => 3 , SENSE5_A :: HIGH => 4 , SENSE5_A :: LOW => 5 } } }
# [ doc = "Reader of field `SENSE5`" ] pub type SENSE5_R = crate :: R < u8 , SENSE5_A > ; impl SENSE5_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SENSE5_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SENSE5_A :: NONE ) , 1 => Val ( SENSE5_A :: RISE ) , 2 => Val ( SENSE5_A :: FALL ) , 3 => Val ( SENSE5_A :: BOTH ) , 4 => Val ( SENSE5_A :: HIGH ) , 5 => Val ( SENSE5_A :: LOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SENSE5_A :: NONE } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == SENSE5_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == SENSE5_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == SENSE5_A :: BOTH } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == SENSE5_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == SENSE5_A :: LOW } }
# [ doc = "Write proxy for field `SENSE5`" ] pub struct SENSE5_W < 'a > { w : & 'a mut W , } impl < 'a > SENSE5_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SENSE5_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No detection" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( SENSE5_A :: NONE ) } # [ doc = "Rising edge detection" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( SENSE5_A :: RISE ) } # [ doc = "Falling edge detection" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( SENSE5_A :: FALL ) } # [ doc = "Both edges detection" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( SENSE5_A :: BOTH ) } # [ doc = "High level detection" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( SENSE5_A :: HIGH ) } # [ doc = "Low level detection" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( SENSE5_A :: LOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 20 ) ) | ( ( ( value as u32 ) & 0x07 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `FILTEN5`" ] pub type FILTEN5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FILTEN5`" ] pub struct FILTEN5_W < 'a > { w : & 'a mut W , } impl < 'a > FILTEN5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Possible values of the field `SENSE6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SENSE6_A { # [ doc = "No detection" ] NONE , # [ doc = "Rising edge detection" ] RISE , # [ doc = "Falling edge detection" ] FALL , # [ doc = "Both edges detection" ] BOTH , # [ doc = "High level detection" ] HIGH , # [ doc = "Low level detection" ] LOW }
impl crate :: ToBits < u8 > for SENSE6_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SENSE6_A :: NONE => 0 , SENSE6_A :: RISE => 1 , SENSE6_A :: FALL => 2 , SENSE6_A :: BOTH => 3 , SENSE6_A :: HIGH => 4 , SENSE6_A :: LOW => 5 } } }
# [ doc = "Reader of field `SENSE6`" ] pub type SENSE6_R = crate :: R < u8 , SENSE6_A > ; impl SENSE6_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SENSE6_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SENSE6_A :: NONE ) , 1 => Val ( SENSE6_A :: RISE ) , 2 => Val ( SENSE6_A :: FALL ) , 3 => Val ( SENSE6_A :: BOTH ) , 4 => Val ( SENSE6_A :: HIGH ) , 5 => Val ( SENSE6_A :: LOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SENSE6_A :: NONE } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == SENSE6_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == SENSE6_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == SENSE6_A :: BOTH } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == SENSE6_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == SENSE6_A :: LOW } }
# [ doc = "Write proxy for field `SENSE6`" ] pub struct SENSE6_W < 'a > { w : & 'a mut W , } impl < 'a > SENSE6_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SENSE6_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No detection" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( SENSE6_A :: NONE ) } # [ doc = "Rising edge detection" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( SENSE6_A :: RISE ) } # [ doc = "Falling edge detection" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( SENSE6_A :: FALL ) } # [ doc = "Both edges detection" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( SENSE6_A :: BOTH ) } # [ doc = "High level detection" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( SENSE6_A :: HIGH ) } # [ doc = "Low level detection" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( SENSE6_A :: LOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 24 ) ) | ( ( ( value as u32 ) & 0x07 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `FILTEN6`" ] pub type FILTEN6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FILTEN6`" ] pub struct FILTEN6_W < 'a > { w : & 'a mut W , } impl < 'a > FILTEN6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Possible values of the field `SENSE7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SENSE7_A { # [ doc = "No detection" ] NONE , # [ doc = "Rising edge detection" ] RISE , # [ doc = "Falling edge detection" ] FALL , # [ doc = "Both edges detection" ] BOTH , # [ doc = "High level detection" ] HIGH , # [ doc = "Low level detection" ] LOW }
impl crate :: ToBits < u8 > for SENSE7_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SENSE7_A :: NONE => 0 , SENSE7_A :: RISE => 1 , SENSE7_A :: FALL => 2 , SENSE7_A :: BOTH => 3 , SENSE7_A :: HIGH => 4 , SENSE7_A :: LOW => 5 } } }
# [ doc = "Reader of field `SENSE7`" ] pub type SENSE7_R = crate :: R < u8 , SENSE7_A > ; impl SENSE7_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SENSE7_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SENSE7_A :: NONE ) , 1 => Val ( SENSE7_A :: RISE ) , 2 => Val ( SENSE7_A :: FALL ) , 3 => Val ( SENSE7_A :: BOTH ) , 4 => Val ( SENSE7_A :: HIGH ) , 5 => Val ( SENSE7_A :: LOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == SENSE7_A :: NONE } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == SENSE7_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == SENSE7_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == SENSE7_A :: BOTH } # [ doc = "Checks if the value of the field is `HIGH`" ] # [ inline ( always ) ] pub fn is_high ( & self ) -> bool { * self == SENSE7_A :: HIGH } # [ doc = "Checks if the value of the field is `LOW`" ] # [ inline ( always ) ] pub fn is_low ( & self ) -> bool { * self == SENSE7_A :: LOW } }
# [ doc = "Write proxy for field `SENSE7`" ] pub struct SENSE7_W < 'a > { w : & 'a mut W , } impl < 'a > SENSE7_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SENSE7_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No detection" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( SENSE7_A :: NONE ) } # [ doc = "Rising edge detection" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( SENSE7_A :: RISE ) } # [ doc = "Falling edge detection" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( SENSE7_A :: FALL ) } # [ doc = "Both edges detection" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( SENSE7_A :: BOTH ) } # [ doc = "High level detection" ] # [ inline ( always ) ] pub fn high ( self ) -> & 'a mut W { self . variant ( SENSE7_A :: HIGH ) } # [ doc = "Low level detection" ] # [ inline ( always ) ] pub fn low ( self ) -> & 'a mut W { self . variant ( SENSE7_A :: LOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 28 ) ) | ( ( ( value as u32 ) & 0x07 ) << 28 ) ; self . w } }
# [ doc = "Reader of field `FILTEN7`" ] pub type FILTEN7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FILTEN7`" ] pub struct FILTEN7_W < 'a > { w : & 'a mut W , } impl < 'a > FILTEN7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Input Sense Configuration 0" ] # [ inline ( always ) ] pub fn sense0 ( & self ) -> SENSE0_R { SENSE0_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bit 3 - Filter Enable 0" ] # [ inline ( always ) ] pub fn filten0 ( & self ) -> FILTEN0_R { FILTEN0_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:6 - Input Sense Configuration 1" ] # [ inline ( always ) ] pub fn sense1 ( & self ) -> SENSE1_R { SENSE1_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 7 - Filter Enable 1" ] # [ inline ( always ) ] pub fn filten1 ( & self ) -> FILTEN1_R { FILTEN1_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Input Sense Configuration 2" ] # [ inline ( always ) ] pub fn sense2 ( & self ) -> SENSE2_R { SENSE2_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 11 - Filter Enable 2" ] # [ inline ( always ) ] pub fn filten2 ( & self ) -> FILTEN2_R { FILTEN2_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:14 - Input Sense Configuration 3" ] # [ inline ( always ) ] pub fn sense3 ( & self ) -> SENSE3_R { SENSE3_R :: new ( ( ( self . bits >> 12 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 15 - Filter Enable 3" ] # [ inline ( always ) ] pub fn filten3 ( & self ) -> FILTEN3_R { FILTEN3_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:18 - Input Sense Configuration 4" ] # [ inline ( always ) ] pub fn sense4 ( & self ) -> SENSE4_R { SENSE4_R :: new ( ( ( self . bits >> 16 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 19 - Filter Enable 4" ] # [ inline ( always ) ] pub fn filten4 ( & self ) -> FILTEN4_R { FILTEN4_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 20:22 - Input Sense Configuration 5" ] # [ inline ( always ) ] pub fn sense5 ( & self ) -> SENSE5_R { SENSE5_R :: new ( ( ( self . bits >> 20 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 23 - Filter Enable 5" ] # [ inline ( always ) ] pub fn filten5 ( & self ) -> FILTEN5_R { FILTEN5_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 24:26 - Input Sense Configuration 6" ] # [ inline ( always ) ] pub fn sense6 ( & self ) -> SENSE6_R { SENSE6_R :: new ( ( ( self . bits >> 24 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 27 - Filter Enable 6" ] # [ inline ( always ) ] pub fn filten6 ( & self ) -> FILTEN6_R { FILTEN6_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 28:30 - Input Sense Configuration 7" ] # [ inline ( always ) ] pub fn sense7 ( & self ) -> SENSE7_R { SENSE7_R :: new ( ( ( self . bits >> 28 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 31 - Filter Enable 7" ] # [ inline ( always ) ] pub fn filten7 ( & self ) -> FILTEN7_R { FILTEN7_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:2 - Input Sense Configuration 0" ] # [ inline ( always ) ] pub fn sense0 ( & mut self ) -> SENSE0_W { SENSE0_W { w : self } }
# [ doc = "Bit 3 - Filter Enable 0" ] # [ inline ( always ) ] pub fn filten0 ( & mut self ) -> FILTEN0_W { FILTEN0_W { w : self } }
# [ doc = "Bits 4:6 - Input Sense Configuration 1" ] # [ inline ( always ) ] pub fn sense1 ( & mut self ) -> SENSE1_W { SENSE1_W { w : self } }
# [ doc = "Bit 7 - Filter Enable 1" ] # [ inline ( always ) ] pub fn filten1 ( & mut self ) -> FILTEN1_W { FILTEN1_W { w : self } }
# [ doc = "Bits 8:10 - Input Sense Configuration 2" ] # [ inline ( always ) ] pub fn sense2 ( & mut self ) -> SENSE2_W { SENSE2_W { w : self } }
# [ doc = "Bit 11 - Filter Enable 2" ] # [ inline ( always ) ] pub fn filten2 ( & mut self ) -> FILTEN2_W { FILTEN2_W { w : self } }
# [ doc = "Bits 12:14 - Input Sense Configuration 3" ] # [ inline ( always ) ] pub fn sense3 ( & mut self ) -> SENSE3_W { SENSE3_W { w : self } }
# [ doc = "Bit 15 - Filter Enable 3" ] # [ inline ( always ) ] pub fn filten3 ( & mut self ) -> FILTEN3_W { FILTEN3_W { w : self } }
# [ doc = "Bits 16:18 - Input Sense Configuration 4" ] # [ inline ( always ) ] pub fn sense4 ( & mut self ) -> SENSE4_W { SENSE4_W { w : self } }
# [ doc = "Bit 19 - Filter Enable 4" ] # [ inline ( always ) ] pub fn filten4 ( & mut self ) -> FILTEN4_W { FILTEN4_W { w : self } }
# [ doc = "Bits 20:22 - Input Sense Configuration 5" ] # [ inline ( always ) ] pub fn sense5 ( & mut self ) -> SENSE5_W { SENSE5_W { w : self } }
# [ doc = "Bit 23 - Filter Enable 5" ] # [ inline ( always ) ] pub fn filten5 ( & mut self ) -> FILTEN5_W { FILTEN5_W { w : self } }
# [ doc = "Bits 24:26 - Input Sense Configuration 6" ] # [ inline ( always ) ] pub fn sense6 ( & mut self ) -> SENSE6_W { SENSE6_W { w : self } }
# [ doc = "Bit 27 - Filter Enable 6" ] # [ inline ( always ) ] pub fn filten6 ( & mut self ) -> FILTEN6_W { FILTEN6_W { w : self } }
# [ doc = "Bits 28:30 - Input Sense Configuration 7" ] # [ inline ( always ) ] pub fn sense7 ( & mut self ) -> SENSE7_W { SENSE7_W { w : self } }
# [ doc = "Bit 31 - Filter Enable 7" ] # [ inline ( always ) ] pub fn filten7 ( & mut self ) -> FILTEN7_W { FILTEN7_W { w : self } }
}
}
# [ doc = "Debouncer Enable\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [debouncen](debouncen) module" ] pub type DEBOUNCEN = crate :: Reg < u32 , _DEBOUNCEN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DEBOUNCEN ;
# [ doc = "`read()` method returns [debouncen::R](debouncen::R) reader structure" ] impl crate :: Readable for DEBOUNCEN { }
# [ doc = "`write(|w| ..)` method takes [debouncen::W](debouncen::W) writer structure" ] impl crate :: Writable for DEBOUNCEN { }
# [ doc = "Debouncer Enable" ] pub mod debouncen {
# [ doc = "Reader of register DEBOUNCEN" ] pub type R = crate :: R < u32 , super :: DEBOUNCEN > ;
# [ doc = "Writer for register DEBOUNCEN" ] pub type W = crate :: W < u32 , super :: DEBOUNCEN > ;
# [ doc = "Register DEBOUNCEN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DEBOUNCEN { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DEBOUNCEN`" ] pub type DEBOUNCEN_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DEBOUNCEN`" ] pub struct DEBOUNCEN_W < 'a > { w : & 'a mut W , } impl < 'a > DEBOUNCEN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Debouncer Enable" ] # [ inline ( always ) ] pub fn debouncen ( & self ) -> DEBOUNCEN_R { DEBOUNCEN_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - Debouncer Enable" ] # [ inline ( always ) ] pub fn debouncen ( & mut self ) -> DEBOUNCEN_W { DEBOUNCEN_W { w : self } }
}
}
# [ doc = "Debouncer Prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dprescaler](dprescaler) module" ] pub type DPRESCALER = crate :: Reg < u32 , _DPRESCALER > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DPRESCALER ;
# [ doc = "`read()` method returns [dprescaler::R](dprescaler::R) reader structure" ] impl crate :: Readable for DPRESCALER { }
# [ doc = "`write(|w| ..)` method takes [dprescaler::W](dprescaler::W) writer structure" ] impl crate :: Writable for DPRESCALER { }
# [ doc = "Debouncer Prescaler" ] pub mod dprescaler {
# [ doc = "Reader of register DPRESCALER" ] pub type R = crate :: R < u32 , super :: DPRESCALER > ;
# [ doc = "Writer for register DPRESCALER" ] pub type W = crate :: W < u32 , super :: DPRESCALER > ;
# [ doc = "Register DPRESCALER `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DPRESCALER { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `PRESCALER0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER0_A { # [ doc = "EIC clock divided by 2" ] DIV2 , # [ doc = "EIC clock divided by 4" ] DIV4 , # [ doc = "EIC clock divided by 8" ] DIV8 , # [ doc = "EIC clock divided by 16" ] DIV16 , # [ doc = "EIC clock divided by 32" ] DIV32 , # [ doc = "EIC clock divided by 64" ] DIV64 , # [ doc = "EIC clock divided by 128" ] DIV128 , # [ doc = "EIC clock divided by 256" ] DIV256 }
impl crate :: ToBits < u8 > for PRESCALER0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER0_A :: DIV2 => 0 , PRESCALER0_A :: DIV4 => 1 , PRESCALER0_A :: DIV8 => 2 , PRESCALER0_A :: DIV16 => 3 , PRESCALER0_A :: DIV32 => 4 , PRESCALER0_A :: DIV64 => 5 , PRESCALER0_A :: DIV128 => 6 , PRESCALER0_A :: DIV256 => 7 } } }
# [ doc = "Reader of field `PRESCALER0`" ] pub type PRESCALER0_R = crate :: R < u8 , PRESCALER0_A > ; impl PRESCALER0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PRESCALER0_A { match self . bits { 0 => PRESCALER0_A :: DIV2 , 1 => PRESCALER0_A :: DIV4 , 2 => PRESCALER0_A :: DIV8 , 3 => PRESCALER0_A :: DIV16 , 4 => PRESCALER0_A :: DIV32 , 5 => PRESCALER0_A :: DIV64 , 6 => PRESCALER0_A :: DIV128 , 7 => PRESCALER0_A :: DIV256 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER0_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER0_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER0_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER0_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == PRESCALER0_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER0_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == PRESCALER0_A :: DIV128 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER0_A :: DIV256 } }
# [ doc = "Write proxy for field `PRESCALER0`" ] pub struct PRESCALER0_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER0_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "EIC clock divided by 2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER0_A :: DIV2 ) } # [ doc = "EIC clock divided by 4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER0_A :: DIV4 ) } # [ doc = "EIC clock divided by 8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER0_A :: DIV8 ) } # [ doc = "EIC clock divided by 16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER0_A :: DIV16 ) } # [ doc = "EIC clock divided by 32" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( PRESCALER0_A :: DIV32 ) } # [ doc = "EIC clock divided by 64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER0_A :: DIV64 ) } # [ doc = "EIC clock divided by 128" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( PRESCALER0_A :: DIV128 ) } # [ doc = "EIC clock divided by 256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER0_A :: DIV256 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
# [ doc = "Possible values of the field `STATES0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STATES0_A { # [ doc = "3 low frequency samples" ] LFREQ3 , # [ doc = "7 low frequency samples" ] LFREQ7 }
impl crate :: ToBits < bool > for STATES0_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { STATES0_A :: LFREQ3 => false , STATES0_A :: LFREQ7 => true } } }
# [ doc = "Reader of field `STATES0`" ] pub type STATES0_R = crate :: R < bool , STATES0_A > ; impl STATES0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> STATES0_A { match self . bits { false => STATES0_A :: LFREQ3 , true => STATES0_A :: LFREQ7 } } # [ doc = "Checks if the value of the field is `LFREQ3`" ] # [ inline ( always ) ] pub fn is_lfreq3 ( & self ) -> bool { * self == STATES0_A :: LFREQ3 } # [ doc = "Checks if the value of the field is `LFREQ7`" ] # [ inline ( always ) ] pub fn is_lfreq7 ( & self ) -> bool { * self == STATES0_A :: LFREQ7 } }
# [ doc = "Write proxy for field `STATES0`" ] pub struct STATES0_W < 'a > { w : & 'a mut W , } impl < 'a > STATES0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : STATES0_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "3 low frequency samples" ] # [ inline ( always ) ] pub fn lfreq3 ( self ) -> & 'a mut W { self . variant ( STATES0_A :: LFREQ3 ) } # [ doc = "7 low frequency samples" ] # [ inline ( always ) ] pub fn lfreq7 ( self ) -> & 'a mut W { self . variant ( STATES0_A :: LFREQ7 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Possible values of the field `PRESCALER1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER1_A { # [ doc = "EIC clock divided by 2" ] DIV2 , # [ doc = "EIC clock divided by 4" ] DIV4 , # [ doc = "EIC clock divided by 8" ] DIV8 , # [ doc = "EIC clock divided by 16" ] DIV16 , # [ doc = "EIC clock divided by 32" ] DIV32 , # [ doc = "EIC clock divided by 64" ] DIV64 , # [ doc = "EIC clock divided by 128" ] DIV128 , # [ doc = "EIC clock divided by 256" ] DIV256 }
impl crate :: ToBits < u8 > for PRESCALER1_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER1_A :: DIV2 => 0 , PRESCALER1_A :: DIV4 => 1 , PRESCALER1_A :: DIV8 => 2 , PRESCALER1_A :: DIV16 => 3 , PRESCALER1_A :: DIV32 => 4 , PRESCALER1_A :: DIV64 => 5 , PRESCALER1_A :: DIV128 => 6 , PRESCALER1_A :: DIV256 => 7 } } }
# [ doc = "Reader of field `PRESCALER1`" ] pub type PRESCALER1_R = crate :: R < u8 , PRESCALER1_A > ; impl PRESCALER1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PRESCALER1_A { match self . bits { 0 => PRESCALER1_A :: DIV2 , 1 => PRESCALER1_A :: DIV4 , 2 => PRESCALER1_A :: DIV8 , 3 => PRESCALER1_A :: DIV16 , 4 => PRESCALER1_A :: DIV32 , 5 => PRESCALER1_A :: DIV64 , 6 => PRESCALER1_A :: DIV128 , 7 => PRESCALER1_A :: DIV256 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER1_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER1_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER1_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER1_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == PRESCALER1_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER1_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == PRESCALER1_A :: DIV128 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER1_A :: DIV256 } }
# [ doc = "Write proxy for field `PRESCALER1`" ] pub struct PRESCALER1_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER1_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "EIC clock divided by 2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER1_A :: DIV2 ) } # [ doc = "EIC clock divided by 4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER1_A :: DIV4 ) } # [ doc = "EIC clock divided by 8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER1_A :: DIV8 ) } # [ doc = "EIC clock divided by 16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER1_A :: DIV16 ) } # [ doc = "EIC clock divided by 32" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( PRESCALER1_A :: DIV32 ) } # [ doc = "EIC clock divided by 64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER1_A :: DIV64 ) } # [ doc = "EIC clock divided by 128" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( PRESCALER1_A :: DIV128 ) } # [ doc = "EIC clock divided by 256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER1_A :: DIV256 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 4 ) ) | ( ( ( value as u32 ) & 0x07 ) << 4 ) ; self . w } }
# [ doc = "Possible values of the field `STATES1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STATES1_A { # [ doc = "3 low frequency samples" ] LFREQ3 , # [ doc = "7 low frequency samples" ] LFREQ7 }
impl crate :: ToBits < bool > for STATES1_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { STATES1_A :: LFREQ3 => false , STATES1_A :: LFREQ7 => true } } }
# [ doc = "Reader of field `STATES1`" ] pub type STATES1_R = crate :: R < bool , STATES1_A > ; impl STATES1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> STATES1_A { match self . bits { false => STATES1_A :: LFREQ3 , true => STATES1_A :: LFREQ7 } } # [ doc = "Checks if the value of the field is `LFREQ3`" ] # [ inline ( always ) ] pub fn is_lfreq3 ( & self ) -> bool { * self == STATES1_A :: LFREQ3 } # [ doc = "Checks if the value of the field is `LFREQ7`" ] # [ inline ( always ) ] pub fn is_lfreq7 ( & self ) -> bool { * self == STATES1_A :: LFREQ7 } }
# [ doc = "Write proxy for field `STATES1`" ] pub struct STATES1_W < 'a > { w : & 'a mut W , } impl < 'a > STATES1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : STATES1_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "3 low frequency samples" ] # [ inline ( always ) ] pub fn lfreq3 ( self ) -> & 'a mut W { self . variant ( STATES1_A :: LFREQ3 ) } # [ doc = "7 low frequency samples" ] # [ inline ( always ) ] pub fn lfreq7 ( self ) -> & 'a mut W { self . variant ( STATES1_A :: LFREQ7 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `TICKON`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TICKON_A { # [ doc = "Clocked by GCLK" ] CLK_GCLK_EIC , # [ doc = "Clocked by Low Frequency Clock" ] CLK_LFREQ }
impl crate :: ToBits < bool > for TICKON_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { TICKON_A :: CLK_GCLK_EIC => false , TICKON_A :: CLK_LFREQ => true } } }
# [ doc = "Reader of field `TICKON`" ] pub type TICKON_R = crate :: R < bool , TICKON_A > ; impl TICKON_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TICKON_A { match self . bits { false => TICKON_A :: CLK_GCLK_EIC , true => TICKON_A :: CLK_LFREQ } } # [ doc = "Checks if the value of the field is `CLK_GCLK_EIC`" ] # [ inline ( always ) ] pub fn is_clk_gclk_eic ( & self ) -> bool { * self == TICKON_A :: CLK_GCLK_EIC } # [ doc = "Checks if the value of the field is `CLK_LFREQ`" ] # [ inline ( always ) ] pub fn is_clk_lfreq ( & self ) -> bool { * self == TICKON_A :: CLK_LFREQ } }
# [ doc = "Write proxy for field `TICKON`" ] pub struct TICKON_W < 'a > { w : & 'a mut W , } impl < 'a > TICKON_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TICKON_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Clocked by GCLK" ] # [ inline ( always ) ] pub fn clk_gclk_eic ( self ) -> & 'a mut W { self . variant ( TICKON_A :: CLK_GCLK_EIC ) } # [ doc = "Clocked by Low Frequency Clock" ] # [ inline ( always ) ] pub fn clk_lfreq ( self ) -> & 'a mut W { self . variant ( TICKON_A :: CLK_LFREQ ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Debouncer Prescaler" ] # [ inline ( always ) ] pub fn prescaler0 ( & self ) -> PRESCALER0_R { PRESCALER0_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bit 3 - Debouncer number of states" ] # [ inline ( always ) ] pub fn states0 ( & self ) -> STATES0_R { STATES0_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:6 - Debouncer Prescaler" ] # [ inline ( always ) ] pub fn prescaler1 ( & self ) -> PRESCALER1_R { PRESCALER1_R :: new ( ( ( self . bits >> 4 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 7 - Debouncer number of states" ] # [ inline ( always ) ] pub fn states1 ( & self ) -> STATES1_R { STATES1_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Pin Sampler frequency selection" ] # [ inline ( always ) ] pub fn tickon ( & self ) -> TICKON_R { TICKON_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:2 - Debouncer Prescaler" ] # [ inline ( always ) ] pub fn prescaler0 ( & mut self ) -> PRESCALER0_W { PRESCALER0_W { w : self } }
# [ doc = "Bit 3 - Debouncer number of states" ] # [ inline ( always ) ] pub fn states0 ( & mut self ) -> STATES0_W { STATES0_W { w : self } }
# [ doc = "Bits 4:6 - Debouncer Prescaler" ] # [ inline ( always ) ] pub fn prescaler1 ( & mut self ) -> PRESCALER1_W { PRESCALER1_W { w : self } }
# [ doc = "Bit 7 - Debouncer number of states" ] # [ inline ( always ) ] pub fn states1 ( & mut self ) -> STATES1_W { STATES1_W { w : self } }
# [ doc = "Bit 16 - Pin Sampler frequency selection" ] # [ inline ( always ) ] pub fn tickon ( & mut self ) -> TICKON_W { TICKON_W { w : self } }
}
}
# [ doc = "Pin State\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pinstate](pinstate) module" ] pub type PINSTATE = crate :: Reg < u32 , _PINSTATE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PINSTATE ;
# [ doc = "`read()` method returns [pinstate::R](pinstate::R) reader structure" ] impl crate :: Readable for PINSTATE { }
# [ doc = "Pin State" ] pub mod pinstate {
# [ doc = "Reader of register PINSTATE" ] pub type R = crate :: R < u32 , super :: PINSTATE > ;
# [ doc = "Reader of field `PINSTATE`" ] pub type PINSTATE_R = crate :: R < u16 , u16 > ;
impl R {
# [ doc = "Bits 0:15 - Pin State" ] # [ inline ( always ) ] pub fn pinstate ( & self ) -> PINSTATE_R { PINSTATE_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
}
}
# [ doc = "Event System Interface" ] pub struct EVSYS { _marker : PhantomData < * const ( ) > } unsafe impl Send for EVSYS { } impl EVSYS { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const evsys :: RegisterBlock { 0x4200_0000 as * const _ } } impl Deref for EVSYS { type Target = evsys :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * EVSYS :: ptr ( ) } } }
# [ doc = "Event System Interface" ] pub mod evsys {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control" ] pub ctrla : CTRLA , _reserved1 : [ u8 ; 11usize ] , # [ doc = "0x0c - Channel Status" ] pub chstatus : CHSTATUS , # [ doc = "0x10 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x14 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x18 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x1c - Software Event" ] pub swevt : SWEVT , # [ doc = "0x20 - Channel n" ] pub channel : [ CHANNEL ; 12 ] , _reserved7 : [ u8 ; 48usize ] , # [ doc = "0x80 - User Multiplexer n" ] pub user : [ USER ; 50 ] , }
# [ doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
}
}
# [ doc = "Channel Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [chstatus](chstatus) module" ] pub type CHSTATUS = crate :: Reg < u32 , _CHSTATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CHSTATUS ;
# [ doc = "`read()` method returns [chstatus::R](chstatus::R) reader structure" ] impl crate :: Readable for CHSTATUS { }
# [ doc = "Channel Status" ] pub mod chstatus {
# [ doc = "Reader of register CHSTATUS" ] pub type R = crate :: R < u32 , super :: CHSTATUS > ;
# [ doc = "Reader of field `USRRDY0`" ] pub type USRRDY0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY1`" ] pub type USRRDY1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY2`" ] pub type USRRDY2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY3`" ] pub type USRRDY3_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY4`" ] pub type USRRDY4_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY5`" ] pub type USRRDY5_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY6`" ] pub type USRRDY6_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY7`" ] pub type USRRDY7_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY8`" ] pub type USRRDY8_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY9`" ] pub type USRRDY9_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY10`" ] pub type USRRDY10_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `USRRDY11`" ] pub type USRRDY11_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY0`" ] pub type CHBUSY0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY1`" ] pub type CHBUSY1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY2`" ] pub type CHBUSY2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY3`" ] pub type CHBUSY3_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY4`" ] pub type CHBUSY4_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY5`" ] pub type CHBUSY5_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY6`" ] pub type CHBUSY6_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY7`" ] pub type CHBUSY7_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY8`" ] pub type CHBUSY8_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY9`" ] pub type CHBUSY9_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY10`" ] pub type CHBUSY10_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CHBUSY11`" ] pub type CHBUSY11_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Channel 0 User Ready" ] # [ inline ( always ) ] pub fn usrrdy0 ( & self ) -> USRRDY0_R { USRRDY0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel 1 User Ready" ] # [ inline ( always ) ] pub fn usrrdy1 ( & self ) -> USRRDY1_R { USRRDY1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel 2 User Ready" ] # [ inline ( always ) ] pub fn usrrdy2 ( & self ) -> USRRDY2_R { USRRDY2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Channel 3 User Ready" ] # [ inline ( always ) ] pub fn usrrdy3 ( & self ) -> USRRDY3_R { USRRDY3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Channel 4 User Ready" ] # [ inline ( always ) ] pub fn usrrdy4 ( & self ) -> USRRDY4_R { USRRDY4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Channel 5 User Ready" ] # [ inline ( always ) ] pub fn usrrdy5 ( & self ) -> USRRDY5_R { USRRDY5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Channel 6 User Ready" ] # [ inline ( always ) ] pub fn usrrdy6 ( & self ) -> USRRDY6_R { USRRDY6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Channel 7 User Ready" ] # [ inline ( always ) ] pub fn usrrdy7 ( & self ) -> USRRDY7_R { USRRDY7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Channel 8 User Ready" ] # [ inline ( always ) ] pub fn usrrdy8 ( & self ) -> USRRDY8_R { USRRDY8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Channel 9 User Ready" ] # [ inline ( always ) ] pub fn usrrdy9 ( & self ) -> USRRDY9_R { USRRDY9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Channel 10 User Ready" ] # [ inline ( always ) ] pub fn usrrdy10 ( & self ) -> USRRDY10_R { USRRDY10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Channel 11 User Ready" ] # [ inline ( always ) ] pub fn usrrdy11 ( & self ) -> USRRDY11_R { USRRDY11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Channel 0 Busy" ] # [ inline ( always ) ] pub fn chbusy0 ( & self ) -> CHBUSY0_R { CHBUSY0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Channel 1 Busy" ] # [ inline ( always ) ] pub fn chbusy1 ( & self ) -> CHBUSY1_R { CHBUSY1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Channel 2 Busy" ] # [ inline ( always ) ] pub fn chbusy2 ( & self ) -> CHBUSY2_R { CHBUSY2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Channel 3 Busy" ] # [ inline ( always ) ] pub fn chbusy3 ( & self ) -> CHBUSY3_R { CHBUSY3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Channel 4 Busy" ] # [ inline ( always ) ] pub fn chbusy4 ( & self ) -> CHBUSY4_R { CHBUSY4_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Channel 5 Busy" ] # [ inline ( always ) ] pub fn chbusy5 ( & self ) -> CHBUSY5_R { CHBUSY5_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Channel 6 Busy" ] # [ inline ( always ) ] pub fn chbusy6 ( & self ) -> CHBUSY6_R { CHBUSY6_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Channel 7 Busy" ] # [ inline ( always ) ] pub fn chbusy7 ( & self ) -> CHBUSY7_R { CHBUSY7_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Channel 8 Busy" ] # [ inline ( always ) ] pub fn chbusy8 ( & self ) -> CHBUSY8_R { CHBUSY8_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Channel 9 Busy" ] # [ inline ( always ) ] pub fn chbusy9 ( & self ) -> CHBUSY9_R { CHBUSY9_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Channel 10 Busy" ] # [ inline ( always ) ] pub fn chbusy10 ( & self ) -> CHBUSY10_R { CHBUSY10_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Channel 11 Busy" ] # [ inline ( always ) ] pub fn chbusy11 ( & self ) -> CHBUSY11_R { CHBUSY11_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u32 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u32 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u32 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OVR0`" ] pub type OVR0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR0`" ] pub struct OVR0_W < 'a > { w : & 'a mut W , } impl < 'a > OVR0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVR1`" ] pub type OVR1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR1`" ] pub struct OVR1_W < 'a > { w : & 'a mut W , } impl < 'a > OVR1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `OVR2`" ] pub type OVR2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR2`" ] pub struct OVR2_W < 'a > { w : & 'a mut W , } impl < 'a > OVR2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `OVR3`" ] pub type OVR3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR3`" ] pub struct OVR3_W < 'a > { w : & 'a mut W , } impl < 'a > OVR3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `OVR4`" ] pub type OVR4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR4`" ] pub struct OVR4_W < 'a > { w : & 'a mut W , } impl < 'a > OVR4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `OVR5`" ] pub type OVR5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR5`" ] pub struct OVR5_W < 'a > { w : & 'a mut W , } impl < 'a > OVR5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `OVR6`" ] pub type OVR6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR6`" ] pub struct OVR6_W < 'a > { w : & 'a mut W , } impl < 'a > OVR6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `OVR7`" ] pub type OVR7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR7`" ] pub struct OVR7_W < 'a > { w : & 'a mut W , } impl < 'a > OVR7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `OVR8`" ] pub type OVR8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR8`" ] pub struct OVR8_W < 'a > { w : & 'a mut W , } impl < 'a > OVR8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `OVR9`" ] pub type OVR9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR9`" ] pub struct OVR9_W < 'a > { w : & 'a mut W , } impl < 'a > OVR9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `OVR10`" ] pub type OVR10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR10`" ] pub struct OVR10_W < 'a > { w : & 'a mut W , } impl < 'a > OVR10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `OVR11`" ] pub type OVR11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR11`" ] pub struct OVR11_W < 'a > { w : & 'a mut W , } impl < 'a > OVR11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `EVD0`" ] pub type EVD0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD0`" ] pub struct EVD0_W < 'a > { w : & 'a mut W , } impl < 'a > EVD0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `EVD1`" ] pub type EVD1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD1`" ] pub struct EVD1_W < 'a > { w : & 'a mut W , } impl < 'a > EVD1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `EVD2`" ] pub type EVD2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD2`" ] pub struct EVD2_W < 'a > { w : & 'a mut W , } impl < 'a > EVD2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `EVD3`" ] pub type EVD3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD3`" ] pub struct EVD3_W < 'a > { w : & 'a mut W , } impl < 'a > EVD3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `EVD4`" ] pub type EVD4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD4`" ] pub struct EVD4_W < 'a > { w : & 'a mut W , } impl < 'a > EVD4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `EVD5`" ] pub type EVD5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD5`" ] pub struct EVD5_W < 'a > { w : & 'a mut W , } impl < 'a > EVD5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `EVD6`" ] pub type EVD6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD6`" ] pub struct EVD6_W < 'a > { w : & 'a mut W , } impl < 'a > EVD6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `EVD7`" ] pub type EVD7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD7`" ] pub struct EVD7_W < 'a > { w : & 'a mut W , } impl < 'a > EVD7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `EVD8`" ] pub type EVD8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD8`" ] pub struct EVD8_W < 'a > { w : & 'a mut W , } impl < 'a > EVD8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `EVD9`" ] pub type EVD9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD9`" ] pub struct EVD9_W < 'a > { w : & 'a mut W , } impl < 'a > EVD9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `EVD10`" ] pub type EVD10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD10`" ] pub struct EVD10_W < 'a > { w : & 'a mut W , } impl < 'a > EVD10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `EVD11`" ] pub type EVD11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD11`" ] pub struct EVD11_W < 'a > { w : & 'a mut W , } impl < 'a > EVD11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Channel 0 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr0 ( & self ) -> OVR0_R { OVR0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel 1 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr1 ( & self ) -> OVR1_R { OVR1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel 2 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr2 ( & self ) -> OVR2_R { OVR2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Channel 3 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr3 ( & self ) -> OVR3_R { OVR3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Channel 4 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr4 ( & self ) -> OVR4_R { OVR4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Channel 5 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr5 ( & self ) -> OVR5_R { OVR5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Channel 6 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr6 ( & self ) -> OVR6_R { OVR6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Channel 7 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr7 ( & self ) -> OVR7_R { OVR7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Channel 8 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr8 ( & self ) -> OVR8_R { OVR8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Channel 9 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr9 ( & self ) -> OVR9_R { OVR9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Channel 10 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr10 ( & self ) -> OVR10_R { OVR10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Channel 11 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr11 ( & self ) -> OVR11_R { OVR11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Channel 0 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd0 ( & self ) -> EVD0_R { EVD0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Channel 1 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd1 ( & self ) -> EVD1_R { EVD1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Channel 2 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd2 ( & self ) -> EVD2_R { EVD2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Channel 3 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd3 ( & self ) -> EVD3_R { EVD3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Channel 4 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd4 ( & self ) -> EVD4_R { EVD4_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Channel 5 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd5 ( & self ) -> EVD5_R { EVD5_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Channel 6 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd6 ( & self ) -> EVD6_R { EVD6_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Channel 7 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd7 ( & self ) -> EVD7_R { EVD7_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd8 ( & self ) -> EVD8_R { EVD8_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd9 ( & self ) -> EVD9_R { EVD9_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd10 ( & self ) -> EVD10_R { EVD10_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd11 ( & self ) -> EVD11_R { EVD11_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Channel 0 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr0 ( & mut self ) -> OVR0_W { OVR0_W { w : self } }
# [ doc = "Bit 1 - Channel 1 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr1 ( & mut self ) -> OVR1_W { OVR1_W { w : self } }
# [ doc = "Bit 2 - Channel 2 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr2 ( & mut self ) -> OVR2_W { OVR2_W { w : self } }
# [ doc = "Bit 3 - Channel 3 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr3 ( & mut self ) -> OVR3_W { OVR3_W { w : self } }
# [ doc = "Bit 4 - Channel 4 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr4 ( & mut self ) -> OVR4_W { OVR4_W { w : self } }
# [ doc = "Bit 5 - Channel 5 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr5 ( & mut self ) -> OVR5_W { OVR5_W { w : self } }
# [ doc = "Bit 6 - Channel 6 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr6 ( & mut self ) -> OVR6_W { OVR6_W { w : self } }
# [ doc = "Bit 7 - Channel 7 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr7 ( & mut self ) -> OVR7_W { OVR7_W { w : self } }
# [ doc = "Bit 8 - Channel 8 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr8 ( & mut self ) -> OVR8_W { OVR8_W { w : self } }
# [ doc = "Bit 9 - Channel 9 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr9 ( & mut self ) -> OVR9_W { OVR9_W { w : self } }
# [ doc = "Bit 10 - Channel 10 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr10 ( & mut self ) -> OVR10_W { OVR10_W { w : self } }
# [ doc = "Bit 11 - Channel 11 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr11 ( & mut self ) -> OVR11_W { OVR11_W { w : self } }
# [ doc = "Bit 16 - Channel 0 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd0 ( & mut self ) -> EVD0_W { EVD0_W { w : self } }
# [ doc = "Bit 17 - Channel 1 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd1 ( & mut self ) -> EVD1_W { EVD1_W { w : self } }
# [ doc = "Bit 18 - Channel 2 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd2 ( & mut self ) -> EVD2_W { EVD2_W { w : self } }
# [ doc = "Bit 19 - Channel 3 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd3 ( & mut self ) -> EVD3_W { EVD3_W { w : self } }
# [ doc = "Bit 20 - Channel 4 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd4 ( & mut self ) -> EVD4_W { EVD4_W { w : self } }
# [ doc = "Bit 21 - Channel 5 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd5 ( & mut self ) -> EVD5_W { EVD5_W { w : self } }
# [ doc = "Bit 22 - Channel 6 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd6 ( & mut self ) -> EVD6_W { EVD6_W { w : self } }
# [ doc = "Bit 23 - Channel 7 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd7 ( & mut self ) -> EVD7_W { EVD7_W { w : self } }
# [ doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd8 ( & mut self ) -> EVD8_W { EVD8_W { w : self } }
# [ doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd9 ( & mut self ) -> EVD9_W { EVD9_W { w : self } }
# [ doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd10 ( & mut self ) -> EVD10_W { EVD10_W { w : self } }
# [ doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd11 ( & mut self ) -> EVD11_W { EVD11_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u32 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u32 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u32 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OVR0`" ] pub type OVR0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR0`" ] pub struct OVR0_W < 'a > { w : & 'a mut W , } impl < 'a > OVR0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVR1`" ] pub type OVR1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR1`" ] pub struct OVR1_W < 'a > { w : & 'a mut W , } impl < 'a > OVR1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `OVR2`" ] pub type OVR2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR2`" ] pub struct OVR2_W < 'a > { w : & 'a mut W , } impl < 'a > OVR2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `OVR3`" ] pub type OVR3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR3`" ] pub struct OVR3_W < 'a > { w : & 'a mut W , } impl < 'a > OVR3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `OVR4`" ] pub type OVR4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR4`" ] pub struct OVR4_W < 'a > { w : & 'a mut W , } impl < 'a > OVR4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `OVR5`" ] pub type OVR5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR5`" ] pub struct OVR5_W < 'a > { w : & 'a mut W , } impl < 'a > OVR5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `OVR6`" ] pub type OVR6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR6`" ] pub struct OVR6_W < 'a > { w : & 'a mut W , } impl < 'a > OVR6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `OVR7`" ] pub type OVR7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR7`" ] pub struct OVR7_W < 'a > { w : & 'a mut W , } impl < 'a > OVR7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `OVR8`" ] pub type OVR8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR8`" ] pub struct OVR8_W < 'a > { w : & 'a mut W , } impl < 'a > OVR8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `OVR9`" ] pub type OVR9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR9`" ] pub struct OVR9_W < 'a > { w : & 'a mut W , } impl < 'a > OVR9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `OVR10`" ] pub type OVR10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR10`" ] pub struct OVR10_W < 'a > { w : & 'a mut W , } impl < 'a > OVR10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `OVR11`" ] pub type OVR11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR11`" ] pub struct OVR11_W < 'a > { w : & 'a mut W , } impl < 'a > OVR11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `EVD0`" ] pub type EVD0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD0`" ] pub struct EVD0_W < 'a > { w : & 'a mut W , } impl < 'a > EVD0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `EVD1`" ] pub type EVD1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD1`" ] pub struct EVD1_W < 'a > { w : & 'a mut W , } impl < 'a > EVD1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `EVD2`" ] pub type EVD2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD2`" ] pub struct EVD2_W < 'a > { w : & 'a mut W , } impl < 'a > EVD2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `EVD3`" ] pub type EVD3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD3`" ] pub struct EVD3_W < 'a > { w : & 'a mut W , } impl < 'a > EVD3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `EVD4`" ] pub type EVD4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD4`" ] pub struct EVD4_W < 'a > { w : & 'a mut W , } impl < 'a > EVD4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `EVD5`" ] pub type EVD5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD5`" ] pub struct EVD5_W < 'a > { w : & 'a mut W , } impl < 'a > EVD5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `EVD6`" ] pub type EVD6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD6`" ] pub struct EVD6_W < 'a > { w : & 'a mut W , } impl < 'a > EVD6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `EVD7`" ] pub type EVD7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD7`" ] pub struct EVD7_W < 'a > { w : & 'a mut W , } impl < 'a > EVD7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `EVD8`" ] pub type EVD8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD8`" ] pub struct EVD8_W < 'a > { w : & 'a mut W , } impl < 'a > EVD8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `EVD9`" ] pub type EVD9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD9`" ] pub struct EVD9_W < 'a > { w : & 'a mut W , } impl < 'a > EVD9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `EVD10`" ] pub type EVD10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD10`" ] pub struct EVD10_W < 'a > { w : & 'a mut W , } impl < 'a > EVD10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `EVD11`" ] pub type EVD11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD11`" ] pub struct EVD11_W < 'a > { w : & 'a mut W , } impl < 'a > EVD11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Channel 0 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr0 ( & self ) -> OVR0_R { OVR0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel 1 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr1 ( & self ) -> OVR1_R { OVR1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel 2 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr2 ( & self ) -> OVR2_R { OVR2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Channel 3 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr3 ( & self ) -> OVR3_R { OVR3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Channel 4 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr4 ( & self ) -> OVR4_R { OVR4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Channel 5 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr5 ( & self ) -> OVR5_R { OVR5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Channel 6 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr6 ( & self ) -> OVR6_R { OVR6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Channel 7 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr7 ( & self ) -> OVR7_R { OVR7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Channel 8 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr8 ( & self ) -> OVR8_R { OVR8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Channel 9 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr9 ( & self ) -> OVR9_R { OVR9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Channel 10 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr10 ( & self ) -> OVR10_R { OVR10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Channel 11 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr11 ( & self ) -> OVR11_R { OVR11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Channel 0 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd0 ( & self ) -> EVD0_R { EVD0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Channel 1 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd1 ( & self ) -> EVD1_R { EVD1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Channel 2 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd2 ( & self ) -> EVD2_R { EVD2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Channel 3 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd3 ( & self ) -> EVD3_R { EVD3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Channel 4 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd4 ( & self ) -> EVD4_R { EVD4_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Channel 5 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd5 ( & self ) -> EVD5_R { EVD5_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Channel 6 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd6 ( & self ) -> EVD6_R { EVD6_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Channel 7 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd7 ( & self ) -> EVD7_R { EVD7_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd8 ( & self ) -> EVD8_R { EVD8_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd9 ( & self ) -> EVD9_R { EVD9_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd10 ( & self ) -> EVD10_R { EVD10_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd11 ( & self ) -> EVD11_R { EVD11_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Channel 0 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr0 ( & mut self ) -> OVR0_W { OVR0_W { w : self } }
# [ doc = "Bit 1 - Channel 1 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr1 ( & mut self ) -> OVR1_W { OVR1_W { w : self } }
# [ doc = "Bit 2 - Channel 2 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr2 ( & mut self ) -> OVR2_W { OVR2_W { w : self } }
# [ doc = "Bit 3 - Channel 3 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr3 ( & mut self ) -> OVR3_W { OVR3_W { w : self } }
# [ doc = "Bit 4 - Channel 4 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr4 ( & mut self ) -> OVR4_W { OVR4_W { w : self } }
# [ doc = "Bit 5 - Channel 5 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr5 ( & mut self ) -> OVR5_W { OVR5_W { w : self } }
# [ doc = "Bit 6 - Channel 6 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr6 ( & mut self ) -> OVR6_W { OVR6_W { w : self } }
# [ doc = "Bit 7 - Channel 7 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr7 ( & mut self ) -> OVR7_W { OVR7_W { w : self } }
# [ doc = "Bit 8 - Channel 8 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr8 ( & mut self ) -> OVR8_W { OVR8_W { w : self } }
# [ doc = "Bit 9 - Channel 9 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr9 ( & mut self ) -> OVR9_W { OVR9_W { w : self } }
# [ doc = "Bit 10 - Channel 10 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr10 ( & mut self ) -> OVR10_W { OVR10_W { w : self } }
# [ doc = "Bit 11 - Channel 11 Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn ovr11 ( & mut self ) -> OVR11_W { OVR11_W { w : self } }
# [ doc = "Bit 16 - Channel 0 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd0 ( & mut self ) -> EVD0_W { EVD0_W { w : self } }
# [ doc = "Bit 17 - Channel 1 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd1 ( & mut self ) -> EVD1_W { EVD1_W { w : self } }
# [ doc = "Bit 18 - Channel 2 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd2 ( & mut self ) -> EVD2_W { EVD2_W { w : self } }
# [ doc = "Bit 19 - Channel 3 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd3 ( & mut self ) -> EVD3_W { EVD3_W { w : self } }
# [ doc = "Bit 20 - Channel 4 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd4 ( & mut self ) -> EVD4_W { EVD4_W { w : self } }
# [ doc = "Bit 21 - Channel 5 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd5 ( & mut self ) -> EVD5_W { EVD5_W { w : self } }
# [ doc = "Bit 22 - Channel 6 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd6 ( & mut self ) -> EVD6_W { EVD6_W { w : self } }
# [ doc = "Bit 23 - Channel 7 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd7 ( & mut self ) -> EVD7_W { EVD7_W { w : self } }
# [ doc = "Bit 24 - Channel 8 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd8 ( & mut self ) -> EVD8_W { EVD8_W { w : self } }
# [ doc = "Bit 25 - Channel 9 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd9 ( & mut self ) -> EVD9_W { EVD9_W { w : self } }
# [ doc = "Bit 26 - Channel 10 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd10 ( & mut self ) -> EVD10_W { EVD10_W { w : self } }
# [ doc = "Bit 27 - Channel 11 Event Detection Interrupt Enable" ] # [ inline ( always ) ] pub fn evd11 ( & mut self ) -> EVD11_W { EVD11_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u32 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u32 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u32 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OVR0`" ] pub type OVR0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR0`" ] pub struct OVR0_W < 'a > { w : & 'a mut W , } impl < 'a > OVR0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVR1`" ] pub type OVR1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR1`" ] pub struct OVR1_W < 'a > { w : & 'a mut W , } impl < 'a > OVR1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `OVR2`" ] pub type OVR2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR2`" ] pub struct OVR2_W < 'a > { w : & 'a mut W , } impl < 'a > OVR2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `OVR3`" ] pub type OVR3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR3`" ] pub struct OVR3_W < 'a > { w : & 'a mut W , } impl < 'a > OVR3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `OVR4`" ] pub type OVR4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR4`" ] pub struct OVR4_W < 'a > { w : & 'a mut W , } impl < 'a > OVR4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `OVR5`" ] pub type OVR5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR5`" ] pub struct OVR5_W < 'a > { w : & 'a mut W , } impl < 'a > OVR5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `OVR6`" ] pub type OVR6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR6`" ] pub struct OVR6_W < 'a > { w : & 'a mut W , } impl < 'a > OVR6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `OVR7`" ] pub type OVR7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR7`" ] pub struct OVR7_W < 'a > { w : & 'a mut W , } impl < 'a > OVR7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `OVR8`" ] pub type OVR8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR8`" ] pub struct OVR8_W < 'a > { w : & 'a mut W , } impl < 'a > OVR8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `OVR9`" ] pub type OVR9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR9`" ] pub struct OVR9_W < 'a > { w : & 'a mut W , } impl < 'a > OVR9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `OVR10`" ] pub type OVR10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR10`" ] pub struct OVR10_W < 'a > { w : & 'a mut W , } impl < 'a > OVR10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `OVR11`" ] pub type OVR11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVR11`" ] pub struct OVR11_W < 'a > { w : & 'a mut W , } impl < 'a > OVR11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `EVD0`" ] pub type EVD0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD0`" ] pub struct EVD0_W < 'a > { w : & 'a mut W , } impl < 'a > EVD0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `EVD1`" ] pub type EVD1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD1`" ] pub struct EVD1_W < 'a > { w : & 'a mut W , } impl < 'a > EVD1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `EVD2`" ] pub type EVD2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD2`" ] pub struct EVD2_W < 'a > { w : & 'a mut W , } impl < 'a > EVD2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `EVD3`" ] pub type EVD3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD3`" ] pub struct EVD3_W < 'a > { w : & 'a mut W , } impl < 'a > EVD3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `EVD4`" ] pub type EVD4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD4`" ] pub struct EVD4_W < 'a > { w : & 'a mut W , } impl < 'a > EVD4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `EVD5`" ] pub type EVD5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD5`" ] pub struct EVD5_W < 'a > { w : & 'a mut W , } impl < 'a > EVD5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `EVD6`" ] pub type EVD6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD6`" ] pub struct EVD6_W < 'a > { w : & 'a mut W , } impl < 'a > EVD6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `EVD7`" ] pub type EVD7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD7`" ] pub struct EVD7_W < 'a > { w : & 'a mut W , } impl < 'a > EVD7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `EVD8`" ] pub type EVD8_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD8`" ] pub struct EVD8_W < 'a > { w : & 'a mut W , } impl < 'a > EVD8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `EVD9`" ] pub type EVD9_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD9`" ] pub struct EVD9_W < 'a > { w : & 'a mut W , } impl < 'a > EVD9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `EVD10`" ] pub type EVD10_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD10`" ] pub struct EVD10_W < 'a > { w : & 'a mut W , } impl < 'a > EVD10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `EVD11`" ] pub type EVD11_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVD11`" ] pub struct EVD11_W < 'a > { w : & 'a mut W , } impl < 'a > EVD11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Channel 0 Overrun" ] # [ inline ( always ) ] pub fn ovr0 ( & self ) -> OVR0_R { OVR0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Channel 1 Overrun" ] # [ inline ( always ) ] pub fn ovr1 ( & self ) -> OVR1_R { OVR1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Channel 2 Overrun" ] # [ inline ( always ) ] pub fn ovr2 ( & self ) -> OVR2_R { OVR2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Channel 3 Overrun" ] # [ inline ( always ) ] pub fn ovr3 ( & self ) -> OVR3_R { OVR3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Channel 4 Overrun" ] # [ inline ( always ) ] pub fn ovr4 ( & self ) -> OVR4_R { OVR4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Channel 5 Overrun" ] # [ inline ( always ) ] pub fn ovr5 ( & self ) -> OVR5_R { OVR5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Channel 6 Overrun" ] # [ inline ( always ) ] pub fn ovr6 ( & self ) -> OVR6_R { OVR6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Channel 7 Overrun" ] # [ inline ( always ) ] pub fn ovr7 ( & self ) -> OVR7_R { OVR7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Channel 8 Overrun" ] # [ inline ( always ) ] pub fn ovr8 ( & self ) -> OVR8_R { OVR8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Channel 9 Overrun" ] # [ inline ( always ) ] pub fn ovr9 ( & self ) -> OVR9_R { OVR9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Channel 10 Overrun" ] # [ inline ( always ) ] pub fn ovr10 ( & self ) -> OVR10_R { OVR10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Channel 11 Overrun" ] # [ inline ( always ) ] pub fn ovr11 ( & self ) -> OVR11_R { OVR11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Channel 0 Event Detection" ] # [ inline ( always ) ] pub fn evd0 ( & self ) -> EVD0_R { EVD0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Channel 1 Event Detection" ] # [ inline ( always ) ] pub fn evd1 ( & self ) -> EVD1_R { EVD1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Channel 2 Event Detection" ] # [ inline ( always ) ] pub fn evd2 ( & self ) -> EVD2_R { EVD2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Channel 3 Event Detection" ] # [ inline ( always ) ] pub fn evd3 ( & self ) -> EVD3_R { EVD3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Channel 4 Event Detection" ] # [ inline ( always ) ] pub fn evd4 ( & self ) -> EVD4_R { EVD4_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Channel 5 Event Detection" ] # [ inline ( always ) ] pub fn evd5 ( & self ) -> EVD5_R { EVD5_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Channel 6 Event Detection" ] # [ inline ( always ) ] pub fn evd6 ( & self ) -> EVD6_R { EVD6_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Channel 7 Event Detection" ] # [ inline ( always ) ] pub fn evd7 ( & self ) -> EVD7_R { EVD7_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Channel 8 Event Detection" ] # [ inline ( always ) ] pub fn evd8 ( & self ) -> EVD8_R { EVD8_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Channel 9 Event Detection" ] # [ inline ( always ) ] pub fn evd9 ( & self ) -> EVD9_R { EVD9_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Channel 10 Event Detection" ] # [ inline ( always ) ] pub fn evd10 ( & self ) -> EVD10_R { EVD10_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Channel 11 Event Detection" ] # [ inline ( always ) ] pub fn evd11 ( & self ) -> EVD11_R { EVD11_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Channel 0 Overrun" ] # [ inline ( always ) ] pub fn ovr0 ( & mut self ) -> OVR0_W { OVR0_W { w : self } }
# [ doc = "Bit 1 - Channel 1 Overrun" ] # [ inline ( always ) ] pub fn ovr1 ( & mut self ) -> OVR1_W { OVR1_W { w : self } }
# [ doc = "Bit 2 - Channel 2 Overrun" ] # [ inline ( always ) ] pub fn ovr2 ( & mut self ) -> OVR2_W { OVR2_W { w : self } }
# [ doc = "Bit 3 - Channel 3 Overrun" ] # [ inline ( always ) ] pub fn ovr3 ( & mut self ) -> OVR3_W { OVR3_W { w : self } }
# [ doc = "Bit 4 - Channel 4 Overrun" ] # [ inline ( always ) ] pub fn ovr4 ( & mut self ) -> OVR4_W { OVR4_W { w : self } }
# [ doc = "Bit 5 - Channel 5 Overrun" ] # [ inline ( always ) ] pub fn ovr5 ( & mut self ) -> OVR5_W { OVR5_W { w : self } }
# [ doc = "Bit 6 - Channel 6 Overrun" ] # [ inline ( always ) ] pub fn ovr6 ( & mut self ) -> OVR6_W { OVR6_W { w : self } }
# [ doc = "Bit 7 - Channel 7 Overrun" ] # [ inline ( always ) ] pub fn ovr7 ( & mut self ) -> OVR7_W { OVR7_W { w : self } }
# [ doc = "Bit 8 - Channel 8 Overrun" ] # [ inline ( always ) ] pub fn ovr8 ( & mut self ) -> OVR8_W { OVR8_W { w : self } }
# [ doc = "Bit 9 - Channel 9 Overrun" ] # [ inline ( always ) ] pub fn ovr9 ( & mut self ) -> OVR9_W { OVR9_W { w : self } }
# [ doc = "Bit 10 - Channel 10 Overrun" ] # [ inline ( always ) ] pub fn ovr10 ( & mut self ) -> OVR10_W { OVR10_W { w : self } }
# [ doc = "Bit 11 - Channel 11 Overrun" ] # [ inline ( always ) ] pub fn ovr11 ( & mut self ) -> OVR11_W { OVR11_W { w : self } }
# [ doc = "Bit 16 - Channel 0 Event Detection" ] # [ inline ( always ) ] pub fn evd0 ( & mut self ) -> EVD0_W { EVD0_W { w : self } }
# [ doc = "Bit 17 - Channel 1 Event Detection" ] # [ inline ( always ) ] pub fn evd1 ( & mut self ) -> EVD1_W { EVD1_W { w : self } }
# [ doc = "Bit 18 - Channel 2 Event Detection" ] # [ inline ( always ) ] pub fn evd2 ( & mut self ) -> EVD2_W { EVD2_W { w : self } }
# [ doc = "Bit 19 - Channel 3 Event Detection" ] # [ inline ( always ) ] pub fn evd3 ( & mut self ) -> EVD3_W { EVD3_W { w : self } }
# [ doc = "Bit 20 - Channel 4 Event Detection" ] # [ inline ( always ) ] pub fn evd4 ( & mut self ) -> EVD4_W { EVD4_W { w : self } }
# [ doc = "Bit 21 - Channel 5 Event Detection" ] # [ inline ( always ) ] pub fn evd5 ( & mut self ) -> EVD5_W { EVD5_W { w : self } }
# [ doc = "Bit 22 - Channel 6 Event Detection" ] # [ inline ( always ) ] pub fn evd6 ( & mut self ) -> EVD6_W { EVD6_W { w : self } }
# [ doc = "Bit 23 - Channel 7 Event Detection" ] # [ inline ( always ) ] pub fn evd7 ( & mut self ) -> EVD7_W { EVD7_W { w : self } }
# [ doc = "Bit 24 - Channel 8 Event Detection" ] # [ inline ( always ) ] pub fn evd8 ( & mut self ) -> EVD8_W { EVD8_W { w : self } }
# [ doc = "Bit 25 - Channel 9 Event Detection" ] # [ inline ( always ) ] pub fn evd9 ( & mut self ) -> EVD9_W { EVD9_W { w : self } }
# [ doc = "Bit 26 - Channel 10 Event Detection" ] # [ inline ( always ) ] pub fn evd10 ( & mut self ) -> EVD10_W { EVD10_W { w : self } }
# [ doc = "Bit 27 - Channel 11 Event Detection" ] # [ inline ( always ) ] pub fn evd11 ( & mut self ) -> EVD11_W { EVD11_W { w : self } }
}
}
# [ doc = "Software Event\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [swevt](swevt) module" ] pub type SWEVT = crate :: Reg < u32 , _SWEVT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SWEVT ;
# [ doc = "`write(|w| ..)` method takes [swevt::W](swevt::W) writer structure" ] impl crate :: Writable for SWEVT { }
# [ doc = "Software Event" ] pub mod swevt {
# [ doc = "Writer for register SWEVT" ] pub type W = crate :: W < u32 , super :: SWEVT > ;
# [ doc = "Register SWEVT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SWEVT { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Write proxy for field `CHANNEL0`" ] pub struct CHANNEL0_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL1`" ] pub struct CHANNEL1_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL2`" ] pub struct CHANNEL2_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL3`" ] pub struct CHANNEL3_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL4`" ] pub struct CHANNEL4_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL5`" ] pub struct CHANNEL5_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL6`" ] pub struct CHANNEL6_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL7`" ] pub struct CHANNEL7_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL8`" ] pub struct CHANNEL8_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL8_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL9`" ] pub struct CHANNEL9_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL9_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL10`" ] pub struct CHANNEL10_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL10_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Write proxy for field `CHANNEL11`" ] pub struct CHANNEL11_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL11_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
impl W {
# [ doc = "Bit 0 - Channel 0 Software Selection" ] # [ inline ( always ) ] pub fn channel0 ( & mut self ) -> CHANNEL0_W { CHANNEL0_W { w : self } }
# [ doc = "Bit 1 - Channel 1 Software Selection" ] # [ inline ( always ) ] pub fn channel1 ( & mut self ) -> CHANNEL1_W { CHANNEL1_W { w : self } }
# [ doc = "Bit 2 - Channel 2 Software Selection" ] # [ inline ( always ) ] pub fn channel2 ( & mut self ) -> CHANNEL2_W { CHANNEL2_W { w : self } }
# [ doc = "Bit 3 - Channel 3 Software Selection" ] # [ inline ( always ) ] pub fn channel3 ( & mut self ) -> CHANNEL3_W { CHANNEL3_W { w : self } }
# [ doc = "Bit 4 - Channel 4 Software Selection" ] # [ inline ( always ) ] pub fn channel4 ( & mut self ) -> CHANNEL4_W { CHANNEL4_W { w : self } }
# [ doc = "Bit 5 - Channel 5 Software Selection" ] # [ inline ( always ) ] pub fn channel5 ( & mut self ) -> CHANNEL5_W { CHANNEL5_W { w : self } }
# [ doc = "Bit 6 - Channel 6 Software Selection" ] # [ inline ( always ) ] pub fn channel6 ( & mut self ) -> CHANNEL6_W { CHANNEL6_W { w : self } }
# [ doc = "Bit 7 - Channel 7 Software Selection" ] # [ inline ( always ) ] pub fn channel7 ( & mut self ) -> CHANNEL7_W { CHANNEL7_W { w : self } }
# [ doc = "Bit 8 - Channel 8 Software Selection" ] # [ inline ( always ) ] pub fn channel8 ( & mut self ) -> CHANNEL8_W { CHANNEL8_W { w : self } }
# [ doc = "Bit 9 - Channel 9 Software Selection" ] # [ inline ( always ) ] pub fn channel9 ( & mut self ) -> CHANNEL9_W { CHANNEL9_W { w : self } }
# [ doc = "Bit 10 - Channel 10 Software Selection" ] # [ inline ( always ) ] pub fn channel10 ( & mut self ) -> CHANNEL10_W { CHANNEL10_W { w : self } }
# [ doc = "Bit 11 - Channel 11 Software Selection" ] # [ inline ( always ) ] pub fn channel11 ( & mut self ) -> CHANNEL11_W { CHANNEL11_W { w : self } }
}
}
# [ doc = "Channel n\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [channel](channel) module" ] pub type CHANNEL = crate :: Reg < u32 , _CHANNEL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CHANNEL ;
# [ doc = "`read()` method returns [channel::R](channel::R) reader structure" ] impl crate :: Readable for CHANNEL { }
# [ doc = "`write(|w| ..)` method takes [channel::W](channel::W) writer structure" ] impl crate :: Writable for CHANNEL { }
# [ doc = "Channel n" ] pub mod channel {
# [ doc = "Reader of register CHANNEL[%s]" ] pub type R = crate :: R < u32 , super :: CHANNEL > ;
# [ doc = "Writer for register CHANNEL[%s]" ] pub type W = crate :: W < u32 , super :: CHANNEL > ;
# [ doc = "Register CHANNEL[%s] `reset()`'s with value 0x8000" ] impl crate :: ResetValue for super :: CHANNEL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x8000 } }
# [ doc = "Reader of field `EVGEN`" ] pub type EVGEN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `EVGEN`" ] pub struct EVGEN_W < 'a > { w : & 'a mut W , } impl < 'a > EVGEN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x7f ) | ( ( value as u32 ) & 0x7f ) ; self . w } }
# [ doc = "Possible values of the field `PATH`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PATH_A { # [ doc = "Synchronous path" ] SYNCHRONOUS , # [ doc = "Resynchronized path" ] RESYNCHRONIZED , # [ doc = "Asynchronous path" ] ASYNCHRONOUS }
impl crate :: ToBits < u8 > for PATH_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PATH_A :: SYNCHRONOUS => 0 , PATH_A :: RESYNCHRONIZED => 1 , PATH_A :: ASYNCHRONOUS => 2 } } }
# [ doc = "Reader of field `PATH`" ] pub type PATH_R = crate :: R < u8 , PATH_A > ; impl PATH_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PATH_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PATH_A :: SYNCHRONOUS ) , 1 => Val ( PATH_A :: RESYNCHRONIZED ) , 2 => Val ( PATH_A :: ASYNCHRONOUS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SYNCHRONOUS`" ] # [ inline ( always ) ] pub fn is_synchronous ( & self ) -> bool { * self == PATH_A :: SYNCHRONOUS } # [ doc = "Checks if the value of the field is `RESYNCHRONIZED`" ] # [ inline ( always ) ] pub fn is_resynchronized ( & self ) -> bool { * self == PATH_A :: RESYNCHRONIZED } # [ doc = "Checks if the value of the field is `ASYNCHRONOUS`" ] # [ inline ( always ) ] pub fn is_asynchronous ( & self ) -> bool { * self == PATH_A :: ASYNCHRONOUS } }
# [ doc = "Write proxy for field `PATH`" ] pub struct PATH_W < 'a > { w : & 'a mut W , } impl < 'a > PATH_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PATH_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Synchronous path" ] # [ inline ( always ) ] pub fn synchronous ( self ) -> & 'a mut W { self . variant ( PATH_A :: SYNCHRONOUS ) } # [ doc = "Resynchronized path" ] # [ inline ( always ) ] pub fn resynchronized ( self ) -> & 'a mut W { self . variant ( PATH_A :: RESYNCHRONIZED ) } # [ doc = "Asynchronous path" ] # [ inline ( always ) ] pub fn asynchronous ( self ) -> & 'a mut W { self . variant ( PATH_A :: ASYNCHRONOUS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Possible values of the field `EDGSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EDGSEL_A { # [ doc = "No event output when using the resynchronized or synchronous path" ] NO_EVT_OUTPUT , # [ doc = "Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path" ] RISING_EDGE , # [ doc = "Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path" ] FALLING_EDGE , # [ doc = "Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path" ] BOTH_EDGES }
impl crate :: ToBits < u8 > for EDGSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { EDGSEL_A :: NO_EVT_OUTPUT => 0 , EDGSEL_A :: RISING_EDGE => 1 , EDGSEL_A :: FALLING_EDGE => 2 , EDGSEL_A :: BOTH_EDGES => 3 } } }
# [ doc = "Reader of field `EDGSEL`" ] pub type EDGSEL_R = crate :: R < u8 , EDGSEL_A > ; impl EDGSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EDGSEL_A { match self . bits { 0 => EDGSEL_A :: NO_EVT_OUTPUT , 1 => EDGSEL_A :: RISING_EDGE , 2 => EDGSEL_A :: FALLING_EDGE , 3 => EDGSEL_A :: BOTH_EDGES , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NO_EVT_OUTPUT`" ] # [ inline ( always ) ] pub fn is_no_evt_output ( & self ) -> bool { * self == EDGSEL_A :: NO_EVT_OUTPUT } # [ doc = "Checks if the value of the field is `RISING_EDGE`" ] # [ inline ( always ) ] pub fn is_rising_edge ( & self ) -> bool { * self == EDGSEL_A :: RISING_EDGE } # [ doc = "Checks if the value of the field is `FALLING_EDGE`" ] # [ inline ( always ) ] pub fn is_falling_edge ( & self ) -> bool { * self == EDGSEL_A :: FALLING_EDGE } # [ doc = "Checks if the value of the field is `BOTH_EDGES`" ] # [ inline ( always ) ] pub fn is_both_edges ( & self ) -> bool { * self == EDGSEL_A :: BOTH_EDGES } }
# [ doc = "Write proxy for field `EDGSEL`" ] pub struct EDGSEL_W < 'a > { w : & 'a mut W , } impl < 'a > EDGSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EDGSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "No event output when using the resynchronized or synchronous path" ] # [ inline ( always ) ] pub fn no_evt_output ( self ) -> & 'a mut W { self . variant ( EDGSEL_A :: NO_EVT_OUTPUT ) } # [ doc = "Event detection only on the rising edge of the signal from the event generator when using the resynchronized or synchronous path" ] # [ inline ( always ) ] pub fn rising_edge ( self ) -> & 'a mut W { self . variant ( EDGSEL_A :: RISING_EDGE ) } # [ doc = "Event detection only on the falling edge of the signal from the event generator when using the resynchronized or synchronous path" ] # [ inline ( always ) ] pub fn falling_edge ( self ) -> & 'a mut W { self . variant ( EDGSEL_A :: FALLING_EDGE ) } # [ doc = "Event detection on rising and falling edges of the signal from the event generator when using the resynchronized or synchronous path" ] # [ inline ( always ) ] pub fn both_edges ( self ) -> & 'a mut W { self . variant ( EDGSEL_A :: BOTH_EDGES ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u32 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bits 0:6 - Event Generator Selection" ] # [ inline ( always ) ] pub fn evgen ( & self ) -> EVGEN_R { EVGEN_R :: new ( ( self . bits & 0x7f ) as u8 ) }
# [ doc = "Bits 8:9 - Path Selection" ] # [ inline ( always ) ] pub fn path ( & self ) -> PATH_R { PATH_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Edge Detection Selection" ] # [ inline ( always ) ] pub fn edgsel ( & self ) -> EDGSEL_R { EDGSEL_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 14 - Run in standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Generic Clock On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:6 - Event Generator Selection" ] # [ inline ( always ) ] pub fn evgen ( & mut self ) -> EVGEN_W { EVGEN_W { w : self } }
# [ doc = "Bits 8:9 - Path Selection" ] # [ inline ( always ) ] pub fn path ( & mut self ) -> PATH_W { PATH_W { w : self } }
# [ doc = "Bits 10:11 - Edge Detection Selection" ] # [ inline ( always ) ] pub fn edgsel ( & mut self ) -> EDGSEL_W { EDGSEL_W { w : self } }
# [ doc = "Bit 14 - Run in standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 15 - Generic Clock On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } }
}
}
# [ doc = "User Multiplexer n\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [user](user) module" ] pub type USER = crate :: Reg < u32 , _USER > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _USER ;
# [ doc = "`read()` method returns [user::R](user::R) reader structure" ] impl crate :: Readable for USER { }
# [ doc = "`write(|w| ..)` method takes [user::W](user::W) writer structure" ] impl crate :: Writable for USER { }
# [ doc = "User Multiplexer n" ] pub mod user {
# [ doc = "Reader of register USER[%s]" ] pub type R = crate :: R < u32 , super :: USER > ;
# [ doc = "Writer for register USER[%s]" ] pub type W = crate :: W < u32 , super :: USER > ;
# [ doc = "Register USER[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: USER { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CHANNEL`" ] pub type CHANNEL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `CHANNEL`" ] pub struct CHANNEL_W < 'a > { w : & 'a mut W , } impl < 'a > CHANNEL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u32 ) & 0x1f ) ; self . w } }
impl R {
# [ doc = "Bits 0:4 - Channel Event Selection" ] # [ inline ( always ) ] pub fn channel ( & self ) -> CHANNEL_R { CHANNEL_R :: new ( ( self . bits & 0x1f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:4 - Channel Event Selection" ] # [ inline ( always ) ] pub fn channel ( & mut self ) -> CHANNEL_W { CHANNEL_W { w : self } }
}
}
}
# [ doc = "Frequency Meter" ] pub struct FREQM { _marker : PhantomData < * const ( ) > } unsafe impl Send for FREQM { } impl FREQM { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const freqm :: RegisterBlock { 0x4000_2c00 as * const _ } } impl Deref for FREQM { type Target = freqm :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * FREQM :: ptr ( ) } } }
# [ doc = "Frequency Meter" ] pub mod freqm {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control A Register" ] pub ctrla : CTRLA , # [ doc = "0x01 - Control B Register" ] pub ctrlb : CTRLB , # [ doc = "0x02 - Config A register" ] pub cfga : CFGA , _reserved3 : [ u8 ; 4usize ] , # [ doc = "0x08 - Interrupt Enable Clear Register" ] pub intenclr : INTENCLR , # [ doc = "0x09 - Interrupt Enable Set Register" ] pub intenset : INTENSET , # [ doc = "0x0a - Interrupt Flag Register" ] pub intflag : INTFLAG , # [ doc = "0x0b - Status Register" ] pub status : STATUS , # [ doc = "0x0c - Synchronization Busy Register" ] pub syncbusy : SYNCBUSY , # [ doc = "0x10 - Count Value Register" ] pub value : VALUE , }
# [ doc = "Control A Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control A Register" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
}
}
# [ doc = "Control B Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u8 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ;
# [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { }
# [ doc = "Control B Register" ] pub mod ctrlb {
# [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u8 , super :: CTRLB > ;
# [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Write proxy for field `START`" ] pub struct START_W < 'a > { w : & 'a mut W , } impl < 'a > START_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl W {
# [ doc = "Bit 0 - Start Measurement" ] # [ inline ( always ) ] pub fn start ( & mut self ) -> START_W { START_W { w : self } }
}
}
# [ doc = "Config A register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cfga](cfga) module" ] pub type CFGA = crate :: Reg < u16 , _CFGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CFGA ;
# [ doc = "`read()` method returns [cfga::R](cfga::R) reader structure" ] impl crate :: Readable for CFGA { }
# [ doc = "`write(|w| ..)` method takes [cfga::W](cfga::W) writer structure" ] impl crate :: Writable for CFGA { }
# [ doc = "Config A register" ] pub mod cfga {
# [ doc = "Reader of register CFGA" ] pub type R = crate :: R < u16 , super :: CFGA > ;
# [ doc = "Writer for register CFGA" ] pub type W = crate :: W < u16 , super :: CFGA > ;
# [ doc = "Register CFGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CFGA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `REFNUM`" ] pub type REFNUM_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `REFNUM`" ] pub struct REFNUM_W < 'a > { w : & 'a mut W , } impl < 'a > REFNUM_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
# [ doc = "Reader of field `DIVREF`" ] pub type DIVREF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DIVREF`" ] pub struct DIVREF_W < 'a > { w : & 'a mut W , } impl < 'a > DIVREF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Number of Reference Clock Cycles" ] # [ inline ( always ) ] pub fn refnum ( & self ) -> REFNUM_R { REFNUM_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bit 15 - Divide Reference Clock" ] # [ inline ( always ) ] pub fn divref ( & self ) -> DIVREF_R { DIVREF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:7 - Number of Reference Clock Cycles" ] # [ inline ( always ) ] pub fn refnum ( & mut self ) -> REFNUM_W { REFNUM_W { w : self } }
# [ doc = "Bit 15 - Divide Reference Clock" ] # [ inline ( always ) ] pub fn divref ( & mut self ) -> DIVREF_W { DIVREF_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear Register" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DONE`" ] pub type DONE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DONE`" ] pub struct DONE_W < 'a > { w : & 'a mut W , } impl < 'a > DONE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Measurement Done Interrupt Enable" ] # [ inline ( always ) ] pub fn done ( & self ) -> DONE_R { DONE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Measurement Done Interrupt Enable" ] # [ inline ( always ) ] pub fn done ( & mut self ) -> DONE_W { DONE_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set Register" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DONE`" ] pub type DONE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DONE`" ] pub struct DONE_W < 'a > { w : & 'a mut W , } impl < 'a > DONE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Measurement Done Interrupt Enable" ] # [ inline ( always ) ] pub fn done ( & self ) -> DONE_R { DONE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Measurement Done Interrupt Enable" ] # [ inline ( always ) ] pub fn done ( & mut self ) -> DONE_W { DONE_W { w : self } }
}
}
# [ doc = "Interrupt Flag Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Register" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DONE`" ] pub type DONE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DONE`" ] pub struct DONE_W < 'a > { w : & 'a mut W , } impl < 'a > DONE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Measurement Done" ] # [ inline ( always ) ] pub fn done ( & self ) -> DONE_R { DONE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Measurement Done" ] # [ inline ( always ) ] pub fn done ( & mut self ) -> DONE_W { DONE_W { w : self } }
}
}
# [ doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u8 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ;
# [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { }
# [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { }
# [ doc = "Status Register" ] pub mod status {
# [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u8 , super :: STATUS > ;
# [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u8 , super :: STATUS > ;
# [ doc = "Register STATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUS { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `BUSY`" ] pub type BUSY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BUSY`" ] pub struct BUSY_W < 'a > { w : & 'a mut W , } impl < 'a > BUSY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - FREQM Status" ] # [ inline ( always ) ] pub fn busy ( & self ) -> BUSY_R { BUSY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Sticky Count Value Overflow" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - FREQM Status" ] # [ inline ( always ) ] pub fn busy ( & mut self ) -> BUSY_W { BUSY_W { w : self } }
# [ doc = "Bit 1 - Sticky Count Value Overflow" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } }
}
}
# [ doc = "Synchronization Busy Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy Register" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Count Value Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [value](value) module" ] pub type VALUE = crate :: Reg < u32 , _VALUE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _VALUE ;
# [ doc = "`read()` method returns [value::R](value::R) reader structure" ] impl crate :: Readable for VALUE { }
# [ doc = "Count Value Register" ] pub mod value {
# [ doc = "Reader of register VALUE" ] pub type R = crate :: R < u32 , super :: VALUE > ;
# [ doc = "Reader of field `VALUE`" ] pub type VALUE_R = crate :: R < u32 , u32 > ;
impl R {
# [ doc = "Bits 0:23 - Measurement Value" ] # [ inline ( always ) ] pub fn value ( & self ) -> VALUE_R { VALUE_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
}
}
# [ doc = "Generic Clock Generator" ] pub struct GCLK { _marker : PhantomData < * const ( ) > } unsafe impl Send for GCLK { } impl GCLK { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const gclk :: RegisterBlock { 0x4000_1c00 as * const _ } } impl Deref for GCLK { type Target = gclk :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * GCLK :: ptr ( ) } } }
# [ doc = "Generic Clock Generator" ] pub mod gclk {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control" ] pub ctrla : CTRLA , _reserved1 : [ u8 ; 3usize ] , # [ doc = "0x04 - Synchronization Busy" ] pub syncbusy : SYNCBUSY , _reserved2 : [ u8 ; 24usize ] , # [ doc = "0x20 - Generic Clock Generator Control" ] pub genctrl : [ GENCTRL ; 9 ] , _reserved3 : [ u8 ; 60usize ] , # [ doc = "0x80 - Peripheral Clock Control" ] pub pchctrl : [ PCHCTRL ; 46 ] , }
# [ doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
}
}
# [ doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Possible values of the field `GENCTRL0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GENCTRL0_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < bool > for GENCTRL0_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { GENCTRL0_A :: GCLK0 => true , GENCTRL0_A :: GCLK1 => true , GENCTRL0_A :: GCLK2 => true , GENCTRL0_A :: GCLK3 => true , GENCTRL0_A :: GCLK4 => true , GENCTRL0_A :: GCLK5 => true , GENCTRL0_A :: GCLK6 => true , GENCTRL0_A :: GCLK7 => true , GENCTRL0_A :: GCLK8 => true } } }
# [ doc = "Reader of field `GENCTRL0`" ] pub type GENCTRL0_R = crate :: R < bool , GENCTRL0_A > ; impl GENCTRL0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < bool , GENCTRL0_A > { use crate :: Variant :: * ; match self . bits { true => Val ( GENCTRL0_A :: GCLK0 ) , true => Val ( GENCTRL0_A :: GCLK1 ) , true => Val ( GENCTRL0_A :: GCLK2 ) , true => Val ( GENCTRL0_A :: GCLK3 ) , true => Val ( GENCTRL0_A :: GCLK4 ) , true => Val ( GENCTRL0_A :: GCLK5 ) , true => Val ( GENCTRL0_A :: GCLK6 ) , true => Val ( GENCTRL0_A :: GCLK7 ) , true => Val ( GENCTRL0_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GENCTRL0_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GENCTRL0_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GENCTRL0_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GENCTRL0_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GENCTRL0_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GENCTRL0_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GENCTRL0_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GENCTRL0_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GENCTRL0_A :: GCLK8 } }
# [ doc = "Possible values of the field `GENCTRL1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GENCTRL1_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < bool > for GENCTRL1_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { GENCTRL1_A :: GCLK0 => true , GENCTRL1_A :: GCLK1 => true , GENCTRL1_A :: GCLK2 => true , GENCTRL1_A :: GCLK3 => true , GENCTRL1_A :: GCLK4 => true , GENCTRL1_A :: GCLK5 => true , GENCTRL1_A :: GCLK6 => true , GENCTRL1_A :: GCLK7 => true , GENCTRL1_A :: GCLK8 => true } } }
# [ doc = "Reader of field `GENCTRL1`" ] pub type GENCTRL1_R = crate :: R < bool , GENCTRL1_A > ; impl GENCTRL1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < bool , GENCTRL1_A > { use crate :: Variant :: * ; match self . bits { true => Val ( GENCTRL1_A :: GCLK0 ) , true => Val ( GENCTRL1_A :: GCLK1 ) , true => Val ( GENCTRL1_A :: GCLK2 ) , true => Val ( GENCTRL1_A :: GCLK3 ) , true => Val ( GENCTRL1_A :: GCLK4 ) , true => Val ( GENCTRL1_A :: GCLK5 ) , true => Val ( GENCTRL1_A :: GCLK6 ) , true => Val ( GENCTRL1_A :: GCLK7 ) , true => Val ( GENCTRL1_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GENCTRL1_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GENCTRL1_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GENCTRL1_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GENCTRL1_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GENCTRL1_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GENCTRL1_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GENCTRL1_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GENCTRL1_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GENCTRL1_A :: GCLK8 } }
# [ doc = "Possible values of the field `GENCTRL2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GENCTRL2_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < bool > for GENCTRL2_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { GENCTRL2_A :: GCLK0 => true , GENCTRL2_A :: GCLK1 => true , GENCTRL2_A :: GCLK2 => true , GENCTRL2_A :: GCLK3 => true , GENCTRL2_A :: GCLK4 => true , GENCTRL2_A :: GCLK5 => true , GENCTRL2_A :: GCLK6 => true , GENCTRL2_A :: GCLK7 => true , GENCTRL2_A :: GCLK8 => true } } }
# [ doc = "Reader of field `GENCTRL2`" ] pub type GENCTRL2_R = crate :: R < bool , GENCTRL2_A > ; impl GENCTRL2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < bool , GENCTRL2_A > { use crate :: Variant :: * ; match self . bits { true => Val ( GENCTRL2_A :: GCLK0 ) , true => Val ( GENCTRL2_A :: GCLK1 ) , true => Val ( GENCTRL2_A :: GCLK2 ) , true => Val ( GENCTRL2_A :: GCLK3 ) , true => Val ( GENCTRL2_A :: GCLK4 ) , true => Val ( GENCTRL2_A :: GCLK5 ) , true => Val ( GENCTRL2_A :: GCLK6 ) , true => Val ( GENCTRL2_A :: GCLK7 ) , true => Val ( GENCTRL2_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GENCTRL2_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GENCTRL2_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GENCTRL2_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GENCTRL2_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GENCTRL2_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GENCTRL2_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GENCTRL2_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GENCTRL2_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GENCTRL2_A :: GCLK8 } }
# [ doc = "Possible values of the field `GENCTRL3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GENCTRL3_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < bool > for GENCTRL3_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { GENCTRL3_A :: GCLK0 => true , GENCTRL3_A :: GCLK1 => true , GENCTRL3_A :: GCLK2 => true , GENCTRL3_A :: GCLK3 => true , GENCTRL3_A :: GCLK4 => true , GENCTRL3_A :: GCLK5 => true , GENCTRL3_A :: GCLK6 => true , GENCTRL3_A :: GCLK7 => true , GENCTRL3_A :: GCLK8 => true } } }
# [ doc = "Reader of field `GENCTRL3`" ] pub type GENCTRL3_R = crate :: R < bool , GENCTRL3_A > ; impl GENCTRL3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < bool , GENCTRL3_A > { use crate :: Variant :: * ; match self . bits { true => Val ( GENCTRL3_A :: GCLK0 ) , true => Val ( GENCTRL3_A :: GCLK1 ) , true => Val ( GENCTRL3_A :: GCLK2 ) , true => Val ( GENCTRL3_A :: GCLK3 ) , true => Val ( GENCTRL3_A :: GCLK4 ) , true => Val ( GENCTRL3_A :: GCLK5 ) , true => Val ( GENCTRL3_A :: GCLK6 ) , true => Val ( GENCTRL3_A :: GCLK7 ) , true => Val ( GENCTRL3_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GENCTRL3_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GENCTRL3_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GENCTRL3_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GENCTRL3_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GENCTRL3_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GENCTRL3_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GENCTRL3_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GENCTRL3_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GENCTRL3_A :: GCLK8 } }
# [ doc = "Possible values of the field `GENCTRL4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GENCTRL4_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < bool > for GENCTRL4_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { GENCTRL4_A :: GCLK0 => true , GENCTRL4_A :: GCLK1 => true , GENCTRL4_A :: GCLK2 => true , GENCTRL4_A :: GCLK3 => true , GENCTRL4_A :: GCLK4 => true , GENCTRL4_A :: GCLK5 => true , GENCTRL4_A :: GCLK6 => true , GENCTRL4_A :: GCLK7 => true , GENCTRL4_A :: GCLK8 => true } } }
# [ doc = "Reader of field `GENCTRL4`" ] pub type GENCTRL4_R = crate :: R < bool , GENCTRL4_A > ; impl GENCTRL4_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < bool , GENCTRL4_A > { use crate :: Variant :: * ; match self . bits { true => Val ( GENCTRL4_A :: GCLK0 ) , true => Val ( GENCTRL4_A :: GCLK1 ) , true => Val ( GENCTRL4_A :: GCLK2 ) , true => Val ( GENCTRL4_A :: GCLK3 ) , true => Val ( GENCTRL4_A :: GCLK4 ) , true => Val ( GENCTRL4_A :: GCLK5 ) , true => Val ( GENCTRL4_A :: GCLK6 ) , true => Val ( GENCTRL4_A :: GCLK7 ) , true => Val ( GENCTRL4_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GENCTRL4_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GENCTRL4_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GENCTRL4_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GENCTRL4_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GENCTRL4_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GENCTRL4_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GENCTRL4_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GENCTRL4_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GENCTRL4_A :: GCLK8 } }
# [ doc = "Possible values of the field `GENCTRL5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GENCTRL5_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < bool > for GENCTRL5_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { GENCTRL5_A :: GCLK0 => true , GENCTRL5_A :: GCLK1 => true , GENCTRL5_A :: GCLK2 => true , GENCTRL5_A :: GCLK3 => true , GENCTRL5_A :: GCLK4 => true , GENCTRL5_A :: GCLK5 => true , GENCTRL5_A :: GCLK6 => true , GENCTRL5_A :: GCLK7 => true , GENCTRL5_A :: GCLK8 => true } } }
# [ doc = "Reader of field `GENCTRL5`" ] pub type GENCTRL5_R = crate :: R < bool , GENCTRL5_A > ; impl GENCTRL5_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < bool , GENCTRL5_A > { use crate :: Variant :: * ; match self . bits { true => Val ( GENCTRL5_A :: GCLK0 ) , true => Val ( GENCTRL5_A :: GCLK1 ) , true => Val ( GENCTRL5_A :: GCLK2 ) , true => Val ( GENCTRL5_A :: GCLK3 ) , true => Val ( GENCTRL5_A :: GCLK4 ) , true => Val ( GENCTRL5_A :: GCLK5 ) , true => Val ( GENCTRL5_A :: GCLK6 ) , true => Val ( GENCTRL5_A :: GCLK7 ) , true => Val ( GENCTRL5_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GENCTRL5_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GENCTRL5_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GENCTRL5_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GENCTRL5_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GENCTRL5_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GENCTRL5_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GENCTRL5_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GENCTRL5_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GENCTRL5_A :: GCLK8 } }
# [ doc = "Possible values of the field `GENCTRL6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GENCTRL6_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < bool > for GENCTRL6_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { GENCTRL6_A :: GCLK0 => true , GENCTRL6_A :: GCLK1 => true , GENCTRL6_A :: GCLK2 => true , GENCTRL6_A :: GCLK3 => true , GENCTRL6_A :: GCLK4 => true , GENCTRL6_A :: GCLK5 => true , GENCTRL6_A :: GCLK6 => true , GENCTRL6_A :: GCLK7 => true , GENCTRL6_A :: GCLK8 => true } } }
# [ doc = "Reader of field `GENCTRL6`" ] pub type GENCTRL6_R = crate :: R < bool , GENCTRL6_A > ; impl GENCTRL6_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < bool , GENCTRL6_A > { use crate :: Variant :: * ; match self . bits { true => Val ( GENCTRL6_A :: GCLK0 ) , true => Val ( GENCTRL6_A :: GCLK1 ) , true => Val ( GENCTRL6_A :: GCLK2 ) , true => Val ( GENCTRL6_A :: GCLK3 ) , true => Val ( GENCTRL6_A :: GCLK4 ) , true => Val ( GENCTRL6_A :: GCLK5 ) , true => Val ( GENCTRL6_A :: GCLK6 ) , true => Val ( GENCTRL6_A :: GCLK7 ) , true => Val ( GENCTRL6_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GENCTRL6_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GENCTRL6_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GENCTRL6_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GENCTRL6_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GENCTRL6_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GENCTRL6_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GENCTRL6_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GENCTRL6_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GENCTRL6_A :: GCLK8 } }
# [ doc = "Possible values of the field `GENCTRL7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GENCTRL7_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < bool > for GENCTRL7_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { GENCTRL7_A :: GCLK0 => true , GENCTRL7_A :: GCLK1 => true , GENCTRL7_A :: GCLK2 => true , GENCTRL7_A :: GCLK3 => true , GENCTRL7_A :: GCLK4 => true , GENCTRL7_A :: GCLK5 => true , GENCTRL7_A :: GCLK6 => true , GENCTRL7_A :: GCLK7 => true , GENCTRL7_A :: GCLK8 => true } } }
# [ doc = "Reader of field `GENCTRL7`" ] pub type GENCTRL7_R = crate :: R < bool , GENCTRL7_A > ; impl GENCTRL7_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < bool , GENCTRL7_A > { use crate :: Variant :: * ; match self . bits { true => Val ( GENCTRL7_A :: GCLK0 ) , true => Val ( GENCTRL7_A :: GCLK1 ) , true => Val ( GENCTRL7_A :: GCLK2 ) , true => Val ( GENCTRL7_A :: GCLK3 ) , true => Val ( GENCTRL7_A :: GCLK4 ) , true => Val ( GENCTRL7_A :: GCLK5 ) , true => Val ( GENCTRL7_A :: GCLK6 ) , true => Val ( GENCTRL7_A :: GCLK7 ) , true => Val ( GENCTRL7_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GENCTRL7_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GENCTRL7_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GENCTRL7_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GENCTRL7_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GENCTRL7_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GENCTRL7_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GENCTRL7_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GENCTRL7_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GENCTRL7_A :: GCLK8 } }
# [ doc = "Possible values of the field `GENCTRL8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GENCTRL8_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < bool > for GENCTRL8_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { GENCTRL8_A :: GCLK0 => true , GENCTRL8_A :: GCLK1 => true , GENCTRL8_A :: GCLK2 => true , GENCTRL8_A :: GCLK3 => true , GENCTRL8_A :: GCLK4 => true , GENCTRL8_A :: GCLK5 => true , GENCTRL8_A :: GCLK6 => true , GENCTRL8_A :: GCLK7 => true , GENCTRL8_A :: GCLK8 => true } } }
# [ doc = "Reader of field `GENCTRL8`" ] pub type GENCTRL8_R = crate :: R < bool , GENCTRL8_A > ; impl GENCTRL8_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < bool , GENCTRL8_A > { use crate :: Variant :: * ; match self . bits { true => Val ( GENCTRL8_A :: GCLK0 ) , true => Val ( GENCTRL8_A :: GCLK1 ) , true => Val ( GENCTRL8_A :: GCLK2 ) , true => Val ( GENCTRL8_A :: GCLK3 ) , true => Val ( GENCTRL8_A :: GCLK4 ) , true => Val ( GENCTRL8_A :: GCLK5 ) , true => Val ( GENCTRL8_A :: GCLK6 ) , true => Val ( GENCTRL8_A :: GCLK7 ) , true => Val ( GENCTRL8_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GENCTRL8_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GENCTRL8_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GENCTRL8_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GENCTRL8_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GENCTRL8_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GENCTRL8_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GENCTRL8_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GENCTRL8_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GENCTRL8_A :: GCLK8 } }
impl R {
# [ doc = "Bit 0 - Software Reset Synchroniation Busy bit" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Generic Clock Generator Control 0 Synchronization Busy bits" ] # [ inline ( always ) ] pub fn genctrl0 ( & self ) -> GENCTRL0_R { GENCTRL0_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Generic Clock Generator Control 1 Synchronization Busy bits" ] # [ inline ( always ) ] pub fn genctrl1 ( & self ) -> GENCTRL1_R { GENCTRL1_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Generic Clock Generator Control 2 Synchronization Busy bits" ] # [ inline ( always ) ] pub fn genctrl2 ( & self ) -> GENCTRL2_R { GENCTRL2_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Generic Clock Generator Control 3 Synchronization Busy bits" ] # [ inline ( always ) ] pub fn genctrl3 ( & self ) -> GENCTRL3_R { GENCTRL3_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Generic Clock Generator Control 4 Synchronization Busy bits" ] # [ inline ( always ) ] pub fn genctrl4 ( & self ) -> GENCTRL4_R { GENCTRL4_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Generic Clock Generator Control 5 Synchronization Busy bits" ] # [ inline ( always ) ] pub fn genctrl5 ( & self ) -> GENCTRL5_R { GENCTRL5_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Generic Clock Generator Control 6 Synchronization Busy bits" ] # [ inline ( always ) ] pub fn genctrl6 ( & self ) -> GENCTRL6_R { GENCTRL6_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Generic Clock Generator Control 7 Synchronization Busy bits" ] # [ inline ( always ) ] pub fn genctrl7 ( & self ) -> GENCTRL7_R { GENCTRL7_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Generic Clock Generator Control 8 Synchronization Busy bits" ] # [ inline ( always ) ] pub fn genctrl8 ( & self ) -> GENCTRL8_R { GENCTRL8_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Generic Clock Generator Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [genctrl](genctrl) module" ] pub type GENCTRL = crate :: Reg < u32 , _GENCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _GENCTRL ;
# [ doc = "`read()` method returns [genctrl::R](genctrl::R) reader structure" ] impl crate :: Readable for GENCTRL { }
# [ doc = "`write(|w| ..)` method takes [genctrl::W](genctrl::W) writer structure" ] impl crate :: Writable for GENCTRL { }
# [ doc = "Generic Clock Generator Control" ] pub mod genctrl {
# [ doc = "Reader of register GENCTRL[%s]" ] pub type R = crate :: R < u32 , super :: GENCTRL > ;
# [ doc = "Writer for register GENCTRL[%s]" ] pub type W = crate :: W < u32 , super :: GENCTRL > ;
# [ doc = "Register GENCTRL[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: GENCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `SRC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SRC_A { # [ doc = "XOSC oscillator output" ] XOSC , # [ doc = "Generator input pad" ] GCLKIN , # [ doc = "Generic clock generator 1 output" ] GCLKGEN1 , # [ doc = "OSCULP32K oscillator output" ] OSCULP32K , # [ doc = "OSC32K oscillator output" ] OSC32K , # [ doc = "XOSC32K oscillator output" ] XOSC32K , # [ doc = "OSC48M oscillator output" ] OSC48M , # [ doc = "DPLL96M output" ] DPLL96M }
impl crate :: ToBits < u8 > for SRC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SRC_A :: XOSC => 0 , SRC_A :: GCLKIN => 1 , SRC_A :: GCLKGEN1 => 2 , SRC_A :: OSCULP32K => 3 , SRC_A :: OSC32K => 4 , SRC_A :: XOSC32K => 5 , SRC_A :: OSC48M => 6 , SRC_A :: DPLL96M => 7 } } }
# [ doc = "Reader of field `SRC`" ] pub type SRC_R = crate :: R < u8 , SRC_A > ; impl SRC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SRC_A { match self . bits { 0 => SRC_A :: XOSC , 1 => SRC_A :: GCLKIN , 2 => SRC_A :: GCLKGEN1 , 3 => SRC_A :: OSCULP32K , 4 => SRC_A :: OSC32K , 5 => SRC_A :: XOSC32K , 6 => SRC_A :: OSC48M , 7 => SRC_A :: DPLL96M , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `XOSC`" ] # [ inline ( always ) ] pub fn is_xosc ( & self ) -> bool { * self == SRC_A :: XOSC } # [ doc = "Checks if the value of the field is `GCLKIN`" ] # [ inline ( always ) ] pub fn is_gclkin ( & self ) -> bool { * self == SRC_A :: GCLKIN } # [ doc = "Checks if the value of the field is `GCLKGEN1`" ] # [ inline ( always ) ] pub fn is_gclkgen1 ( & self ) -> bool { * self == SRC_A :: GCLKGEN1 } # [ doc = "Checks if the value of the field is `OSCULP32K`" ] # [ inline ( always ) ] pub fn is_osculp32k ( & self ) -> bool { * self == SRC_A :: OSCULP32K } # [ doc = "Checks if the value of the field is `OSC32K`" ] # [ inline ( always ) ] pub fn is_osc32k ( & self ) -> bool { * self == SRC_A :: OSC32K } # [ doc = "Checks if the value of the field is `XOSC32K`" ] # [ inline ( always ) ] pub fn is_xosc32k ( & self ) -> bool { * self == SRC_A :: XOSC32K } # [ doc = "Checks if the value of the field is `OSC48M`" ] # [ inline ( always ) ] pub fn is_osc48m ( & self ) -> bool { * self == SRC_A :: OSC48M } # [ doc = "Checks if the value of the field is `DPLL96M`" ] # [ inline ( always ) ] pub fn is_dpll96m ( & self ) -> bool { * self == SRC_A :: DPLL96M } }
# [ doc = "Write proxy for field `SRC`" ] pub struct SRC_W < 'a > { w : & 'a mut W , } impl < 'a > SRC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SRC_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "XOSC oscillator output" ] # [ inline ( always ) ] pub fn xosc ( self ) -> & 'a mut W { self . variant ( SRC_A :: XOSC ) } # [ doc = "Generator input pad" ] # [ inline ( always ) ] pub fn gclkin ( self ) -> & 'a mut W { self . variant ( SRC_A :: GCLKIN ) } # [ doc = "Generic clock generator 1 output" ] # [ inline ( always ) ] pub fn gclkgen1 ( self ) -> & 'a mut W { self . variant ( SRC_A :: GCLKGEN1 ) } # [ doc = "OSCULP32K oscillator output" ] # [ inline ( always ) ] pub fn osculp32k ( self ) -> & 'a mut W { self . variant ( SRC_A :: OSCULP32K ) } # [ doc = "OSC32K oscillator output" ] # [ inline ( always ) ] pub fn osc32k ( self ) -> & 'a mut W { self . variant ( SRC_A :: OSC32K ) } # [ doc = "XOSC32K oscillator output" ] # [ inline ( always ) ] pub fn xosc32k ( self ) -> & 'a mut W { self . variant ( SRC_A :: XOSC32K ) } # [ doc = "OSC48M oscillator output" ] # [ inline ( always ) ] pub fn osc48m ( self ) -> & 'a mut W { self . variant ( SRC_A :: OSC48M ) } # [ doc = "DPLL96M output" ] # [ inline ( always ) ] pub fn dpll96m ( self ) -> & 'a mut W { self . variant ( SRC_A :: DPLL96M ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
# [ doc = "Reader of field `GENEN`" ] pub type GENEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `GENEN`" ] pub struct GENEN_W < 'a > { w : & 'a mut W , } impl < 'a > GENEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `IDC`" ] pub type IDC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `IDC`" ] pub struct IDC_W < 'a > { w : & 'a mut W , } impl < 'a > IDC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `OOV`" ] pub type OOV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OOV`" ] pub struct OOV_W < 'a > { w : & 'a mut W , } impl < 'a > OOV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `OE`" ] pub type OE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OE`" ] pub struct OE_W < 'a > { w : & 'a mut W , } impl < 'a > OE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Possible values of the field `DIVSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DIVSEL_A { # [ doc = "Divide input directly by divider factor" ] DIV1 , # [ doc = "Divide input by 2^(divider factor+ 1)" ] DIV2 }
impl crate :: ToBits < bool > for DIVSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { DIVSEL_A :: DIV1 => false , DIVSEL_A :: DIV2 => true } } }
# [ doc = "Reader of field `DIVSEL`" ] pub type DIVSEL_R = crate :: R < bool , DIVSEL_A > ; impl DIVSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DIVSEL_A { match self . bits { false => DIVSEL_A :: DIV1 , true => DIVSEL_A :: DIV2 } } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == DIVSEL_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == DIVSEL_A :: DIV2 } }
# [ doc = "Write proxy for field `DIVSEL`" ] pub struct DIVSEL_W < 'a > { w : & 'a mut W , } impl < 'a > DIVSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DIVSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Divide input directly by divider factor" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( DIVSEL_A :: DIV1 ) } # [ doc = "Divide input by 2^(divider factor+ 1)" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( DIVSEL_A :: DIV2 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `DIV`" ] pub type DIV_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DIV`" ] pub struct DIV_W < 'a > { w : & 'a mut W , } impl < 'a > DIV_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Source Select" ] # [ inline ( always ) ] pub fn src ( & self ) -> SRC_R { SRC_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bit 8 - Generic Clock Generator Enable" ] # [ inline ( always ) ] pub fn genen ( & self ) -> GENEN_R { GENEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Improve Duty Cycle" ] # [ inline ( always ) ] pub fn idc ( & self ) -> IDC_R { IDC_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Output Off Value" ] # [ inline ( always ) ] pub fn oov ( & self ) -> OOV_R { OOV_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Output Enable" ] # [ inline ( always ) ] pub fn oe ( & self ) -> OE_R { OE_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Divide Selection" ] # [ inline ( always ) ] pub fn divsel ( & self ) -> DIVSEL_R { DIVSEL_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:31 - Division Factor" ] # [ inline ( always ) ] pub fn div ( & self ) -> DIV_R { DIV_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:2 - Source Select" ] # [ inline ( always ) ] pub fn src ( & mut self ) -> SRC_W { SRC_W { w : self } }
# [ doc = "Bit 8 - Generic Clock Generator Enable" ] # [ inline ( always ) ] pub fn genen ( & mut self ) -> GENEN_W { GENEN_W { w : self } }
# [ doc = "Bit 9 - Improve Duty Cycle" ] # [ inline ( always ) ] pub fn idc ( & mut self ) -> IDC_W { IDC_W { w : self } }
# [ doc = "Bit 10 - Output Off Value" ] # [ inline ( always ) ] pub fn oov ( & mut self ) -> OOV_W { OOV_W { w : self } }
# [ doc = "Bit 11 - Output Enable" ] # [ inline ( always ) ] pub fn oe ( & mut self ) -> OE_W { OE_W { w : self } }
# [ doc = "Bit 12 - Divide Selection" ] # [ inline ( always ) ] pub fn divsel ( & mut self ) -> DIVSEL_W { DIVSEL_W { w : self } }
# [ doc = "Bit 13 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bits 16:31 - Division Factor" ] # [ inline ( always ) ] pub fn div ( & mut self ) -> DIV_W { DIV_W { w : self } }
}
}
# [ doc = "Peripheral Clock Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pchctrl](pchctrl) module" ] pub type PCHCTRL = crate :: Reg < u32 , _PCHCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PCHCTRL ;
# [ doc = "`read()` method returns [pchctrl::R](pchctrl::R) reader structure" ] impl crate :: Readable for PCHCTRL { }
# [ doc = "`write(|w| ..)` method takes [pchctrl::W](pchctrl::W) writer structure" ] impl crate :: Writable for PCHCTRL { }
# [ doc = "Peripheral Clock Control" ] pub mod pchctrl {
# [ doc = "Reader of register PCHCTRL[%s]" ] pub type R = crate :: R < u32 , super :: PCHCTRL > ;
# [ doc = "Writer for register PCHCTRL[%s]" ] pub type W = crate :: W < u32 , super :: PCHCTRL > ;
# [ doc = "Register PCHCTRL[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PCHCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `GEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GEN_A { # [ doc = "Generic clock generator 0" ] GCLK0 , # [ doc = "Generic clock generator 1" ] GCLK1 , # [ doc = "Generic clock generator 2" ] GCLK2 , # [ doc = "Generic clock generator 3" ] GCLK3 , # [ doc = "Generic clock generator 4" ] GCLK4 , # [ doc = "Generic clock generator 5" ] GCLK5 , # [ doc = "Generic clock generator 6" ] GCLK6 , # [ doc = "Generic clock generator 7" ] GCLK7 , # [ doc = "Generic clock generator 8" ] GCLK8 }
impl crate :: ToBits < u8 > for GEN_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { GEN_A :: GCLK0 => 0 , GEN_A :: GCLK1 => 1 , GEN_A :: GCLK2 => 2 , GEN_A :: GCLK3 => 3 , GEN_A :: GCLK4 => 4 , GEN_A :: GCLK5 => 5 , GEN_A :: GCLK6 => 6 , GEN_A :: GCLK7 => 7 , GEN_A :: GCLK8 => 8 } } }
# [ doc = "Reader of field `GEN`" ] pub type GEN_R = crate :: R < u8 , GEN_A > ; impl GEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , GEN_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( GEN_A :: GCLK0 ) , 1 => Val ( GEN_A :: GCLK1 ) , 2 => Val ( GEN_A :: GCLK2 ) , 3 => Val ( GEN_A :: GCLK3 ) , 4 => Val ( GEN_A :: GCLK4 ) , 5 => Val ( GEN_A :: GCLK5 ) , 6 => Val ( GEN_A :: GCLK6 ) , 7 => Val ( GEN_A :: GCLK7 ) , 8 => Val ( GEN_A :: GCLK8 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK0`" ] # [ inline ( always ) ] pub fn is_gclk0 ( & self ) -> bool { * self == GEN_A :: GCLK0 } # [ doc = "Checks if the value of the field is `GCLK1`" ] # [ inline ( always ) ] pub fn is_gclk1 ( & self ) -> bool { * self == GEN_A :: GCLK1 } # [ doc = "Checks if the value of the field is `GCLK2`" ] # [ inline ( always ) ] pub fn is_gclk2 ( & self ) -> bool { * self == GEN_A :: GCLK2 } # [ doc = "Checks if the value of the field is `GCLK3`" ] # [ inline ( always ) ] pub fn is_gclk3 ( & self ) -> bool { * self == GEN_A :: GCLK3 } # [ doc = "Checks if the value of the field is `GCLK4`" ] # [ inline ( always ) ] pub fn is_gclk4 ( & self ) -> bool { * self == GEN_A :: GCLK4 } # [ doc = "Checks if the value of the field is `GCLK5`" ] # [ inline ( always ) ] pub fn is_gclk5 ( & self ) -> bool { * self == GEN_A :: GCLK5 } # [ doc = "Checks if the value of the field is `GCLK6`" ] # [ inline ( always ) ] pub fn is_gclk6 ( & self ) -> bool { * self == GEN_A :: GCLK6 } # [ doc = "Checks if the value of the field is `GCLK7`" ] # [ inline ( always ) ] pub fn is_gclk7 ( & self ) -> bool { * self == GEN_A :: GCLK7 } # [ doc = "Checks if the value of the field is `GCLK8`" ] # [ inline ( always ) ] pub fn is_gclk8 ( & self ) -> bool { * self == GEN_A :: GCLK8 } }
# [ doc = "Write proxy for field `GEN`" ] pub struct GEN_W < 'a > { w : & 'a mut W , } impl < 'a > GEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : GEN_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Generic clock generator 0" ] # [ inline ( always ) ] pub fn gclk0 ( self ) -> & 'a mut W { self . variant ( GEN_A :: GCLK0 ) } # [ doc = "Generic clock generator 1" ] # [ inline ( always ) ] pub fn gclk1 ( self ) -> & 'a mut W { self . variant ( GEN_A :: GCLK1 ) } # [ doc = "Generic clock generator 2" ] # [ inline ( always ) ] pub fn gclk2 ( self ) -> & 'a mut W { self . variant ( GEN_A :: GCLK2 ) } # [ doc = "Generic clock generator 3" ] # [ inline ( always ) ] pub fn gclk3 ( self ) -> & 'a mut W { self . variant ( GEN_A :: GCLK3 ) } # [ doc = "Generic clock generator 4" ] # [ inline ( always ) ] pub fn gclk4 ( self ) -> & 'a mut W { self . variant ( GEN_A :: GCLK4 ) } # [ doc = "Generic clock generator 5" ] # [ inline ( always ) ] pub fn gclk5 ( self ) -> & 'a mut W { self . variant ( GEN_A :: GCLK5 ) } # [ doc = "Generic clock generator 6" ] # [ inline ( always ) ] pub fn gclk6 ( self ) -> & 'a mut W { self . variant ( GEN_A :: GCLK6 ) } # [ doc = "Generic clock generator 7" ] # [ inline ( always ) ] pub fn gclk7 ( self ) -> & 'a mut W { self . variant ( GEN_A :: GCLK7 ) } # [ doc = "Generic clock generator 8" ] # [ inline ( always ) ] pub fn gclk8 ( self ) -> & 'a mut W { self . variant ( GEN_A :: GCLK8 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u32 ) & 0x0f ) ; self . w } }
# [ doc = "Reader of field `CHEN`" ] pub type CHEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CHEN`" ] pub struct CHEN_W < 'a > { w : & 'a mut W , } impl < 'a > CHEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `WRTLOCK`" ] pub type WRTLOCK_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WRTLOCK`" ] pub struct WRTLOCK_W < 'a > { w : & 'a mut W , } impl < 'a > WRTLOCK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Generic Clock Generator" ] # [ inline ( always ) ] pub fn gen ( & self ) -> GEN_R { GEN_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bit 6 - Channel Enable" ] # [ inline ( always ) ] pub fn chen ( & self ) -> CHEN_R { CHEN_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Write Lock" ] # [ inline ( always ) ] pub fn wrtlock ( & self ) -> WRTLOCK_R { WRTLOCK_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:3 - Generic Clock Generator" ] # [ inline ( always ) ] pub fn gen ( & mut self ) -> GEN_W { GEN_W { w : self } }
# [ doc = "Bit 6 - Channel Enable" ] # [ inline ( always ) ] pub fn chen ( & mut self ) -> CHEN_W { CHEN_W { w : self } }
# [ doc = "Bit 7 - Write Lock" ] # [ inline ( always ) ] pub fn wrtlock ( & mut self ) -> WRTLOCK_W { WRTLOCK_W { w : self } }
}
}
}
# [ doc = "HSB Matrix" ] pub struct HMATRIXHS { _marker : PhantomData < * const ( ) > } unsafe impl Send for HMATRIXHS { } impl HMATRIXHS { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const hmatrixhs :: RegisterBlock { 0x4100_a000 as * const _ } } impl Deref for HMATRIXHS { type Target = hmatrixhs :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * HMATRIXHS :: ptr ( ) } } }
# [ doc = "HSB Matrix" ] pub mod hmatrixhs {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Master Configuration" ] pub mcfg : [ MCFG ; 16 ] , # [ doc = "0x40 - Slave Configuration" ] pub scfg : [ SCFG ; 16 ] , # [ doc = "0x80 - cluster" ] pub prs : [ PRS ; 4 ] , _reserved3 : [ u8 ; 96usize ] , # [ doc = "0x100 - Master Remap Control" ] pub mrcr : MRCR , _reserved4 : [ u8 ; 12usize ] , # [ doc = "0x110 - Special Function" ] pub sfr : [ SFR ; 16 ] , }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct PRS { # [ doc = "0x00 - Priority A for Slave" ] pub pras : self::prs::PRAS , # [ doc = "0x04 - Priority B for Slave" ] pub prbs : self::prs::PRBS , } # [ doc = r"Register block" ] # [ doc = "cluster" ] pub mod prs { # [ doc = "Priority A for Slave\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pras](pras) module" ] pub type PRAS = crate :: Reg < u32 , _PRAS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PRAS ; # [ doc = "`read()` method returns [pras::R](pras::R) reader structure" ] impl crate :: Readable for PRAS { } # [ doc = "`write(|w| ..)` method takes [pras::W](pras::W) writer structure" ] impl crate :: Writable for PRAS { } # [ doc = "Priority A for Slave" ] pub mod pras { # [ doc = "Reader of register PRAS" ] pub type R = crate :: R < u32 , super :: PRAS > ; # [ doc = "Writer for register PRAS" ] pub type W = crate :: W < u32 , super :: PRAS > ; # [ doc = "Register PRAS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PRAS { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `M0PR`" ] pub type M0PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M0PR`" ] pub struct M0PR_W < 'a > { w : & 'a mut W , } impl < 'a > M0PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u32 ) & 0x0f ) ; self . w } } # [ doc = "Reader of field `M1PR`" ] pub type M1PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M1PR`" ] pub struct M1PR_W < 'a > { w : & 'a mut W , } impl < 'a > M1PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 4 ) ) | ( ( ( value as u32 ) & 0x0f ) << 4 ) ; self . w } } # [ doc = "Reader of field `M2PR`" ] pub type M2PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M2PR`" ] pub struct M2PR_W < 'a > { w : & 'a mut W , } impl < 'a > M2PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u32 ) & 0x0f ) << 8 ) ; self . w } } # [ doc = "Reader of field `M3PR`" ] pub type M3PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M3PR`" ] pub struct M3PR_W < 'a > { w : & 'a mut W , } impl < 'a > M3PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 12 ) ) | ( ( ( value as u32 ) & 0x0f ) << 12 ) ; self . w } } # [ doc = "Reader of field `M4PR`" ] pub type M4PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M4PR`" ] pub struct M4PR_W < 'a > { w : & 'a mut W , } impl < 'a > M4PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 16 ) ) | ( ( ( value as u32 ) & 0x0f ) << 16 ) ; self . w } } # [ doc = "Reader of field `M5PR`" ] pub type M5PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M5PR`" ] pub struct M5PR_W < 'a > { w : & 'a mut W , } impl < 'a > M5PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 20 ) ) | ( ( ( value as u32 ) & 0x0f ) << 20 ) ; self . w } } # [ doc = "Reader of field `M6PR`" ] pub type M6PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M6PR`" ] pub struct M6PR_W < 'a > { w : & 'a mut W , } impl < 'a > M6PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } } # [ doc = "Reader of field `M7PR`" ] pub type M7PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M7PR`" ] pub struct M7PR_W < 'a > { w : & 'a mut W , } impl < 'a > M7PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 28 ) ) | ( ( ( value as u32 ) & 0x0f ) << 28 ) ; self . w } } impl R { # [ doc = "Bits 0:3 - Master 0 Priority" ] # [ inline ( always ) ] pub fn m0pr ( & self ) -> M0PR_R { M0PR_R :: new ( ( self . bits & 0x0f ) as u8 ) } # [ doc = "Bits 4:7 - Master 1 Priority" ] # [ inline ( always ) ] pub fn m1pr ( & self ) -> M1PR_R { M1PR_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) } # [ doc = "Bits 8:11 - Master 2 Priority" ] # [ inline ( always ) ] pub fn m2pr ( & self ) -> M2PR_R { M2PR_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) } # [ doc = "Bits 12:15 - Master 3 Priority" ] # [ inline ( always ) ] pub fn m3pr ( & self ) -> M3PR_R { M3PR_R :: new ( ( ( self . bits >> 12 ) & 0x0f ) as u8 ) } # [ doc = "Bits 16:19 - Master 4 Priority" ] # [ inline ( always ) ] pub fn m4pr ( & self ) -> M4PR_R { M4PR_R :: new ( ( ( self . bits >> 16 ) & 0x0f ) as u8 ) } # [ doc = "Bits 20:23 - Master 5 Priority" ] # [ inline ( always ) ] pub fn m5pr ( & self ) -> M5PR_R { M5PR_R :: new ( ( ( self . bits >> 20 ) & 0x0f ) as u8 ) } # [ doc = "Bits 24:27 - Master 6 Priority" ] # [ inline ( always ) ] pub fn m6pr ( & self ) -> M6PR_R { M6PR_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) } # [ doc = "Bits 28:31 - Master 7 Priority" ] # [ inline ( always ) ] pub fn m7pr ( & self ) -> M7PR_R { M7PR_R :: new ( ( ( self . bits >> 28 ) & 0x0f ) as u8 ) } } impl W { # [ doc = "Bits 0:3 - Master 0 Priority" ] # [ inline ( always ) ] pub fn m0pr ( & mut self ) -> M0PR_W { M0PR_W { w : self } } # [ doc = "Bits 4:7 - Master 1 Priority" ] # [ inline ( always ) ] pub fn m1pr ( & mut self ) -> M1PR_W { M1PR_W { w : self } } # [ doc = "Bits 8:11 - Master 2 Priority" ] # [ inline ( always ) ] pub fn m2pr ( & mut self ) -> M2PR_W { M2PR_W { w : self } } # [ doc = "Bits 12:15 - Master 3 Priority" ] # [ inline ( always ) ] pub fn m3pr ( & mut self ) -> M3PR_W { M3PR_W { w : self } } # [ doc = "Bits 16:19 - Master 4 Priority" ] # [ inline ( always ) ] pub fn m4pr ( & mut self ) -> M4PR_W { M4PR_W { w : self } } # [ doc = "Bits 20:23 - Master 5 Priority" ] # [ inline ( always ) ] pub fn m5pr ( & mut self ) -> M5PR_W { M5PR_W { w : self } } # [ doc = "Bits 24:27 - Master 6 Priority" ] # [ inline ( always ) ] pub fn m6pr ( & mut self ) -> M6PR_W { M6PR_W { w : self } } # [ doc = "Bits 28:31 - Master 7 Priority" ] # [ inline ( always ) ] pub fn m7pr ( & mut self ) -> M7PR_W { M7PR_W { w : self } } } } # [ doc = "Priority B for Slave\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [prbs](prbs) module" ] pub type PRBS = crate :: Reg < u32 , _PRBS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PRBS ; # [ doc = "`read()` method returns [prbs::R](prbs::R) reader structure" ] impl crate :: Readable for PRBS { } # [ doc = "`write(|w| ..)` method takes [prbs::W](prbs::W) writer structure" ] impl crate :: Writable for PRBS { } # [ doc = "Priority B for Slave" ] pub mod prbs { # [ doc = "Reader of register PRBS" ] pub type R = crate :: R < u32 , super :: PRBS > ; # [ doc = "Writer for register PRBS" ] pub type W = crate :: W < u32 , super :: PRBS > ; # [ doc = "Register PRBS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PRBS { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `M8PR`" ] pub type M8PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M8PR`" ] pub struct M8PR_W < 'a > { w : & 'a mut W , } impl < 'a > M8PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u32 ) & 0x0f ) ; self . w } } # [ doc = "Reader of field `M9PR`" ] pub type M9PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M9PR`" ] pub struct M9PR_W < 'a > { w : & 'a mut W , } impl < 'a > M9PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 4 ) ) | ( ( ( value as u32 ) & 0x0f ) << 4 ) ; self . w } } # [ doc = "Reader of field `M10PR`" ] pub type M10PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M10PR`" ] pub struct M10PR_W < 'a > { w : & 'a mut W , } impl < 'a > M10PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u32 ) & 0x0f ) << 8 ) ; self . w } } # [ doc = "Reader of field `M11PR`" ] pub type M11PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M11PR`" ] pub struct M11PR_W < 'a > { w : & 'a mut W , } impl < 'a > M11PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 12 ) ) | ( ( ( value as u32 ) & 0x0f ) << 12 ) ; self . w } } # [ doc = "Reader of field `M12PR`" ] pub type M12PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M12PR`" ] pub struct M12PR_W < 'a > { w : & 'a mut W , } impl < 'a > M12PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 16 ) ) | ( ( ( value as u32 ) & 0x0f ) << 16 ) ; self . w } } # [ doc = "Reader of field `M13PR`" ] pub type M13PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M13PR`" ] pub struct M13PR_W < 'a > { w : & 'a mut W , } impl < 'a > M13PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 20 ) ) | ( ( ( value as u32 ) & 0x0f ) << 20 ) ; self . w } } # [ doc = "Reader of field `M14PR`" ] pub type M14PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M14PR`" ] pub struct M14PR_W < 'a > { w : & 'a mut W , } impl < 'a > M14PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } } # [ doc = "Reader of field `M15PR`" ] pub type M15PR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `M15PR`" ] pub struct M15PR_W < 'a > { w : & 'a mut W , } impl < 'a > M15PR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 28 ) ) | ( ( ( value as u32 ) & 0x0f ) << 28 ) ; self . w } } impl R { # [ doc = "Bits 0:3 - Master 8 Priority" ] # [ inline ( always ) ] pub fn m8pr ( & self ) -> M8PR_R { M8PR_R :: new ( ( self . bits & 0x0f ) as u8 ) } # [ doc = "Bits 4:7 - Master 9 Priority" ] # [ inline ( always ) ] pub fn m9pr ( & self ) -> M9PR_R { M9PR_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) } # [ doc = "Bits 8:11 - Master 10 Priority" ] # [ inline ( always ) ] pub fn m10pr ( & self ) -> M10PR_R { M10PR_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) } # [ doc = "Bits 12:15 - Master 11 Priority" ] # [ inline ( always ) ] pub fn m11pr ( & self ) -> M11PR_R { M11PR_R :: new ( ( ( self . bits >> 12 ) & 0x0f ) as u8 ) } # [ doc = "Bits 16:19 - Master 12 Priority" ] # [ inline ( always ) ] pub fn m12pr ( & self ) -> M12PR_R { M12PR_R :: new ( ( ( self . bits >> 16 ) & 0x0f ) as u8 ) } # [ doc = "Bits 20:23 - Master 13 Priority" ] # [ inline ( always ) ] pub fn m13pr ( & self ) -> M13PR_R { M13PR_R :: new ( ( ( self . bits >> 20 ) & 0x0f ) as u8 ) } # [ doc = "Bits 24:27 - Master 14 Priority" ] # [ inline ( always ) ] pub fn m14pr ( & self ) -> M14PR_R { M14PR_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) } # [ doc = "Bits 28:31 - Master 15 Priority" ] # [ inline ( always ) ] pub fn m15pr ( & self ) -> M15PR_R { M15PR_R :: new ( ( ( self . bits >> 28 ) & 0x0f ) as u8 ) } } impl W { # [ doc = "Bits 0:3 - Master 8 Priority" ] # [ inline ( always ) ] pub fn m8pr ( & mut self ) -> M8PR_W { M8PR_W { w : self } } # [ doc = "Bits 4:7 - Master 9 Priority" ] # [ inline ( always ) ] pub fn m9pr ( & mut self ) -> M9PR_W { M9PR_W { w : self } } # [ doc = "Bits 8:11 - Master 10 Priority" ] # [ inline ( always ) ] pub fn m10pr ( & mut self ) -> M10PR_W { M10PR_W { w : self } } # [ doc = "Bits 12:15 - Master 11 Priority" ] # [ inline ( always ) ] pub fn m11pr ( & mut self ) -> M11PR_W { M11PR_W { w : self } } # [ doc = "Bits 16:19 - Master 12 Priority" ] # [ inline ( always ) ] pub fn m12pr ( & mut self ) -> M12PR_W { M12PR_W { w : self } } # [ doc = "Bits 20:23 - Master 13 Priority" ] # [ inline ( always ) ] pub fn m13pr ( & mut self ) -> M13PR_W { M13PR_W { w : self } } # [ doc = "Bits 24:27 - Master 14 Priority" ] # [ inline ( always ) ] pub fn m14pr ( & mut self ) -> M14PR_W { M14PR_W { w : self } } # [ doc = "Bits 28:31 - Master 15 Priority" ] # [ inline ( always ) ] pub fn m15pr ( & mut self ) -> M15PR_W { M15PR_W { w : self } } } } }
# [ doc = "Master Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [mcfg](mcfg) module" ] pub type MCFG = crate :: Reg < u32 , _MCFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MCFG ;
# [ doc = "`read()` method returns [mcfg::R](mcfg::R) reader structure" ] impl crate :: Readable for MCFG { }
# [ doc = "`write(|w| ..)` method takes [mcfg::W](mcfg::W) writer structure" ] impl crate :: Writable for MCFG { }
# [ doc = "Master Configuration" ] pub mod mcfg {
# [ doc = "Reader of register MCFG[%s]" ] pub type R = crate :: R < u32 , super :: MCFG > ;
# [ doc = "Writer for register MCFG[%s]" ] pub type W = crate :: W < u32 , super :: MCFG > ;
# [ doc = "Register MCFG[%s] `reset()`'s with value 0x02" ] impl crate :: ResetValue for super :: MCFG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x02 } }
# [ doc = "Possible values of the field `ULBT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ULBT_A { # [ doc = "Infinite Length" ] INFINITE , # [ doc = "Single Access" ] SINGLE , # [ doc = "Four Beat Burst" ] FOUR_BEAT , # [ doc = "Eight Beat Burst" ] EIGHT_BEAT , # [ doc = "Sixteen Beat Burst" ] SIXTEEN_BEAT }
impl crate :: ToBits < u8 > for ULBT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { ULBT_A :: INFINITE => 0 , ULBT_A :: SINGLE => 1 , ULBT_A :: FOUR_BEAT => 2 , ULBT_A :: EIGHT_BEAT => 3 , ULBT_A :: SIXTEEN_BEAT => 4 } } }
# [ doc = "Reader of field `ULBT`" ] pub type ULBT_R = crate :: R < u8 , ULBT_A > ; impl ULBT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , ULBT_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( ULBT_A :: INFINITE ) , 1 => Val ( ULBT_A :: SINGLE ) , 2 => Val ( ULBT_A :: FOUR_BEAT ) , 3 => Val ( ULBT_A :: EIGHT_BEAT ) , 4 => Val ( ULBT_A :: SIXTEEN_BEAT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `INFINITE`" ] # [ inline ( always ) ] pub fn is_infinite ( & self ) -> bool { * self == ULBT_A :: INFINITE } # [ doc = "Checks if the value of the field is `SINGLE`" ] # [ inline ( always ) ] pub fn is_single ( & self ) -> bool { * self == ULBT_A :: SINGLE } # [ doc = "Checks if the value of the field is `FOUR_BEAT`" ] # [ inline ( always ) ] pub fn is_four_beat ( & self ) -> bool { * self == ULBT_A :: FOUR_BEAT } # [ doc = "Checks if the value of the field is `EIGHT_BEAT`" ] # [ inline ( always ) ] pub fn is_eight_beat ( & self ) -> bool { * self == ULBT_A :: EIGHT_BEAT } # [ doc = "Checks if the value of the field is `SIXTEEN_BEAT`" ] # [ inline ( always ) ] pub fn is_sixteen_beat ( & self ) -> bool { * self == ULBT_A :: SIXTEEN_BEAT } }
# [ doc = "Write proxy for field `ULBT`" ] pub struct ULBT_W < 'a > { w : & 'a mut W , } impl < 'a > ULBT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ULBT_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Infinite Length" ] # [ inline ( always ) ] pub fn infinite ( self ) -> & 'a mut W { self . variant ( ULBT_A :: INFINITE ) } # [ doc = "Single Access" ] # [ inline ( always ) ] pub fn single ( self ) -> & 'a mut W { self . variant ( ULBT_A :: SINGLE ) } # [ doc = "Four Beat Burst" ] # [ inline ( always ) ] pub fn four_beat ( self ) -> & 'a mut W { self . variant ( ULBT_A :: FOUR_BEAT ) } # [ doc = "Eight Beat Burst" ] # [ inline ( always ) ] pub fn eight_beat ( self ) -> & 'a mut W { self . variant ( ULBT_A :: EIGHT_BEAT ) } # [ doc = "Sixteen Beat Burst" ] # [ inline ( always ) ] pub fn sixteen_beat ( self ) -> & 'a mut W { self . variant ( ULBT_A :: SIXTEEN_BEAT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Undefined Length Burst Type" ] # [ inline ( always ) ] pub fn ulbt ( & self ) -> ULBT_R { ULBT_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Undefined Length Burst Type" ] # [ inline ( always ) ] pub fn ulbt ( & mut self ) -> ULBT_W { ULBT_W { w : self } }
}
}
# [ doc = "Slave Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [scfg](scfg) module" ] pub type SCFG = crate :: Reg < u32 , _SCFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SCFG ;
# [ doc = "`read()` method returns [scfg::R](scfg::R) reader structure" ] impl crate :: Readable for SCFG { }
# [ doc = "`write(|w| ..)` method takes [scfg::W](scfg::W) writer structure" ] impl crate :: Writable for SCFG { }
# [ doc = "Slave Configuration" ] pub mod scfg {
# [ doc = "Reader of register SCFG[%s]" ] pub type R = crate :: R < u32 , super :: SCFG > ;
# [ doc = "Writer for register SCFG[%s]" ] pub type W = crate :: W < u32 , super :: SCFG > ;
# [ doc = "Register SCFG[%s] `reset()`'s with value 0x10" ] impl crate :: ResetValue for super :: SCFG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x10 } }
# [ doc = "Reader of field `SLOT_CYCLE`" ] pub type SLOT_CYCLE_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `SLOT_CYCLE`" ] pub struct SLOT_CYCLE_W < 'a > { w : & 'a mut W , } impl < 'a > SLOT_CYCLE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u32 ) & 0xff ) ; self . w } }
# [ doc = "Possible values of the field `DEFMSTR_TYPE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DEFMSTR_TYPE_A { # [ doc = "No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This resusts in having a one cycle latency for the first transfer of a burst." ] NO_DEFAULT , # [ doc = "Last Default Master At the end of current slave access, if no other master request is pending, the slave stay connected with the last master havingaccessed it.This resusts in not having the one cycle latency when the last master re-trying access on the slave." ] LAST_DEFAULT , # [ doc = "Fixed Default Master At the end of current slave access, if no other master request is pending, the slave connects with fixed master which numberis in FIXED_DEFMSTR register.This resusts in not having the one cycle latency when the fixed master re-trying access on the slave." ] FIXED_DEFAULT }
impl crate :: ToBits < u8 > for DEFMSTR_TYPE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DEFMSTR_TYPE_A :: NO_DEFAULT => 0 , DEFMSTR_TYPE_A :: LAST_DEFAULT => 1 , DEFMSTR_TYPE_A :: FIXED_DEFAULT => 2 } } }
# [ doc = "Reader of field `DEFMSTR_TYPE`" ] pub type DEFMSTR_TYPE_R = crate :: R < u8 , DEFMSTR_TYPE_A > ; impl DEFMSTR_TYPE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , DEFMSTR_TYPE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( DEFMSTR_TYPE_A :: NO_DEFAULT ) , 1 => Val ( DEFMSTR_TYPE_A :: LAST_DEFAULT ) , 2 => Val ( DEFMSTR_TYPE_A :: FIXED_DEFAULT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NO_DEFAULT`" ] # [ inline ( always ) ] pub fn is_no_default ( & self ) -> bool { * self == DEFMSTR_TYPE_A :: NO_DEFAULT } # [ doc = "Checks if the value of the field is `LAST_DEFAULT`" ] # [ inline ( always ) ] pub fn is_last_default ( & self ) -> bool { * self == DEFMSTR_TYPE_A :: LAST_DEFAULT } # [ doc = "Checks if the value of the field is `FIXED_DEFAULT`" ] # [ inline ( always ) ] pub fn is_fixed_default ( & self ) -> bool { * self == DEFMSTR_TYPE_A :: FIXED_DEFAULT } }
# [ doc = "Write proxy for field `DEFMSTR_TYPE`" ] pub struct DEFMSTR_TYPE_W < 'a > { w : & 'a mut W , } impl < 'a > DEFMSTR_TYPE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DEFMSTR_TYPE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No Default Master. At the end of current slave access, if no other master request is pending, the slave is deconnected from all masters. This resusts in having a one cycle latency for the first transfer of a burst." ] # [ inline ( always ) ] pub fn no_default ( self ) -> & 'a mut W { self . variant ( DEFMSTR_TYPE_A :: NO_DEFAULT ) } # [ doc = "Last Default Master At the end of current slave access, if no other master request is pending, the slave stay connected with the last master havingaccessed it.This resusts in not having the one cycle latency when the last master re-trying access on the slave." ] # [ inline ( always ) ] pub fn last_default ( self ) -> & 'a mut W { self . variant ( DEFMSTR_TYPE_A :: LAST_DEFAULT ) } # [ doc = "Fixed Default Master At the end of current slave access, if no other master request is pending, the slave connects with fixed master which numberis in FIXED_DEFMSTR register.This resusts in not having the one cycle latency when the fixed master re-trying access on the slave." ] # [ inline ( always ) ] pub fn fixed_default ( self ) -> & 'a mut W { self . variant ( DEFMSTR_TYPE_A :: FIXED_DEFAULT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 16 ) ) | ( ( ( value as u32 ) & 0x03 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `FIXED_DEFMSTR`" ] pub type FIXED_DEFMSTR_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FIXED_DEFMSTR`" ] pub struct FIXED_DEFMSTR_W < 'a > { w : & 'a mut W , } impl < 'a > FIXED_DEFMSTR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 18 ) ) | ( ( ( value as u32 ) & 0x0f ) << 18 ) ; self . w } }
# [ doc = "Possible values of the field `ARBT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ARBT_A { # [ doc = "Round-Robin Arbitration" ] ROUND_ROBIN , # [ doc = "Fixed Priority Arbitration" ] FIXED_PRIORITY }
impl crate :: ToBits < bool > for ARBT_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { ARBT_A :: ROUND_ROBIN => false , ARBT_A :: FIXED_PRIORITY => true } } }
# [ doc = "Reader of field `ARBT`" ] pub type ARBT_R = crate :: R < bool , ARBT_A > ; impl ARBT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ARBT_A { match self . bits { false => ARBT_A :: ROUND_ROBIN , true => ARBT_A :: FIXED_PRIORITY } } # [ doc = "Checks if the value of the field is `ROUND_ROBIN`" ] # [ inline ( always ) ] pub fn is_round_robin ( & self ) -> bool { * self == ARBT_A :: ROUND_ROBIN } # [ doc = "Checks if the value of the field is `FIXED_PRIORITY`" ] # [ inline ( always ) ] pub fn is_fixed_priority ( & self ) -> bool { * self == ARBT_A :: FIXED_PRIORITY } }
# [ doc = "Write proxy for field `ARBT`" ] pub struct ARBT_W < 'a > { w : & 'a mut W , } impl < 'a > ARBT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ARBT_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Round-Robin Arbitration" ] # [ inline ( always ) ] pub fn round_robin ( self ) -> & 'a mut W { self . variant ( ARBT_A :: ROUND_ROBIN ) } # [ doc = "Fixed Priority Arbitration" ] # [ inline ( always ) ] pub fn fixed_priority ( self ) -> & 'a mut W { self . variant ( ARBT_A :: FIXED_PRIORITY ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Maximum Number of Allowed Cycles for a Burst" ] # [ inline ( always ) ] pub fn slot_cycle ( & self ) -> SLOT_CYCLE_R { SLOT_CYCLE_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bits 16:17 - Default Master Type" ] # [ inline ( always ) ] pub fn defmstr_type ( & self ) -> DEFMSTR_TYPE_R { DEFMSTR_TYPE_R :: new ( ( ( self . bits >> 16 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 18:21 - Fixed Index of Default Master" ] # [ inline ( always ) ] pub fn fixed_defmstr ( & self ) -> FIXED_DEFMSTR_R { FIXED_DEFMSTR_R :: new ( ( ( self . bits >> 18 ) & 0x0f ) as u8 ) }
# [ doc = "Bit 24 - Arbitration Type" ] # [ inline ( always ) ] pub fn arbt ( & self ) -> ARBT_R { ARBT_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:7 - Maximum Number of Allowed Cycles for a Burst" ] # [ inline ( always ) ] pub fn slot_cycle ( & mut self ) -> SLOT_CYCLE_W { SLOT_CYCLE_W { w : self } }
# [ doc = "Bits 16:17 - Default Master Type" ] # [ inline ( always ) ] pub fn defmstr_type ( & mut self ) -> DEFMSTR_TYPE_W { DEFMSTR_TYPE_W { w : self } }
# [ doc = "Bits 18:21 - Fixed Index of Default Master" ] # [ inline ( always ) ] pub fn fixed_defmstr ( & mut self ) -> FIXED_DEFMSTR_W { FIXED_DEFMSTR_W { w : self } }
# [ doc = "Bit 24 - Arbitration Type" ] # [ inline ( always ) ] pub fn arbt ( & mut self ) -> ARBT_W { ARBT_W { w : self } }
}
}
# [ doc = "Master Remap Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [mrcr](mrcr) module" ] pub type MRCR = crate :: Reg < u32 , _MRCR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MRCR ;
# [ doc = "`read()` method returns [mrcr::R](mrcr::R) reader structure" ] impl crate :: Readable for MRCR { }
# [ doc = "`write(|w| ..)` method takes [mrcr::W](mrcr::W) writer structure" ] impl crate :: Writable for MRCR { }
# [ doc = "Master Remap Control" ] pub mod mrcr {
# [ doc = "Reader of register MRCR" ] pub type R = crate :: R < u32 , super :: MRCR > ;
# [ doc = "Writer for register MRCR" ] pub type W = crate :: W < u32 , super :: MRCR > ;
# [ doc = "Register MRCR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MRCR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `RCB0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB0_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB0_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB0_A :: DIS => false , RCB0_A :: ENA => true } } }
# [ doc = "Reader of field `RCB0`" ] pub type RCB0_R = crate :: R < bool , RCB0_A > ; impl RCB0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB0_A { match self . bits { false => RCB0_A :: DIS , true => RCB0_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB0_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB0_A :: ENA } }
# [ doc = "Write proxy for field `RCB0`" ] pub struct RCB0_W < 'a > { w : & 'a mut W , } impl < 'a > RCB0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB0_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB0_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB0_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Possible values of the field `RCB1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB1_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB1_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB1_A :: DIS => false , RCB1_A :: ENA => true } } }
# [ doc = "Reader of field `RCB1`" ] pub type RCB1_R = crate :: R < bool , RCB1_A > ; impl RCB1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB1_A { match self . bits { false => RCB1_A :: DIS , true => RCB1_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB1_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB1_A :: ENA } }
# [ doc = "Write proxy for field `RCB1`" ] pub struct RCB1_W < 'a > { w : & 'a mut W , } impl < 'a > RCB1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB1_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB1_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB1_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Possible values of the field `RCB2`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB2_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB2_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB2_A :: DIS => false , RCB2_A :: ENA => true } } }
# [ doc = "Reader of field `RCB2`" ] pub type RCB2_R = crate :: R < bool , RCB2_A > ; impl RCB2_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB2_A { match self . bits { false => RCB2_A :: DIS , true => RCB2_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB2_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB2_A :: ENA } }
# [ doc = "Write proxy for field `RCB2`" ] pub struct RCB2_W < 'a > { w : & 'a mut W , } impl < 'a > RCB2_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB2_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB2_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB2_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `RCB3`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB3_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB3_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB3_A :: DIS => false , RCB3_A :: ENA => true } } }
# [ doc = "Reader of field `RCB3`" ] pub type RCB3_R = crate :: R < bool , RCB3_A > ; impl RCB3_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB3_A { match self . bits { false => RCB3_A :: DIS , true => RCB3_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB3_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB3_A :: ENA } }
# [ doc = "Write proxy for field `RCB3`" ] pub struct RCB3_W < 'a > { w : & 'a mut W , } impl < 'a > RCB3_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB3_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB3_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB3_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Possible values of the field `RCB4`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB4_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB4_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB4_A :: DIS => false , RCB4_A :: ENA => true } } }
# [ doc = "Reader of field `RCB4`" ] pub type RCB4_R = crate :: R < bool , RCB4_A > ; impl RCB4_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB4_A { match self . bits { false => RCB4_A :: DIS , true => RCB4_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB4_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB4_A :: ENA } }
# [ doc = "Write proxy for field `RCB4`" ] pub struct RCB4_W < 'a > { w : & 'a mut W , } impl < 'a > RCB4_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB4_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB4_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB4_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Possible values of the field `RCB5`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB5_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB5_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB5_A :: DIS => false , RCB5_A :: ENA => true } } }
# [ doc = "Reader of field `RCB5`" ] pub type RCB5_R = crate :: R < bool , RCB5_A > ; impl RCB5_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB5_A { match self . bits { false => RCB5_A :: DIS , true => RCB5_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB5_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB5_A :: ENA } }
# [ doc = "Write proxy for field `RCB5`" ] pub struct RCB5_W < 'a > { w : & 'a mut W , } impl < 'a > RCB5_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB5_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB5_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB5_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Possible values of the field `RCB6`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB6_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB6_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB6_A :: DIS => false , RCB6_A :: ENA => true } } }
# [ doc = "Reader of field `RCB6`" ] pub type RCB6_R = crate :: R < bool , RCB6_A > ; impl RCB6_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB6_A { match self . bits { false => RCB6_A :: DIS , true => RCB6_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB6_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB6_A :: ENA } }
# [ doc = "Write proxy for field `RCB6`" ] pub struct RCB6_W < 'a > { w : & 'a mut W , } impl < 'a > RCB6_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB6_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB6_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB6_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Possible values of the field `RCB7`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB7_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB7_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB7_A :: DIS => false , RCB7_A :: ENA => true } } }
# [ doc = "Reader of field `RCB7`" ] pub type RCB7_R = crate :: R < bool , RCB7_A > ; impl RCB7_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB7_A { match self . bits { false => RCB7_A :: DIS , true => RCB7_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB7_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB7_A :: ENA } }
# [ doc = "Write proxy for field `RCB7`" ] pub struct RCB7_W < 'a > { w : & 'a mut W , } impl < 'a > RCB7_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB7_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB7_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB7_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `RCB8`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB8_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB8_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB8_A :: DIS => false , RCB8_A :: ENA => true } } }
# [ doc = "Reader of field `RCB8`" ] pub type RCB8_R = crate :: R < bool , RCB8_A > ; impl RCB8_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB8_A { match self . bits { false => RCB8_A :: DIS , true => RCB8_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB8_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB8_A :: ENA } }
# [ doc = "Write proxy for field `RCB8`" ] pub struct RCB8_W < 'a > { w : & 'a mut W , } impl < 'a > RCB8_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB8_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB8_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB8_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Possible values of the field `RCB9`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB9_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB9_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB9_A :: DIS => false , RCB9_A :: ENA => true } } }
# [ doc = "Reader of field `RCB9`" ] pub type RCB9_R = crate :: R < bool , RCB9_A > ; impl RCB9_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB9_A { match self . bits { false => RCB9_A :: DIS , true => RCB9_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB9_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB9_A :: ENA } }
# [ doc = "Write proxy for field `RCB9`" ] pub struct RCB9_W < 'a > { w : & 'a mut W , } impl < 'a > RCB9_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB9_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB9_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB9_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Possible values of the field `RCB10`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB10_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB10_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB10_A :: DIS => false , RCB10_A :: ENA => true } } }
# [ doc = "Reader of field `RCB10`" ] pub type RCB10_R = crate :: R < bool , RCB10_A > ; impl RCB10_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB10_A { match self . bits { false => RCB10_A :: DIS , true => RCB10_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB10_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB10_A :: ENA } }
# [ doc = "Write proxy for field `RCB10`" ] pub struct RCB10_W < 'a > { w : & 'a mut W , } impl < 'a > RCB10_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB10_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB10_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB10_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Possible values of the field `RCB11`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB11_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB11_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB11_A :: DIS => false , RCB11_A :: ENA => true } } }
# [ doc = "Reader of field `RCB11`" ] pub type RCB11_R = crate :: R < bool , RCB11_A > ; impl RCB11_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB11_A { match self . bits { false => RCB11_A :: DIS , true => RCB11_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB11_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB11_A :: ENA } }
# [ doc = "Write proxy for field `RCB11`" ] pub struct RCB11_W < 'a > { w : & 'a mut W , } impl < 'a > RCB11_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB11_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB11_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB11_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Possible values of the field `RCB12`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB12_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB12_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB12_A :: DIS => false , RCB12_A :: ENA => true } } }
# [ doc = "Reader of field `RCB12`" ] pub type RCB12_R = crate :: R < bool , RCB12_A > ; impl RCB12_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB12_A { match self . bits { false => RCB12_A :: DIS , true => RCB12_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB12_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB12_A :: ENA } }
# [ doc = "Write proxy for field `RCB12`" ] pub struct RCB12_W < 'a > { w : & 'a mut W , } impl < 'a > RCB12_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB12_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB12_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB12_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Possible values of the field `RCB13`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB13_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB13_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB13_A :: DIS => false , RCB13_A :: ENA => true } } }
# [ doc = "Reader of field `RCB13`" ] pub type RCB13_R = crate :: R < bool , RCB13_A > ; impl RCB13_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB13_A { match self . bits { false => RCB13_A :: DIS , true => RCB13_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB13_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB13_A :: ENA } }
# [ doc = "Write proxy for field `RCB13`" ] pub struct RCB13_W < 'a > { w : & 'a mut W , } impl < 'a > RCB13_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB13_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB13_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB13_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Possible values of the field `RCB14`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB14_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB14_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB14_A :: DIS => false , RCB14_A :: ENA => true } } }
# [ doc = "Reader of field `RCB14`" ] pub type RCB14_R = crate :: R < bool , RCB14_A > ; impl RCB14_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB14_A { match self . bits { false => RCB14_A :: DIS , true => RCB14_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB14_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB14_A :: ENA } }
# [ doc = "Write proxy for field `RCB14`" ] pub struct RCB14_W < 'a > { w : & 'a mut W , } impl < 'a > RCB14_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB14_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB14_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB14_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Possible values of the field `RCB15`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RCB15_A { # [ doc = "Disable remapped address decoding for master" ] DIS , # [ doc = "Enable remapped address decoding for master" ] ENA }
impl crate :: ToBits < bool > for RCB15_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { RCB15_A :: DIS => false , RCB15_A :: ENA => true } } }
# [ doc = "Reader of field `RCB15`" ] pub type RCB15_R = crate :: R < bool , RCB15_A > ; impl RCB15_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RCB15_A { match self . bits { false => RCB15_A :: DIS , true => RCB15_A :: ENA } } # [ doc = "Checks if the value of the field is `DIS`" ] # [ inline ( always ) ] pub fn is_dis ( & self ) -> bool { * self == RCB15_A :: DIS } # [ doc = "Checks if the value of the field is `ENA`" ] # [ inline ( always ) ] pub fn is_ena ( & self ) -> bool { * self == RCB15_A :: ENA } }
# [ doc = "Write proxy for field `RCB15`" ] pub struct RCB15_W < 'a > { w : & 'a mut W , } impl < 'a > RCB15_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RCB15_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Disable remapped address decoding for master" ] # [ inline ( always ) ] pub fn dis ( self ) -> & 'a mut W { self . variant ( RCB15_A :: DIS ) } # [ doc = "Enable remapped address decoding for master" ] # [ inline ( always ) ] pub fn ena ( self ) -> & 'a mut W { self . variant ( RCB15_A :: ENA ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Remap Command Bit for Master 0" ] # [ inline ( always ) ] pub fn rcb0 ( & self ) -> RCB0_R { RCB0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Remap Command Bit for Master 1" ] # [ inline ( always ) ] pub fn rcb1 ( & self ) -> RCB1_R { RCB1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Remap Command Bit for Master 2" ] # [ inline ( always ) ] pub fn rcb2 ( & self ) -> RCB2_R { RCB2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Remap Command Bit for Master 3" ] # [ inline ( always ) ] pub fn rcb3 ( & self ) -> RCB3_R { RCB3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Remap Command Bit for Master 4" ] # [ inline ( always ) ] pub fn rcb4 ( & self ) -> RCB4_R { RCB4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Remap Command Bit for Master 5" ] # [ inline ( always ) ] pub fn rcb5 ( & self ) -> RCB5_R { RCB5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Remap Command Bit for Master 6" ] # [ inline ( always ) ] pub fn rcb6 ( & self ) -> RCB6_R { RCB6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Remap Command Bit for Master 7" ] # [ inline ( always ) ] pub fn rcb7 ( & self ) -> RCB7_R { RCB7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Remap Command Bit for Master 8" ] # [ inline ( always ) ] pub fn rcb8 ( & self ) -> RCB8_R { RCB8_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Remap Command Bit for Master 9" ] # [ inline ( always ) ] pub fn rcb9 ( & self ) -> RCB9_R { RCB9_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Remap Command Bit for Master 10" ] # [ inline ( always ) ] pub fn rcb10 ( & self ) -> RCB10_R { RCB10_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Remap Command Bit for Master 11" ] # [ inline ( always ) ] pub fn rcb11 ( & self ) -> RCB11_R { RCB11_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Remap Command Bit for Master 12" ] # [ inline ( always ) ] pub fn rcb12 ( & self ) -> RCB12_R { RCB12_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Remap Command Bit for Master 13" ] # [ inline ( always ) ] pub fn rcb13 ( & self ) -> RCB13_R { RCB13_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Remap Command Bit for Master 14" ] # [ inline ( always ) ] pub fn rcb14 ( & self ) -> RCB14_R { RCB14_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Remap Command Bit for Master 15" ] # [ inline ( always ) ] pub fn rcb15 ( & self ) -> RCB15_R { RCB15_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Remap Command Bit for Master 0" ] # [ inline ( always ) ] pub fn rcb0 ( & mut self ) -> RCB0_W { RCB0_W { w : self } }
# [ doc = "Bit 1 - Remap Command Bit for Master 1" ] # [ inline ( always ) ] pub fn rcb1 ( & mut self ) -> RCB1_W { RCB1_W { w : self } }
# [ doc = "Bit 2 - Remap Command Bit for Master 2" ] # [ inline ( always ) ] pub fn rcb2 ( & mut self ) -> RCB2_W { RCB2_W { w : self } }
# [ doc = "Bit 3 - Remap Command Bit for Master 3" ] # [ inline ( always ) ] pub fn rcb3 ( & mut self ) -> RCB3_W { RCB3_W { w : self } }
# [ doc = "Bit 4 - Remap Command Bit for Master 4" ] # [ inline ( always ) ] pub fn rcb4 ( & mut self ) -> RCB4_W { RCB4_W { w : self } }
# [ doc = "Bit 5 - Remap Command Bit for Master 5" ] # [ inline ( always ) ] pub fn rcb5 ( & mut self ) -> RCB5_W { RCB5_W { w : self } }
# [ doc = "Bit 6 - Remap Command Bit for Master 6" ] # [ inline ( always ) ] pub fn rcb6 ( & mut self ) -> RCB6_W { RCB6_W { w : self } }
# [ doc = "Bit 7 - Remap Command Bit for Master 7" ] # [ inline ( always ) ] pub fn rcb7 ( & mut self ) -> RCB7_W { RCB7_W { w : self } }
# [ doc = "Bit 8 - Remap Command Bit for Master 8" ] # [ inline ( always ) ] pub fn rcb8 ( & mut self ) -> RCB8_W { RCB8_W { w : self } }
# [ doc = "Bit 9 - Remap Command Bit for Master 9" ] # [ inline ( always ) ] pub fn rcb9 ( & mut self ) -> RCB9_W { RCB9_W { w : self } }
# [ doc = "Bit 10 - Remap Command Bit for Master 10" ] # [ inline ( always ) ] pub fn rcb10 ( & mut self ) -> RCB10_W { RCB10_W { w : self } }
# [ doc = "Bit 11 - Remap Command Bit for Master 11" ] # [ inline ( always ) ] pub fn rcb11 ( & mut self ) -> RCB11_W { RCB11_W { w : self } }
# [ doc = "Bit 12 - Remap Command Bit for Master 12" ] # [ inline ( always ) ] pub fn rcb12 ( & mut self ) -> RCB12_W { RCB12_W { w : self } }
# [ doc = "Bit 13 - Remap Command Bit for Master 13" ] # [ inline ( always ) ] pub fn rcb13 ( & mut self ) -> RCB13_W { RCB13_W { w : self } }
# [ doc = "Bit 14 - Remap Command Bit for Master 14" ] # [ inline ( always ) ] pub fn rcb14 ( & mut self ) -> RCB14_W { RCB14_W { w : self } }
# [ doc = "Bit 15 - Remap Command Bit for Master 15" ] # [ inline ( always ) ] pub fn rcb15 ( & mut self ) -> RCB15_W { RCB15_W { w : self } }
}
}
# [ doc = "Special Function\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [sfr](sfr) module" ] pub type SFR = crate :: Reg < u32 , _SFR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SFR ;
# [ doc = "`read()` method returns [sfr::R](sfr::R) reader structure" ] impl crate :: Readable for SFR { }
# [ doc = "`write(|w| ..)` method takes [sfr::W](sfr::W) writer structure" ] impl crate :: Writable for SFR { }
# [ doc = "Special Function" ] pub mod sfr {
# [ doc = "Reader of register SFR[%s]" ] pub type R = crate :: R < u32 , super :: SFR > ;
# [ doc = "Writer for register SFR[%s]" ] pub type W = crate :: W < u32 , super :: SFR > ;
# [ doc = "Register SFR[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SFR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SFR`" ] pub type SFR_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `SFR`" ] pub struct SFR_W < 'a > { w : & 'a mut W , } impl < 'a > SFR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:31 - Special Function Register" ] # [ inline ( always ) ] pub fn sfr ( & self ) -> SFR_R { SFR_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:31 - Special Function Register" ] # [ inline ( always ) ] pub fn sfr ( & mut self ) -> SFR_W { SFR_W { w : self } }
}
}
}
# [ doc = "Main Clock" ] pub struct MCLK { _marker : PhantomData < * const ( ) > } unsafe impl Send for MCLK { } impl MCLK { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const mclk :: RegisterBlock { 0x4000_0800 as * const _ } } impl Deref for MCLK { type Target = mclk :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * MCLK :: ptr ( ) } } }
# [ doc = "Main Clock" ] pub mod mclk {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1usize ] , # [ doc = "0x01 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x02 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x03 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x04 - CPU Clock Division" ] pub cpudiv : CPUDIV , _reserved4 : [ u8 ; 11usize ] , # [ doc = "0x10 - AHB Mask" ] pub ahbmask : AHBMASK , # [ doc = "0x14 - APBA Mask" ] pub apbamask : APBAMASK , # [ doc = "0x18 - APBB Mask" ] pub apbbmask : APBBMASK , # [ doc = "0x1c - APBC Mask" ] pub apbcmask : APBCMASK , # [ doc = "0x20 - APBD Mask" ] pub apbdmask : APBDMASK , }
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CKRDY`" ] pub type CKRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CKRDY`" ] pub struct CKRDY_W < 'a > { w : & 'a mut W , } impl < 'a > CKRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Clock Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn ckrdy ( & self ) -> CKRDY_R { CKRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Clock Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn ckrdy ( & mut self ) -> CKRDY_W { CKRDY_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CKRDY`" ] pub type CKRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CKRDY`" ] pub struct CKRDY_W < 'a > { w : & 'a mut W , } impl < 'a > CKRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Clock Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn ckrdy ( & self ) -> CKRDY_R { CKRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Clock Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn ckrdy ( & mut self ) -> CKRDY_W { CKRDY_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0x01" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x01 } }
# [ doc = "Reader of field `CKRDY`" ] pub type CKRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CKRDY`" ] pub struct CKRDY_W < 'a > { w : & 'a mut W , } impl < 'a > CKRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Clock Ready" ] # [ inline ( always ) ] pub fn ckrdy ( & self ) -> CKRDY_R { CKRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Clock Ready" ] # [ inline ( always ) ] pub fn ckrdy ( & mut self ) -> CKRDY_W { CKRDY_W { w : self } }
}
}
# [ doc = "CPU Clock Division\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cpudiv](cpudiv) module" ] pub type CPUDIV = crate :: Reg < u8 , _CPUDIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPUDIV ;
# [ doc = "`read()` method returns [cpudiv::R](cpudiv::R) reader structure" ] impl crate :: Readable for CPUDIV { }
# [ doc = "`write(|w| ..)` method takes [cpudiv::W](cpudiv::W) writer structure" ] impl crate :: Writable for CPUDIV { }
# [ doc = "CPU Clock Division" ] pub mod cpudiv {
# [ doc = "Reader of register CPUDIV" ] pub type R = crate :: R < u8 , super :: CPUDIV > ;
# [ doc = "Writer for register CPUDIV" ] pub type W = crate :: W < u8 , super :: CPUDIV > ;
# [ doc = "Register CPUDIV `reset()`'s with value 0x01" ] impl crate :: ResetValue for super :: CPUDIV { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x01 } }
# [ doc = "Possible values of the field `CPUDIV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPUDIV_A { # [ doc = "Divide by 1" ] DIV1 , # [ doc = "Divide by 2" ] DIV2 , # [ doc = "Divide by 4" ] DIV4 , # [ doc = "Divide by 8" ] DIV8 , # [ doc = "Divide by 16" ] DIV16 , # [ doc = "Divide by 32" ] DIV32 , # [ doc = "Divide by 64" ] DIV64 , # [ doc = "Divide by 128" ] DIV128 }
impl crate :: ToBits < u8 > for CPUDIV_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CPUDIV_A :: DIV1 => 1 , CPUDIV_A :: DIV2 => 2 , CPUDIV_A :: DIV4 => 4 , CPUDIV_A :: DIV8 => 8 , CPUDIV_A :: DIV16 => 16 , CPUDIV_A :: DIV32 => 32 , CPUDIV_A :: DIV64 => 64 , CPUDIV_A :: DIV128 => 128 } } }
# [ doc = "Reader of field `CPUDIV`" ] pub type CPUDIV_R = crate :: R < u8 , CPUDIV_A > ; impl CPUDIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CPUDIV_A > { use crate :: Variant :: * ; match self . bits { 1 => Val ( CPUDIV_A :: DIV1 ) , 2 => Val ( CPUDIV_A :: DIV2 ) , 4 => Val ( CPUDIV_A :: DIV4 ) , 8 => Val ( CPUDIV_A :: DIV8 ) , 16 => Val ( CPUDIV_A :: DIV16 ) , 32 => Val ( CPUDIV_A :: DIV32 ) , 64 => Val ( CPUDIV_A :: DIV64 ) , 128 => Val ( CPUDIV_A :: DIV128 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == CPUDIV_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == CPUDIV_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == CPUDIV_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == CPUDIV_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == CPUDIV_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == CPUDIV_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == CPUDIV_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == CPUDIV_A :: DIV128 } }
# [ doc = "Write proxy for field `CPUDIV`" ] pub struct CPUDIV_W < 'a > { w : & 'a mut W , } impl < 'a > CPUDIV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPUDIV_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Divide by 1" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( CPUDIV_A :: DIV1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( CPUDIV_A :: DIV2 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( CPUDIV_A :: DIV4 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( CPUDIV_A :: DIV8 ) } # [ doc = "Divide by 16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( CPUDIV_A :: DIV16 ) } # [ doc = "Divide by 32" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( CPUDIV_A :: DIV32 ) } # [ doc = "Divide by 64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( CPUDIV_A :: DIV64 ) } # [ doc = "Divide by 128" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( CPUDIV_A :: DIV128 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - CPU Clock Division Factor" ] # [ inline ( always ) ] pub fn cpudiv ( & self ) -> CPUDIV_R { CPUDIV_R :: new ( ( self . bits & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - CPU Clock Division Factor" ] # [ inline ( always ) ] pub fn cpudiv ( & mut self ) -> CPUDIV_W { CPUDIV_W { w : self } }
}
}
# [ doc = "AHB Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ahbmask](ahbmask) module" ] pub type AHBMASK = crate :: Reg < u32 , _AHBMASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _AHBMASK ;
# [ doc = "`read()` method returns [ahbmask::R](ahbmask::R) reader structure" ] impl crate :: Readable for AHBMASK { }
# [ doc = "`write(|w| ..)` method takes [ahbmask::W](ahbmask::W) writer structure" ] impl crate :: Writable for AHBMASK { }
# [ doc = "AHB Mask" ] pub mod ahbmask {
# [ doc = "Reader of register AHBMASK" ] pub type R = crate :: R < u32 , super :: AHBMASK > ;
# [ doc = "Writer for register AHBMASK" ] pub type W = crate :: W < u32 , super :: AHBMASK > ;
# [ doc = "Register AHBMASK `reset()`'s with value 0x3cff" ] impl crate :: ResetValue for super :: AHBMASK { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x3cff } }
# [ doc = "Reader of field `HPB0_`" ] pub type HPB0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPB0_`" ] pub struct HPB0__W < 'a > { w : & 'a mut W , } impl < 'a > HPB0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `HPB1_`" ] pub type HPB1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPB1_`" ] pub struct HPB1__W < 'a > { w : & 'a mut W , } impl < 'a > HPB1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `HPB2_`" ] pub type HPB2__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPB2_`" ] pub struct HPB2__W < 'a > { w : & 'a mut W , } impl < 'a > HPB2__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `DSU_`" ] pub type DSU__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DSU_`" ] pub struct DSU__W < 'a > { w : & 'a mut W , } impl < 'a > DSU__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `HMATRIXHS_`" ] pub type HMATRIXHS__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HMATRIXHS_`" ] pub struct HMATRIXHS__W < 'a > { w : & 'a mut W , } impl < 'a > HMATRIXHS__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `NVMCTRL_`" ] pub type NVMCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NVMCTRL_`" ] pub struct NVMCTRL__W < 'a > { w : & 'a mut W , } impl < 'a > NVMCTRL__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `HSRAM_`" ] pub type HSRAM__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HSRAM_`" ] pub struct HSRAM__W < 'a > { w : & 'a mut W , } impl < 'a > HSRAM__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `DMAC_`" ] pub type DMAC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DMAC_`" ] pub struct DMAC__W < 'a > { w : & 'a mut W , } impl < 'a > DMAC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `CAN0_`" ] pub type CAN0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CAN0_`" ] pub struct CAN0__W < 'a > { w : & 'a mut W , } impl < 'a > CAN0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `CAN1_`" ] pub type CAN1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CAN1_`" ] pub struct CAN1__W < 'a > { w : & 'a mut W , } impl < 'a > CAN1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `PAC_`" ] pub type PAC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PAC_`" ] pub struct PAC__W < 'a > { w : & 'a mut W , } impl < 'a > PAC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `NVMCTRL_PICACHU_`" ] pub type NVMCTRL_PICACHU__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NVMCTRL_PICACHU_`" ] pub struct NVMCTRL_PICACHU__W < 'a > { w : & 'a mut W , } impl < 'a > NVMCTRL_PICACHU__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `DIVAS_`" ] pub type DIVAS__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DIVAS_`" ] pub struct DIVAS__W < 'a > { w : & 'a mut W , } impl < 'a > DIVAS__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `HPB3_`" ] pub type HPB3__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPB3_`" ] pub struct HPB3__W < 'a > { w : & 'a mut W , } impl < 'a > HPB3__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - HPB0 AHB Clock Mask" ] # [ inline ( always ) ] pub fn hpb0_ ( & self ) -> HPB0__R { HPB0__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - HPB1 AHB Clock Mask" ] # [ inline ( always ) ] pub fn hpb1_ ( & self ) -> HPB1__R { HPB1__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - HPB2 AHB Clock Mask" ] # [ inline ( always ) ] pub fn hpb2_ ( & self ) -> HPB2__R { HPB2__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - DSU AHB Clock Mask" ] # [ inline ( always ) ] pub fn dsu_ ( & self ) -> DSU__R { DSU__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - HMATRIXHS AHB Clock Mask" ] # [ inline ( always ) ] pub fn hmatrixhs_ ( & self ) -> HMATRIXHS__R { HMATRIXHS__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - NVMCTRL AHB Clock Mask" ] # [ inline ( always ) ] pub fn nvmctrl_ ( & self ) -> NVMCTRL__R { NVMCTRL__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - HSRAM AHB Clock Mask" ] # [ inline ( always ) ] pub fn hsram_ ( & self ) -> HSRAM__R { HSRAM__R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - DMAC AHB Clock Mask" ] # [ inline ( always ) ] pub fn dmac_ ( & self ) -> DMAC__R { DMAC__R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - CAN0 AHB Clock Mask" ] # [ inline ( always ) ] pub fn can0_ ( & self ) -> CAN0__R { CAN0__R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - CAN1 AHB Clock Mask" ] # [ inline ( always ) ] pub fn can1_ ( & self ) -> CAN1__R { CAN1__R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - PAC AHB Clock Mask" ] # [ inline ( always ) ] pub fn pac_ ( & self ) -> PAC__R { PAC__R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - NVMCTRL_PICACHU AHB Clock Mask" ] # [ inline ( always ) ] pub fn nvmctrl_picachu_ ( & self ) -> NVMCTRL_PICACHU__R { NVMCTRL_PICACHU__R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - DIVAS AHB Clock Mask" ] # [ inline ( always ) ] pub fn divas_ ( & self ) -> DIVAS__R { DIVAS__R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - HPB3 AHB Clock Mask" ] # [ inline ( always ) ] pub fn hpb3_ ( & self ) -> HPB3__R { HPB3__R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - HPB0 AHB Clock Mask" ] # [ inline ( always ) ] pub fn hpb0_ ( & mut self ) -> HPB0__W { HPB0__W { w : self } }
# [ doc = "Bit 1 - HPB1 AHB Clock Mask" ] # [ inline ( always ) ] pub fn hpb1_ ( & mut self ) -> HPB1__W { HPB1__W { w : self } }
# [ doc = "Bit 2 - HPB2 AHB Clock Mask" ] # [ inline ( always ) ] pub fn hpb2_ ( & mut self ) -> HPB2__W { HPB2__W { w : self } }
# [ doc = "Bit 3 - DSU AHB Clock Mask" ] # [ inline ( always ) ] pub fn dsu_ ( & mut self ) -> DSU__W { DSU__W { w : self } }
# [ doc = "Bit 4 - HMATRIXHS AHB Clock Mask" ] # [ inline ( always ) ] pub fn hmatrixhs_ ( & mut self ) -> HMATRIXHS__W { HMATRIXHS__W { w : self } }
# [ doc = "Bit 5 - NVMCTRL AHB Clock Mask" ] # [ inline ( always ) ] pub fn nvmctrl_ ( & mut self ) -> NVMCTRL__W { NVMCTRL__W { w : self } }
# [ doc = "Bit 6 - HSRAM AHB Clock Mask" ] # [ inline ( always ) ] pub fn hsram_ ( & mut self ) -> HSRAM__W { HSRAM__W { w : self } }
# [ doc = "Bit 7 - DMAC AHB Clock Mask" ] # [ inline ( always ) ] pub fn dmac_ ( & mut self ) -> DMAC__W { DMAC__W { w : self } }
# [ doc = "Bit 8 - CAN0 AHB Clock Mask" ] # [ inline ( always ) ] pub fn can0_ ( & mut self ) -> CAN0__W { CAN0__W { w : self } }
# [ doc = "Bit 9 - CAN1 AHB Clock Mask" ] # [ inline ( always ) ] pub fn can1_ ( & mut self ) -> CAN1__W { CAN1__W { w : self } }
# [ doc = "Bit 10 - PAC AHB Clock Mask" ] # [ inline ( always ) ] pub fn pac_ ( & mut self ) -> PAC__W { PAC__W { w : self } }
# [ doc = "Bit 11 - NVMCTRL_PICACHU AHB Clock Mask" ] # [ inline ( always ) ] pub fn nvmctrl_picachu_ ( & mut self ) -> NVMCTRL_PICACHU__W { NVMCTRL_PICACHU__W { w : self } }
# [ doc = "Bit 12 - DIVAS AHB Clock Mask" ] # [ inline ( always ) ] pub fn divas_ ( & mut self ) -> DIVAS__W { DIVAS__W { w : self } }
# [ doc = "Bit 13 - HPB3 AHB Clock Mask" ] # [ inline ( always ) ] pub fn hpb3_ ( & mut self ) -> HPB3__W { HPB3__W { w : self } }
}
}
# [ doc = "APBA Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [apbamask](apbamask) module" ] pub type APBAMASK = crate :: Reg < u32 , _APBAMASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _APBAMASK ;
# [ doc = "`read()` method returns [apbamask::R](apbamask::R) reader structure" ] impl crate :: Readable for APBAMASK { }
# [ doc = "`write(|w| ..)` method takes [apbamask::W](apbamask::W) writer structure" ] impl crate :: Writable for APBAMASK { }
# [ doc = "APBA Mask" ] pub mod apbamask {
# [ doc = "Reader of register APBAMASK" ] pub type R = crate :: R < u32 , super :: APBAMASK > ;
# [ doc = "Writer for register APBAMASK" ] pub type W = crate :: W < u32 , super :: APBAMASK > ;
# [ doc = "Register APBAMASK `reset()`'s with value 0x0fff" ] impl crate :: ResetValue for super :: APBAMASK { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x0fff } }
# [ doc = "Reader of field `PAC_`" ] pub type PAC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PAC_`" ] pub struct PAC__W < 'a > { w : & 'a mut W , } impl < 'a > PAC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `PM_`" ] pub type PM__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PM_`" ] pub struct PM__W < 'a > { w : & 'a mut W , } impl < 'a > PM__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `MCLK_`" ] pub type MCLK__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCLK_`" ] pub struct MCLK__W < 'a > { w : & 'a mut W , } impl < 'a > MCLK__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `RSTC_`" ] pub type RSTC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RSTC_`" ] pub struct RSTC__W < 'a > { w : & 'a mut W , } impl < 'a > RSTC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `OSCCTRL_`" ] pub type OSCCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSCCTRL_`" ] pub struct OSCCTRL__W < 'a > { w : & 'a mut W , } impl < 'a > OSCCTRL__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `OSC32KCTRL_`" ] pub type OSC32KCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSC32KCTRL_`" ] pub struct OSC32KCTRL__W < 'a > { w : & 'a mut W , } impl < 'a > OSC32KCTRL__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `SUPC_`" ] pub type SUPC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SUPC_`" ] pub struct SUPC__W < 'a > { w : & 'a mut W , } impl < 'a > SUPC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `GCLK_`" ] pub type GCLK__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `GCLK_`" ] pub struct GCLK__W < 'a > { w : & 'a mut W , } impl < 'a > GCLK__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `WDT_`" ] pub type WDT__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WDT_`" ] pub struct WDT__W < 'a > { w : & 'a mut W , } impl < 'a > WDT__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `RTC_`" ] pub type RTC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RTC_`" ] pub struct RTC__W < 'a > { w : & 'a mut W , } impl < 'a > RTC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `EIC_`" ] pub type EIC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EIC_`" ] pub struct EIC__W < 'a > { w : & 'a mut W , } impl < 'a > EIC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `FREQM_`" ] pub type FREQM__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FREQM_`" ] pub struct FREQM__W < 'a > { w : & 'a mut W , } impl < 'a > FREQM__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `TSENS_`" ] pub type TSENS__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TSENS_`" ] pub struct TSENS__W < 'a > { w : & 'a mut W , } impl < 'a > TSENS__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - PAC APB Clock Enable" ] # [ inline ( always ) ] pub fn pac_ ( & self ) -> PAC__R { PAC__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - PM APB Clock Enable" ] # [ inline ( always ) ] pub fn pm_ ( & self ) -> PM__R { PM__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - MCLK APB Clock Enable" ] # [ inline ( always ) ] pub fn mclk_ ( & self ) -> MCLK__R { MCLK__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - RSTC APB Clock Enable" ] # [ inline ( always ) ] pub fn rstc_ ( & self ) -> RSTC__R { RSTC__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - OSCCTRL APB Clock Enable" ] # [ inline ( always ) ] pub fn oscctrl_ ( & self ) -> OSCCTRL__R { OSCCTRL__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - OSC32KCTRL APB Clock Enable" ] # [ inline ( always ) ] pub fn osc32kctrl_ ( & self ) -> OSC32KCTRL__R { OSC32KCTRL__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SUPC APB Clock Enable" ] # [ inline ( always ) ] pub fn supc_ ( & self ) -> SUPC__R { SUPC__R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - GCLK APB Clock Enable" ] # [ inline ( always ) ] pub fn gclk_ ( & self ) -> GCLK__R { GCLK__R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - WDT APB Clock Enable" ] # [ inline ( always ) ] pub fn wdt_ ( & self ) -> WDT__R { WDT__R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - RTC APB Clock Enable" ] # [ inline ( always ) ] pub fn rtc_ ( & self ) -> RTC__R { RTC__R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - EIC APB Clock Enable" ] # [ inline ( always ) ] pub fn eic_ ( & self ) -> EIC__R { EIC__R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - FREQM APB Clock Enable" ] # [ inline ( always ) ] pub fn freqm_ ( & self ) -> FREQM__R { FREQM__R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - TSENS APB Clock Enable" ] # [ inline ( always ) ] pub fn tsens_ ( & self ) -> TSENS__R { TSENS__R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - PAC APB Clock Enable" ] # [ inline ( always ) ] pub fn pac_ ( & mut self ) -> PAC__W { PAC__W { w : self } }
# [ doc = "Bit 1 - PM APB Clock Enable" ] # [ inline ( always ) ] pub fn pm_ ( & mut self ) -> PM__W { PM__W { w : self } }
# [ doc = "Bit 2 - MCLK APB Clock Enable" ] # [ inline ( always ) ] pub fn mclk_ ( & mut self ) -> MCLK__W { MCLK__W { w : self } }
# [ doc = "Bit 3 - RSTC APB Clock Enable" ] # [ inline ( always ) ] pub fn rstc_ ( & mut self ) -> RSTC__W { RSTC__W { w : self } }
# [ doc = "Bit 4 - OSCCTRL APB Clock Enable" ] # [ inline ( always ) ] pub fn oscctrl_ ( & mut self ) -> OSCCTRL__W { OSCCTRL__W { w : self } }
# [ doc = "Bit 5 - OSC32KCTRL APB Clock Enable" ] # [ inline ( always ) ] pub fn osc32kctrl_ ( & mut self ) -> OSC32KCTRL__W { OSC32KCTRL__W { w : self } }
# [ doc = "Bit 6 - SUPC APB Clock Enable" ] # [ inline ( always ) ] pub fn supc_ ( & mut self ) -> SUPC__W { SUPC__W { w : self } }
# [ doc = "Bit 7 - GCLK APB Clock Enable" ] # [ inline ( always ) ] pub fn gclk_ ( & mut self ) -> GCLK__W { GCLK__W { w : self } }
# [ doc = "Bit 8 - WDT APB Clock Enable" ] # [ inline ( always ) ] pub fn wdt_ ( & mut self ) -> WDT__W { WDT__W { w : self } }
# [ doc = "Bit 9 - RTC APB Clock Enable" ] # [ inline ( always ) ] pub fn rtc_ ( & mut self ) -> RTC__W { RTC__W { w : self } }
# [ doc = "Bit 10 - EIC APB Clock Enable" ] # [ inline ( always ) ] pub fn eic_ ( & mut self ) -> EIC__W { EIC__W { w : self } }
# [ doc = "Bit 11 - FREQM APB Clock Enable" ] # [ inline ( always ) ] pub fn freqm_ ( & mut self ) -> FREQM__W { FREQM__W { w : self } }
# [ doc = "Bit 12 - TSENS APB Clock Enable" ] # [ inline ( always ) ] pub fn tsens_ ( & mut self ) -> TSENS__W { TSENS__W { w : self } }
}
}
# [ doc = "APBB Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [apbbmask](apbbmask) module" ] pub type APBBMASK = crate :: Reg < u32 , _APBBMASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _APBBMASK ;
# [ doc = "`read()` method returns [apbbmask::R](apbbmask::R) reader structure" ] impl crate :: Readable for APBBMASK { }
# [ doc = "`write(|w| ..)` method takes [apbbmask::W](apbbmask::W) writer structure" ] impl crate :: Writable for APBBMASK { }
# [ doc = "APBB Mask" ] pub mod apbbmask {
# [ doc = "Reader of register APBBMASK" ] pub type R = crate :: R < u32 , super :: APBBMASK > ;
# [ doc = "Writer for register APBBMASK" ] pub type W = crate :: W < u32 , super :: APBBMASK > ;
# [ doc = "Register APBBMASK `reset()`'s with value 0x07" ] impl crate :: ResetValue for super :: APBBMASK { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x07 } }
# [ doc = "Reader of field `PORT_`" ] pub type PORT__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PORT_`" ] pub struct PORT__W < 'a > { w : & 'a mut W , } impl < 'a > PORT__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `DSU_`" ] pub type DSU__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DSU_`" ] pub struct DSU__W < 'a > { w : & 'a mut W , } impl < 'a > DSU__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `NVMCTRL_`" ] pub type NVMCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NVMCTRL_`" ] pub struct NVMCTRL__W < 'a > { w : & 'a mut W , } impl < 'a > NVMCTRL__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `HMATRIXHS_`" ] pub type HMATRIXHS__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HMATRIXHS_`" ] pub struct HMATRIXHS__W < 'a > { w : & 'a mut W , } impl < 'a > HMATRIXHS__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - PORT APB Clock Enable" ] # [ inline ( always ) ] pub fn port_ ( & self ) -> PORT__R { PORT__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - DSU APB Clock Enable" ] # [ inline ( always ) ] pub fn dsu_ ( & self ) -> DSU__R { DSU__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - NVMCTRL APB Clock Enable" ] # [ inline ( always ) ] pub fn nvmctrl_ ( & self ) -> NVMCTRL__R { NVMCTRL__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - HMATRIXHS APB Clock Enable" ] # [ inline ( always ) ] pub fn hmatrixhs_ ( & self ) -> HMATRIXHS__R { HMATRIXHS__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - PORT APB Clock Enable" ] # [ inline ( always ) ] pub fn port_ ( & mut self ) -> PORT__W { PORT__W { w : self } }
# [ doc = "Bit 1 - DSU APB Clock Enable" ] # [ inline ( always ) ] pub fn dsu_ ( & mut self ) -> DSU__W { DSU__W { w : self } }
# [ doc = "Bit 2 - NVMCTRL APB Clock Enable" ] # [ inline ( always ) ] pub fn nvmctrl_ ( & mut self ) -> NVMCTRL__W { NVMCTRL__W { w : self } }
# [ doc = "Bit 5 - HMATRIXHS APB Clock Enable" ] # [ inline ( always ) ] pub fn hmatrixhs_ ( & mut self ) -> HMATRIXHS__W { HMATRIXHS__W { w : self } }
}
}
# [ doc = "APBC Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [apbcmask](apbcmask) module" ] pub type APBCMASK = crate :: Reg < u32 , _APBCMASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _APBCMASK ;
# [ doc = "`read()` method returns [apbcmask::R](apbcmask::R) reader structure" ] impl crate :: Readable for APBCMASK { }
# [ doc = "`write(|w| ..)` method takes [apbcmask::W](apbcmask::W) writer structure" ] impl crate :: Writable for APBCMASK { }
# [ doc = "APBC Mask" ] pub mod apbcmask {
# [ doc = "Reader of register APBCMASK" ] pub type R = crate :: R < u32 , super :: APBCMASK > ;
# [ doc = "Writer for register APBCMASK" ] pub type W = crate :: W < u32 , super :: APBCMASK > ;
# [ doc = "Register APBCMASK `reset()`'s with value 0" ] impl crate :: ResetValue for super :: APBCMASK { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EVSYS_`" ] pub type EVSYS__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVSYS_`" ] pub struct EVSYS__W < 'a > { w : & 'a mut W , } impl < 'a > EVSYS__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `SERCOM0_`" ] pub type SERCOM0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM0_`" ] pub struct SERCOM0__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `SERCOM1_`" ] pub type SERCOM1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM1_`" ] pub struct SERCOM1__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `SERCOM2_`" ] pub type SERCOM2__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM2_`" ] pub struct SERCOM2__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM2__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `SERCOM3_`" ] pub type SERCOM3__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM3_`" ] pub struct SERCOM3__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM3__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `SERCOM4_`" ] pub type SERCOM4__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM4_`" ] pub struct SERCOM4__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM4__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `SERCOM5_`" ] pub type SERCOM5__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM5_`" ] pub struct SERCOM5__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM5__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `TCC0_`" ] pub type TCC0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCC0_`" ] pub struct TCC0__W < 'a > { w : & 'a mut W , } impl < 'a > TCC0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `TCC1_`" ] pub type TCC1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCC1_`" ] pub struct TCC1__W < 'a > { w : & 'a mut W , } impl < 'a > TCC1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `TCC2_`" ] pub type TCC2__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCC2_`" ] pub struct TCC2__W < 'a > { w : & 'a mut W , } impl < 'a > TCC2__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `TC0_`" ] pub type TC0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC0_`" ] pub struct TC0__W < 'a > { w : & 'a mut W , } impl < 'a > TC0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `TC1_`" ] pub type TC1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC1_`" ] pub struct TC1__W < 'a > { w : & 'a mut W , } impl < 'a > TC1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `TC2_`" ] pub type TC2__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC2_`" ] pub struct TC2__W < 'a > { w : & 'a mut W , } impl < 'a > TC2__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `TC3_`" ] pub type TC3__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC3_`" ] pub struct TC3__W < 'a > { w : & 'a mut W , } impl < 'a > TC3__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `TC4_`" ] pub type TC4__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC4_`" ] pub struct TC4__W < 'a > { w : & 'a mut W , } impl < 'a > TC4__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `ADC0_`" ] pub type ADC0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ADC0_`" ] pub struct ADC0__W < 'a > { w : & 'a mut W , } impl < 'a > ADC0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `ADC1_`" ] pub type ADC1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ADC1_`" ] pub struct ADC1__W < 'a > { w : & 'a mut W , } impl < 'a > ADC1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `SDADC_`" ] pub type SDADC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SDADC_`" ] pub struct SDADC__W < 'a > { w : & 'a mut W , } impl < 'a > SDADC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `AC_`" ] pub type AC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AC_`" ] pub struct AC__W < 'a > { w : & 'a mut W , } impl < 'a > AC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `DAC_`" ] pub type DAC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DAC_`" ] pub struct DAC__W < 'a > { w : & 'a mut W , } impl < 'a > DAC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `PTC_`" ] pub type PTC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PTC_`" ] pub struct PTC__W < 'a > { w : & 'a mut W , } impl < 'a > PTC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `CCL_`" ] pub type CCL__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CCL_`" ] pub struct CCL__W < 'a > { w : & 'a mut W , } impl < 'a > CCL__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - EVSYS APB Clock Enable" ] # [ inline ( always ) ] pub fn evsys_ ( & self ) -> EVSYS__R { EVSYS__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SERCOM0 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom0_ ( & self ) -> SERCOM0__R { SERCOM0__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SERCOM1 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom1_ ( & self ) -> SERCOM1__R { SERCOM1__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - SERCOM2 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom2_ ( & self ) -> SERCOM2__R { SERCOM2__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - SERCOM3 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom3_ ( & self ) -> SERCOM3__R { SERCOM3__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - SERCOM4 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom4_ ( & self ) -> SERCOM4__R { SERCOM4__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SERCOM5 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom5_ ( & self ) -> SERCOM5__R { SERCOM5__R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - TCC0 APB Clock Enable" ] # [ inline ( always ) ] pub fn tcc0_ ( & self ) -> TCC0__R { TCC0__R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - TCC1 APB Clock Enable" ] # [ inline ( always ) ] pub fn tcc1_ ( & self ) -> TCC1__R { TCC1__R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - TCC2 APB Clock Enable" ] # [ inline ( always ) ] pub fn tcc2_ ( & self ) -> TCC2__R { TCC2__R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - TC0 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc0_ ( & self ) -> TC0__R { TC0__R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - TC1 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc1_ ( & self ) -> TC1__R { TC1__R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - TC2 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc2_ ( & self ) -> TC2__R { TC2__R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - TC3 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc3_ ( & self ) -> TC3__R { TC3__R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - TC4 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc4_ ( & self ) -> TC4__R { TC4__R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - ADC0 APB Clock Enable" ] # [ inline ( always ) ] pub fn adc0_ ( & self ) -> ADC0__R { ADC0__R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - ADC1 APB Clock Enable" ] # [ inline ( always ) ] pub fn adc1_ ( & self ) -> ADC1__R { ADC1__R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - SDADC APB Clock Enable" ] # [ inline ( always ) ] pub fn sdadc_ ( & self ) -> SDADC__R { SDADC__R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - AC APB Clock Enable" ] # [ inline ( always ) ] pub fn ac_ ( & self ) -> AC__R { AC__R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - DAC APB Clock Enable" ] # [ inline ( always ) ] pub fn dac_ ( & self ) -> DAC__R { DAC__R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - PTC APB Clock Enable" ] # [ inline ( always ) ] pub fn ptc_ ( & self ) -> PTC__R { PTC__R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - CCL APB Clock Enable" ] # [ inline ( always ) ] pub fn ccl_ ( & self ) -> CCL__R { CCL__R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - EVSYS APB Clock Enable" ] # [ inline ( always ) ] pub fn evsys_ ( & mut self ) -> EVSYS__W { EVSYS__W { w : self } }
# [ doc = "Bit 1 - SERCOM0 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom0_ ( & mut self ) -> SERCOM0__W { SERCOM0__W { w : self } }
# [ doc = "Bit 2 - SERCOM1 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom1_ ( & mut self ) -> SERCOM1__W { SERCOM1__W { w : self } }
# [ doc = "Bit 3 - SERCOM2 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom2_ ( & mut self ) -> SERCOM2__W { SERCOM2__W { w : self } }
# [ doc = "Bit 4 - SERCOM3 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom3_ ( & mut self ) -> SERCOM3__W { SERCOM3__W { w : self } }
# [ doc = "Bit 5 - SERCOM4 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom4_ ( & mut self ) -> SERCOM4__W { SERCOM4__W { w : self } }
# [ doc = "Bit 6 - SERCOM5 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom5_ ( & mut self ) -> SERCOM5__W { SERCOM5__W { w : self } }
# [ doc = "Bit 9 - TCC0 APB Clock Enable" ] # [ inline ( always ) ] pub fn tcc0_ ( & mut self ) -> TCC0__W { TCC0__W { w : self } }
# [ doc = "Bit 10 - TCC1 APB Clock Enable" ] # [ inline ( always ) ] pub fn tcc1_ ( & mut self ) -> TCC1__W { TCC1__W { w : self } }
# [ doc = "Bit 11 - TCC2 APB Clock Enable" ] # [ inline ( always ) ] pub fn tcc2_ ( & mut self ) -> TCC2__W { TCC2__W { w : self } }
# [ doc = "Bit 12 - TC0 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc0_ ( & mut self ) -> TC0__W { TC0__W { w : self } }
# [ doc = "Bit 13 - TC1 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc1_ ( & mut self ) -> TC1__W { TC1__W { w : self } }
# [ doc = "Bit 14 - TC2 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc2_ ( & mut self ) -> TC2__W { TC2__W { w : self } }
# [ doc = "Bit 15 - TC3 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc3_ ( & mut self ) -> TC3__W { TC3__W { w : self } }
# [ doc = "Bit 16 - TC4 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc4_ ( & mut self ) -> TC4__W { TC4__W { w : self } }
# [ doc = "Bit 17 - ADC0 APB Clock Enable" ] # [ inline ( always ) ] pub fn adc0_ ( & mut self ) -> ADC0__W { ADC0__W { w : self } }
# [ doc = "Bit 18 - ADC1 APB Clock Enable" ] # [ inline ( always ) ] pub fn adc1_ ( & mut self ) -> ADC1__W { ADC1__W { w : self } }
# [ doc = "Bit 19 - SDADC APB Clock Enable" ] # [ inline ( always ) ] pub fn sdadc_ ( & mut self ) -> SDADC__W { SDADC__W { w : self } }
# [ doc = "Bit 20 - AC APB Clock Enable" ] # [ inline ( always ) ] pub fn ac_ ( & mut self ) -> AC__W { AC__W { w : self } }
# [ doc = "Bit 21 - DAC APB Clock Enable" ] # [ inline ( always ) ] pub fn dac_ ( & mut self ) -> DAC__W { DAC__W { w : self } }
# [ doc = "Bit 22 - PTC APB Clock Enable" ] # [ inline ( always ) ] pub fn ptc_ ( & mut self ) -> PTC__W { PTC__W { w : self } }
# [ doc = "Bit 23 - CCL APB Clock Enable" ] # [ inline ( always ) ] pub fn ccl_ ( & mut self ) -> CCL__W { CCL__W { w : self } }
}
}
# [ doc = "APBD Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [apbdmask](apbdmask) module" ] pub type APBDMASK = crate :: Reg < u32 , _APBDMASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _APBDMASK ;
# [ doc = "`read()` method returns [apbdmask::R](apbdmask::R) reader structure" ] impl crate :: Readable for APBDMASK { }
# [ doc = "`write(|w| ..)` method takes [apbdmask::W](apbdmask::W) writer structure" ] impl crate :: Writable for APBDMASK { }
# [ doc = "APBD Mask" ] pub mod apbdmask {
# [ doc = "Reader of register APBDMASK" ] pub type R = crate :: R < u32 , super :: APBDMASK > ;
# [ doc = "Writer for register APBDMASK" ] pub type W = crate :: W < u32 , super :: APBDMASK > ;
# [ doc = "Register APBDMASK `reset()`'s with value 0" ] impl crate :: ResetValue for super :: APBDMASK { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SERCOM6_`" ] pub type SERCOM6__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM6_`" ] pub struct SERCOM6__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM6__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `SERCOM7_`" ] pub type SERCOM7__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM7_`" ] pub struct SERCOM7__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM7__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TC5_`" ] pub type TC5__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC5_`" ] pub struct TC5__W < 'a > { w : & 'a mut W , } impl < 'a > TC5__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `TC6_`" ] pub type TC6__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC6_`" ] pub struct TC6__W < 'a > { w : & 'a mut W , } impl < 'a > TC6__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `TC7_`" ] pub type TC7__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC7_`" ] pub struct TC7__W < 'a > { w : & 'a mut W , } impl < 'a > TC7__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SERCOM6 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom6_ ( & self ) -> SERCOM6__R { SERCOM6__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SERCOM7 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom7_ ( & self ) -> SERCOM7__R { SERCOM7__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TC5 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc5_ ( & self ) -> TC5__R { TC5__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - TC6 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc6_ ( & self ) -> TC6__R { TC6__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - TC7 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc7_ ( & self ) -> TC7__R { TC7__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SERCOM6 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom6_ ( & mut self ) -> SERCOM6__W { SERCOM6__W { w : self } }
# [ doc = "Bit 1 - SERCOM7 APB Clock Enable" ] # [ inline ( always ) ] pub fn sercom7_ ( & mut self ) -> SERCOM7__W { SERCOM7__W { w : self } }
# [ doc = "Bit 2 - TC5 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc5_ ( & mut self ) -> TC5__W { TC5__W { w : self } }
# [ doc = "Bit 3 - TC6 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc6_ ( & mut self ) -> TC6__W { TC6__W { w : self } }
# [ doc = "Bit 4 - TC7 APB Clock Enable" ] # [ inline ( always ) ] pub fn tc7_ ( & mut self ) -> TC7__W { TC7__W { w : self } }
}
}
}
# [ doc = "Cortex-M0+ Micro-Trace Buffer" ] pub struct MTB { _marker : PhantomData < * const ( ) > } unsafe impl Send for MTB { } impl MTB { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const mtb :: RegisterBlock { 0x4100_8000 as * const _ } } impl Deref for MTB { type Target = mtb :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * MTB :: ptr ( ) } } }
# [ doc = "Cortex-M0+ Micro-Trace Buffer" ] pub mod mtb {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - MTB Position" ] pub position : POSITION , # [ doc = "0x04 - MTB Master" ] pub master : MASTER , # [ doc = "0x08 - MTB Flow" ] pub flow : FLOW , # [ doc = "0x0c - MTB Base" ] pub base : BASE , _reserved4 : [ u8 ; 3824usize ] , # [ doc = "0xf00 - MTB Integration Mode Control" ] pub itctrl : ITCTRL , _reserved5 : [ u8 ; 156usize ] , # [ doc = "0xfa0 - MTB Claim Set" ] pub claimset : CLAIMSET , # [ doc = "0xfa4 - MTB Claim Clear" ] pub claimclr : CLAIMCLR , _reserved7 : [ u8 ; 8usize ] , # [ doc = "0xfb0 - MTB Lock Access" ] pub lockaccess : LOCKACCESS , # [ doc = "0xfb4 - MTB Lock Status" ] pub lockstatus : LOCKSTATUS , # [ doc = "0xfb8 - MTB Authentication Status" ] pub authstatus : AUTHSTATUS , # [ doc = "0xfbc - MTB Device Architecture" ] pub devarch : DEVARCH , _reserved11 : [ u8 ; 8usize ] , # [ doc = "0xfc8 - MTB Device Configuration" ] pub devid : DEVID , # [ doc = "0xfcc - MTB Device Type" ] pub devtype : DEVTYPE , # [ doc = "0xfd0 - Peripheral Identification 4" ] pub pid4 : PID4 , # [ doc = "0xfd4 - Peripheral Identification 5" ] pub pid5 : PID5 , # [ doc = "0xfd8 - Peripheral Identification 6" ] pub pid6 : PID6 , # [ doc = "0xfdc - Peripheral Identification 7" ] pub pid7 : PID7 , # [ doc = "0xfe0 - Peripheral Identification 0" ] pub pid0 : PID0 , # [ doc = "0xfe4 - Peripheral Identification 1" ] pub pid1 : PID1 , # [ doc = "0xfe8 - Peripheral Identification 2" ] pub pid2 : PID2 , # [ doc = "0xfec - Peripheral Identification 3" ] pub pid3 : PID3 , # [ doc = "0xff0 - Component Identification 0" ] pub cid0 : CID0 , # [ doc = "0xff4 - Component Identification 1" ] pub cid1 : CID1 , # [ doc = "0xff8 - Component Identification 2" ] pub cid2 : CID2 , # [ doc = "0xffc - Component Identification 3" ] pub cid3 : CID3 , }
# [ doc = "MTB Position\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [position](position) module" ] pub type POSITION = crate :: Reg < u32 , _POSITION > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _POSITION ;
# [ doc = "`read()` method returns [position::R](position::R) reader structure" ] impl crate :: Readable for POSITION { }
# [ doc = "`write(|w| ..)` method takes [position::W](position::W) writer structure" ] impl crate :: Writable for POSITION { }
# [ doc = "MTB Position" ] pub mod position {
# [ doc = "Reader of register POSITION" ] pub type R = crate :: R < u32 , super :: POSITION > ;
# [ doc = "Writer for register POSITION" ] pub type W = crate :: W < u32 , super :: POSITION > ;
# [ doc = "Register POSITION `reset()`'s with value 0" ] impl crate :: ResetValue for super :: POSITION { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WRAP`" ] pub type WRAP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WRAP`" ] pub struct WRAP_W < 'a > { w : & 'a mut W , } impl < 'a > WRAP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `POINTER`" ] pub type POINTER_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `POINTER`" ] pub struct POINTER_W < 'a > { w : & 'a mut W , } impl < 'a > POINTER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1fff_ffff << 3 ) ) | ( ( ( value as u32 ) & 0x1fff_ffff ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 2 - Pointer Value Wraps" ] # [ inline ( always ) ] pub fn wrap ( & self ) -> WRAP_R { WRAP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 3:31 - Trace Packet Location Pointer" ] # [ inline ( always ) ] pub fn pointer ( & self ) -> POINTER_R { POINTER_R :: new ( ( ( self . bits >> 3 ) & 0x1fff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bit 2 - Pointer Value Wraps" ] # [ inline ( always ) ] pub fn wrap ( & mut self ) -> WRAP_W { WRAP_W { w : self } }
# [ doc = "Bits 3:31 - Trace Packet Location Pointer" ] # [ inline ( always ) ] pub fn pointer ( & mut self ) -> POINTER_W { POINTER_W { w : self } }
}
}
# [ doc = "MTB Master\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [master](master) module" ] pub type MASTER = crate :: Reg < u32 , _MASTER > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MASTER ;
# [ doc = "`read()` method returns [master::R](master::R) reader structure" ] impl crate :: Readable for MASTER { }
# [ doc = "`write(|w| ..)` method takes [master::W](master::W) writer structure" ] impl crate :: Writable for MASTER { }
# [ doc = "MTB Master" ] pub mod master {
# [ doc = "Reader of register MASTER" ] pub type R = crate :: R < u32 , super :: MASTER > ;
# [ doc = "Writer for register MASTER" ] pub type W = crate :: W < u32 , super :: MASTER > ;
# [ doc = "Register MASTER `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MASTER { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `MASK`" ] pub type MASK_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `MASK`" ] pub struct MASK_W < 'a > { w : & 'a mut W , } impl < 'a > MASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u32 ) & 0x1f ) ; self . w } }
# [ doc = "Reader of field `TSTARTEN`" ] pub type TSTARTEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TSTARTEN`" ] pub struct TSTARTEN_W < 'a > { w : & 'a mut W , } impl < 'a > TSTARTEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `TSTOPEN`" ] pub type TSTOPEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TSTOPEN`" ] pub struct TSTOPEN_W < 'a > { w : & 'a mut W , } impl < 'a > TSTOPEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `SFRWPRIV`" ] pub type SFRWPRIV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SFRWPRIV`" ] pub struct SFRWPRIV_W < 'a > { w : & 'a mut W , } impl < 'a > SFRWPRIV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `RAMPRIV`" ] pub type RAMPRIV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RAMPRIV`" ] pub struct RAMPRIV_W < 'a > { w : & 'a mut W , } impl < 'a > RAMPRIV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `HALTREQ`" ] pub type HALTREQ_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HALTREQ`" ] pub struct HALTREQ_W < 'a > { w : & 'a mut W , } impl < 'a > HALTREQ_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `EN`" ] pub type EN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EN`" ] pub struct EN_W < 'a > { w : & 'a mut W , } impl < 'a > EN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bits 0:4 - Maximum Value of the Trace Buffer in SRAM" ] # [ inline ( always ) ] pub fn mask ( & self ) -> MASK_R { MASK_R :: new ( ( self . bits & 0x1f ) as u8 ) }
# [ doc = "Bit 5 - Trace Start Input Enable" ] # [ inline ( always ) ] pub fn tstarten ( & self ) -> TSTARTEN_R { TSTARTEN_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Trace Stop Input Enable" ] # [ inline ( always ) ] pub fn tstopen ( & self ) -> TSTOPEN_R { TSTOPEN_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Special Function Register Write Privilege" ] # [ inline ( always ) ] pub fn sfrwpriv ( & self ) -> SFRWPRIV_R { SFRWPRIV_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - SRAM Privilege" ] # [ inline ( always ) ] pub fn rampriv ( & self ) -> RAMPRIV_R { RAMPRIV_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Halt Request" ] # [ inline ( always ) ] pub fn haltreq ( & self ) -> HALTREQ_R { HALTREQ_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - Main Trace Enable" ] # [ inline ( always ) ] pub fn en ( & self ) -> EN_R { EN_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:4 - Maximum Value of the Trace Buffer in SRAM" ] # [ inline ( always ) ] pub fn mask ( & mut self ) -> MASK_W { MASK_W { w : self } }
# [ doc = "Bit 5 - Trace Start Input Enable" ] # [ inline ( always ) ] pub fn tstarten ( & mut self ) -> TSTARTEN_W { TSTARTEN_W { w : self } }
# [ doc = "Bit 6 - Trace Stop Input Enable" ] # [ inline ( always ) ] pub fn tstopen ( & mut self ) -> TSTOPEN_W { TSTOPEN_W { w : self } }
# [ doc = "Bit 7 - Special Function Register Write Privilege" ] # [ inline ( always ) ] pub fn sfrwpriv ( & mut self ) -> SFRWPRIV_W { SFRWPRIV_W { w : self } }
# [ doc = "Bit 8 - SRAM Privilege" ] # [ inline ( always ) ] pub fn rampriv ( & mut self ) -> RAMPRIV_W { RAMPRIV_W { w : self } }
# [ doc = "Bit 9 - Halt Request" ] # [ inline ( always ) ] pub fn haltreq ( & mut self ) -> HALTREQ_W { HALTREQ_W { w : self } }
# [ doc = "Bit 31 - Main Trace Enable" ] # [ inline ( always ) ] pub fn en ( & mut self ) -> EN_W { EN_W { w : self } }
}
}
# [ doc = "MTB Flow\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [flow](flow) module" ] pub type FLOW = crate :: Reg < u32 , _FLOW > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _FLOW ;
# [ doc = "`read()` method returns [flow::R](flow::R) reader structure" ] impl crate :: Readable for FLOW { }
# [ doc = "`write(|w| ..)` method takes [flow::W](flow::W) writer structure" ] impl crate :: Writable for FLOW { }
# [ doc = "MTB Flow" ] pub mod flow {
# [ doc = "Reader of register FLOW" ] pub type R = crate :: R < u32 , super :: FLOW > ;
# [ doc = "Writer for register FLOW" ] pub type W = crate :: W < u32 , super :: FLOW > ;
# [ doc = "Register FLOW `reset()`'s with value 0" ] impl crate :: ResetValue for super :: FLOW { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `AUTOSTOP`" ] pub type AUTOSTOP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AUTOSTOP`" ] pub struct AUTOSTOP_W < 'a > { w : & 'a mut W , } impl < 'a > AUTOSTOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `AUTOHALT`" ] pub type AUTOHALT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AUTOHALT`" ] pub struct AUTOHALT_W < 'a > { w : & 'a mut W , } impl < 'a > AUTOHALT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WATERMARK`" ] pub type WATERMARK_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `WATERMARK`" ] pub struct WATERMARK_W < 'a > { w : & 'a mut W , } impl < 'a > WATERMARK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1fff_ffff << 3 ) ) | ( ( ( value as u32 ) & 0x1fff_ffff ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Auto Stop Tracing" ] # [ inline ( always ) ] pub fn autostop ( & self ) -> AUTOSTOP_R { AUTOSTOP_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Auto Halt Request" ] # [ inline ( always ) ] pub fn autohalt ( & self ) -> AUTOHALT_R { AUTOHALT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 3:31 - Watermark value" ] # [ inline ( always ) ] pub fn watermark ( & self ) -> WATERMARK_R { WATERMARK_R :: new ( ( ( self . bits >> 3 ) & 0x1fff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bit 0 - Auto Stop Tracing" ] # [ inline ( always ) ] pub fn autostop ( & mut self ) -> AUTOSTOP_W { AUTOSTOP_W { w : self } }
# [ doc = "Bit 1 - Auto Halt Request" ] # [ inline ( always ) ] pub fn autohalt ( & mut self ) -> AUTOHALT_W { AUTOHALT_W { w : self } }
# [ doc = "Bits 3:31 - Watermark value" ] # [ inline ( always ) ] pub fn watermark ( & mut self ) -> WATERMARK_W { WATERMARK_W { w : self } }
}
}
# [ doc = "MTB Base\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [base](base) module" ] pub type BASE = crate :: Reg < u32 , _BASE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BASE ;
# [ doc = "`read()` method returns [base::R](base::R) reader structure" ] impl crate :: Readable for BASE { }
# [ doc = "MTB Base" ] pub mod base {
# [ doc = "Reader of register BASE" ] pub type R = crate :: R < u32 , super :: BASE > ;
impl R {
}
}
# [ doc = "MTB Integration Mode Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [itctrl](itctrl) module" ] pub type ITCTRL = crate :: Reg < u32 , _ITCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ITCTRL ;
# [ doc = "`read()` method returns [itctrl::R](itctrl::R) reader structure" ] impl crate :: Readable for ITCTRL { }
# [ doc = "`write(|w| ..)` method takes [itctrl::W](itctrl::W) writer structure" ] impl crate :: Writable for ITCTRL { }
# [ doc = "MTB Integration Mode Control" ] pub mod itctrl {
# [ doc = "Reader of register ITCTRL" ] pub type R = crate :: R < u32 , super :: ITCTRL > ;
# [ doc = "Writer for register ITCTRL" ] pub type W = crate :: W < u32 , super :: ITCTRL > ;
# [ doc = "Register ITCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ITCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "MTB Claim Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [claimset](claimset) module" ] pub type CLAIMSET = crate :: Reg < u32 , _CLAIMSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CLAIMSET ;
# [ doc = "`read()` method returns [claimset::R](claimset::R) reader structure" ] impl crate :: Readable for CLAIMSET { }
# [ doc = "`write(|w| ..)` method takes [claimset::W](claimset::W) writer structure" ] impl crate :: Writable for CLAIMSET { }
# [ doc = "MTB Claim Set" ] pub mod claimset {
# [ doc = "Reader of register CLAIMSET" ] pub type R = crate :: R < u32 , super :: CLAIMSET > ;
# [ doc = "Writer for register CLAIMSET" ] pub type W = crate :: W < u32 , super :: CLAIMSET > ;
# [ doc = "Register CLAIMSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CLAIMSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "MTB Claim Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [claimclr](claimclr) module" ] pub type CLAIMCLR = crate :: Reg < u32 , _CLAIMCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CLAIMCLR ;
# [ doc = "`read()` method returns [claimclr::R](claimclr::R) reader structure" ] impl crate :: Readable for CLAIMCLR { }
# [ doc = "`write(|w| ..)` method takes [claimclr::W](claimclr::W) writer structure" ] impl crate :: Writable for CLAIMCLR { }
# [ doc = "MTB Claim Clear" ] pub mod claimclr {
# [ doc = "Reader of register CLAIMCLR" ] pub type R = crate :: R < u32 , super :: CLAIMCLR > ;
# [ doc = "Writer for register CLAIMCLR" ] pub type W = crate :: W < u32 , super :: CLAIMCLR > ;
# [ doc = "Register CLAIMCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CLAIMCLR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "MTB Lock Access\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [lockaccess](lockaccess) module" ] pub type LOCKACCESS = crate :: Reg < u32 , _LOCKACCESS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _LOCKACCESS ;
# [ doc = "`read()` method returns [lockaccess::R](lockaccess::R) reader structure" ] impl crate :: Readable for LOCKACCESS { }
# [ doc = "`write(|w| ..)` method takes [lockaccess::W](lockaccess::W) writer structure" ] impl crate :: Writable for LOCKACCESS { }
# [ doc = "MTB Lock Access" ] pub mod lockaccess {
# [ doc = "Reader of register LOCKACCESS" ] pub type R = crate :: R < u32 , super :: LOCKACCESS > ;
# [ doc = "Writer for register LOCKACCESS" ] pub type W = crate :: W < u32 , super :: LOCKACCESS > ;
# [ doc = "Register LOCKACCESS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: LOCKACCESS { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
impl R {
}
impl W {
}
}
# [ doc = "MTB Lock Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [lockstatus](lockstatus) module" ] pub type LOCKSTATUS = crate :: Reg < u32 , _LOCKSTATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _LOCKSTATUS ;
# [ doc = "`read()` method returns [lockstatus::R](lockstatus::R) reader structure" ] impl crate :: Readable for LOCKSTATUS { }
# [ doc = "MTB Lock Status" ] pub mod lockstatus {
# [ doc = "Reader of register LOCKSTATUS" ] pub type R = crate :: R < u32 , super :: LOCKSTATUS > ;
impl R {
}
}
# [ doc = "MTB Authentication Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [authstatus](authstatus) module" ] pub type AUTHSTATUS = crate :: Reg < u32 , _AUTHSTATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _AUTHSTATUS ;
# [ doc = "`read()` method returns [authstatus::R](authstatus::R) reader structure" ] impl crate :: Readable for AUTHSTATUS { }
# [ doc = "MTB Authentication Status" ] pub mod authstatus {
# [ doc = "Reader of register AUTHSTATUS" ] pub type R = crate :: R < u32 , super :: AUTHSTATUS > ;
impl R {
}
}
# [ doc = "MTB Device Architecture\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [devarch](devarch) module" ] pub type DEVARCH = crate :: Reg < u32 , _DEVARCH > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DEVARCH ;
# [ doc = "`read()` method returns [devarch::R](devarch::R) reader structure" ] impl crate :: Readable for DEVARCH { }
# [ doc = "MTB Device Architecture" ] pub mod devarch {
# [ doc = "Reader of register DEVARCH" ] pub type R = crate :: R < u32 , super :: DEVARCH > ;
impl R {
}
}
# [ doc = "MTB Device Configuration\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [devid](devid) module" ] pub type DEVID = crate :: Reg < u32 , _DEVID > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DEVID ;
# [ doc = "`read()` method returns [devid::R](devid::R) reader structure" ] impl crate :: Readable for DEVID { }
# [ doc = "MTB Device Configuration" ] pub mod devid {
# [ doc = "Reader of register DEVID" ] pub type R = crate :: R < u32 , super :: DEVID > ;
impl R {
}
}
# [ doc = "MTB Device Type\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [devtype](devtype) module" ] pub type DEVTYPE = crate :: Reg < u32 , _DEVTYPE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DEVTYPE ;
# [ doc = "`read()` method returns [devtype::R](devtype::R) reader structure" ] impl crate :: Readable for DEVTYPE { }
# [ doc = "MTB Device Type" ] pub mod devtype {
# [ doc = "Reader of register DEVTYPE" ] pub type R = crate :: R < u32 , super :: DEVTYPE > ;
impl R {
}
}
# [ doc = "Peripheral Identification 4\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid4](pid4) module" ] pub type PID4 = crate :: Reg < u32 , _PID4 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID4 ;
# [ doc = "`read()` method returns [pid4::R](pid4::R) reader structure" ] impl crate :: Readable for PID4 { }
# [ doc = "Peripheral Identification 4" ] pub mod pid4 {
# [ doc = "Reader of register PID4" ] pub type R = crate :: R < u32 , super :: PID4 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 5\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid5](pid5) module" ] pub type PID5 = crate :: Reg < u32 , _PID5 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID5 ;
# [ doc = "`read()` method returns [pid5::R](pid5::R) reader structure" ] impl crate :: Readable for PID5 { }
# [ doc = "Peripheral Identification 5" ] pub mod pid5 {
# [ doc = "Reader of register PID5" ] pub type R = crate :: R < u32 , super :: PID5 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 6\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid6](pid6) module" ] pub type PID6 = crate :: Reg < u32 , _PID6 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID6 ;
# [ doc = "`read()` method returns [pid6::R](pid6::R) reader structure" ] impl crate :: Readable for PID6 { }
# [ doc = "Peripheral Identification 6" ] pub mod pid6 {
# [ doc = "Reader of register PID6" ] pub type R = crate :: R < u32 , super :: PID6 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 7\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid7](pid7) module" ] pub type PID7 = crate :: Reg < u32 , _PID7 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID7 ;
# [ doc = "`read()` method returns [pid7::R](pid7::R) reader structure" ] impl crate :: Readable for PID7 { }
# [ doc = "Peripheral Identification 7" ] pub mod pid7 {
# [ doc = "Reader of register PID7" ] pub type R = crate :: R < u32 , super :: PID7 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid0](pid0) module" ] pub type PID0 = crate :: Reg < u32 , _PID0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID0 ;
# [ doc = "`read()` method returns [pid0::R](pid0::R) reader structure" ] impl crate :: Readable for PID0 { }
# [ doc = "Peripheral Identification 0" ] pub mod pid0 {
# [ doc = "Reader of register PID0" ] pub type R = crate :: R < u32 , super :: PID0 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid1](pid1) module" ] pub type PID1 = crate :: Reg < u32 , _PID1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID1 ;
# [ doc = "`read()` method returns [pid1::R](pid1::R) reader structure" ] impl crate :: Readable for PID1 { }
# [ doc = "Peripheral Identification 1" ] pub mod pid1 {
# [ doc = "Reader of register PID1" ] pub type R = crate :: R < u32 , super :: PID1 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid2](pid2) module" ] pub type PID2 = crate :: Reg < u32 , _PID2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID2 ;
# [ doc = "`read()` method returns [pid2::R](pid2::R) reader structure" ] impl crate :: Readable for PID2 { }
# [ doc = "Peripheral Identification 2" ] pub mod pid2 {
# [ doc = "Reader of register PID2" ] pub type R = crate :: R < u32 , super :: PID2 > ;
impl R {
}
}
# [ doc = "Peripheral Identification 3\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pid3](pid3) module" ] pub type PID3 = crate :: Reg < u32 , _PID3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PID3 ;
# [ doc = "`read()` method returns [pid3::R](pid3::R) reader structure" ] impl crate :: Readable for PID3 { }
# [ doc = "Peripheral Identification 3" ] pub mod pid3 {
# [ doc = "Reader of register PID3" ] pub type R = crate :: R < u32 , super :: PID3 > ;
impl R {
}
}
# [ doc = "Component Identification 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cid0](cid0) module" ] pub type CID0 = crate :: Reg < u32 , _CID0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CID0 ;
# [ doc = "`read()` method returns [cid0::R](cid0::R) reader structure" ] impl crate :: Readable for CID0 { }
# [ doc = "Component Identification 0" ] pub mod cid0 {
# [ doc = "Reader of register CID0" ] pub type R = crate :: R < u32 , super :: CID0 > ;
impl R {
}
}
# [ doc = "Component Identification 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cid1](cid1) module" ] pub type CID1 = crate :: Reg < u32 , _CID1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CID1 ;
# [ doc = "`read()` method returns [cid1::R](cid1::R) reader structure" ] impl crate :: Readable for CID1 { }
# [ doc = "Component Identification 1" ] pub mod cid1 {
# [ doc = "Reader of register CID1" ] pub type R = crate :: R < u32 , super :: CID1 > ;
impl R {
}
}
# [ doc = "Component Identification 2\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cid2](cid2) module" ] pub type CID2 = crate :: Reg < u32 , _CID2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CID2 ;
# [ doc = "`read()` method returns [cid2::R](cid2::R) reader structure" ] impl crate :: Readable for CID2 { }
# [ doc = "Component Identification 2" ] pub mod cid2 {
# [ doc = "Reader of register CID2" ] pub type R = crate :: R < u32 , super :: CID2 > ;
impl R {
}
}
# [ doc = "Component Identification 3\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cid3](cid3) module" ] pub type CID3 = crate :: Reg < u32 , _CID3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CID3 ;
# [ doc = "`read()` method returns [cid3::R](cid3::R) reader structure" ] impl crate :: Readable for CID3 { }
# [ doc = "Component Identification 3" ] pub mod cid3 {
# [ doc = "Reader of register CID3" ] pub type R = crate :: R < u32 , super :: CID3 > ;
impl R {
}
}
}
# [ doc = "Non-Volatile Memory Controller" ] pub struct NVMCTRL { _marker : PhantomData < * const ( ) > } unsafe impl Send for NVMCTRL { } impl NVMCTRL { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const nvmctrl :: RegisterBlock { 0x4100_4000 as * const _ } } impl Deref for NVMCTRL { type Target = nvmctrl :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * NVMCTRL :: ptr ( ) } } }
# [ doc = "Non-Volatile Memory Controller" ] pub mod nvmctrl {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control A" ] pub ctrla : CTRLA , _reserved1 : [ u8 ; 2usize ] , # [ doc = "0x04 - Control B" ] pub ctrlb : CTRLB , # [ doc = "0x08 - NVM Parameter" ] pub param : PARAM , # [ doc = "0x0c - Interrupt Enable Clear" ] pub intenclr : INTENCLR , _reserved4 : [ u8 ; 3usize ] , # [ doc = "0x10 - Interrupt Enable Set" ] pub intenset : INTENSET , _reserved5 : [ u8 ; 3usize ] , # [ doc = "0x14 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , _reserved6 : [ u8 ; 3usize ] , # [ doc = "0x18 - Status" ] pub status : STATUS , _reserved7 : [ u8 ; 2usize ] , # [ doc = "0x1c - Address" ] pub addr : ADDR , # [ doc = "0x20 - Lock Section" ] pub lock : LOCK , _reserved9 : [ u8 ; 6usize ] , # [ doc = "0x28 - Page Buffer Load Data 0" ] pub pbldata0 : PBLDATA0 , # [ doc = "0x2c - Page Buffer Load Data 1" ] pub pbldata1 : PBLDATA1 , }
# [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u16 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control A" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u16 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u16 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "Erase Row - Erases the row addressed by the ADDR register." ] ER , # [ doc = "Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register." ] WP , # [ doc = "Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row." ] EAR , # [ doc = "Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row." ] WAP , # [ doc = "Security Flow Command" ] SF , # [ doc = "Write lockbits" ] WL , # [ doc = "RWW EEPROM area Erase Row - Erases the row addressed by the ADDR register." ] RWWEEER , # [ doc = "RWW EEPROM Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register." ] RWWEEWP , # [ doc = "Lock Region - Locks the region containing the address location in the ADDR register." ] LR , # [ doc = "Unlock Region - Unlocks the region containing the address location in the ADDR register." ] UR , # [ doc = "Sets the power reduction mode." ] SPRM , # [ doc = "Clears the power reduction mode." ] CPRM , # [ doc = "Page Buffer Clear - Clears the page buffer." ] PBC , # [ doc = "Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row." ] SSB , # [ doc = "Invalidate all cache lines." ] INVALL }
impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: ER => 2 , CMD_A :: WP => 4 , CMD_A :: EAR => 5 , CMD_A :: WAP => 6 , CMD_A :: SF => 10 , CMD_A :: WL => 15 , CMD_A :: RWWEEER => 26 , CMD_A :: RWWEEWP => 28 , CMD_A :: LR => 64 , CMD_A :: UR => 65 , CMD_A :: SPRM => 66 , CMD_A :: CPRM => 67 , CMD_A :: PBC => 68 , CMD_A :: SSB => 69 , CMD_A :: INVALL => 70 } } }
# [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 2 => Val ( CMD_A :: ER ) , 4 => Val ( CMD_A :: WP ) , 5 => Val ( CMD_A :: EAR ) , 6 => Val ( CMD_A :: WAP ) , 10 => Val ( CMD_A :: SF ) , 15 => Val ( CMD_A :: WL ) , 26 => Val ( CMD_A :: RWWEEER ) , 28 => Val ( CMD_A :: RWWEEWP ) , 64 => Val ( CMD_A :: LR ) , 65 => Val ( CMD_A :: UR ) , 66 => Val ( CMD_A :: SPRM ) , 67 => Val ( CMD_A :: CPRM ) , 68 => Val ( CMD_A :: PBC ) , 69 => Val ( CMD_A :: SSB ) , 70 => Val ( CMD_A :: INVALL ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `ER`" ] # [ inline ( always ) ] pub fn is_er ( & self ) -> bool { * self == CMD_A :: ER } # [ doc = "Checks if the value of the field is `WP`" ] # [ inline ( always ) ] pub fn is_wp ( & self ) -> bool { * self == CMD_A :: WP } # [ doc = "Checks if the value of the field is `EAR`" ] # [ inline ( always ) ] pub fn is_ear ( & self ) -> bool { * self == CMD_A :: EAR } # [ doc = "Checks if the value of the field is `WAP`" ] # [ inline ( always ) ] pub fn is_wap ( & self ) -> bool { * self == CMD_A :: WAP } # [ doc = "Checks if the value of the field is `SF`" ] # [ inline ( always ) ] pub fn is_sf ( & self ) -> bool { * self == CMD_A :: SF } # [ doc = "Checks if the value of the field is `WL`" ] # [ inline ( always ) ] pub fn is_wl ( & self ) -> bool { * self == CMD_A :: WL } # [ doc = "Checks if the value of the field is `RWWEEER`" ] # [ inline ( always ) ] pub fn is_rwweeer ( & self ) -> bool { * self == CMD_A :: RWWEEER } # [ doc = "Checks if the value of the field is `RWWEEWP`" ] # [ inline ( always ) ] pub fn is_rwweewp ( & self ) -> bool { * self == CMD_A :: RWWEEWP } # [ doc = "Checks if the value of the field is `LR`" ] # [ inline ( always ) ] pub fn is_lr ( & self ) -> bool { * self == CMD_A :: LR } # [ doc = "Checks if the value of the field is `UR`" ] # [ inline ( always ) ] pub fn is_ur ( & self ) -> bool { * self == CMD_A :: UR } # [ doc = "Checks if the value of the field is `SPRM`" ] # [ inline ( always ) ] pub fn is_sprm ( & self ) -> bool { * self == CMD_A :: SPRM } # [ doc = "Checks if the value of the field is `CPRM`" ] # [ inline ( always ) ] pub fn is_cprm ( & self ) -> bool { * self == CMD_A :: CPRM } # [ doc = "Checks if the value of the field is `PBC`" ] # [ inline ( always ) ] pub fn is_pbc ( & self ) -> bool { * self == CMD_A :: PBC } # [ doc = "Checks if the value of the field is `SSB`" ] # [ inline ( always ) ] pub fn is_ssb ( & self ) -> bool { * self == CMD_A :: SSB } # [ doc = "Checks if the value of the field is `INVALL`" ] # [ inline ( always ) ] pub fn is_invall ( & self ) -> bool { * self == CMD_A :: INVALL } }
# [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Erase Row - Erases the row addressed by the ADDR register." ] # [ inline ( always ) ] pub fn er ( self ) -> & 'a mut W { self . variant ( CMD_A :: ER ) } # [ doc = "Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register." ] # [ inline ( always ) ] pub fn wp ( self ) -> & 'a mut W { self . variant ( CMD_A :: WP ) } # [ doc = "Erase Auxiliary Row - Erases the auxiliary row addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row." ] # [ inline ( always ) ] pub fn ear ( self ) -> & 'a mut W { self . variant ( CMD_A :: EAR ) } # [ doc = "Write Auxiliary Page - Writes the contents of the page buffer to the page addressed by the ADDR register. This command can be given only when the security bit is not set and only to the user configuration row." ] # [ inline ( always ) ] pub fn wap ( self ) -> & 'a mut W { self . variant ( CMD_A :: WAP ) } # [ doc = "Security Flow Command" ] # [ inline ( always ) ] pub fn sf ( self ) -> & 'a mut W { self . variant ( CMD_A :: SF ) } # [ doc = "Write lockbits" ] # [ inline ( always ) ] pub fn wl ( self ) -> & 'a mut W { self . variant ( CMD_A :: WL ) } # [ doc = "RWW EEPROM area Erase Row - Erases the row addressed by the ADDR register." ] # [ inline ( always ) ] pub fn rwweeer ( self ) -> & 'a mut W { self . variant ( CMD_A :: RWWEEER ) } # [ doc = "RWW EEPROM Write Page - Writes the contents of the page buffer to the page addressed by the ADDR register." ] # [ inline ( always ) ] pub fn rwweewp ( self ) -> & 'a mut W { self . variant ( CMD_A :: RWWEEWP ) } # [ doc = "Lock Region - Locks the region containing the address location in the ADDR register." ] # [ inline ( always ) ] pub fn lr ( self ) -> & 'a mut W { self . variant ( CMD_A :: LR ) } # [ doc = "Unlock Region - Unlocks the region containing the address location in the ADDR register." ] # [ inline ( always ) ] pub fn ur ( self ) -> & 'a mut W { self . variant ( CMD_A :: UR ) } # [ doc = "Sets the power reduction mode." ] # [ inline ( always ) ] pub fn sprm ( self ) -> & 'a mut W { self . variant ( CMD_A :: SPRM ) } # [ doc = "Clears the power reduction mode." ] # [ inline ( always ) ] pub fn cprm ( self ) -> & 'a mut W { self . variant ( CMD_A :: CPRM ) } # [ doc = "Page Buffer Clear - Clears the page buffer." ] # [ inline ( always ) ] pub fn pbc ( self ) -> & 'a mut W { self . variant ( CMD_A :: PBC ) } # [ doc = "Set Security Bit - Sets the security bit by writing 0x00 to the first byte in the lockbit row." ] # [ inline ( always ) ] pub fn ssb ( self ) -> & 'a mut W { self . variant ( CMD_A :: SSB ) } # [ doc = "Invalidate all cache lines." ] # [ inline ( always ) ] pub fn invall ( self ) -> & 'a mut W { self . variant ( CMD_A :: INVALL ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x7f ) | ( ( value as u16 ) & 0x7f ) ; self . w } }
# [ doc = "Possible values of the field `CMDEX`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMDEX_A { # [ doc = "Execution Key" ] KEY }
impl crate :: ToBits < u8 > for CMDEX_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMDEX_A :: KEY => 165 } } }
# [ doc = "Reader of field `CMDEX`" ] pub type CMDEX_R = crate :: R < u8 , CMDEX_A > ; impl CMDEX_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMDEX_A > { use crate :: Variant :: * ; match self . bits { 165 => Val ( CMDEX_A :: KEY ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `KEY`" ] # [ inline ( always ) ] pub fn is_key ( & self ) -> bool { * self == CMDEX_A :: KEY } }
# [ doc = "Write proxy for field `CMDEX`" ] pub struct CMDEX_W < 'a > { w : & 'a mut W , } impl < 'a > CMDEX_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMDEX_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Execution Key" ] # [ inline ( always ) ] pub fn key ( self ) -> & 'a mut W { self . variant ( CMDEX_A :: KEY ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u16 ) & 0xff ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:6 - Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( self . bits & 0x7f ) as u8 ) }
# [ doc = "Bits 8:15 - Command Execution" ] # [ inline ( always ) ] pub fn cmdex ( & self ) -> CMDEX_R { CMDEX_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:6 - Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } }
# [ doc = "Bits 8:15 - Command Execution" ] # [ inline ( always ) ] pub fn cmdex ( & mut self ) -> CMDEX_W { CMDEX_W { w : self } }
}
}
# [ doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u32 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ;
# [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { }
# [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { }
# [ doc = "Control B" ] pub mod ctrlb {
# [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u32 , super :: CTRLB > ;
# [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u32 , super :: CTRLB > ;
# [ doc = "Register CTRLB `reset()`'s with value 0x80" ] impl crate :: ResetValue for super :: CTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x80 } }
# [ doc = "Possible values of the field `RWS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RWS_A { # [ doc = "Single Auto Wait State" ] SINGLE , # [ doc = "Half Auto Wait State" ] HALF , # [ doc = "Dual Auto Wait State" ] DUAL }
impl crate :: ToBits < u8 > for RWS_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { RWS_A :: SINGLE => 0 , RWS_A :: HALF => 1 , RWS_A :: DUAL => 2 } } }
# [ doc = "Reader of field `RWS`" ] pub type RWS_R = crate :: R < u8 , RWS_A > ; impl RWS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , RWS_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( RWS_A :: SINGLE ) , 1 => Val ( RWS_A :: HALF ) , 2 => Val ( RWS_A :: DUAL ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SINGLE`" ] # [ inline ( always ) ] pub fn is_single ( & self ) -> bool { * self == RWS_A :: SINGLE } # [ doc = "Checks if the value of the field is `HALF`" ] # [ inline ( always ) ] pub fn is_half ( & self ) -> bool { * self == RWS_A :: HALF } # [ doc = "Checks if the value of the field is `DUAL`" ] # [ inline ( always ) ] pub fn is_dual ( & self ) -> bool { * self == RWS_A :: DUAL } }
# [ doc = "Write proxy for field `RWS`" ] pub struct RWS_W < 'a > { w : & 'a mut W , } impl < 'a > RWS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RWS_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Single Auto Wait State" ] # [ inline ( always ) ] pub fn single ( self ) -> & 'a mut W { self . variant ( RWS_A :: SINGLE ) } # [ doc = "Half Auto Wait State" ] # [ inline ( always ) ] pub fn half ( self ) -> & 'a mut W { self . variant ( RWS_A :: HALF ) } # [ doc = "Dual Auto Wait State" ] # [ inline ( always ) ] pub fn dual ( self ) -> & 'a mut W { self . variant ( RWS_A :: DUAL ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 1 ) ) | ( ( ( value as u32 ) & 0x0f ) << 1 ) ; self . w } }
# [ doc = "Reader of field `MANW`" ] pub type MANW_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MANW`" ] pub struct MANW_W < 'a > { w : & 'a mut W , } impl < 'a > MANW_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `SLEEPPRM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SLEEPPRM_A { # [ doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access." ] WAKEONACCESS , # [ doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep." ] WAKEUPINSTANT , # [ doc = "Auto power reduction disabled." ] DISABLED }
impl crate :: ToBits < u8 > for SLEEPPRM_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SLEEPPRM_A :: WAKEONACCESS => 0 , SLEEPPRM_A :: WAKEUPINSTANT => 1 , SLEEPPRM_A :: DISABLED => 3 } } }
# [ doc = "Reader of field `SLEEPPRM`" ] pub type SLEEPPRM_R = crate :: R < u8 , SLEEPPRM_A > ; impl SLEEPPRM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SLEEPPRM_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SLEEPPRM_A :: WAKEONACCESS ) , 1 => Val ( SLEEPPRM_A :: WAKEUPINSTANT ) , 3 => Val ( SLEEPPRM_A :: DISABLED ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `WAKEONACCESS`" ] # [ inline ( always ) ] pub fn is_wakeonaccess ( & self ) -> bool { * self == SLEEPPRM_A :: WAKEONACCESS } # [ doc = "Checks if the value of the field is `WAKEUPINSTANT`" ] # [ inline ( always ) ] pub fn is_wakeupinstant ( & self ) -> bool { * self == SLEEPPRM_A :: WAKEUPINSTANT } # [ doc = "Checks if the value of the field is `DISABLED`" ] # [ inline ( always ) ] pub fn is_disabled ( & self ) -> bool { * self == SLEEPPRM_A :: DISABLED } }
# [ doc = "Write proxy for field `SLEEPPRM`" ] pub struct SLEEPPRM_W < 'a > { w : & 'a mut W , } impl < 'a > SLEEPPRM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SLEEPPRM_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode upon first access." ] # [ inline ( always ) ] pub fn wakeonaccess ( self ) -> & 'a mut W { self . variant ( SLEEPPRM_A :: WAKEONACCESS ) } # [ doc = "NVM block enters low-power mode when entering sleep.NVM block exits low-power mode when exiting sleep." ] # [ inline ( always ) ] pub fn wakeupinstant ( self ) -> & 'a mut W { self . variant ( SLEEPPRM_A :: WAKEUPINSTANT ) } # [ doc = "Auto power reduction disabled." ] # [ inline ( always ) ] pub fn disabled ( self ) -> & 'a mut W { self . variant ( SLEEPPRM_A :: DISABLED ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Possible values of the field `READMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum READMODE_A { # [ doc = "The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance." ] NO_MISS_PENALTY , # [ doc = "Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time." ] LOW_POWER , # [ doc = "The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings." ] DETERMINISTIC }
impl crate :: ToBits < u8 > for READMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { READMODE_A :: NO_MISS_PENALTY => 0 , READMODE_A :: LOW_POWER => 1 , READMODE_A :: DETERMINISTIC => 2 } } }
# [ doc = "Reader of field `READMODE`" ] pub type READMODE_R = crate :: R < u8 , READMODE_A > ; impl READMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , READMODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( READMODE_A :: NO_MISS_PENALTY ) , 1 => Val ( READMODE_A :: LOW_POWER ) , 2 => Val ( READMODE_A :: DETERMINISTIC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NO_MISS_PENALTY`" ] # [ inline ( always ) ] pub fn is_no_miss_penalty ( & self ) -> bool { * self == READMODE_A :: NO_MISS_PENALTY } # [ doc = "Checks if the value of the field is `LOW_POWER`" ] # [ inline ( always ) ] pub fn is_low_power ( & self ) -> bool { * self == READMODE_A :: LOW_POWER } # [ doc = "Checks if the value of the field is `DETERMINISTIC`" ] # [ inline ( always ) ] pub fn is_deterministic ( & self ) -> bool { * self == READMODE_A :: DETERMINISTIC } }
# [ doc = "Write proxy for field `READMODE`" ] pub struct READMODE_W < 'a > { w : & 'a mut W , } impl < 'a > READMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : READMODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "The NVM Controller (cache system) does not insert wait states on a cache miss. Gives the best system performance." ] # [ inline ( always ) ] pub fn no_miss_penalty ( self ) -> & 'a mut W { self . variant ( READMODE_A :: NO_MISS_PENALTY ) } # [ doc = "Reduces power consumption of the cache system, but inserts a wait state each time there is a cache miss. This mode may not be relevant if CPU performance is required, as the application will be stalled and may lead to increase run time." ] # [ inline ( always ) ] pub fn low_power ( self ) -> & 'a mut W { self . variant ( READMODE_A :: LOW_POWER ) } # [ doc = "The cache system ensures that a cache hit or miss takes the same amount of time, determined by the number of programmed flash wait states. This mode can be used for real-time applications that require deterministic execution timings." ] # [ inline ( always ) ] pub fn deterministic ( self ) -> & 'a mut W { self . variant ( READMODE_A :: DETERMINISTIC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 16 ) ) | ( ( ( value as u32 ) & 0x03 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `CACHEDIS`" ] pub type CACHEDIS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `CACHEDIS`" ] pub struct CACHEDIS_W < 'a > { w : & 'a mut W , } impl < 'a > CACHEDIS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 18 ) ) | ( ( ( value as u32 ) & 0x03 ) << 18 ) ; self . w } }
impl R {
# [ doc = "Bits 1:4 - NVM Read Wait States" ] # [ inline ( always ) ] pub fn rws ( & self ) -> RWS_R { RWS_R :: new ( ( ( self . bits >> 1 ) & 0x0f ) as u8 ) }
# [ doc = "Bit 7 - Manual Write" ] # [ inline ( always ) ] pub fn manw ( & self ) -> MANW_R { MANW_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - Power Reduction Mode during Sleep" ] # [ inline ( always ) ] pub fn sleepprm ( & self ) -> SLEEPPRM_R { SLEEPPRM_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 16:17 - NVMCTRL Read Mode" ] # [ inline ( always ) ] pub fn readmode ( & self ) -> READMODE_R { READMODE_R :: new ( ( ( self . bits >> 16 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 18:19 - Cache Disable" ] # [ inline ( always ) ] pub fn cachedis ( & self ) -> CACHEDIS_R { CACHEDIS_R :: new ( ( ( self . bits >> 18 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 1:4 - NVM Read Wait States" ] # [ inline ( always ) ] pub fn rws ( & mut self ) -> RWS_W { RWS_W { w : self } }
# [ doc = "Bit 7 - Manual Write" ] # [ inline ( always ) ] pub fn manw ( & mut self ) -> MANW_W { MANW_W { w : self } }
# [ doc = "Bits 8:9 - Power Reduction Mode during Sleep" ] # [ inline ( always ) ] pub fn sleepprm ( & mut self ) -> SLEEPPRM_W { SLEEPPRM_W { w : self } }
# [ doc = "Bits 16:17 - NVMCTRL Read Mode" ] # [ inline ( always ) ] pub fn readmode ( & mut self ) -> READMODE_W { READMODE_W { w : self } }
# [ doc = "Bits 18:19 - Cache Disable" ] # [ inline ( always ) ] pub fn cachedis ( & mut self ) -> CACHEDIS_W { CACHEDIS_W { w : self } }
}
}
# [ doc = "NVM Parameter\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [param](param) module" ] pub type PARAM = crate :: Reg < u32 , _PARAM > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PARAM ;
# [ doc = "`read()` method returns [param::R](param::R) reader structure" ] impl crate :: Readable for PARAM { }
# [ doc = "`write(|w| ..)` method takes [param::W](param::W) writer structure" ] impl crate :: Writable for PARAM { }
# [ doc = "NVM Parameter" ] pub mod param {
# [ doc = "Reader of register PARAM" ] pub type R = crate :: R < u32 , super :: PARAM > ;
# [ doc = "Writer for register PARAM" ] pub type W = crate :: W < u32 , super :: PARAM > ;
# [ doc = "Register PARAM `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PARAM { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `NVMP`" ] pub type NVMP_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `NVMP`" ] pub struct NVMP_W < 'a > { w : & 'a mut W , } impl < 'a > NVMP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
# [ doc = "Possible values of the field `PSZ`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PSZ_A { # [ doc = "8 bytes" ] _8 , # [ doc = "16 bytes" ] _16 , # [ doc = "32 bytes" ] _32 , # [ doc = "64 bytes" ] _64 , # [ doc = "128 bytes" ] _128 , # [ doc = "256 bytes" ] _256 , # [ doc = "512 bytes" ] _512 , # [ doc = "1024 bytes" ] _1024 }
impl crate :: ToBits < u8 > for PSZ_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PSZ_A :: _8 => 0 , PSZ_A :: _16 => 1 , PSZ_A :: _32 => 2 , PSZ_A :: _64 => 3 , PSZ_A :: _128 => 4 , PSZ_A :: _256 => 5 , PSZ_A :: _512 => 6 , PSZ_A :: _1024 => 7 } } }
# [ doc = "Reader of field `PSZ`" ] pub type PSZ_R = crate :: R < u8 , PSZ_A > ; impl PSZ_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PSZ_A { match self . bits { 0 => PSZ_A :: _8 , 1 => PSZ_A :: _16 , 2 => PSZ_A :: _32 , 3 => PSZ_A :: _64 , 4 => PSZ_A :: _128 , 5 => PSZ_A :: _256 , 6 => PSZ_A :: _512 , 7 => PSZ_A :: _1024 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `_8`" ] # [ inline ( always ) ] pub fn is_8 ( & self ) -> bool { * self == PSZ_A :: _8 } # [ doc = "Checks if the value of the field is `_16`" ] # [ inline ( always ) ] pub fn is_16 ( & self ) -> bool { * self == PSZ_A :: _16 } # [ doc = "Checks if the value of the field is `_32`" ] # [ inline ( always ) ] pub fn is_32 ( & self ) -> bool { * self == PSZ_A :: _32 } # [ doc = "Checks if the value of the field is `_64`" ] # [ inline ( always ) ] pub fn is_64 ( & self ) -> bool { * self == PSZ_A :: _64 } # [ doc = "Checks if the value of the field is `_128`" ] # [ inline ( always ) ] pub fn is_128 ( & self ) -> bool { * self == PSZ_A :: _128 } # [ doc = "Checks if the value of the field is `_256`" ] # [ inline ( always ) ] pub fn is_256 ( & self ) -> bool { * self == PSZ_A :: _256 } # [ doc = "Checks if the value of the field is `_512`" ] # [ inline ( always ) ] pub fn is_512 ( & self ) -> bool { * self == PSZ_A :: _512 } # [ doc = "Checks if the value of the field is `_1024`" ] # [ inline ( always ) ] pub fn is_1024 ( & self ) -> bool { * self == PSZ_A :: _1024 } }
# [ doc = "Write proxy for field `PSZ`" ] pub struct PSZ_W < 'a > { w : & 'a mut W , } impl < 'a > PSZ_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSZ_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 bytes" ] # [ inline ( always ) ] pub fn _8 ( self ) -> & 'a mut W { self . variant ( PSZ_A :: _8 ) } # [ doc = "16 bytes" ] # [ inline ( always ) ] pub fn _16 ( self ) -> & 'a mut W { self . variant ( PSZ_A :: _16 ) } # [ doc = "32 bytes" ] # [ inline ( always ) ] pub fn _32 ( self ) -> & 'a mut W { self . variant ( PSZ_A :: _32 ) } # [ doc = "64 bytes" ] # [ inline ( always ) ] pub fn _64 ( self ) -> & 'a mut W { self . variant ( PSZ_A :: _64 ) } # [ doc = "128 bytes" ] # [ inline ( always ) ] pub fn _128 ( self ) -> & 'a mut W { self . variant ( PSZ_A :: _128 ) } # [ doc = "256 bytes" ] # [ inline ( always ) ] pub fn _256 ( self ) -> & 'a mut W { self . variant ( PSZ_A :: _256 ) } # [ doc = "512 bytes" ] # [ inline ( always ) ] pub fn _512 ( self ) -> & 'a mut W { self . variant ( PSZ_A :: _512 ) } # [ doc = "1024 bytes" ] # [ inline ( always ) ] pub fn _1024 ( self ) -> & 'a mut W { self . variant ( PSZ_A :: _1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 16 ) ) | ( ( ( value as u32 ) & 0x07 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `RWWEEP`" ] pub type RWWEEP_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `RWWEEP`" ] pub struct RWWEEP_W < 'a > { w : & 'a mut W , } impl < 'a > RWWEEP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0fff << 20 ) ) | ( ( ( value as u32 ) & 0x0fff ) << 20 ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - NVM Pages" ] # [ inline ( always ) ] pub fn nvmp ( & self ) -> NVMP_R { NVMP_R :: new ( ( self . bits & 0xffff ) as u16 ) }
# [ doc = "Bits 16:18 - Page Size" ] # [ inline ( always ) ] pub fn psz ( & self ) -> PSZ_R { PSZ_R :: new ( ( ( self . bits >> 16 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 20:31 - RWW EEPROM Pages" ] # [ inline ( always ) ] pub fn rwweep ( & self ) -> RWWEEP_R { RWWEEP_R :: new ( ( ( self . bits >> 20 ) & 0x0fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - NVM Pages" ] # [ inline ( always ) ] pub fn nvmp ( & mut self ) -> NVMP_W { NVMP_W { w : self } }
# [ doc = "Bits 16:18 - Page Size" ] # [ inline ( always ) ] pub fn psz ( & mut self ) -> PSZ_W { PSZ_W { w : self } }
# [ doc = "Bits 20:31 - RWW EEPROM Pages" ] # [ inline ( always ) ] pub fn rwweep ( & mut self ) -> RWWEEP_W { RWWEEP_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `READY`" ] pub type READY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `READY`" ] pub struct READY_W < 'a > { w : & 'a mut W , } impl < 'a > READY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - NVM Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn ready ( & self ) -> READY_R { READY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - NVM Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn ready ( & mut self ) -> READY_W { READY_W { w : self } }
# [ doc = "Bit 1 - Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `READY`" ] pub type READY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `READY`" ] pub struct READY_W < 'a > { w : & 'a mut W , } impl < 'a > READY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - NVM Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn ready ( & self ) -> READY_R { READY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - NVM Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn ready ( & mut self ) -> READY_W { READY_W { w : self } }
# [ doc = "Bit 1 - Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `READY`" ] pub type READY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `READY`" ] pub struct READY_W < 'a > { w : & 'a mut W , } impl < 'a > READY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - NVM Ready" ] # [ inline ( always ) ] pub fn ready ( & self ) -> READY_R { READY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Error" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - NVM Ready" ] # [ inline ( always ) ] pub fn ready ( & mut self ) -> READY_W { READY_W { w : self } }
# [ doc = "Bit 1 - Error" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } }
}
}
# [ doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u16 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ;
# [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { }
# [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { }
# [ doc = "Status" ] pub mod status {
# [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u16 , super :: STATUS > ;
# [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u16 , super :: STATUS > ;
# [ doc = "Register STATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `PRM`" ] pub type PRM_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PRM`" ] pub struct PRM_W < 'a > { w : & 'a mut W , } impl < 'a > PRM_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `LOAD`" ] pub type LOAD_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LOAD`" ] pub struct LOAD_W < 'a > { w : & 'a mut W , } impl < 'a > LOAD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `PROGE`" ] pub type PROGE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PROGE`" ] pub struct PROGE_W < 'a > { w : & 'a mut W , } impl < 'a > PROGE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `LOCKE`" ] pub type LOCKE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LOCKE`" ] pub struct LOCKE_W < 'a > { w : & 'a mut W , } impl < 'a > LOCKE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `NVME`" ] pub type NVME_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NVME`" ] pub struct NVME_W < 'a > { w : & 'a mut W , } impl < 'a > NVME_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `SB`" ] pub type SB_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SB`" ] pub struct SB_W < 'a > { w : & 'a mut W , } impl < 'a > SB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Power Reduction Mode" ] # [ inline ( always ) ] pub fn prm ( & self ) -> PRM_R { PRM_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - NVM Page Buffer Active Loading" ] # [ inline ( always ) ] pub fn load ( & self ) -> LOAD_R { LOAD_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Programming Error Status" ] # [ inline ( always ) ] pub fn proge ( & self ) -> PROGE_R { PROGE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Lock Error Status" ] # [ inline ( always ) ] pub fn locke ( & self ) -> LOCKE_R { LOCKE_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - NVM Error" ] # [ inline ( always ) ] pub fn nvme ( & self ) -> NVME_R { NVME_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Security Bit Status" ] # [ inline ( always ) ] pub fn sb ( & self ) -> SB_R { SB_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Power Reduction Mode" ] # [ inline ( always ) ] pub fn prm ( & mut self ) -> PRM_W { PRM_W { w : self } }
# [ doc = "Bit 1 - NVM Page Buffer Active Loading" ] # [ inline ( always ) ] pub fn load ( & mut self ) -> LOAD_W { LOAD_W { w : self } }
# [ doc = "Bit 2 - Programming Error Status" ] # [ inline ( always ) ] pub fn proge ( & mut self ) -> PROGE_W { PROGE_W { w : self } }
# [ doc = "Bit 3 - Lock Error Status" ] # [ inline ( always ) ] pub fn locke ( & mut self ) -> LOCKE_W { LOCKE_W { w : self } }
# [ doc = "Bit 4 - NVM Error" ] # [ inline ( always ) ] pub fn nvme ( & mut self ) -> NVME_W { NVME_W { w : self } }
# [ doc = "Bit 8 - Security Bit Status" ] # [ inline ( always ) ] pub fn sb ( & mut self ) -> SB_W { SB_W { w : self } }
}
}
# [ doc = "Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [addr](addr) module" ] pub type ADDR = crate :: Reg < u32 , _ADDR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADDR ;
# [ doc = "`read()` method returns [addr::R](addr::R) reader structure" ] impl crate :: Readable for ADDR { }
# [ doc = "`write(|w| ..)` method takes [addr::W](addr::W) writer structure" ] impl crate :: Writable for ADDR { }
# [ doc = "Address" ] pub mod addr {
# [ doc = "Reader of register ADDR" ] pub type R = crate :: R < u32 , super :: ADDR > ;
# [ doc = "Writer for register ADDR" ] pub type W = crate :: W < u32 , super :: ADDR > ;
# [ doc = "Register ADDR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADDR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ADDR`" ] pub type ADDR_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `ADDR`" ] pub struct ADDR_W < 'a > { w : & 'a mut W , } impl < 'a > ADDR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x003f_ffff ) | ( ( value as u32 ) & 0x003f_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:21 - NVM Address" ] # [ inline ( always ) ] pub fn addr ( & self ) -> ADDR_R { ADDR_R :: new ( ( self . bits & 0x003f_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:21 - NVM Address" ] # [ inline ( always ) ] pub fn addr ( & mut self ) -> ADDR_W { ADDR_W { w : self } }
}
}
# [ doc = "Lock Section\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [lock](lock) module" ] pub type LOCK = crate :: Reg < u16 , _LOCK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _LOCK ;
# [ doc = "`read()` method returns [lock::R](lock::R) reader structure" ] impl crate :: Readable for LOCK { }
# [ doc = "`write(|w| ..)` method takes [lock::W](lock::W) writer structure" ] impl crate :: Writable for LOCK { }
# [ doc = "Lock Section" ] pub mod lock {
# [ doc = "Reader of register LOCK" ] pub type R = crate :: R < u16 , super :: LOCK > ;
# [ doc = "Writer for register LOCK" ] pub type W = crate :: W < u16 , super :: LOCK > ;
# [ doc = "Register LOCK `reset()`'s with value 0" ] impl crate :: ResetValue for super :: LOCK { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `LOCK`" ] pub type LOCK_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `LOCK`" ] pub struct LOCK_W < 'a > { w : & 'a mut W , } impl < 'a > LOCK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Region Lock Bits" ] # [ inline ( always ) ] pub fn lock ( & self ) -> LOCK_R { LOCK_R :: new ( ( self . bits & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:15 - Region Lock Bits" ] # [ inline ( always ) ] pub fn lock ( & mut self ) -> LOCK_W { LOCK_W { w : self } }
}
}
# [ doc = "Page Buffer Load Data 0\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pbldata0](pbldata0) module" ] pub type PBLDATA0 = crate :: Reg < u32 , _PBLDATA0 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PBLDATA0 ;
# [ doc = "`read()` method returns [pbldata0::R](pbldata0::R) reader structure" ] impl crate :: Readable for PBLDATA0 { }
# [ doc = "Page Buffer Load Data 0" ] pub mod pbldata0 {
# [ doc = "Reader of register PBLDATA0" ] pub type R = crate :: R < u32 , super :: PBLDATA0 > ;
impl R {
}
}
# [ doc = "Page Buffer Load Data 1\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pbldata1](pbldata1) module" ] pub type PBLDATA1 = crate :: Reg < u32 , _PBLDATA1 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PBLDATA1 ;
# [ doc = "`read()` method returns [pbldata1::R](pbldata1::R) reader structure" ] impl crate :: Readable for PBLDATA1 { }
# [ doc = "Page Buffer Load Data 1" ] pub mod pbldata1 {
# [ doc = "Reader of register PBLDATA1" ] pub type R = crate :: R < u32 , super :: PBLDATA1 > ;
impl R {
}
}
}
# [ doc = "Oscillators Control" ] pub struct OSCCTRL { _marker : PhantomData < * const ( ) > } unsafe impl Send for OSCCTRL { } impl OSCCTRL { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const oscctrl :: RegisterBlock { 0x4000_1000 as * const _ } } impl Deref for OSCCTRL { type Target = oscctrl :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * OSCCTRL :: ptr ( ) } } }
# [ doc = "Oscillators Control" ] pub mod oscctrl {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x04 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x08 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x0c - Power and Clocks Status" ] pub status : STATUS , # [ doc = "0x10 - External Multipurpose Crystal Oscillator (XOSC) Control" ] pub xoscctrl : XOSCCTRL , # [ doc = "0x12 - Clock Failure Detector Prescaler" ] pub cfdpresc : CFDPRESC , # [ doc = "0x13 - Event Control" ] pub evctrl : EVCTRL , # [ doc = "0x14 - 48MHz Internal Oscillator (OSC48M) Control" ] pub osc48mctrl : OSC48MCTRL , # [ doc = "0x15 - OSC48M Divider" ] pub osc48mdiv : OSC48MDIV , # [ doc = "0x16 - OSC48M Startup Time" ] pub osc48mstup : OSC48MSTUP , _reserved10 : [ u8 ; 1usize ] , # [ doc = "0x18 - OSC48M Synchronization Busy" ] pub osc48msyncbusy : OSC48MSYNCBUSY , # [ doc = "0x1c - DPLL Control" ] pub dpllctrla : DPLLCTRLA , _reserved12 : [ u8 ; 3usize ] , # [ doc = "0x20 - DPLL Ratio Control" ] pub dpllratio : DPLLRATIO , # [ doc = "0x24 - Digital Core Configuration" ] pub dpllctrlb : DPLLCTRLB , # [ doc = "0x28 - DPLL Prescaler" ] pub dpllpresc : DPLLPRESC , _reserved15 : [ u8 ; 3usize ] , # [ doc = "0x2c - DPLL Synchronization Busy" ] pub dpllsyncbusy : DPLLSYNCBUSY , _reserved16 : [ u8 ; 3usize ] , # [ doc = "0x30 - DPLL Status" ] pub dpllstatus : DPLLSTATUS , _reserved17 : [ u8 ; 7usize ] , # [ doc = "0x38 - 48MHz Oscillator Calibration" ] pub cal48m : CAL48M , }
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u32 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u32 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u32 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `XOSCRDY`" ] pub type XOSCRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XOSCRDY`" ] pub struct XOSCRDY_W < 'a > { w : & 'a mut W , } impl < 'a > XOSCRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `XOSCFAIL`" ] pub type XOSCFAIL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XOSCFAIL`" ] pub struct XOSCFAIL_W < 'a > { w : & 'a mut W , } impl < 'a > XOSCFAIL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `OSC48MRDY`" ] pub type OSC48MRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSC48MRDY`" ] pub struct OSC48MRDY_W < 'a > { w : & 'a mut W , } impl < 'a > OSC48MRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `DPLLLCKR`" ] pub type DPLLLCKR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLCKR`" ] pub struct DPLLLCKR_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLCKR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `DPLLLCKF`" ] pub type DPLLLCKF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLCKF`" ] pub struct DPLLLCKF_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLCKF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `DPLLLTO`" ] pub type DPLLLTO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLTO`" ] pub struct DPLLLTO_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLTO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `DPLLLDRTO`" ] pub type DPLLLDRTO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLDRTO`" ] pub struct DPLLLDRTO_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLDRTO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - XOSC Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn xoscrdy ( & self ) -> XOSCRDY_R { XOSCRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - XOSC Clock Failure Detector Interrupt Enable" ] # [ inline ( always ) ] pub fn xoscfail ( & self ) -> XOSCFAIL_R { XOSCFAIL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - OSC48M Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn osc48mrdy ( & self ) -> OSC48MRDY_R { OSC48MRDY_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - DPLL Lock Rise Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllckr ( & self ) -> DPLLLCKR_R { DPLLLCKR_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - DPLL Lock Fall Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllckf ( & self ) -> DPLLLCKF_R { DPLLLCKF_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - DPLL Time Out Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllto ( & self ) -> DPLLLTO_R { DPLLLTO_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - DPLL Ratio Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn dpllldrto ( & self ) -> DPLLLDRTO_R { DPLLLDRTO_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - XOSC Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn xoscrdy ( & mut self ) -> XOSCRDY_W { XOSCRDY_W { w : self } }
# [ doc = "Bit 1 - XOSC Clock Failure Detector Interrupt Enable" ] # [ inline ( always ) ] pub fn xoscfail ( & mut self ) -> XOSCFAIL_W { XOSCFAIL_W { w : self } }
# [ doc = "Bit 4 - OSC48M Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn osc48mrdy ( & mut self ) -> OSC48MRDY_W { OSC48MRDY_W { w : self } }
# [ doc = "Bit 8 - DPLL Lock Rise Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllckr ( & mut self ) -> DPLLLCKR_W { DPLLLCKR_W { w : self } }
# [ doc = "Bit 9 - DPLL Lock Fall Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllckf ( & mut self ) -> DPLLLCKF_W { DPLLLCKF_W { w : self } }
# [ doc = "Bit 10 - DPLL Time Out Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllto ( & mut self ) -> DPLLLTO_W { DPLLLTO_W { w : self } }
# [ doc = "Bit 11 - DPLL Ratio Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn dpllldrto ( & mut self ) -> DPLLLDRTO_W { DPLLLDRTO_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u32 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u32 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u32 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `XOSCRDY`" ] pub type XOSCRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XOSCRDY`" ] pub struct XOSCRDY_W < 'a > { w : & 'a mut W , } impl < 'a > XOSCRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `XOSCFAIL`" ] pub type XOSCFAIL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XOSCFAIL`" ] pub struct XOSCFAIL_W < 'a > { w : & 'a mut W , } impl < 'a > XOSCFAIL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `OSC48MRDY`" ] pub type OSC48MRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSC48MRDY`" ] pub struct OSC48MRDY_W < 'a > { w : & 'a mut W , } impl < 'a > OSC48MRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `DPLLLCKR`" ] pub type DPLLLCKR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLCKR`" ] pub struct DPLLLCKR_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLCKR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `DPLLLCKF`" ] pub type DPLLLCKF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLCKF`" ] pub struct DPLLLCKF_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLCKF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `DPLLLTO`" ] pub type DPLLLTO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLTO`" ] pub struct DPLLLTO_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLTO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `DPLLLDRTO`" ] pub type DPLLLDRTO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLDRTO`" ] pub struct DPLLLDRTO_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLDRTO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - XOSC Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn xoscrdy ( & self ) -> XOSCRDY_R { XOSCRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - XOSC Clock Failure Detector Interrupt Enable" ] # [ inline ( always ) ] pub fn xoscfail ( & self ) -> XOSCFAIL_R { XOSCFAIL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - OSC48M Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn osc48mrdy ( & self ) -> OSC48MRDY_R { OSC48MRDY_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - DPLL Lock Rise Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllckr ( & self ) -> DPLLLCKR_R { DPLLLCKR_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - DPLL Lock Fall Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllckf ( & self ) -> DPLLLCKF_R { DPLLLCKF_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - DPLL Time Out Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllto ( & self ) -> DPLLLTO_R { DPLLLTO_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - DPLL Ratio Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn dpllldrto ( & self ) -> DPLLLDRTO_R { DPLLLDRTO_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - XOSC Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn xoscrdy ( & mut self ) -> XOSCRDY_W { XOSCRDY_W { w : self } }
# [ doc = "Bit 1 - XOSC Clock Failure Detector Interrupt Enable" ] # [ inline ( always ) ] pub fn xoscfail ( & mut self ) -> XOSCFAIL_W { XOSCFAIL_W { w : self } }
# [ doc = "Bit 4 - OSC48M Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn osc48mrdy ( & mut self ) -> OSC48MRDY_W { OSC48MRDY_W { w : self } }
# [ doc = "Bit 8 - DPLL Lock Rise Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllckr ( & mut self ) -> DPLLLCKR_W { DPLLLCKR_W { w : self } }
# [ doc = "Bit 9 - DPLL Lock Fall Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllckf ( & mut self ) -> DPLLLCKF_W { DPLLLCKF_W { w : self } }
# [ doc = "Bit 10 - DPLL Time Out Interrupt Enable" ] # [ inline ( always ) ] pub fn dplllto ( & mut self ) -> DPLLLTO_W { DPLLLTO_W { w : self } }
# [ doc = "Bit 11 - DPLL Ratio Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn dpllldrto ( & mut self ) -> DPLLLDRTO_W { DPLLLDRTO_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u32 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u32 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u32 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `XOSCRDY`" ] pub type XOSCRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XOSCRDY`" ] pub struct XOSCRDY_W < 'a > { w : & 'a mut W , } impl < 'a > XOSCRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `XOSCFAIL`" ] pub type XOSCFAIL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XOSCFAIL`" ] pub struct XOSCFAIL_W < 'a > { w : & 'a mut W , } impl < 'a > XOSCFAIL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `OSC48MRDY`" ] pub type OSC48MRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSC48MRDY`" ] pub struct OSC48MRDY_W < 'a > { w : & 'a mut W , } impl < 'a > OSC48MRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `DPLLLCKR`" ] pub type DPLLLCKR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLCKR`" ] pub struct DPLLLCKR_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLCKR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `DPLLLCKF`" ] pub type DPLLLCKF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLCKF`" ] pub struct DPLLLCKF_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLCKF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `DPLLLTO`" ] pub type DPLLLTO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLTO`" ] pub struct DPLLLTO_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLTO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `DPLLLDRTO`" ] pub type DPLLLDRTO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DPLLLDRTO`" ] pub struct DPLLLDRTO_W < 'a > { w : & 'a mut W , } impl < 'a > DPLLLDRTO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - XOSC Ready" ] # [ inline ( always ) ] pub fn xoscrdy ( & self ) -> XOSCRDY_R { XOSCRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - XOSC Clock Failure Detector" ] # [ inline ( always ) ] pub fn xoscfail ( & self ) -> XOSCFAIL_R { XOSCFAIL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - OSC48M Ready" ] # [ inline ( always ) ] pub fn osc48mrdy ( & self ) -> OSC48MRDY_R { OSC48MRDY_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - DPLL Lock Rise" ] # [ inline ( always ) ] pub fn dplllckr ( & self ) -> DPLLLCKR_R { DPLLLCKR_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - DPLL Lock Fall" ] # [ inline ( always ) ] pub fn dplllckf ( & self ) -> DPLLLCKF_R { DPLLLCKF_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - DPLL Timeout" ] # [ inline ( always ) ] pub fn dplllto ( & self ) -> DPLLLTO_R { DPLLLTO_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - DPLL Ratio Ready" ] # [ inline ( always ) ] pub fn dpllldrto ( & self ) -> DPLLLDRTO_R { DPLLLDRTO_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - XOSC Ready" ] # [ inline ( always ) ] pub fn xoscrdy ( & mut self ) -> XOSCRDY_W { XOSCRDY_W { w : self } }
# [ doc = "Bit 1 - XOSC Clock Failure Detector" ] # [ inline ( always ) ] pub fn xoscfail ( & mut self ) -> XOSCFAIL_W { XOSCFAIL_W { w : self } }
# [ doc = "Bit 4 - OSC48M Ready" ] # [ inline ( always ) ] pub fn osc48mrdy ( & mut self ) -> OSC48MRDY_W { OSC48MRDY_W { w : self } }
# [ doc = "Bit 8 - DPLL Lock Rise" ] # [ inline ( always ) ] pub fn dplllckr ( & mut self ) -> DPLLLCKR_W { DPLLLCKR_W { w : self } }
# [ doc = "Bit 9 - DPLL Lock Fall" ] # [ inline ( always ) ] pub fn dplllckf ( & mut self ) -> DPLLLCKF_W { DPLLLCKF_W { w : self } }
# [ doc = "Bit 10 - DPLL Timeout" ] # [ inline ( always ) ] pub fn dplllto ( & mut self ) -> DPLLLTO_W { DPLLLTO_W { w : self } }
# [ doc = "Bit 11 - DPLL Ratio Ready" ] # [ inline ( always ) ] pub fn dpllldrto ( & mut self ) -> DPLLLDRTO_W { DPLLLDRTO_W { w : self } }
}
}
# [ doc = "Power and Clocks Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u32 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ;
# [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { }
# [ doc = "Power and Clocks Status" ] pub mod status {
# [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u32 , super :: STATUS > ;
# [ doc = "Reader of field `XOSCRDY`" ] pub type XOSCRDY_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `XOSCFAIL`" ] pub type XOSCFAIL_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `XOSCCKSW`" ] pub type XOSCCKSW_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `OSC48MRDY`" ] pub type OSC48MRDY_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DPLLLCKR`" ] pub type DPLLLCKR_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DPLLLCKF`" ] pub type DPLLLCKF_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DPLLTO`" ] pub type DPLLTO_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DPLLLDRTO`" ] pub type DPLLLDRTO_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - XOSC Ready" ] # [ inline ( always ) ] pub fn xoscrdy ( & self ) -> XOSCRDY_R { XOSCRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - XOSC Clock Failure Detector" ] # [ inline ( always ) ] pub fn xoscfail ( & self ) -> XOSCFAIL_R { XOSCFAIL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - XOSC Clock Switch" ] # [ inline ( always ) ] pub fn xosccksw ( & self ) -> XOSCCKSW_R { XOSCCKSW_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - OSC48M Ready" ] # [ inline ( always ) ] pub fn osc48mrdy ( & self ) -> OSC48MRDY_R { OSC48MRDY_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - DPLL Lock Rise" ] # [ inline ( always ) ] pub fn dplllckr ( & self ) -> DPLLLCKR_R { DPLLLCKR_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - DPLL Lock Fall" ] # [ inline ( always ) ] pub fn dplllckf ( & self ) -> DPLLLCKF_R { DPLLLCKF_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - DPLL Timeout" ] # [ inline ( always ) ] pub fn dpllto ( & self ) -> DPLLTO_R { DPLLTO_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - DPLL Ratio Ready" ] # [ inline ( always ) ] pub fn dpllldrto ( & self ) -> DPLLLDRTO_R { DPLLLDRTO_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "External Multipurpose Crystal Oscillator (XOSC) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [xoscctrl](xoscctrl) module" ] pub type XOSCCTRL = crate :: Reg < u16 , _XOSCCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _XOSCCTRL ;
# [ doc = "`read()` method returns [xoscctrl::R](xoscctrl::R) reader structure" ] impl crate :: Readable for XOSCCTRL { }
# [ doc = "`write(|w| ..)` method takes [xoscctrl::W](xoscctrl::W) writer structure" ] impl crate :: Writable for XOSCCTRL { }
# [ doc = "External Multipurpose Crystal Oscillator (XOSC) Control" ] pub mod xoscctrl {
# [ doc = "Reader of register XOSCCTRL" ] pub type R = crate :: R < u16 , super :: XOSCCTRL > ;
# [ doc = "Writer for register XOSCCTRL" ] pub type W = crate :: W < u16 , super :: XOSCCTRL > ;
# [ doc = "Register XOSCCTRL `reset()`'s with value 0x80" ] impl crate :: ResetValue for super :: XOSCCTRL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x80 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `XTALEN`" ] pub type XTALEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XTALEN`" ] pub struct XTALEN_W < 'a > { w : & 'a mut W , } impl < 'a > XTALEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `CFDEN`" ] pub type CFDEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFDEN`" ] pub struct CFDEN_W < 'a > { w : & 'a mut W , } impl < 'a > CFDEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `SWBEN`" ] pub type SWBEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWBEN`" ] pub struct SWBEN_W < 'a > { w : & 'a mut W , } impl < 'a > SWBEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `GAIN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum GAIN_A { # [ doc = "2 MHz" ] GAIN2 , # [ doc = "4 MHz" ] GAIN4 , # [ doc = "8 MHz" ] GAIN8 , # [ doc = "16 MHz" ] GAIN16 , # [ doc = "30 MHz" ] GAIN30 }
impl crate :: ToBits < u8 > for GAIN_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { GAIN_A :: GAIN2 => 0 , GAIN_A :: GAIN4 => 1 , GAIN_A :: GAIN8 => 2 , GAIN_A :: GAIN16 => 3 , GAIN_A :: GAIN30 => 4 } } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u8 , GAIN_A > ; impl GAIN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , GAIN_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( GAIN_A :: GAIN2 ) , 1 => Val ( GAIN_A :: GAIN4 ) , 2 => Val ( GAIN_A :: GAIN8 ) , 3 => Val ( GAIN_A :: GAIN16 ) , 4 => Val ( GAIN_A :: GAIN30 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GAIN2`" ] # [ inline ( always ) ] pub fn is_gain2 ( & self ) -> bool { * self == GAIN_A :: GAIN2 } # [ doc = "Checks if the value of the field is `GAIN4`" ] # [ inline ( always ) ] pub fn is_gain4 ( & self ) -> bool { * self == GAIN_A :: GAIN4 } # [ doc = "Checks if the value of the field is `GAIN8`" ] # [ inline ( always ) ] pub fn is_gain8 ( & self ) -> bool { * self == GAIN_A :: GAIN8 } # [ doc = "Checks if the value of the field is `GAIN16`" ] # [ inline ( always ) ] pub fn is_gain16 ( & self ) -> bool { * self == GAIN_A :: GAIN16 } # [ doc = "Checks if the value of the field is `GAIN30`" ] # [ inline ( always ) ] pub fn is_gain30 ( & self ) -> bool { * self == GAIN_A :: GAIN30 } }
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : GAIN_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "2 MHz" ] # [ inline ( always ) ] pub fn gain2 ( self ) -> & 'a mut W { self . variant ( GAIN_A :: GAIN2 ) } # [ doc = "4 MHz" ] # [ inline ( always ) ] pub fn gain4 ( self ) -> & 'a mut W { self . variant ( GAIN_A :: GAIN4 ) } # [ doc = "8 MHz" ] # [ inline ( always ) ] pub fn gain8 ( self ) -> & 'a mut W { self . variant ( GAIN_A :: GAIN8 ) } # [ doc = "16 MHz" ] # [ inline ( always ) ] pub fn gain16 ( self ) -> & 'a mut W { self . variant ( GAIN_A :: GAIN16 ) } # [ doc = "30 MHz" ] # [ inline ( always ) ] pub fn gain30 ( self ) -> & 'a mut W { self . variant ( GAIN_A :: GAIN30 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `AMPGC`" ] pub type AMPGC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AMPGC`" ] pub struct AMPGC_W < 'a > { w : & 'a mut W , } impl < 'a > AMPGC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Possible values of the field `STARTUP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STARTUP_A { # [ doc = "31 us" ] CYCLE1 , # [ doc = "61 us" ] CYCLE2 , # [ doc = "122 us" ] CYCLE4 , # [ doc = "244 us" ] CYCLE8 , # [ doc = "488 us" ] CYCLE16 , # [ doc = "977 us" ] CYCLE32 , # [ doc = "1953 us" ] CYCLE64 , # [ doc = "3906 us" ] CYCLE128 , # [ doc = "7813 us" ] CYCLE256 , # [ doc = "15625 us" ] CYCLE512 , # [ doc = "31250 us" ] CYCLE1024 , # [ doc = "62500 us" ] CYCLE2048 , # [ doc = "125000 us" ] CYCLE4096 , # [ doc = "250000 us" ] CYCLE8192 , # [ doc = "500000 us" ] CYCLE16384 , # [ doc = "1000000 us" ] CYCLE32768 }
impl crate :: ToBits < u8 > for STARTUP_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { STARTUP_A :: CYCLE1 => 0 , STARTUP_A :: CYCLE2 => 1 , STARTUP_A :: CYCLE4 => 2 , STARTUP_A :: CYCLE8 => 3 , STARTUP_A :: CYCLE16 => 4 , STARTUP_A :: CYCLE32 => 5 , STARTUP_A :: CYCLE64 => 6 , STARTUP_A :: CYCLE128 => 7 , STARTUP_A :: CYCLE256 => 8 , STARTUP_A :: CYCLE512 => 9 , STARTUP_A :: CYCLE1024 => 10 , STARTUP_A :: CYCLE2048 => 11 , STARTUP_A :: CYCLE4096 => 12 , STARTUP_A :: CYCLE8192 => 13 , STARTUP_A :: CYCLE16384 => 14 , STARTUP_A :: CYCLE32768 => 15 } } }
# [ doc = "Reader of field `STARTUP`" ] pub type STARTUP_R = crate :: R < u8 , STARTUP_A > ; impl STARTUP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> STARTUP_A { match self . bits { 0 => STARTUP_A :: CYCLE1 , 1 => STARTUP_A :: CYCLE2 , 2 => STARTUP_A :: CYCLE4 , 3 => STARTUP_A :: CYCLE8 , 4 => STARTUP_A :: CYCLE16 , 5 => STARTUP_A :: CYCLE32 , 6 => STARTUP_A :: CYCLE64 , 7 => STARTUP_A :: CYCLE128 , 8 => STARTUP_A :: CYCLE256 , 9 => STARTUP_A :: CYCLE512 , 10 => STARTUP_A :: CYCLE1024 , 11 => STARTUP_A :: CYCLE2048 , 12 => STARTUP_A :: CYCLE4096 , 13 => STARTUP_A :: CYCLE8192 , 14 => STARTUP_A :: CYCLE16384 , 15 => STARTUP_A :: CYCLE32768 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CYCLE1`" ] # [ inline ( always ) ] pub fn is_cycle1 ( & self ) -> bool { * self == STARTUP_A :: CYCLE1 } # [ doc = "Checks if the value of the field is `CYCLE2`" ] # [ inline ( always ) ] pub fn is_cycle2 ( & self ) -> bool { * self == STARTUP_A :: CYCLE2 } # [ doc = "Checks if the value of the field is `CYCLE4`" ] # [ inline ( always ) ] pub fn is_cycle4 ( & self ) -> bool { * self == STARTUP_A :: CYCLE4 } # [ doc = "Checks if the value of the field is `CYCLE8`" ] # [ inline ( always ) ] pub fn is_cycle8 ( & self ) -> bool { * self == STARTUP_A :: CYCLE8 } # [ doc = "Checks if the value of the field is `CYCLE16`" ] # [ inline ( always ) ] pub fn is_cycle16 ( & self ) -> bool { * self == STARTUP_A :: CYCLE16 } # [ doc = "Checks if the value of the field is `CYCLE32`" ] # [ inline ( always ) ] pub fn is_cycle32 ( & self ) -> bool { * self == STARTUP_A :: CYCLE32 } # [ doc = "Checks if the value of the field is `CYCLE64`" ] # [ inline ( always ) ] pub fn is_cycle64 ( & self ) -> bool { * self == STARTUP_A :: CYCLE64 } # [ doc = "Checks if the value of the field is `CYCLE128`" ] # [ inline ( always ) ] pub fn is_cycle128 ( & self ) -> bool { * self == STARTUP_A :: CYCLE128 } # [ doc = "Checks if the value of the field is `CYCLE256`" ] # [ inline ( always ) ] pub fn is_cycle256 ( & self ) -> bool { * self == STARTUP_A :: CYCLE256 } # [ doc = "Checks if the value of the field is `CYCLE512`" ] # [ inline ( always ) ] pub fn is_cycle512 ( & self ) -> bool { * self == STARTUP_A :: CYCLE512 } # [ doc = "Checks if the value of the field is `CYCLE1024`" ] # [ inline ( always ) ] pub fn is_cycle1024 ( & self ) -> bool { * self == STARTUP_A :: CYCLE1024 } # [ doc = "Checks if the value of the field is `CYCLE2048`" ] # [ inline ( always ) ] pub fn is_cycle2048 ( & self ) -> bool { * self == STARTUP_A :: CYCLE2048 } # [ doc = "Checks if the value of the field is `CYCLE4096`" ] # [ inline ( always ) ] pub fn is_cycle4096 ( & self ) -> bool { * self == STARTUP_A :: CYCLE4096 } # [ doc = "Checks if the value of the field is `CYCLE8192`" ] # [ inline ( always ) ] pub fn is_cycle8192 ( & self ) -> bool { * self == STARTUP_A :: CYCLE8192 } # [ doc = "Checks if the value of the field is `CYCLE16384`" ] # [ inline ( always ) ] pub fn is_cycle16384 ( & self ) -> bool { * self == STARTUP_A :: CYCLE16384 } # [ doc = "Checks if the value of the field is `CYCLE32768`" ] # [ inline ( always ) ] pub fn is_cycle32768 ( & self ) -> bool { * self == STARTUP_A :: CYCLE32768 } }
# [ doc = "Write proxy for field `STARTUP`" ] pub struct STARTUP_W < 'a > { w : & 'a mut W , } impl < 'a > STARTUP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : STARTUP_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "31 us" ] # [ inline ( always ) ] pub fn cycle1 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE1 ) } # [ doc = "61 us" ] # [ inline ( always ) ] pub fn cycle2 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE2 ) } # [ doc = "122 us" ] # [ inline ( always ) ] pub fn cycle4 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE4 ) } # [ doc = "244 us" ] # [ inline ( always ) ] pub fn cycle8 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE8 ) } # [ doc = "488 us" ] # [ inline ( always ) ] pub fn cycle16 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE16 ) } # [ doc = "977 us" ] # [ inline ( always ) ] pub fn cycle32 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE32 ) } # [ doc = "1953 us" ] # [ inline ( always ) ] pub fn cycle64 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE64 ) } # [ doc = "3906 us" ] # [ inline ( always ) ] pub fn cycle128 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE128 ) } # [ doc = "7813 us" ] # [ inline ( always ) ] pub fn cycle256 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE256 ) } # [ doc = "15625 us" ] # [ inline ( always ) ] pub fn cycle512 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE512 ) } # [ doc = "31250 us" ] # [ inline ( always ) ] pub fn cycle1024 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE1024 ) } # [ doc = "62500 us" ] # [ inline ( always ) ] pub fn cycle2048 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE2048 ) } # [ doc = "125000 us" ] # [ inline ( always ) ] pub fn cycle4096 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE4096 ) } # [ doc = "250000 us" ] # [ inline ( always ) ] pub fn cycle8192 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE8192 ) } # [ doc = "500000 us" ] # [ inline ( always ) ] pub fn cycle16384 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE16384 ) } # [ doc = "1000000 us" ] # [ inline ( always ) ] pub fn cycle32768 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE32768 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 12 ) ) | ( ( ( value as u16 ) & 0x0f ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Oscillator Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Crystal Oscillator Enable" ] # [ inline ( always ) ] pub fn xtalen ( & self ) -> XTALEN_R { XTALEN_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Xosc Clock Failure Detector Enable" ] # [ inline ( always ) ] pub fn cfden ( & self ) -> CFDEN_R { CFDEN_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Xosc Clock Switch Enable" ] # [ inline ( always ) ] pub fn swben ( & self ) -> SWBEN_R { SWBEN_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Oscillator Gain" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 11 - Automatic Amplitude Gain Control" ] # [ inline ( always ) ] pub fn ampgc ( & self ) -> AMPGC_R { AMPGC_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:15 - Start-Up Time" ] # [ inline ( always ) ] pub fn startup ( & self ) -> STARTUP_R { STARTUP_R :: new ( ( ( self . bits >> 12 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bit 1 - Oscillator Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 2 - Crystal Oscillator Enable" ] # [ inline ( always ) ] pub fn xtalen ( & mut self ) -> XTALEN_W { XTALEN_W { w : self } }
# [ doc = "Bit 3 - Xosc Clock Failure Detector Enable" ] # [ inline ( always ) ] pub fn cfden ( & mut self ) -> CFDEN_W { CFDEN_W { w : self } }
# [ doc = "Bit 4 - Xosc Clock Switch Enable" ] # [ inline ( always ) ] pub fn swben ( & mut self ) -> SWBEN_W { SWBEN_W { w : self } }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } }
# [ doc = "Bits 8:10 - Oscillator Gain" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
# [ doc = "Bit 11 - Automatic Amplitude Gain Control" ] # [ inline ( always ) ] pub fn ampgc ( & mut self ) -> AMPGC_W { AMPGC_W { w : self } }
# [ doc = "Bits 12:15 - Start-Up Time" ] # [ inline ( always ) ] pub fn startup ( & mut self ) -> STARTUP_W { STARTUP_W { w : self } }
}
}
# [ doc = "Clock Failure Detector Prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cfdpresc](cfdpresc) module" ] pub type CFDPRESC = crate :: Reg < u8 , _CFDPRESC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CFDPRESC ;
# [ doc = "`read()` method returns [cfdpresc::R](cfdpresc::R) reader structure" ] impl crate :: Readable for CFDPRESC { }
# [ doc = "`write(|w| ..)` method takes [cfdpresc::W](cfdpresc::W) writer structure" ] impl crate :: Writable for CFDPRESC { }
# [ doc = "Clock Failure Detector Prescaler" ] pub mod cfdpresc {
# [ doc = "Reader of register CFDPRESC" ] pub type R = crate :: R < u8 , super :: CFDPRESC > ;
# [ doc = "Writer for register CFDPRESC" ] pub type W = crate :: W < u8 , super :: CFDPRESC > ;
# [ doc = "Register CFDPRESC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CFDPRESC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `CFDPRESC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CFDPRESC_A { # [ doc = "48 MHz" ] DIV1 , # [ doc = "24 MHz" ] DIV2 , # [ doc = "12 MHz" ] DIV4 , # [ doc = "6 MHz" ] DIV8 , # [ doc = "3 MHz" ] DIV16 , # [ doc = "1.5 MHz" ] DIV32 , # [ doc = "0.75 MHz" ] DIV64 , # [ doc = "0.3125 MHz" ] DIV128 }
impl crate :: ToBits < u8 > for CFDPRESC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CFDPRESC_A :: DIV1 => 0 , CFDPRESC_A :: DIV2 => 1 , CFDPRESC_A :: DIV4 => 2 , CFDPRESC_A :: DIV8 => 3 , CFDPRESC_A :: DIV16 => 4 , CFDPRESC_A :: DIV32 => 5 , CFDPRESC_A :: DIV64 => 6 , CFDPRESC_A :: DIV128 => 7 } } }
# [ doc = "Reader of field `CFDPRESC`" ] pub type CFDPRESC_R = crate :: R < u8 , CFDPRESC_A > ; impl CFDPRESC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CFDPRESC_A { match self . bits { 0 => CFDPRESC_A :: DIV1 , 1 => CFDPRESC_A :: DIV2 , 2 => CFDPRESC_A :: DIV4 , 3 => CFDPRESC_A :: DIV8 , 4 => CFDPRESC_A :: DIV16 , 5 => CFDPRESC_A :: DIV32 , 6 => CFDPRESC_A :: DIV64 , 7 => CFDPRESC_A :: DIV128 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == CFDPRESC_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == CFDPRESC_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == CFDPRESC_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == CFDPRESC_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == CFDPRESC_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == CFDPRESC_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == CFDPRESC_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == CFDPRESC_A :: DIV128 } }
# [ doc = "Write proxy for field `CFDPRESC`" ] pub struct CFDPRESC_W < 'a > { w : & 'a mut W , } impl < 'a > CFDPRESC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CFDPRESC_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "48 MHz" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( CFDPRESC_A :: DIV1 ) } # [ doc = "24 MHz" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( CFDPRESC_A :: DIV2 ) } # [ doc = "12 MHz" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( CFDPRESC_A :: DIV4 ) } # [ doc = "6 MHz" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( CFDPRESC_A :: DIV8 ) } # [ doc = "3 MHz" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( CFDPRESC_A :: DIV16 ) } # [ doc = "1.5 MHz" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( CFDPRESC_A :: DIV32 ) } # [ doc = "0.75 MHz" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( CFDPRESC_A :: DIV64 ) } # [ doc = "0.3125 MHz" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( CFDPRESC_A :: DIV128 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u8 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Clock Failure Detector Prescaler" ] # [ inline ( always ) ] pub fn cfdpresc ( & self ) -> CFDPRESC_R { CFDPRESC_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Clock Failure Detector Prescaler" ] # [ inline ( always ) ] pub fn cfdpresc ( & mut self ) -> CFDPRESC_W { CFDPRESC_W { w : self } }
}
}
# [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u8 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event Control" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u8 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u8 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CFDEO`" ] pub type CFDEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFDEO`" ] pub struct CFDEO_W < 'a > { w : & 'a mut W , } impl < 'a > CFDEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Clock Failure Detector Event Output Enable" ] # [ inline ( always ) ] pub fn cfdeo ( & self ) -> CFDEO_R { CFDEO_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Clock Failure Detector Event Output Enable" ] # [ inline ( always ) ] pub fn cfdeo ( & mut self ) -> CFDEO_W { CFDEO_W { w : self } }
}
}
# [ doc = "48MHz Internal Oscillator (OSC48M) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [osc48mctrl](osc48mctrl) module" ] pub type OSC48MCTRL = crate :: Reg < u8 , _OSC48MCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OSC48MCTRL ;
# [ doc = "`read()` method returns [osc48mctrl::R](osc48mctrl::R) reader structure" ] impl crate :: Readable for OSC48MCTRL { }
# [ doc = "`write(|w| ..)` method takes [osc48mctrl::W](osc48mctrl::W) writer structure" ] impl crate :: Writable for OSC48MCTRL { }
# [ doc = "48MHz Internal Oscillator (OSC48M) Control" ] pub mod osc48mctrl {
# [ doc = "Reader of register OSC48MCTRL" ] pub type R = crate :: R < u8 , super :: OSC48MCTRL > ;
# [ doc = "Writer for register OSC48MCTRL" ] pub type W = crate :: W < u8 , super :: OSC48MCTRL > ;
# [ doc = "Register OSC48MCTRL `reset()`'s with value 0x82" ] impl crate :: ResetValue for super :: OSC48MCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x82 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Oscillator Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Oscillator Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } }
}
}
# [ doc = "OSC48M Divider\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [osc48mdiv](osc48mdiv) module" ] pub type OSC48MDIV = crate :: Reg < u8 , _OSC48MDIV > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OSC48MDIV ;
# [ doc = "`read()` method returns [osc48mdiv::R](osc48mdiv::R) reader structure" ] impl crate :: Readable for OSC48MDIV { }
# [ doc = "`write(|w| ..)` method takes [osc48mdiv::W](osc48mdiv::W) writer structure" ] impl crate :: Writable for OSC48MDIV { }
# [ doc = "OSC48M Divider" ] pub mod osc48mdiv {
# [ doc = "Reader of register OSC48MDIV" ] pub type R = crate :: R < u8 , super :: OSC48MDIV > ;
# [ doc = "Writer for register OSC48MDIV" ] pub type W = crate :: W < u8 , super :: OSC48MDIV > ;
# [ doc = "Register OSC48MDIV `reset()`'s with value 0x0b" ] impl crate :: ResetValue for super :: OSC48MDIV { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x0b } }
# [ doc = "Possible values of the field `DIV`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DIV_A { # [ doc = "48 MHz" ] DIV1 , # [ doc = "24 MHz" ] DIV2 , # [ doc = "16 MHz" ] DIV3 , # [ doc = "12 MHz" ] DIV4 , # [ doc = "9.6 MHz" ] DIV5 , # [ doc = "8 MHz" ] DIV6 , # [ doc = "6.86 MHz" ] DIV7 , # [ doc = "6 MHz" ] DIV8 , # [ doc = "5.33 MHz" ] DIV9 , # [ doc = "4.8 MHz" ] DIV10 , # [ doc = "4.36 MHz" ] DIV11 , # [ doc = "4 MHz" ] DIV12 , # [ doc = "3.69 MHz" ] DIV13 , # [ doc = "3.43 MHz" ] DIV14 , # [ doc = "3.2 MHz" ] DIV15 , # [ doc = "3 MHz" ] DIV16 }
impl crate :: ToBits < u8 > for DIV_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DIV_A :: DIV1 => 0 , DIV_A :: DIV2 => 1 , DIV_A :: DIV3 => 2 , DIV_A :: DIV4 => 3 , DIV_A :: DIV5 => 4 , DIV_A :: DIV6 => 5 , DIV_A :: DIV7 => 6 , DIV_A :: DIV8 => 7 , DIV_A :: DIV9 => 8 , DIV_A :: DIV10 => 9 , DIV_A :: DIV11 => 10 , DIV_A :: DIV12 => 11 , DIV_A :: DIV13 => 12 , DIV_A :: DIV14 => 13 , DIV_A :: DIV15 => 14 , DIV_A :: DIV16 => 15 } } }
# [ doc = "Reader of field `DIV`" ] pub type DIV_R = crate :: R < u8 , DIV_A > ; impl DIV_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DIV_A { match self . bits { 0 => DIV_A :: DIV1 , 1 => DIV_A :: DIV2 , 2 => DIV_A :: DIV3 , 3 => DIV_A :: DIV4 , 4 => DIV_A :: DIV5 , 5 => DIV_A :: DIV6 , 6 => DIV_A :: DIV7 , 7 => DIV_A :: DIV8 , 8 => DIV_A :: DIV9 , 9 => DIV_A :: DIV10 , 10 => DIV_A :: DIV11 , 11 => DIV_A :: DIV12 , 12 => DIV_A :: DIV13 , 13 => DIV_A :: DIV14 , 14 => DIV_A :: DIV15 , 15 => DIV_A :: DIV16 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == DIV_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == DIV_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV3`" ] # [ inline ( always ) ] pub fn is_div3 ( & self ) -> bool { * self == DIV_A :: DIV3 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == DIV_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV5`" ] # [ inline ( always ) ] pub fn is_div5 ( & self ) -> bool { * self == DIV_A :: DIV5 } # [ doc = "Checks if the value of the field is `DIV6`" ] # [ inline ( always ) ] pub fn is_div6 ( & self ) -> bool { * self == DIV_A :: DIV6 } # [ doc = "Checks if the value of the field is `DIV7`" ] # [ inline ( always ) ] pub fn is_div7 ( & self ) -> bool { * self == DIV_A :: DIV7 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == DIV_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV9`" ] # [ inline ( always ) ] pub fn is_div9 ( & self ) -> bool { * self == DIV_A :: DIV9 } # [ doc = "Checks if the value of the field is `DIV10`" ] # [ inline ( always ) ] pub fn is_div10 ( & self ) -> bool { * self == DIV_A :: DIV10 } # [ doc = "Checks if the value of the field is `DIV11`" ] # [ inline ( always ) ] pub fn is_div11 ( & self ) -> bool { * self == DIV_A :: DIV11 } # [ doc = "Checks if the value of the field is `DIV12`" ] # [ inline ( always ) ] pub fn is_div12 ( & self ) -> bool { * self == DIV_A :: DIV12 } # [ doc = "Checks if the value of the field is `DIV13`" ] # [ inline ( always ) ] pub fn is_div13 ( & self ) -> bool { * self == DIV_A :: DIV13 } # [ doc = "Checks if the value of the field is `DIV14`" ] # [ inline ( always ) ] pub fn is_div14 ( & self ) -> bool { * self == DIV_A :: DIV14 } # [ doc = "Checks if the value of the field is `DIV15`" ] # [ inline ( always ) ] pub fn is_div15 ( & self ) -> bool { * self == DIV_A :: DIV15 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == DIV_A :: DIV16 } }
# [ doc = "Write proxy for field `DIV`" ] pub struct DIV_W < 'a > { w : & 'a mut W , } impl < 'a > DIV_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DIV_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "48 MHz" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV1 ) } # [ doc = "24 MHz" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV2 ) } # [ doc = "16 MHz" ] # [ inline ( always ) ] pub fn div3 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV3 ) } # [ doc = "12 MHz" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV4 ) } # [ doc = "9.6 MHz" ] # [ inline ( always ) ] pub fn div5 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV5 ) } # [ doc = "8 MHz" ] # [ inline ( always ) ] pub fn div6 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV6 ) } # [ doc = "6.86 MHz" ] # [ inline ( always ) ] pub fn div7 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV7 ) } # [ doc = "6 MHz" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV8 ) } # [ doc = "5.33 MHz" ] # [ inline ( always ) ] pub fn div9 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV9 ) } # [ doc = "4.8 MHz" ] # [ inline ( always ) ] pub fn div10 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV10 ) } # [ doc = "4.36 MHz" ] # [ inline ( always ) ] pub fn div11 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV11 ) } # [ doc = "4 MHz" ] # [ inline ( always ) ] pub fn div12 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV12 ) } # [ doc = "3.69 MHz" ] # [ inline ( always ) ] pub fn div13 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV13 ) } # [ doc = "3.43 MHz" ] # [ inline ( always ) ] pub fn div14 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV14 ) } # [ doc = "3.2 MHz" ] # [ inline ( always ) ] pub fn div15 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV15 ) } # [ doc = "3 MHz" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( DIV_A :: DIV16 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - OSC48M Division Factor" ] # [ inline ( always ) ] pub fn div ( & self ) -> DIV_R { DIV_R :: new ( ( self . bits & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:3 - OSC48M Division Factor" ] # [ inline ( always ) ] pub fn div ( & mut self ) -> DIV_W { DIV_W { w : self } }
}
}
# [ doc = "OSC48M Startup Time\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [osc48mstup](osc48mstup) module" ] pub type OSC48MSTUP = crate :: Reg < u8 , _OSC48MSTUP > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OSC48MSTUP ;
# [ doc = "`read()` method returns [osc48mstup::R](osc48mstup::R) reader structure" ] impl crate :: Readable for OSC48MSTUP { }
# [ doc = "`write(|w| ..)` method takes [osc48mstup::W](osc48mstup::W) writer structure" ] impl crate :: Writable for OSC48MSTUP { }
# [ doc = "OSC48M Startup Time" ] pub mod osc48mstup {
# [ doc = "Reader of register OSC48MSTUP" ] pub type R = crate :: R < u8 , super :: OSC48MSTUP > ;
# [ doc = "Writer for register OSC48MSTUP" ] pub type W = crate :: W < u8 , super :: OSC48MSTUP > ;
# [ doc = "Register OSC48MSTUP `reset()`'s with value 0x07" ] impl crate :: ResetValue for super :: OSC48MSTUP { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x07 } }
# [ doc = "Possible values of the field `STARTUP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STARTUP_A { # [ doc = "166 ns" ] CYCLE8 , # [ doc = "333 ns" ] CYCLE16 , # [ doc = "667 ns" ] CYCLE32 , # [ doc = "1.333 us" ] CYCLE64 , # [ doc = "2.667 us" ] CYCLE128 , # [ doc = "5.333 us" ] CYCLE256 , # [ doc = "10.667 us" ] CYCLE512 , # [ doc = "21.333 us" ] CYCLE1024 }
impl crate :: ToBits < u8 > for STARTUP_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { STARTUP_A :: CYCLE8 => 0 , STARTUP_A :: CYCLE16 => 1 , STARTUP_A :: CYCLE32 => 2 , STARTUP_A :: CYCLE64 => 3 , STARTUP_A :: CYCLE128 => 4 , STARTUP_A :: CYCLE256 => 5 , STARTUP_A :: CYCLE512 => 6 , STARTUP_A :: CYCLE1024 => 7 } } }
# [ doc = "Reader of field `STARTUP`" ] pub type STARTUP_R = crate :: R < u8 , STARTUP_A > ; impl STARTUP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> STARTUP_A { match self . bits { 0 => STARTUP_A :: CYCLE8 , 1 => STARTUP_A :: CYCLE16 , 2 => STARTUP_A :: CYCLE32 , 3 => STARTUP_A :: CYCLE64 , 4 => STARTUP_A :: CYCLE128 , 5 => STARTUP_A :: CYCLE256 , 6 => STARTUP_A :: CYCLE512 , 7 => STARTUP_A :: CYCLE1024 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CYCLE8`" ] # [ inline ( always ) ] pub fn is_cycle8 ( & self ) -> bool { * self == STARTUP_A :: CYCLE8 } # [ doc = "Checks if the value of the field is `CYCLE16`" ] # [ inline ( always ) ] pub fn is_cycle16 ( & self ) -> bool { * self == STARTUP_A :: CYCLE16 } # [ doc = "Checks if the value of the field is `CYCLE32`" ] # [ inline ( always ) ] pub fn is_cycle32 ( & self ) -> bool { * self == STARTUP_A :: CYCLE32 } # [ doc = "Checks if the value of the field is `CYCLE64`" ] # [ inline ( always ) ] pub fn is_cycle64 ( & self ) -> bool { * self == STARTUP_A :: CYCLE64 } # [ doc = "Checks if the value of the field is `CYCLE128`" ] # [ inline ( always ) ] pub fn is_cycle128 ( & self ) -> bool { * self == STARTUP_A :: CYCLE128 } # [ doc = "Checks if the value of the field is `CYCLE256`" ] # [ inline ( always ) ] pub fn is_cycle256 ( & self ) -> bool { * self == STARTUP_A :: CYCLE256 } # [ doc = "Checks if the value of the field is `CYCLE512`" ] # [ inline ( always ) ] pub fn is_cycle512 ( & self ) -> bool { * self == STARTUP_A :: CYCLE512 } # [ doc = "Checks if the value of the field is `CYCLE1024`" ] # [ inline ( always ) ] pub fn is_cycle1024 ( & self ) -> bool { * self == STARTUP_A :: CYCLE1024 } }
# [ doc = "Write proxy for field `STARTUP`" ] pub struct STARTUP_W < 'a > { w : & 'a mut W , } impl < 'a > STARTUP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : STARTUP_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "166 ns" ] # [ inline ( always ) ] pub fn cycle8 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE8 ) } # [ doc = "333 ns" ] # [ inline ( always ) ] pub fn cycle16 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE16 ) } # [ doc = "667 ns" ] # [ inline ( always ) ] pub fn cycle32 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE32 ) } # [ doc = "1.333 us" ] # [ inline ( always ) ] pub fn cycle64 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE64 ) } # [ doc = "2.667 us" ] # [ inline ( always ) ] pub fn cycle128 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE128 ) } # [ doc = "5.333 us" ] # [ inline ( always ) ] pub fn cycle256 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE256 ) } # [ doc = "10.667 us" ] # [ inline ( always ) ] pub fn cycle512 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE512 ) } # [ doc = "21.333 us" ] # [ inline ( always ) ] pub fn cycle1024 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u8 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Startup Time" ] # [ inline ( always ) ] pub fn startup ( & self ) -> STARTUP_R { STARTUP_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Startup Time" ] # [ inline ( always ) ] pub fn startup ( & mut self ) -> STARTUP_W { STARTUP_W { w : self } }
}
}
# [ doc = "OSC48M Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [osc48msyncbusy](osc48msyncbusy) module" ] pub type OSC48MSYNCBUSY = crate :: Reg < u32 , _OSC48MSYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OSC48MSYNCBUSY ;
# [ doc = "`read()` method returns [osc48msyncbusy::R](osc48msyncbusy::R) reader structure" ] impl crate :: Readable for OSC48MSYNCBUSY { }
# [ doc = "OSC48M Synchronization Busy" ] pub mod osc48msyncbusy {
# [ doc = "Reader of register OSC48MSYNCBUSY" ] pub type R = crate :: R < u32 , super :: OSC48MSYNCBUSY > ;
# [ doc = "Reader of field `OSC48MDIV`" ] pub type OSC48MDIV_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 2 - OSC48MDIV Synchronization Status" ] # [ inline ( always ) ] pub fn osc48mdiv ( & self ) -> OSC48MDIV_R { OSC48MDIV_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "DPLL Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dpllctrla](dpllctrla) module" ] pub type DPLLCTRLA = crate :: Reg < u8 , _DPLLCTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DPLLCTRLA ;
# [ doc = "`read()` method returns [dpllctrla::R](dpllctrla::R) reader structure" ] impl crate :: Readable for DPLLCTRLA { }
# [ doc = "`write(|w| ..)` method takes [dpllctrla::W](dpllctrla::W) writer structure" ] impl crate :: Writable for DPLLCTRLA { }
# [ doc = "DPLL Control" ] pub mod dpllctrla {
# [ doc = "Reader of register DPLLCTRLA" ] pub type R = crate :: R < u8 , super :: DPLLCTRLA > ;
# [ doc = "Writer for register DPLLCTRLA" ] pub type W = crate :: W < u8 , super :: DPLLCTRLA > ;
# [ doc = "Register DPLLCTRLA `reset()`'s with value 0x80" ] impl crate :: ResetValue for super :: DPLLCTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x80 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 7 - On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } }
}
}
# [ doc = "DPLL Ratio Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dpllratio](dpllratio) module" ] pub type DPLLRATIO = crate :: Reg < u32 , _DPLLRATIO > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DPLLRATIO ;
# [ doc = "`read()` method returns [dpllratio::R](dpllratio::R) reader structure" ] impl crate :: Readable for DPLLRATIO { }
# [ doc = "`write(|w| ..)` method takes [dpllratio::W](dpllratio::W) writer structure" ] impl crate :: Writable for DPLLRATIO { }
# [ doc = "DPLL Ratio Control" ] pub mod dpllratio {
# [ doc = "Reader of register DPLLRATIO" ] pub type R = crate :: R < u32 , super :: DPLLRATIO > ;
# [ doc = "Writer for register DPLLRATIO" ] pub type W = crate :: W < u32 , super :: DPLLRATIO > ;
# [ doc = "Register DPLLRATIO `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DPLLRATIO { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `LDR`" ] pub type LDR_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `LDR`" ] pub struct LDR_W < 'a > { w : & 'a mut W , } impl < 'a > LDR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0fff ) | ( ( value as u32 ) & 0x0fff ) ; self . w } }
# [ doc = "Reader of field `LDRFRAC`" ] pub type LDRFRAC_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `LDRFRAC`" ] pub struct LDRFRAC_W < 'a > { w : & 'a mut W , } impl < 'a > LDRFRAC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 16 ) ) | ( ( ( value as u32 ) & 0x0f ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bits 0:11 - Loop Divider Ratio" ] # [ inline ( always ) ] pub fn ldr ( & self ) -> LDR_R { LDR_R :: new ( ( self . bits & 0x0fff ) as u16 ) }
# [ doc = "Bits 16:19 - Loop Divider Ratio Fractional Part" ] # [ inline ( always ) ] pub fn ldrfrac ( & self ) -> LDRFRAC_R { LDRFRAC_R :: new ( ( ( self . bits >> 16 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:11 - Loop Divider Ratio" ] # [ inline ( always ) ] pub fn ldr ( & mut self ) -> LDR_W { LDR_W { w : self } }
# [ doc = "Bits 16:19 - Loop Divider Ratio Fractional Part" ] # [ inline ( always ) ] pub fn ldrfrac ( & mut self ) -> LDRFRAC_W { LDRFRAC_W { w : self } }
}
}
# [ doc = "Digital Core Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dpllctrlb](dpllctrlb) module" ] pub type DPLLCTRLB = crate :: Reg < u32 , _DPLLCTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DPLLCTRLB ;
# [ doc = "`read()` method returns [dpllctrlb::R](dpllctrlb::R) reader structure" ] impl crate :: Readable for DPLLCTRLB { }
# [ doc = "`write(|w| ..)` method takes [dpllctrlb::W](dpllctrlb::W) writer structure" ] impl crate :: Writable for DPLLCTRLB { }
# [ doc = "Digital Core Configuration" ] pub mod dpllctrlb {
# [ doc = "Reader of register DPLLCTRLB" ] pub type R = crate :: R < u32 , super :: DPLLCTRLB > ;
# [ doc = "Writer for register DPLLCTRLB" ] pub type W = crate :: W < u32 , super :: DPLLCTRLB > ;
# [ doc = "Register DPLLCTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DPLLCTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `FILTER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FILTER_A { # [ doc = "Default filter mode" ] DEFAULT , # [ doc = "Low bandwidth filter" ] LBFILT , # [ doc = "High bandwidth filter" ] HBFILT , # [ doc = "High damping filter" ] HDFILT }
impl crate :: ToBits < u8 > for FILTER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { FILTER_A :: DEFAULT => 0 , FILTER_A :: LBFILT => 1 , FILTER_A :: HBFILT => 2 , FILTER_A :: HDFILT => 3 } } }
# [ doc = "Reader of field `FILTER`" ] pub type FILTER_R = crate :: R < u8 , FILTER_A > ; impl FILTER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> FILTER_A { match self . bits { 0 => FILTER_A :: DEFAULT , 1 => FILTER_A :: LBFILT , 2 => FILTER_A :: HBFILT , 3 => FILTER_A :: HDFILT , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DEFAULT`" ] # [ inline ( always ) ] pub fn is_default ( & self ) -> bool { * self == FILTER_A :: DEFAULT } # [ doc = "Checks if the value of the field is `LBFILT`" ] # [ inline ( always ) ] pub fn is_lbfilt ( & self ) -> bool { * self == FILTER_A :: LBFILT } # [ doc = "Checks if the value of the field is `HBFILT`" ] # [ inline ( always ) ] pub fn is_hbfilt ( & self ) -> bool { * self == FILTER_A :: HBFILT } # [ doc = "Checks if the value of the field is `HDFILT`" ] # [ inline ( always ) ] pub fn is_hdfilt ( & self ) -> bool { * self == FILTER_A :: HDFILT } }
# [ doc = "Write proxy for field `FILTER`" ] pub struct FILTER_W < 'a > { w : & 'a mut W , } impl < 'a > FILTER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FILTER_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Default filter mode" ] # [ inline ( always ) ] pub fn default ( self ) -> & 'a mut W { self . variant ( FILTER_A :: DEFAULT ) } # [ doc = "Low bandwidth filter" ] # [ inline ( always ) ] pub fn lbfilt ( self ) -> & 'a mut W { self . variant ( FILTER_A :: LBFILT ) } # [ doc = "High bandwidth filter" ] # [ inline ( always ) ] pub fn hbfilt ( self ) -> & 'a mut W { self . variant ( FILTER_A :: HBFILT ) } # [ doc = "High damping filter" ] # [ inline ( always ) ] pub fn hdfilt ( self ) -> & 'a mut W { self . variant ( FILTER_A :: HDFILT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `LPEN`" ] pub type LPEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LPEN`" ] pub struct LPEN_W < 'a > { w : & 'a mut W , } impl < 'a > LPEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `WUF`" ] pub type WUF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WUF`" ] pub struct WUF_W < 'a > { w : & 'a mut W , } impl < 'a > WUF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Possible values of the field `REFCLK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFCLK_A { # [ doc = "XOSC32K clock reference" ] XOSC32K , # [ doc = "XOSC clock reference" ] XOSC , # [ doc = "GCLK clock reference" ] GCLK }
impl crate :: ToBits < u8 > for REFCLK_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { REFCLK_A :: XOSC32K => 0 , REFCLK_A :: XOSC => 1 , REFCLK_A :: GCLK => 2 } } }
# [ doc = "Reader of field `REFCLK`" ] pub type REFCLK_R = crate :: R < u8 , REFCLK_A > ; impl REFCLK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , REFCLK_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( REFCLK_A :: XOSC32K ) , 1 => Val ( REFCLK_A :: XOSC ) , 2 => Val ( REFCLK_A :: GCLK ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `XOSC32K`" ] # [ inline ( always ) ] pub fn is_xosc32k ( & self ) -> bool { * self == REFCLK_A :: XOSC32K } # [ doc = "Checks if the value of the field is `XOSC`" ] # [ inline ( always ) ] pub fn is_xosc ( & self ) -> bool { * self == REFCLK_A :: XOSC } # [ doc = "Checks if the value of the field is `GCLK`" ] # [ inline ( always ) ] pub fn is_gclk ( & self ) -> bool { * self == REFCLK_A :: GCLK } }
# [ doc = "Write proxy for field `REFCLK`" ] pub struct REFCLK_W < 'a > { w : & 'a mut W , } impl < 'a > REFCLK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFCLK_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "XOSC32K clock reference" ] # [ inline ( always ) ] pub fn xosc32k ( self ) -> & 'a mut W { self . variant ( REFCLK_A :: XOSC32K ) } # [ doc = "XOSC clock reference" ] # [ inline ( always ) ] pub fn xosc ( self ) -> & 'a mut W { self . variant ( REFCLK_A :: XOSC ) } # [ doc = "GCLK clock reference" ] # [ inline ( always ) ] pub fn gclk ( self ) -> & 'a mut W { self . variant ( REFCLK_A :: GCLK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Possible values of the field `LTIME`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum LTIME_A { # [ doc = "No time-out. Automatic lock." ] DEFAULT , # [ doc = "Time-out if no lock within 8ms" ] _8MS , # [ doc = "Time-out if no lock within 9ms" ] _9MS , # [ doc = "Time-out if no lock within 10ms" ] _10MS , # [ doc = "Time-out if no lock within 11ms" ] _11MS }
impl crate :: ToBits < u8 > for LTIME_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { LTIME_A :: DEFAULT => 0 , LTIME_A :: _8MS => 4 , LTIME_A :: _9MS => 5 , LTIME_A :: _10MS => 6 , LTIME_A :: _11MS => 7 } } }
# [ doc = "Reader of field `LTIME`" ] pub type LTIME_R = crate :: R < u8 , LTIME_A > ; impl LTIME_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , LTIME_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( LTIME_A :: DEFAULT ) , 4 => Val ( LTIME_A :: _8MS ) , 5 => Val ( LTIME_A :: _9MS ) , 6 => Val ( LTIME_A :: _10MS ) , 7 => Val ( LTIME_A :: _11MS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DEFAULT`" ] # [ inline ( always ) ] pub fn is_default ( & self ) -> bool { * self == LTIME_A :: DEFAULT } # [ doc = "Checks if the value of the field is `_8MS`" ] # [ inline ( always ) ] pub fn is_8ms ( & self ) -> bool { * self == LTIME_A :: _8MS } # [ doc = "Checks if the value of the field is `_9MS`" ] # [ inline ( always ) ] pub fn is_9ms ( & self ) -> bool { * self == LTIME_A :: _9MS } # [ doc = "Checks if the value of the field is `_10MS`" ] # [ inline ( always ) ] pub fn is_10ms ( & self ) -> bool { * self == LTIME_A :: _10MS } # [ doc = "Checks if the value of the field is `_11MS`" ] # [ inline ( always ) ] pub fn is_11ms ( & self ) -> bool { * self == LTIME_A :: _11MS } }
# [ doc = "Write proxy for field `LTIME`" ] pub struct LTIME_W < 'a > { w : & 'a mut W , } impl < 'a > LTIME_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : LTIME_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No time-out. Automatic lock." ] # [ inline ( always ) ] pub fn default ( self ) -> & 'a mut W { self . variant ( LTIME_A :: DEFAULT ) } # [ doc = "Time-out if no lock within 8ms" ] # [ inline ( always ) ] pub fn _8ms ( self ) -> & 'a mut W { self . variant ( LTIME_A :: _8MS ) } # [ doc = "Time-out if no lock within 9ms" ] # [ inline ( always ) ] pub fn _9ms ( self ) -> & 'a mut W { self . variant ( LTIME_A :: _9MS ) } # [ doc = "Time-out if no lock within 10ms" ] # [ inline ( always ) ] pub fn _10ms ( self ) -> & 'a mut W { self . variant ( LTIME_A :: _10MS ) } # [ doc = "Time-out if no lock within 11ms" ] # [ inline ( always ) ] pub fn _11ms ( self ) -> & 'a mut W { self . variant ( LTIME_A :: _11MS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u32 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `LBYPASS`" ] pub type LBYPASS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LBYPASS`" ] pub struct LBYPASS_W < 'a > { w : & 'a mut W , } impl < 'a > LBYPASS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `DIV`" ] pub type DIV_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `DIV`" ] pub struct DIV_W < 'a > { w : & 'a mut W , } impl < 'a > DIV_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07ff << 16 ) ) | ( ( ( value as u32 ) & 0x07ff ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Proportional Integral Filter Selection" ] # [ inline ( always ) ] pub fn filter ( & self ) -> FILTER_R { FILTER_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 2 - Low-Power Enable" ] # [ inline ( always ) ] pub fn lpen ( & self ) -> LPEN_R { LPEN_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Wake Up Fast" ] # [ inline ( always ) ] pub fn wuf ( & self ) -> WUF_R { WUF_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 4:5 - Reference Clock Selection" ] # [ inline ( always ) ] pub fn refclk ( & self ) -> REFCLK_R { REFCLK_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:10 - Lock Time" ] # [ inline ( always ) ] pub fn ltime ( & self ) -> LTIME_R { LTIME_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 12 - Lock Bypass" ] # [ inline ( always ) ] pub fn lbypass ( & self ) -> LBYPASS_R { LBYPASS_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:26 - Clock Divider" ] # [ inline ( always ) ] pub fn div ( & self ) -> DIV_R { DIV_R :: new ( ( ( self . bits >> 16 ) & 0x07ff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:1 - Proportional Integral Filter Selection" ] # [ inline ( always ) ] pub fn filter ( & mut self ) -> FILTER_W { FILTER_W { w : self } }
# [ doc = "Bit 2 - Low-Power Enable" ] # [ inline ( always ) ] pub fn lpen ( & mut self ) -> LPEN_W { LPEN_W { w : self } }
# [ doc = "Bit 3 - Wake Up Fast" ] # [ inline ( always ) ] pub fn wuf ( & mut self ) -> WUF_W { WUF_W { w : self } }
# [ doc = "Bits 4:5 - Reference Clock Selection" ] # [ inline ( always ) ] pub fn refclk ( & mut self ) -> REFCLK_W { REFCLK_W { w : self } }
# [ doc = "Bits 8:10 - Lock Time" ] # [ inline ( always ) ] pub fn ltime ( & mut self ) -> LTIME_W { LTIME_W { w : self } }
# [ doc = "Bit 12 - Lock Bypass" ] # [ inline ( always ) ] pub fn lbypass ( & mut self ) -> LBYPASS_W { LBYPASS_W { w : self } }
# [ doc = "Bits 16:26 - Clock Divider" ] # [ inline ( always ) ] pub fn div ( & mut self ) -> DIV_W { DIV_W { w : self } }
}
}
# [ doc = "DPLL Prescaler\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dpllpresc](dpllpresc) module" ] pub type DPLLPRESC = crate :: Reg < u8 , _DPLLPRESC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DPLLPRESC ;
# [ doc = "`read()` method returns [dpllpresc::R](dpllpresc::R) reader structure" ] impl crate :: Readable for DPLLPRESC { }
# [ doc = "`write(|w| ..)` method takes [dpllpresc::W](dpllpresc::W) writer structure" ] impl crate :: Writable for DPLLPRESC { }
# [ doc = "DPLL Prescaler" ] pub mod dpllpresc {
# [ doc = "Reader of register DPLLPRESC" ] pub type R = crate :: R < u8 , super :: DPLLPRESC > ;
# [ doc = "Writer for register DPLLPRESC" ] pub type W = crate :: W < u8 , super :: DPLLPRESC > ;
# [ doc = "Register DPLLPRESC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DPLLPRESC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `PRESC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESC_A { # [ doc = "DPLL output is divided by 1" ] DIV1 , # [ doc = "DPLL output is divided by 2" ] DIV2 , # [ doc = "DPLL output is divided by 4" ] DIV4 }
impl crate :: ToBits < u8 > for PRESC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESC_A :: DIV1 => 0 , PRESC_A :: DIV2 => 1 , PRESC_A :: DIV4 => 2 } } }
# [ doc = "Reader of field `PRESC`" ] pub type PRESC_R = crate :: R < u8 , PRESC_A > ; impl PRESC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PRESC_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PRESC_A :: DIV1 ) , 1 => Val ( PRESC_A :: DIV2 ) , 2 => Val ( PRESC_A :: DIV4 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == PRESC_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESC_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESC_A :: DIV4 } }
# [ doc = "Write proxy for field `PRESC`" ] pub struct PRESC_W < 'a > { w : & 'a mut W , } impl < 'a > PRESC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESC_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "DPLL output is divided by 1" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( PRESC_A :: DIV1 ) } # [ doc = "DPLL output is divided by 2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESC_A :: DIV2 ) } # [ doc = "DPLL output is divided by 4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESC_A :: DIV4 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u8 ) & 0x03 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Output Clock Prescaler" ] # [ inline ( always ) ] pub fn presc ( & self ) -> PRESC_R { PRESC_R :: new ( ( self . bits & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Output Clock Prescaler" ] # [ inline ( always ) ] pub fn presc ( & mut self ) -> PRESC_W { PRESC_W { w : self } }
}
}
# [ doc = "DPLL Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dpllsyncbusy](dpllsyncbusy) module" ] pub type DPLLSYNCBUSY = crate :: Reg < u8 , _DPLLSYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DPLLSYNCBUSY ;
# [ doc = "`read()` method returns [dpllsyncbusy::R](dpllsyncbusy::R) reader structure" ] impl crate :: Readable for DPLLSYNCBUSY { }
# [ doc = "DPLL Synchronization Busy" ] pub mod dpllsyncbusy {
# [ doc = "Reader of register DPLLSYNCBUSY" ] pub type R = crate :: R < u8 , super :: DPLLSYNCBUSY > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DPLLRATIO`" ] pub type DPLLRATIO_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DPLLPRESC`" ] pub type DPLLPRESC_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 1 - DPLL Enable Synchronization Status" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - DPLL Ratio Synchronization Status" ] # [ inline ( always ) ] pub fn dpllratio ( & self ) -> DPLLRATIO_R { DPLLRATIO_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - DPLL Prescaler Synchronization Status" ] # [ inline ( always ) ] pub fn dpllpresc ( & self ) -> DPLLPRESC_R { DPLLPRESC_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "DPLL Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dpllstatus](dpllstatus) module" ] pub type DPLLSTATUS = crate :: Reg < u8 , _DPLLSTATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DPLLSTATUS ;
# [ doc = "`read()` method returns [dpllstatus::R](dpllstatus::R) reader structure" ] impl crate :: Readable for DPLLSTATUS { }
# [ doc = "DPLL Status" ] pub mod dpllstatus {
# [ doc = "Reader of register DPLLSTATUS" ] pub type R = crate :: R < u8 , super :: DPLLSTATUS > ;
# [ doc = "Reader of field `LOCK`" ] pub type LOCK_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CLKRDY`" ] pub type CLKRDY_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - DPLL Lock Status" ] # [ inline ( always ) ] pub fn lock ( & self ) -> LOCK_R { LOCK_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - DPLL Clock Ready" ] # [ inline ( always ) ] pub fn clkrdy ( & self ) -> CLKRDY_R { CLKRDY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "48MHz Oscillator Calibration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cal48m](cal48m) module" ] pub type CAL48M = crate :: Reg < u32 , _CAL48M > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CAL48M ;
# [ doc = "`read()` method returns [cal48m::R](cal48m::R) reader structure" ] impl crate :: Readable for CAL48M { }
# [ doc = "`write(|w| ..)` method takes [cal48m::W](cal48m::W) writer structure" ] impl crate :: Writable for CAL48M { }
# [ doc = "48MHz Oscillator Calibration" ] pub mod cal48m {
# [ doc = "Reader of register CAL48M" ] pub type R = crate :: R < u32 , super :: CAL48M > ;
# [ doc = "Writer for register CAL48M" ] pub type W = crate :: W < u32 , super :: CAL48M > ;
# [ doc = "Register CAL48M `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CAL48M { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FCAL`" ] pub type FCAL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FCAL`" ] pub struct FCAL_W < 'a > { w : & 'a mut W , } impl < 'a > FCAL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } }
# [ doc = "Reader of field `FRANGE`" ] pub type FRANGE_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FRANGE`" ] pub struct FRANGE_W < 'a > { w : & 'a mut W , } impl < 'a > FRANGE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `TCAL`" ] pub type TCAL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `TCAL`" ] pub struct TCAL_W < 'a > { w : & 'a mut W , } impl < 'a > TCAL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 16 ) ) | ( ( ( value as u32 ) & 0x3f ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Frequency Calibration (48MHz)" ] # [ inline ( always ) ] pub fn fcal ( & self ) -> FCAL_R { FCAL_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 8:9 - Frequency Range (48MHz)" ] # [ inline ( always ) ] pub fn frange ( & self ) -> FRANGE_R { FRANGE_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 16:21 - Temperature Calibration (48MHz)" ] # [ inline ( always ) ] pub fn tcal ( & self ) -> TCAL_R { TCAL_R :: new ( ( ( self . bits >> 16 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:5 - Frequency Calibration (48MHz)" ] # [ inline ( always ) ] pub fn fcal ( & mut self ) -> FCAL_W { FCAL_W { w : self } }
# [ doc = "Bits 8:9 - Frequency Range (48MHz)" ] # [ inline ( always ) ] pub fn frange ( & mut self ) -> FRANGE_W { FRANGE_W { w : self } }
# [ doc = "Bits 16:21 - Temperature Calibration (48MHz)" ] # [ inline ( always ) ] pub fn tcal ( & mut self ) -> TCAL_W { TCAL_W { w : self } }
}
}
}
# [ doc = "32k Oscillators Control" ] pub struct OSC32KCTRL { _marker : PhantomData < * const ( ) > } unsafe impl Send for OSC32KCTRL { } impl OSC32KCTRL { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const osc32kctrl :: RegisterBlock { 0x4000_1400 as * const _ } } impl Deref for OSC32KCTRL { type Target = osc32kctrl :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * OSC32KCTRL :: ptr ( ) } } }
# [ doc = "32k Oscillators Control" ] pub mod osc32kctrl {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x04 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x08 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x0c - Power and Clocks Status" ] pub status : STATUS , # [ doc = "0x10 - Clock selection" ] pub rtcctrl : RTCCTRL , # [ doc = "0x14 - 32kHz External Crystal Oscillator (XOSC32K) Control" ] pub xosc32k : XOSC32K , # [ doc = "0x16 - Clock Failure Detector Control" ] pub cfdctrl : CFDCTRL , # [ doc = "0x17 - Event Control" ] pub evctrl : EVCTRL , # [ doc = "0x18 - 32kHz Internal Oscillator (OSC32K) Control" ] pub osc32k : OSC32K , # [ doc = "0x1c - 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control" ] pub osculp32k : OSCULP32K , }
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u32 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u32 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u32 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `XOSC32KRDY`" ] pub type XOSC32KRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XOSC32KRDY`" ] pub struct XOSC32KRDY_W < 'a > { w : & 'a mut W , } impl < 'a > XOSC32KRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OSC32KRDY`" ] pub type OSC32KRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSC32KRDY`" ] pub struct OSC32KRDY_W < 'a > { w : & 'a mut W , } impl < 'a > OSC32KRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CLKFAIL`" ] pub type CLKFAIL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CLKFAIL`" ] pub struct CLKFAIL_W < 'a > { w : & 'a mut W , } impl < 'a > CLKFAIL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - XOSC32K Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn xosc32krdy ( & self ) -> XOSC32KRDY_R { XOSC32KRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - OSC32K Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn osc32krdy ( & self ) -> OSC32KRDY_R { OSC32KRDY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - XOSC32K Clock Failure Detector Interrupt Enable" ] # [ inline ( always ) ] pub fn clkfail ( & self ) -> CLKFAIL_R { CLKFAIL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - XOSC32K Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn xosc32krdy ( & mut self ) -> XOSC32KRDY_W { XOSC32KRDY_W { w : self } }
# [ doc = "Bit 1 - OSC32K Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn osc32krdy ( & mut self ) -> OSC32KRDY_W { OSC32KRDY_W { w : self } }
# [ doc = "Bit 2 - XOSC32K Clock Failure Detector Interrupt Enable" ] # [ inline ( always ) ] pub fn clkfail ( & mut self ) -> CLKFAIL_W { CLKFAIL_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u32 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u32 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u32 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `XOSC32KRDY`" ] pub type XOSC32KRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XOSC32KRDY`" ] pub struct XOSC32KRDY_W < 'a > { w : & 'a mut W , } impl < 'a > XOSC32KRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OSC32KRDY`" ] pub type OSC32KRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSC32KRDY`" ] pub struct OSC32KRDY_W < 'a > { w : & 'a mut W , } impl < 'a > OSC32KRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CLKFAIL`" ] pub type CLKFAIL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CLKFAIL`" ] pub struct CLKFAIL_W < 'a > { w : & 'a mut W , } impl < 'a > CLKFAIL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - XOSC32K Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn xosc32krdy ( & self ) -> XOSC32KRDY_R { XOSC32KRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - OSC32K Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn osc32krdy ( & self ) -> OSC32KRDY_R { OSC32KRDY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - XOSC32K Clock Failure Detector Interrupt Enable" ] # [ inline ( always ) ] pub fn clkfail ( & self ) -> CLKFAIL_R { CLKFAIL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - XOSC32K Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn xosc32krdy ( & mut self ) -> XOSC32KRDY_W { XOSC32KRDY_W { w : self } }
# [ doc = "Bit 1 - OSC32K Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn osc32krdy ( & mut self ) -> OSC32KRDY_W { OSC32KRDY_W { w : self } }
# [ doc = "Bit 2 - XOSC32K Clock Failure Detector Interrupt Enable" ] # [ inline ( always ) ] pub fn clkfail ( & mut self ) -> CLKFAIL_W { CLKFAIL_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u32 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u32 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u32 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `XOSC32KRDY`" ] pub type XOSC32KRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XOSC32KRDY`" ] pub struct XOSC32KRDY_W < 'a > { w : & 'a mut W , } impl < 'a > XOSC32KRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OSC32KRDY`" ] pub type OSC32KRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSC32KRDY`" ] pub struct OSC32KRDY_W < 'a > { w : & 'a mut W , } impl < 'a > OSC32KRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CLKFAIL`" ] pub type CLKFAIL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CLKFAIL`" ] pub struct CLKFAIL_W < 'a > { w : & 'a mut W , } impl < 'a > CLKFAIL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - XOSC32K Ready" ] # [ inline ( always ) ] pub fn xosc32krdy ( & self ) -> XOSC32KRDY_R { XOSC32KRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - OSC32K Ready" ] # [ inline ( always ) ] pub fn osc32krdy ( & self ) -> OSC32KRDY_R { OSC32KRDY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - XOSC32K Clock Failure Detector" ] # [ inline ( always ) ] pub fn clkfail ( & self ) -> CLKFAIL_R { CLKFAIL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - XOSC32K Ready" ] # [ inline ( always ) ] pub fn xosc32krdy ( & mut self ) -> XOSC32KRDY_W { XOSC32KRDY_W { w : self } }
# [ doc = "Bit 1 - OSC32K Ready" ] # [ inline ( always ) ] pub fn osc32krdy ( & mut self ) -> OSC32KRDY_W { OSC32KRDY_W { w : self } }
# [ doc = "Bit 2 - XOSC32K Clock Failure Detector" ] # [ inline ( always ) ] pub fn clkfail ( & mut self ) -> CLKFAIL_W { CLKFAIL_W { w : self } }
}
}
# [ doc = "Power and Clocks Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u32 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ;
# [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { }
# [ doc = "Power and Clocks Status" ] pub mod status {
# [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u32 , super :: STATUS > ;
# [ doc = "Reader of field `XOSC32KRDY`" ] pub type XOSC32KRDY_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `OSC32KRDY`" ] pub type OSC32KRDY_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CLKFAIL`" ] pub type CLKFAIL_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CLKSW`" ] pub type CLKSW_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - XOSC32K Ready" ] # [ inline ( always ) ] pub fn xosc32krdy ( & self ) -> XOSC32KRDY_R { XOSC32KRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - OSC32K Ready" ] # [ inline ( always ) ] pub fn osc32krdy ( & self ) -> OSC32KRDY_R { OSC32KRDY_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - XOSC32K Clock Failure Detector" ] # [ inline ( always ) ] pub fn clkfail ( & self ) -> CLKFAIL_R { CLKFAIL_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - XOSC32K Clock switch" ] # [ inline ( always ) ] pub fn clksw ( & self ) -> CLKSW_R { CLKSW_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Clock selection\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rtcctrl](rtcctrl) module" ] pub type RTCCTRL = crate :: Reg < u32 , _RTCCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RTCCTRL ;
# [ doc = "`read()` method returns [rtcctrl::R](rtcctrl::R) reader structure" ] impl crate :: Readable for RTCCTRL { }
# [ doc = "`write(|w| ..)` method takes [rtcctrl::W](rtcctrl::W) writer structure" ] impl crate :: Writable for RTCCTRL { }
# [ doc = "Clock selection" ] pub mod rtcctrl {
# [ doc = "Reader of register RTCCTRL" ] pub type R = crate :: R < u32 , super :: RTCCTRL > ;
# [ doc = "Writer for register RTCCTRL" ] pub type W = crate :: W < u32 , super :: RTCCTRL > ;
# [ doc = "Register RTCCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RTCCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `RTCSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RTCSEL_A { # [ doc = "1.024kHz from 32kHz internal ULP oscillator" ] ULP1K , # [ doc = "32.768kHz from 32kHz internal ULP oscillator" ] ULP32K , # [ doc = "1.024kHz from 32.768kHz internal oscillator" ] OSC1K , # [ doc = "32.768kHz from 32.768kHz internal oscillator" ] OSC32K , # [ doc = "1.024kHz from 32.768kHz internal oscillator" ] XOSC1K , # [ doc = "32.768kHz from 32.768kHz external crystal oscillator" ] XOSC32K }
impl crate :: ToBits < u8 > for RTCSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { RTCSEL_A :: ULP1K => 0 , RTCSEL_A :: ULP32K => 1 , RTCSEL_A :: OSC1K => 2 , RTCSEL_A :: OSC32K => 3 , RTCSEL_A :: XOSC1K => 4 , RTCSEL_A :: XOSC32K => 5 } } }
# [ doc = "Reader of field `RTCSEL`" ] pub type RTCSEL_R = crate :: R < u8 , RTCSEL_A > ; impl RTCSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , RTCSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( RTCSEL_A :: ULP1K ) , 1 => Val ( RTCSEL_A :: ULP32K ) , 2 => Val ( RTCSEL_A :: OSC1K ) , 3 => Val ( RTCSEL_A :: OSC32K ) , 4 => Val ( RTCSEL_A :: XOSC1K ) , 5 => Val ( RTCSEL_A :: XOSC32K ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `ULP1K`" ] # [ inline ( always ) ] pub fn is_ulp1k ( & self ) -> bool { * self == RTCSEL_A :: ULP1K } # [ doc = "Checks if the value of the field is `ULP32K`" ] # [ inline ( always ) ] pub fn is_ulp32k ( & self ) -> bool { * self == RTCSEL_A :: ULP32K } # [ doc = "Checks if the value of the field is `OSC1K`" ] # [ inline ( always ) ] pub fn is_osc1k ( & self ) -> bool { * self == RTCSEL_A :: OSC1K } # [ doc = "Checks if the value of the field is `OSC32K`" ] # [ inline ( always ) ] pub fn is_osc32k ( & self ) -> bool { * self == RTCSEL_A :: OSC32K } # [ doc = "Checks if the value of the field is `XOSC1K`" ] # [ inline ( always ) ] pub fn is_xosc1k ( & self ) -> bool { * self == RTCSEL_A :: XOSC1K } # [ doc = "Checks if the value of the field is `XOSC32K`" ] # [ inline ( always ) ] pub fn is_xosc32k ( & self ) -> bool { * self == RTCSEL_A :: XOSC32K } }
# [ doc = "Write proxy for field `RTCSEL`" ] pub struct RTCSEL_W < 'a > { w : & 'a mut W , } impl < 'a > RTCSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RTCSEL_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "1.024kHz from 32kHz internal ULP oscillator" ] # [ inline ( always ) ] pub fn ulp1k ( self ) -> & 'a mut W { self . variant ( RTCSEL_A :: ULP1K ) } # [ doc = "32.768kHz from 32kHz internal ULP oscillator" ] # [ inline ( always ) ] pub fn ulp32k ( self ) -> & 'a mut W { self . variant ( RTCSEL_A :: ULP32K ) } # [ doc = "1.024kHz from 32.768kHz internal oscillator" ] # [ inline ( always ) ] pub fn osc1k ( self ) -> & 'a mut W { self . variant ( RTCSEL_A :: OSC1K ) } # [ doc = "32.768kHz from 32.768kHz internal oscillator" ] # [ inline ( always ) ] pub fn osc32k ( self ) -> & 'a mut W { self . variant ( RTCSEL_A :: OSC32K ) } # [ doc = "1.024kHz from 32.768kHz internal oscillator" ] # [ inline ( always ) ] pub fn xosc1k ( self ) -> & 'a mut W { self . variant ( RTCSEL_A :: XOSC1K ) } # [ doc = "32.768kHz from 32.768kHz external crystal oscillator" ] # [ inline ( always ) ] pub fn xosc32k ( self ) -> & 'a mut W { self . variant ( RTCSEL_A :: XOSC32K ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - RTC Clock Selection" ] # [ inline ( always ) ] pub fn rtcsel ( & self ) -> RTCSEL_R { RTCSEL_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - RTC Clock Selection" ] # [ inline ( always ) ] pub fn rtcsel ( & mut self ) -> RTCSEL_W { RTCSEL_W { w : self } }
}
}
# [ doc = "32kHz External Crystal Oscillator (XOSC32K) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [xosc32k](xosc32k) module" ] pub type XOSC32K = crate :: Reg < u16 , _XOSC32K > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _XOSC32K ;
# [ doc = "`read()` method returns [xosc32k::R](xosc32k::R) reader structure" ] impl crate :: Readable for XOSC32K { }
# [ doc = "`write(|w| ..)` method takes [xosc32k::W](xosc32k::W) writer structure" ] impl crate :: Writable for XOSC32K { }
# [ doc = "32kHz External Crystal Oscillator (XOSC32K) Control" ] pub mod xosc32k {
# [ doc = "Reader of register XOSC32K" ] pub type R = crate :: R < u16 , super :: XOSC32K > ;
# [ doc = "Writer for register XOSC32K" ] pub type W = crate :: W < u16 , super :: XOSC32K > ;
# [ doc = "Register XOSC32K `reset()`'s with value 0x80" ] impl crate :: ResetValue for super :: XOSC32K { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x80 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `XTALEN`" ] pub type XTALEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `XTALEN`" ] pub struct XTALEN_W < 'a > { w : & 'a mut W , } impl < 'a > XTALEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `EN32K`" ] pub type EN32K_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EN32K`" ] pub struct EN32K_W < 'a > { w : & 'a mut W , } impl < 'a > EN32K_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `EN1K`" ] pub type EN1K_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EN1K`" ] pub struct EN1K_W < 'a > { w : & 'a mut W , } impl < 'a > EN1K_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `STARTUP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STARTUP_A { # [ doc = "0.122 ms" ] CYCLE1 , # [ doc = "1.068 ms" ] CYCLE32 , # [ doc = "62.6 ms" ] CYCLE2048 , # [ doc = "125 ms" ] CYCLE4096 , # [ doc = "500 ms" ] CYCLE16384 , # [ doc = "1000 ms" ] CYCLE32768 , # [ doc = "2000 ms" ] CYCLE65536 , # [ doc = "4000 ms" ] CYCLE131072 }
impl crate :: ToBits < u8 > for STARTUP_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { STARTUP_A :: CYCLE1 => 0 , STARTUP_A :: CYCLE32 => 1 , STARTUP_A :: CYCLE2048 => 2 , STARTUP_A :: CYCLE4096 => 3 , STARTUP_A :: CYCLE16384 => 4 , STARTUP_A :: CYCLE32768 => 5 , STARTUP_A :: CYCLE65536 => 6 , STARTUP_A :: CYCLE131072 => 7 } } }
# [ doc = "Reader of field `STARTUP`" ] pub type STARTUP_R = crate :: R < u8 , STARTUP_A > ; impl STARTUP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> STARTUP_A { match self . bits { 0 => STARTUP_A :: CYCLE1 , 1 => STARTUP_A :: CYCLE32 , 2 => STARTUP_A :: CYCLE2048 , 3 => STARTUP_A :: CYCLE4096 , 4 => STARTUP_A :: CYCLE16384 , 5 => STARTUP_A :: CYCLE32768 , 6 => STARTUP_A :: CYCLE65536 , 7 => STARTUP_A :: CYCLE131072 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CYCLE1`" ] # [ inline ( always ) ] pub fn is_cycle1 ( & self ) -> bool { * self == STARTUP_A :: CYCLE1 } # [ doc = "Checks if the value of the field is `CYCLE32`" ] # [ inline ( always ) ] pub fn is_cycle32 ( & self ) -> bool { * self == STARTUP_A :: CYCLE32 } # [ doc = "Checks if the value of the field is `CYCLE2048`" ] # [ inline ( always ) ] pub fn is_cycle2048 ( & self ) -> bool { * self == STARTUP_A :: CYCLE2048 } # [ doc = "Checks if the value of the field is `CYCLE4096`" ] # [ inline ( always ) ] pub fn is_cycle4096 ( & self ) -> bool { * self == STARTUP_A :: CYCLE4096 } # [ doc = "Checks if the value of the field is `CYCLE16384`" ] # [ inline ( always ) ] pub fn is_cycle16384 ( & self ) -> bool { * self == STARTUP_A :: CYCLE16384 } # [ doc = "Checks if the value of the field is `CYCLE32768`" ] # [ inline ( always ) ] pub fn is_cycle32768 ( & self ) -> bool { * self == STARTUP_A :: CYCLE32768 } # [ doc = "Checks if the value of the field is `CYCLE65536`" ] # [ inline ( always ) ] pub fn is_cycle65536 ( & self ) -> bool { * self == STARTUP_A :: CYCLE65536 } # [ doc = "Checks if the value of the field is `CYCLE131072`" ] # [ inline ( always ) ] pub fn is_cycle131072 ( & self ) -> bool { * self == STARTUP_A :: CYCLE131072 } }
# [ doc = "Write proxy for field `STARTUP`" ] pub struct STARTUP_W < 'a > { w : & 'a mut W , } impl < 'a > STARTUP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : STARTUP_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "0.122 ms" ] # [ inline ( always ) ] pub fn cycle1 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE1 ) } # [ doc = "1.068 ms" ] # [ inline ( always ) ] pub fn cycle32 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE32 ) } # [ doc = "62.6 ms" ] # [ inline ( always ) ] pub fn cycle2048 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE2048 ) } # [ doc = "125 ms" ] # [ inline ( always ) ] pub fn cycle4096 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE4096 ) } # [ doc = "500 ms" ] # [ inline ( always ) ] pub fn cycle16384 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE16384 ) } # [ doc = "1000 ms" ] # [ inline ( always ) ] pub fn cycle32768 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE32768 ) } # [ doc = "2000 ms" ] # [ inline ( always ) ] pub fn cycle65536 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE65536 ) } # [ doc = "4000 ms" ] # [ inline ( always ) ] pub fn cycle131072 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE131072 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `WRTLOCK`" ] pub type WRTLOCK_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WRTLOCK`" ] pub struct WRTLOCK_W < 'a > { w : & 'a mut W , } impl < 'a > WRTLOCK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Oscillator Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Crystal Oscillator Enable" ] # [ inline ( always ) ] pub fn xtalen ( & self ) -> XTALEN_R { XTALEN_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - 32kHz Output Enable" ] # [ inline ( always ) ] pub fn en32k ( & self ) -> EN32K_R { EN32K_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - 1kHz Output Enable" ] # [ inline ( always ) ] pub fn en1k ( & self ) -> EN1K_R { EN1K_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Oscillator Start-Up Time" ] # [ inline ( always ) ] pub fn startup ( & self ) -> STARTUP_R { STARTUP_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 12 - Write Lock" ] # [ inline ( always ) ] pub fn wrtlock ( & self ) -> WRTLOCK_R { WRTLOCK_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Oscillator Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 2 - Crystal Oscillator Enable" ] # [ inline ( always ) ] pub fn xtalen ( & mut self ) -> XTALEN_W { XTALEN_W { w : self } }
# [ doc = "Bit 3 - 32kHz Output Enable" ] # [ inline ( always ) ] pub fn en32k ( & mut self ) -> EN32K_W { EN32K_W { w : self } }
# [ doc = "Bit 4 - 1kHz Output Enable" ] # [ inline ( always ) ] pub fn en1k ( & mut self ) -> EN1K_W { EN1K_W { w : self } }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } }
# [ doc = "Bits 8:10 - Oscillator Start-Up Time" ] # [ inline ( always ) ] pub fn startup ( & mut self ) -> STARTUP_W { STARTUP_W { w : self } }
# [ doc = "Bit 12 - Write Lock" ] # [ inline ( always ) ] pub fn wrtlock ( & mut self ) -> WRTLOCK_W { WRTLOCK_W { w : self } }
}
}
# [ doc = "Clock Failure Detector Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cfdctrl](cfdctrl) module" ] pub type CFDCTRL = crate :: Reg < u8 , _CFDCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CFDCTRL ;
# [ doc = "`read()` method returns [cfdctrl::R](cfdctrl::R) reader structure" ] impl crate :: Readable for CFDCTRL { }
# [ doc = "`write(|w| ..)` method takes [cfdctrl::W](cfdctrl::W) writer structure" ] impl crate :: Writable for CFDCTRL { }
# [ doc = "Clock Failure Detector Control" ] pub mod cfdctrl {
# [ doc = "Reader of register CFDCTRL" ] pub type R = crate :: R < u8 , super :: CFDCTRL > ;
# [ doc = "Writer for register CFDCTRL" ] pub type W = crate :: W < u8 , super :: CFDCTRL > ;
# [ doc = "Register CFDCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CFDCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CFDEN`" ] pub type CFDEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFDEN`" ] pub struct CFDEN_W < 'a > { w : & 'a mut W , } impl < 'a > CFDEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `SWBACK`" ] pub type SWBACK_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWBACK`" ] pub struct SWBACK_W < 'a > { w : & 'a mut W , } impl < 'a > SWBACK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CFDPRESC`" ] pub type CFDPRESC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFDPRESC`" ] pub struct CFDPRESC_W < 'a > { w : & 'a mut W , } impl < 'a > CFDPRESC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Clock Failure Detector Enable" ] # [ inline ( always ) ] pub fn cfden ( & self ) -> CFDEN_R { CFDEN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Clock Switch Back" ] # [ inline ( always ) ] pub fn swback ( & self ) -> SWBACK_R { SWBACK_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Clock Failure Detector Prescaler" ] # [ inline ( always ) ] pub fn cfdpresc ( & self ) -> CFDPRESC_R { CFDPRESC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Clock Failure Detector Enable" ] # [ inline ( always ) ] pub fn cfden ( & mut self ) -> CFDEN_W { CFDEN_W { w : self } }
# [ doc = "Bit 1 - Clock Switch Back" ] # [ inline ( always ) ] pub fn swback ( & mut self ) -> SWBACK_W { SWBACK_W { w : self } }
# [ doc = "Bit 2 - Clock Failure Detector Prescaler" ] # [ inline ( always ) ] pub fn cfdpresc ( & mut self ) -> CFDPRESC_W { CFDPRESC_W { w : self } }
}
}
# [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u8 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event Control" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u8 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u8 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CFDEO`" ] pub type CFDEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CFDEO`" ] pub struct CFDEO_W < 'a > { w : & 'a mut W , } impl < 'a > CFDEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Clock Failure Detector Event Output Enable" ] # [ inline ( always ) ] pub fn cfdeo ( & self ) -> CFDEO_R { CFDEO_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Clock Failure Detector Event Output Enable" ] # [ inline ( always ) ] pub fn cfdeo ( & mut self ) -> CFDEO_W { CFDEO_W { w : self } }
}
}
# [ doc = "32kHz Internal Oscillator (OSC32K) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [osc32k](osc32k) module" ] pub type OSC32K = crate :: Reg < u32 , _OSC32K > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OSC32K ;
# [ doc = "`read()` method returns [osc32k::R](osc32k::R) reader structure" ] impl crate :: Readable for OSC32K { }
# [ doc = "`write(|w| ..)` method takes [osc32k::W](osc32k::W) writer structure" ] impl crate :: Writable for OSC32K { }
# [ doc = "32kHz Internal Oscillator (OSC32K) Control" ] pub mod osc32k {
# [ doc = "Reader of register OSC32K" ] pub type R = crate :: R < u32 , super :: OSC32K > ;
# [ doc = "Writer for register OSC32K" ] pub type W = crate :: W < u32 , super :: OSC32K > ;
# [ doc = "Register OSC32K `reset()`'s with value 0x003f_0080" ] impl crate :: ResetValue for super :: OSC32K { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x003f_0080 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `EN32K`" ] pub type EN32K_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EN32K`" ] pub struct EN32K_W < 'a > { w : & 'a mut W , } impl < 'a > EN32K_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `EN1K`" ] pub type EN1K_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EN1K`" ] pub struct EN1K_W < 'a > { w : & 'a mut W , } impl < 'a > EN1K_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `STARTUP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STARTUP_A { # [ doc = "0.092 ms" ] CYCLE3 , # [ doc = "0.122 ms" ] CYCLE4 , # [ doc = "0.183 ms" ] CYCLE6 , # [ doc = "0.305 ms" ] CYCLE10 , # [ doc = "0.549 ms" ] CYCLE18 , # [ doc = "1.038 ms" ] CYCLE34 , # [ doc = "2.014 ms" ] CYCLE66 , # [ doc = "3.967 ms" ] CYCLE130 }
impl crate :: ToBits < u8 > for STARTUP_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { STARTUP_A :: CYCLE3 => 0 , STARTUP_A :: CYCLE4 => 1 , STARTUP_A :: CYCLE6 => 2 , STARTUP_A :: CYCLE10 => 3 , STARTUP_A :: CYCLE18 => 4 , STARTUP_A :: CYCLE34 => 5 , STARTUP_A :: CYCLE66 => 6 , STARTUP_A :: CYCLE130 => 7 } } }
# [ doc = "Reader of field `STARTUP`" ] pub type STARTUP_R = crate :: R < u8 , STARTUP_A > ; impl STARTUP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> STARTUP_A { match self . bits { 0 => STARTUP_A :: CYCLE3 , 1 => STARTUP_A :: CYCLE4 , 2 => STARTUP_A :: CYCLE6 , 3 => STARTUP_A :: CYCLE10 , 4 => STARTUP_A :: CYCLE18 , 5 => STARTUP_A :: CYCLE34 , 6 => STARTUP_A :: CYCLE66 , 7 => STARTUP_A :: CYCLE130 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CYCLE3`" ] # [ inline ( always ) ] pub fn is_cycle3 ( & self ) -> bool { * self == STARTUP_A :: CYCLE3 } # [ doc = "Checks if the value of the field is `CYCLE4`" ] # [ inline ( always ) ] pub fn is_cycle4 ( & self ) -> bool { * self == STARTUP_A :: CYCLE4 } # [ doc = "Checks if the value of the field is `CYCLE6`" ] # [ inline ( always ) ] pub fn is_cycle6 ( & self ) -> bool { * self == STARTUP_A :: CYCLE6 } # [ doc = "Checks if the value of the field is `CYCLE10`" ] # [ inline ( always ) ] pub fn is_cycle10 ( & self ) -> bool { * self == STARTUP_A :: CYCLE10 } # [ doc = "Checks if the value of the field is `CYCLE18`" ] # [ inline ( always ) ] pub fn is_cycle18 ( & self ) -> bool { * self == STARTUP_A :: CYCLE18 } # [ doc = "Checks if the value of the field is `CYCLE34`" ] # [ inline ( always ) ] pub fn is_cycle34 ( & self ) -> bool { * self == STARTUP_A :: CYCLE34 } # [ doc = "Checks if the value of the field is `CYCLE66`" ] # [ inline ( always ) ] pub fn is_cycle66 ( & self ) -> bool { * self == STARTUP_A :: CYCLE66 } # [ doc = "Checks if the value of the field is `CYCLE130`" ] # [ inline ( always ) ] pub fn is_cycle130 ( & self ) -> bool { * self == STARTUP_A :: CYCLE130 } }
# [ doc = "Write proxy for field `STARTUP`" ] pub struct STARTUP_W < 'a > { w : & 'a mut W , } impl < 'a > STARTUP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : STARTUP_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "0.092 ms" ] # [ inline ( always ) ] pub fn cycle3 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE3 ) } # [ doc = "0.122 ms" ] # [ inline ( always ) ] pub fn cycle4 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE4 ) } # [ doc = "0.183 ms" ] # [ inline ( always ) ] pub fn cycle6 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE6 ) } # [ doc = "0.305 ms" ] # [ inline ( always ) ] pub fn cycle10 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE10 ) } # [ doc = "0.549 ms" ] # [ inline ( always ) ] pub fn cycle18 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE18 ) } # [ doc = "1.038 ms" ] # [ inline ( always ) ] pub fn cycle34 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE34 ) } # [ doc = "2.014 ms" ] # [ inline ( always ) ] pub fn cycle66 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE66 ) } # [ doc = "3.967 ms" ] # [ inline ( always ) ] pub fn cycle130 ( self ) -> & 'a mut W { self . variant ( STARTUP_A :: CYCLE130 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u32 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `WRTLOCK`" ] pub type WRTLOCK_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WRTLOCK`" ] pub struct WRTLOCK_W < 'a > { w : & 'a mut W , } impl < 'a > WRTLOCK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `CALIB`" ] pub type CALIB_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `CALIB`" ] pub struct CALIB_W < 'a > { w : & 'a mut W , } impl < 'a > CALIB_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x7f << 16 ) ) | ( ( ( value as u32 ) & 0x7f ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Oscillator Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - 32kHz Output Enable" ] # [ inline ( always ) ] pub fn en32k ( & self ) -> EN32K_R { EN32K_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - 1kHz Output Enable" ] # [ inline ( always ) ] pub fn en1k ( & self ) -> EN1K_R { EN1K_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:10 - Oscillator Start-Up Time" ] # [ inline ( always ) ] pub fn startup ( & self ) -> STARTUP_R { STARTUP_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 12 - Write Lock" ] # [ inline ( always ) ] pub fn wrtlock ( & self ) -> WRTLOCK_R { WRTLOCK_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:22 - Oscillator Calibration" ] # [ inline ( always ) ] pub fn calib ( & self ) -> CALIB_R { CALIB_R :: new ( ( ( self . bits >> 16 ) & 0x7f ) as u8 ) }
}
impl W {
# [ doc = "Bit 1 - Oscillator Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 2 - 32kHz Output Enable" ] # [ inline ( always ) ] pub fn en32k ( & mut self ) -> EN32K_W { EN32K_W { w : self } }
# [ doc = "Bit 3 - 1kHz Output Enable" ] # [ inline ( always ) ] pub fn en1k ( & mut self ) -> EN1K_W { EN1K_W { w : self } }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } }
# [ doc = "Bits 8:10 - Oscillator Start-Up Time" ] # [ inline ( always ) ] pub fn startup ( & mut self ) -> STARTUP_W { STARTUP_W { w : self } }
# [ doc = "Bit 12 - Write Lock" ] # [ inline ( always ) ] pub fn wrtlock ( & mut self ) -> WRTLOCK_W { WRTLOCK_W { w : self } }
# [ doc = "Bits 16:22 - Oscillator Calibration" ] # [ inline ( always ) ] pub fn calib ( & mut self ) -> CALIB_W { CALIB_W { w : self } }
}
}
# [ doc = "32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [osculp32k](osculp32k) module" ] pub type OSCULP32K = crate :: Reg < u32 , _OSCULP32K > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OSCULP32K ;
# [ doc = "`read()` method returns [osculp32k::R](osculp32k::R) reader structure" ] impl crate :: Readable for OSCULP32K { }
# [ doc = "`write(|w| ..)` method takes [osculp32k::W](osculp32k::W) writer structure" ] impl crate :: Writable for OSCULP32K { }
# [ doc = "32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control" ] pub mod osculp32k {
# [ doc = "Reader of register OSCULP32K" ] pub type R = crate :: R < u32 , super :: OSCULP32K > ;
# [ doc = "Writer for register OSCULP32K" ] pub type W = crate :: W < u32 , super :: OSCULP32K > ;
# [ doc = "Register OSCULP32K `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OSCULP32K { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CALIB`" ] pub type CALIB_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `CALIB`" ] pub struct CALIB_W < 'a > { w : & 'a mut W , } impl < 'a > CALIB_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 8 ) ) | ( ( ( value as u32 ) & 0x1f ) << 8 ) ; self . w } }
# [ doc = "Reader of field `WRTLOCK`" ] pub type WRTLOCK_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WRTLOCK`" ] pub struct WRTLOCK_W < 'a > { w : & 'a mut W , } impl < 'a > WRTLOCK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bits 8:12 - Oscillator Calibration" ] # [ inline ( always ) ] pub fn calib ( & self ) -> CALIB_R { CALIB_R :: new ( ( ( self . bits >> 8 ) & 0x1f ) as u8 ) }
# [ doc = "Bit 15 - Write Lock" ] # [ inline ( always ) ] pub fn wrtlock ( & self ) -> WRTLOCK_R { WRTLOCK_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 8:12 - Oscillator Calibration" ] # [ inline ( always ) ] pub fn calib ( & mut self ) -> CALIB_W { CALIB_W { w : self } }
# [ doc = "Bit 15 - Write Lock" ] # [ inline ( always ) ] pub fn wrtlock ( & mut self ) -> WRTLOCK_W { WRTLOCK_W { w : self } }
}
}
}
# [ doc = "Peripheral Access Controller" ] pub struct PAC { _marker : PhantomData < * const ( ) > } unsafe impl Send for PAC { } impl PAC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const pac :: RegisterBlock { 0x4000_0000 as * const _ } } impl Deref for PAC { type Target = pac :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * PAC :: ptr ( ) } } }
# [ doc = "Peripheral Access Controller" ] pub mod pac {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Write control" ] pub wrctrl : WRCTRL , # [ doc = "0x04 - Event control" ] pub evctrl : EVCTRL , _reserved2 : [ u8 ; 3usize ] , # [ doc = "0x08 - Interrupt enable clear" ] pub intenclr : INTENCLR , # [ doc = "0x09 - Interrupt enable set" ] pub intenset : INTENSET , _reserved4 : [ u8 ; 6usize ] , # [ doc = "0x10 - Bridge interrupt flag status" ] pub intflagahb : INTFLAGAHB , # [ doc = "0x14 - Peripheral interrupt flag status - Bridge A" ] pub intflaga : INTFLAGA , # [ doc = "0x18 - Peripheral interrupt flag status - Bridge B" ] pub intflagb : INTFLAGB , # [ doc = "0x1c - Peripheral interrupt flag status - Bridge C" ] pub intflagc : INTFLAGC , # [ doc = "0x20 - Peripheral interrupt flag status - Bridge D" ] pub intflagd : INTFLAGD , _reserved9 : [ u8 ; 16usize ] , # [ doc = "0x34 - Peripheral write protection status - Bridge A" ] pub statusa : STATUSA , # [ doc = "0x38 - Peripheral write protection status - Bridge B" ] pub statusb : STATUSB , # [ doc = "0x3c - Peripheral write protection status - Bridge C" ] pub statusc : STATUSC , # [ doc = "0x40 - Peripheral write protection status - Bridge D" ] pub statusd : STATUSD , }
# [ doc = "Write control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [wrctrl](wrctrl) module" ] pub type WRCTRL = crate :: Reg < u32 , _WRCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WRCTRL ;
# [ doc = "`read()` method returns [wrctrl::R](wrctrl::R) reader structure" ] impl crate :: Readable for WRCTRL { }
# [ doc = "`write(|w| ..)` method takes [wrctrl::W](wrctrl::W) writer structure" ] impl crate :: Writable for WRCTRL { }
# [ doc = "Write control" ] pub mod wrctrl {
# [ doc = "Reader of register WRCTRL" ] pub type R = crate :: R < u32 , super :: WRCTRL > ;
# [ doc = "Writer for register WRCTRL" ] pub type W = crate :: W < u32 , super :: WRCTRL > ;
# [ doc = "Register WRCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WRCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `PERID`" ] pub type PERID_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `PERID`" ] pub struct PERID_W < 'a > { w : & 'a mut W , } impl < 'a > PERID_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } }
# [ doc = "Possible values of the field `KEY`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum KEY_A { # [ doc = "No action" ] OFF , # [ doc = "Clear protection" ] CLR , # [ doc = "Set protection" ] SET , # [ doc = "Set and lock protection" ] SETLCK }
impl crate :: ToBits < u8 > for KEY_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { KEY_A :: OFF => 0 , KEY_A :: CLR => 1 , KEY_A :: SET => 2 , KEY_A :: SETLCK => 3 } } }
# [ doc = "Reader of field `KEY`" ] pub type KEY_R = crate :: R < u8 , KEY_A > ; impl KEY_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , KEY_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( KEY_A :: OFF ) , 1 => Val ( KEY_A :: CLR ) , 2 => Val ( KEY_A :: SET ) , 3 => Val ( KEY_A :: SETLCK ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == KEY_A :: OFF } # [ doc = "Checks if the value of the field is `CLR`" ] # [ inline ( always ) ] pub fn is_clr ( & self ) -> bool { * self == KEY_A :: CLR } # [ doc = "Checks if the value of the field is `SET`" ] # [ inline ( always ) ] pub fn is_set ( & self ) -> bool { * self == KEY_A :: SET } # [ doc = "Checks if the value of the field is `SETLCK`" ] # [ inline ( always ) ] pub fn is_setlck ( & self ) -> bool { * self == KEY_A :: SETLCK } }
# [ doc = "Write proxy for field `KEY`" ] pub struct KEY_W < 'a > { w : & 'a mut W , } impl < 'a > KEY_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : KEY_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( KEY_A :: OFF ) } # [ doc = "Clear protection" ] # [ inline ( always ) ] pub fn clr ( self ) -> & 'a mut W { self . variant ( KEY_A :: CLR ) } # [ doc = "Set protection" ] # [ inline ( always ) ] pub fn set ( self ) -> & 'a mut W { self . variant ( KEY_A :: SET ) } # [ doc = "Set and lock protection" ] # [ inline ( always ) ] pub fn setlck ( self ) -> & 'a mut W { self . variant ( KEY_A :: SETLCK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bits 0:15 - Peripheral identifier" ] # [ inline ( always ) ] pub fn perid ( & self ) -> PERID_R { PERID_R :: new ( ( self . bits & 0xffff ) as u16 ) }
# [ doc = "Bits 16:23 - Peripheral access control key" ] # [ inline ( always ) ] pub fn key ( & self ) -> KEY_R { KEY_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:15 - Peripheral identifier" ] # [ inline ( always ) ] pub fn perid ( & mut self ) -> PERID_W { PERID_W { w : self } }
# [ doc = "Bits 16:23 - Peripheral access control key" ] # [ inline ( always ) ] pub fn key ( & mut self ) -> KEY_W { KEY_W { w : self } }
}
}
# [ doc = "Event control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u8 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event control" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u8 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u8 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ERREO`" ] pub type ERREO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ERREO`" ] pub struct ERREO_W < 'a > { w : & 'a mut W , } impl < 'a > ERREO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Peripheral acess error event output" ] # [ inline ( always ) ] pub fn erreo ( & self ) -> ERREO_R { ERREO_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Peripheral acess error event output" ] # [ inline ( always ) ] pub fn erreo ( & mut self ) -> ERREO_W { ERREO_W { w : self } }
}
}
# [ doc = "Interrupt enable clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt enable clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Peripheral access error interrupt disable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Peripheral access error interrupt disable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } }
}
}
# [ doc = "Interrupt enable set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt enable set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Peripheral access error interrupt enable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Peripheral access error interrupt enable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } }
}
}
# [ doc = "Bridge interrupt flag status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflagahb](intflagahb) module" ] pub type INTFLAGAHB = crate :: Reg < u32 , _INTFLAGAHB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAGAHB ;
# [ doc = "`read()` method returns [intflagahb::R](intflagahb::R) reader structure" ] impl crate :: Readable for INTFLAGAHB { }
# [ doc = "`write(|w| ..)` method takes [intflagahb::W](intflagahb::W) writer structure" ] impl crate :: Writable for INTFLAGAHB { }
# [ doc = "Bridge interrupt flag status" ] pub mod intflagahb {
# [ doc = "Reader of register INTFLAGAHB" ] pub type R = crate :: R < u32 , super :: INTFLAGAHB > ;
# [ doc = "Writer for register INTFLAGAHB" ] pub type W = crate :: W < u32 , super :: INTFLAGAHB > ;
# [ doc = "Register INTFLAGAHB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAGAHB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FLASH_`" ] pub type FLASH__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FLASH_`" ] pub struct FLASH__W < 'a > { w : & 'a mut W , } impl < 'a > FLASH__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `HSRAMCM0P_`" ] pub type HSRAMCM0P__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HSRAMCM0P_`" ] pub struct HSRAMCM0P__W < 'a > { w : & 'a mut W , } impl < 'a > HSRAMCM0P__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `HSRAMDSU_`" ] pub type HSRAMDSU__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HSRAMDSU_`" ] pub struct HSRAMDSU__W < 'a > { w : & 'a mut W , } impl < 'a > HSRAMDSU__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `HPB1_`" ] pub type HPB1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPB1_`" ] pub struct HPB1__W < 'a > { w : & 'a mut W , } impl < 'a > HPB1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `HPB0_`" ] pub type HPB0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPB0_`" ] pub struct HPB0__W < 'a > { w : & 'a mut W , } impl < 'a > HPB0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `HPB2_`" ] pub type HPB2__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPB2_`" ] pub struct HPB2__W < 'a > { w : & 'a mut W , } impl < 'a > HPB2__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `LPRAMDMAC_`" ] pub type LPRAMDMAC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LPRAMDMAC_`" ] pub struct LPRAMDMAC__W < 'a > { w : & 'a mut W , } impl < 'a > LPRAMDMAC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `DIVAS_`" ] pub type DIVAS__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DIVAS_`" ] pub struct DIVAS__W < 'a > { w : & 'a mut W , } impl < 'a > DIVAS__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `HPB3_`" ] pub type HPB3__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HPB3_`" ] pub struct HPB3__W < 'a > { w : & 'a mut W , } impl < 'a > HPB3__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - FLASH" ] # [ inline ( always ) ] pub fn flash_ ( & self ) -> FLASH__R { FLASH__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - HSRAMCM0P" ] # [ inline ( always ) ] pub fn hsramcm0p_ ( & self ) -> HSRAMCM0P__R { HSRAMCM0P__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - HSRAMDSU" ] # [ inline ( always ) ] pub fn hsramdsu_ ( & self ) -> HSRAMDSU__R { HSRAMDSU__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - HPB1" ] # [ inline ( always ) ] pub fn hpb1_ ( & self ) -> HPB1__R { HPB1__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - HPB0" ] # [ inline ( always ) ] pub fn hpb0_ ( & self ) -> HPB0__R { HPB0__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - HPB2" ] # [ inline ( always ) ] pub fn hpb2_ ( & self ) -> HPB2__R { HPB2__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - LPRAMDMAC" ] # [ inline ( always ) ] pub fn lpramdmac_ ( & self ) -> LPRAMDMAC__R { LPRAMDMAC__R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - DIVAS" ] # [ inline ( always ) ] pub fn divas_ ( & self ) -> DIVAS__R { DIVAS__R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - HPB3" ] # [ inline ( always ) ] pub fn hpb3_ ( & self ) -> HPB3__R { HPB3__R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - FLASH" ] # [ inline ( always ) ] pub fn flash_ ( & mut self ) -> FLASH__W { FLASH__W { w : self } }
# [ doc = "Bit 1 - HSRAMCM0P" ] # [ inline ( always ) ] pub fn hsramcm0p_ ( & mut self ) -> HSRAMCM0P__W { HSRAMCM0P__W { w : self } }
# [ doc = "Bit 2 - HSRAMDSU" ] # [ inline ( always ) ] pub fn hsramdsu_ ( & mut self ) -> HSRAMDSU__W { HSRAMDSU__W { w : self } }
# [ doc = "Bit 3 - HPB1" ] # [ inline ( always ) ] pub fn hpb1_ ( & mut self ) -> HPB1__W { HPB1__W { w : self } }
# [ doc = "Bit 4 - HPB0" ] # [ inline ( always ) ] pub fn hpb0_ ( & mut self ) -> HPB0__W { HPB0__W { w : self } }
# [ doc = "Bit 5 - HPB2" ] # [ inline ( always ) ] pub fn hpb2_ ( & mut self ) -> HPB2__W { HPB2__W { w : self } }
# [ doc = "Bit 6 - LPRAMDMAC" ] # [ inline ( always ) ] pub fn lpramdmac_ ( & mut self ) -> LPRAMDMAC__W { LPRAMDMAC__W { w : self } }
# [ doc = "Bit 7 - DIVAS" ] # [ inline ( always ) ] pub fn divas_ ( & mut self ) -> DIVAS__W { DIVAS__W { w : self } }
# [ doc = "Bit 8 - HPB3" ] # [ inline ( always ) ] pub fn hpb3_ ( & mut self ) -> HPB3__W { HPB3__W { w : self } }
}
}
# [ doc = "Peripheral interrupt flag status - Bridge A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflaga](intflaga) module" ] pub type INTFLAGA = crate :: Reg < u32 , _INTFLAGA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAGA ;
# [ doc = "`read()` method returns [intflaga::R](intflaga::R) reader structure" ] impl crate :: Readable for INTFLAGA { }
# [ doc = "`write(|w| ..)` method takes [intflaga::W](intflaga::W) writer structure" ] impl crate :: Writable for INTFLAGA { }
# [ doc = "Peripheral interrupt flag status - Bridge A" ] pub mod intflaga {
# [ doc = "Reader of register INTFLAGA" ] pub type R = crate :: R < u32 , super :: INTFLAGA > ;
# [ doc = "Writer for register INTFLAGA" ] pub type W = crate :: W < u32 , super :: INTFLAGA > ;
# [ doc = "Register INTFLAGA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAGA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `PAC_`" ] pub type PAC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PAC_`" ] pub struct PAC__W < 'a > { w : & 'a mut W , } impl < 'a > PAC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `PM_`" ] pub type PM__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PM_`" ] pub struct PM__W < 'a > { w : & 'a mut W , } impl < 'a > PM__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `MCLK_`" ] pub type MCLK__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCLK_`" ] pub struct MCLK__W < 'a > { w : & 'a mut W , } impl < 'a > MCLK__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `RSTC_`" ] pub type RSTC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RSTC_`" ] pub struct RSTC__W < 'a > { w : & 'a mut W , } impl < 'a > RSTC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `OSCCTRL_`" ] pub type OSCCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSCCTRL_`" ] pub struct OSCCTRL__W < 'a > { w : & 'a mut W , } impl < 'a > OSCCTRL__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `OSC32KCTRL_`" ] pub type OSC32KCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OSC32KCTRL_`" ] pub struct OSC32KCTRL__W < 'a > { w : & 'a mut W , } impl < 'a > OSC32KCTRL__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `SUPC_`" ] pub type SUPC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SUPC_`" ] pub struct SUPC__W < 'a > { w : & 'a mut W , } impl < 'a > SUPC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `GCLK_`" ] pub type GCLK__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `GCLK_`" ] pub struct GCLK__W < 'a > { w : & 'a mut W , } impl < 'a > GCLK__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `WDT_`" ] pub type WDT__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WDT_`" ] pub struct WDT__W < 'a > { w : & 'a mut W , } impl < 'a > WDT__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `RTC_`" ] pub type RTC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RTC_`" ] pub struct RTC__W < 'a > { w : & 'a mut W , } impl < 'a > RTC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `EIC_`" ] pub type EIC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EIC_`" ] pub struct EIC__W < 'a > { w : & 'a mut W , } impl < 'a > EIC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `FREQM_`" ] pub type FREQM__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FREQM_`" ] pub struct FREQM__W < 'a > { w : & 'a mut W , } impl < 'a > FREQM__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `TSENS_`" ] pub type TSENS__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TSENS_`" ] pub struct TSENS__W < 'a > { w : & 'a mut W , } impl < 'a > TSENS__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - PAC" ] # [ inline ( always ) ] pub fn pac_ ( & self ) -> PAC__R { PAC__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - PM" ] # [ inline ( always ) ] pub fn pm_ ( & self ) -> PM__R { PM__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - MCLK" ] # [ inline ( always ) ] pub fn mclk_ ( & self ) -> MCLK__R { MCLK__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - RSTC" ] # [ inline ( always ) ] pub fn rstc_ ( & self ) -> RSTC__R { RSTC__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - OSCCTRL" ] # [ inline ( always ) ] pub fn oscctrl_ ( & self ) -> OSCCTRL__R { OSCCTRL__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - OSC32KCTRL" ] # [ inline ( always ) ] pub fn osc32kctrl_ ( & self ) -> OSC32KCTRL__R { OSC32KCTRL__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SUPC" ] # [ inline ( always ) ] pub fn supc_ ( & self ) -> SUPC__R { SUPC__R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - GCLK" ] # [ inline ( always ) ] pub fn gclk_ ( & self ) -> GCLK__R { GCLK__R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - WDT" ] # [ inline ( always ) ] pub fn wdt_ ( & self ) -> WDT__R { WDT__R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - RTC" ] # [ inline ( always ) ] pub fn rtc_ ( & self ) -> RTC__R { RTC__R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - EIC" ] # [ inline ( always ) ] pub fn eic_ ( & self ) -> EIC__R { EIC__R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - FREQM" ] # [ inline ( always ) ] pub fn freqm_ ( & self ) -> FREQM__R { FREQM__R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - TSENS" ] # [ inline ( always ) ] pub fn tsens_ ( & self ) -> TSENS__R { TSENS__R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - PAC" ] # [ inline ( always ) ] pub fn pac_ ( & mut self ) -> PAC__W { PAC__W { w : self } }
# [ doc = "Bit 1 - PM" ] # [ inline ( always ) ] pub fn pm_ ( & mut self ) -> PM__W { PM__W { w : self } }
# [ doc = "Bit 2 - MCLK" ] # [ inline ( always ) ] pub fn mclk_ ( & mut self ) -> MCLK__W { MCLK__W { w : self } }
# [ doc = "Bit 3 - RSTC" ] # [ inline ( always ) ] pub fn rstc_ ( & mut self ) -> RSTC__W { RSTC__W { w : self } }
# [ doc = "Bit 4 - OSCCTRL" ] # [ inline ( always ) ] pub fn oscctrl_ ( & mut self ) -> OSCCTRL__W { OSCCTRL__W { w : self } }
# [ doc = "Bit 5 - OSC32KCTRL" ] # [ inline ( always ) ] pub fn osc32kctrl_ ( & mut self ) -> OSC32KCTRL__W { OSC32KCTRL__W { w : self } }
# [ doc = "Bit 6 - SUPC" ] # [ inline ( always ) ] pub fn supc_ ( & mut self ) -> SUPC__W { SUPC__W { w : self } }
# [ doc = "Bit 7 - GCLK" ] # [ inline ( always ) ] pub fn gclk_ ( & mut self ) -> GCLK__W { GCLK__W { w : self } }
# [ doc = "Bit 8 - WDT" ] # [ inline ( always ) ] pub fn wdt_ ( & mut self ) -> WDT__W { WDT__W { w : self } }
# [ doc = "Bit 9 - RTC" ] # [ inline ( always ) ] pub fn rtc_ ( & mut self ) -> RTC__W { RTC__W { w : self } }
# [ doc = "Bit 10 - EIC" ] # [ inline ( always ) ] pub fn eic_ ( & mut self ) -> EIC__W { EIC__W { w : self } }
# [ doc = "Bit 11 - FREQM" ] # [ inline ( always ) ] pub fn freqm_ ( & mut self ) -> FREQM__W { FREQM__W { w : self } }
# [ doc = "Bit 12 - TSENS" ] # [ inline ( always ) ] pub fn tsens_ ( & mut self ) -> TSENS__W { TSENS__W { w : self } }
}
}
# [ doc = "Peripheral interrupt flag status - Bridge B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflagb](intflagb) module" ] pub type INTFLAGB = crate :: Reg < u32 , _INTFLAGB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAGB ;
# [ doc = "`read()` method returns [intflagb::R](intflagb::R) reader structure" ] impl crate :: Readable for INTFLAGB { }
# [ doc = "`write(|w| ..)` method takes [intflagb::W](intflagb::W) writer structure" ] impl crate :: Writable for INTFLAGB { }
# [ doc = "Peripheral interrupt flag status - Bridge B" ] pub mod intflagb {
# [ doc = "Reader of register INTFLAGB" ] pub type R = crate :: R < u32 , super :: INTFLAGB > ;
# [ doc = "Writer for register INTFLAGB" ] pub type W = crate :: W < u32 , super :: INTFLAGB > ;
# [ doc = "Register INTFLAGB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAGB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `PORT_`" ] pub type PORT__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PORT_`" ] pub struct PORT__W < 'a > { w : & 'a mut W , } impl < 'a > PORT__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `DSU_`" ] pub type DSU__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DSU_`" ] pub struct DSU__W < 'a > { w : & 'a mut W , } impl < 'a > DSU__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `NVMCTRL_`" ] pub type NVMCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NVMCTRL_`" ] pub struct NVMCTRL__W < 'a > { w : & 'a mut W , } impl < 'a > NVMCTRL__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `DMAC_`" ] pub type DMAC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DMAC_`" ] pub struct DMAC__W < 'a > { w : & 'a mut W , } impl < 'a > DMAC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `MTB_`" ] pub type MTB__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MTB_`" ] pub struct MTB__W < 'a > { w : & 'a mut W , } impl < 'a > MTB__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `HMATRIXHS_`" ] pub type HMATRIXHS__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HMATRIXHS_`" ] pub struct HMATRIXHS__W < 'a > { w : & 'a mut W , } impl < 'a > HMATRIXHS__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - PORT" ] # [ inline ( always ) ] pub fn port_ ( & self ) -> PORT__R { PORT__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - DSU" ] # [ inline ( always ) ] pub fn dsu_ ( & self ) -> DSU__R { DSU__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - NVMCTRL" ] # [ inline ( always ) ] pub fn nvmctrl_ ( & self ) -> NVMCTRL__R { NVMCTRL__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - DMAC" ] # [ inline ( always ) ] pub fn dmac_ ( & self ) -> DMAC__R { DMAC__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - MTB" ] # [ inline ( always ) ] pub fn mtb_ ( & self ) -> MTB__R { MTB__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - HMATRIXHS" ] # [ inline ( always ) ] pub fn hmatrixhs_ ( & self ) -> HMATRIXHS__R { HMATRIXHS__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - PORT" ] # [ inline ( always ) ] pub fn port_ ( & mut self ) -> PORT__W { PORT__W { w : self } }
# [ doc = "Bit 1 - DSU" ] # [ inline ( always ) ] pub fn dsu_ ( & mut self ) -> DSU__W { DSU__W { w : self } }
# [ doc = "Bit 2 - NVMCTRL" ] # [ inline ( always ) ] pub fn nvmctrl_ ( & mut self ) -> NVMCTRL__W { NVMCTRL__W { w : self } }
# [ doc = "Bit 3 - DMAC" ] # [ inline ( always ) ] pub fn dmac_ ( & mut self ) -> DMAC__W { DMAC__W { w : self } }
# [ doc = "Bit 4 - MTB" ] # [ inline ( always ) ] pub fn mtb_ ( & mut self ) -> MTB__W { MTB__W { w : self } }
# [ doc = "Bit 5 - HMATRIXHS" ] # [ inline ( always ) ] pub fn hmatrixhs_ ( & mut self ) -> HMATRIXHS__W { HMATRIXHS__W { w : self } }
}
}
# [ doc = "Peripheral interrupt flag status - Bridge C\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflagc](intflagc) module" ] pub type INTFLAGC = crate :: Reg < u32 , _INTFLAGC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAGC ;
# [ doc = "`read()` method returns [intflagc::R](intflagc::R) reader structure" ] impl crate :: Readable for INTFLAGC { }
# [ doc = "`write(|w| ..)` method takes [intflagc::W](intflagc::W) writer structure" ] impl crate :: Writable for INTFLAGC { }
# [ doc = "Peripheral interrupt flag status - Bridge C" ] pub mod intflagc {
# [ doc = "Reader of register INTFLAGC" ] pub type R = crate :: R < u32 , super :: INTFLAGC > ;
# [ doc = "Writer for register INTFLAGC" ] pub type W = crate :: W < u32 , super :: INTFLAGC > ;
# [ doc = "Register INTFLAGC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAGC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EVSYS_`" ] pub type EVSYS__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EVSYS_`" ] pub struct EVSYS__W < 'a > { w : & 'a mut W , } impl < 'a > EVSYS__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `SERCOM0_`" ] pub type SERCOM0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM0_`" ] pub struct SERCOM0__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `SERCOM1_`" ] pub type SERCOM1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM1_`" ] pub struct SERCOM1__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `SERCOM2_`" ] pub type SERCOM2__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM2_`" ] pub struct SERCOM2__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM2__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `SERCOM3_`" ] pub type SERCOM3__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM3_`" ] pub struct SERCOM3__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM3__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `SERCOM4_`" ] pub type SERCOM4__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM4_`" ] pub struct SERCOM4__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM4__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `SERCOM5_`" ] pub type SERCOM5__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM5_`" ] pub struct SERCOM5__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM5__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `CAN0_`" ] pub type CAN0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CAN0_`" ] pub struct CAN0__W < 'a > { w : & 'a mut W , } impl < 'a > CAN0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `CAN1_`" ] pub type CAN1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CAN1_`" ] pub struct CAN1__W < 'a > { w : & 'a mut W , } impl < 'a > CAN1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `TCC0_`" ] pub type TCC0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCC0_`" ] pub struct TCC0__W < 'a > { w : & 'a mut W , } impl < 'a > TCC0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `TCC1_`" ] pub type TCC1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCC1_`" ] pub struct TCC1__W < 'a > { w : & 'a mut W , } impl < 'a > TCC1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `TCC2_`" ] pub type TCC2__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCC2_`" ] pub struct TCC2__W < 'a > { w : & 'a mut W , } impl < 'a > TCC2__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `TC0_`" ] pub type TC0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC0_`" ] pub struct TC0__W < 'a > { w : & 'a mut W , } impl < 'a > TC0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `TC1_`" ] pub type TC1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC1_`" ] pub struct TC1__W < 'a > { w : & 'a mut W , } impl < 'a > TC1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `TC2_`" ] pub type TC2__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC2_`" ] pub struct TC2__W < 'a > { w : & 'a mut W , } impl < 'a > TC2__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `TC3_`" ] pub type TC3__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC3_`" ] pub struct TC3__W < 'a > { w : & 'a mut W , } impl < 'a > TC3__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `TC4_`" ] pub type TC4__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC4_`" ] pub struct TC4__W < 'a > { w : & 'a mut W , } impl < 'a > TC4__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `ADC0_`" ] pub type ADC0__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ADC0_`" ] pub struct ADC0__W < 'a > { w : & 'a mut W , } impl < 'a > ADC0__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `ADC1_`" ] pub type ADC1__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ADC1_`" ] pub struct ADC1__W < 'a > { w : & 'a mut W , } impl < 'a > ADC1__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `SDADC_`" ] pub type SDADC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SDADC_`" ] pub struct SDADC__W < 'a > { w : & 'a mut W , } impl < 'a > SDADC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `AC_`" ] pub type AC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `AC_`" ] pub struct AC__W < 'a > { w : & 'a mut W , } impl < 'a > AC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `DAC_`" ] pub type DAC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DAC_`" ] pub struct DAC__W < 'a > { w : & 'a mut W , } impl < 'a > DAC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `PTC_`" ] pub type PTC__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PTC_`" ] pub struct PTC__W < 'a > { w : & 'a mut W , } impl < 'a > PTC__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `CCL_`" ] pub type CCL__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CCL_`" ] pub struct CCL__W < 'a > { w : & 'a mut W , } impl < 'a > CCL__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - EVSYS" ] # [ inline ( always ) ] pub fn evsys_ ( & self ) -> EVSYS__R { EVSYS__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SERCOM0" ] # [ inline ( always ) ] pub fn sercom0_ ( & self ) -> SERCOM0__R { SERCOM0__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SERCOM1" ] # [ inline ( always ) ] pub fn sercom1_ ( & self ) -> SERCOM1__R { SERCOM1__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - SERCOM2" ] # [ inline ( always ) ] pub fn sercom2_ ( & self ) -> SERCOM2__R { SERCOM2__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - SERCOM3" ] # [ inline ( always ) ] pub fn sercom3_ ( & self ) -> SERCOM3__R { SERCOM3__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - SERCOM4" ] # [ inline ( always ) ] pub fn sercom4_ ( & self ) -> SERCOM4__R { SERCOM4__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SERCOM5" ] # [ inline ( always ) ] pub fn sercom5_ ( & self ) -> SERCOM5__R { SERCOM5__R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - CAN0" ] # [ inline ( always ) ] pub fn can0_ ( & self ) -> CAN0__R { CAN0__R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - CAN1" ] # [ inline ( always ) ] pub fn can1_ ( & self ) -> CAN1__R { CAN1__R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - TCC0" ] # [ inline ( always ) ] pub fn tcc0_ ( & self ) -> TCC0__R { TCC0__R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - TCC1" ] # [ inline ( always ) ] pub fn tcc1_ ( & self ) -> TCC1__R { TCC1__R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - TCC2" ] # [ inline ( always ) ] pub fn tcc2_ ( & self ) -> TCC2__R { TCC2__R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - TC0" ] # [ inline ( always ) ] pub fn tc0_ ( & self ) -> TC0__R { TC0__R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - TC1" ] # [ inline ( always ) ] pub fn tc1_ ( & self ) -> TC1__R { TC1__R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - TC2" ] # [ inline ( always ) ] pub fn tc2_ ( & self ) -> TC2__R { TC2__R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - TC3" ] # [ inline ( always ) ] pub fn tc3_ ( & self ) -> TC3__R { TC3__R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - TC4" ] # [ inline ( always ) ] pub fn tc4_ ( & self ) -> TC4__R { TC4__R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - ADC0" ] # [ inline ( always ) ] pub fn adc0_ ( & self ) -> ADC0__R { ADC0__R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - ADC1" ] # [ inline ( always ) ] pub fn adc1_ ( & self ) -> ADC1__R { ADC1__R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - SDADC" ] # [ inline ( always ) ] pub fn sdadc_ ( & self ) -> SDADC__R { SDADC__R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - AC" ] # [ inline ( always ) ] pub fn ac_ ( & self ) -> AC__R { AC__R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - DAC" ] # [ inline ( always ) ] pub fn dac_ ( & self ) -> DAC__R { DAC__R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - PTC" ] # [ inline ( always ) ] pub fn ptc_ ( & self ) -> PTC__R { PTC__R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - CCL" ] # [ inline ( always ) ] pub fn ccl_ ( & self ) -> CCL__R { CCL__R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - EVSYS" ] # [ inline ( always ) ] pub fn evsys_ ( & mut self ) -> EVSYS__W { EVSYS__W { w : self } }
# [ doc = "Bit 1 - SERCOM0" ] # [ inline ( always ) ] pub fn sercom0_ ( & mut self ) -> SERCOM0__W { SERCOM0__W { w : self } }
# [ doc = "Bit 2 - SERCOM1" ] # [ inline ( always ) ] pub fn sercom1_ ( & mut self ) -> SERCOM1__W { SERCOM1__W { w : self } }
# [ doc = "Bit 3 - SERCOM2" ] # [ inline ( always ) ] pub fn sercom2_ ( & mut self ) -> SERCOM2__W { SERCOM2__W { w : self } }
# [ doc = "Bit 4 - SERCOM3" ] # [ inline ( always ) ] pub fn sercom3_ ( & mut self ) -> SERCOM3__W { SERCOM3__W { w : self } }
# [ doc = "Bit 5 - SERCOM4" ] # [ inline ( always ) ] pub fn sercom4_ ( & mut self ) -> SERCOM4__W { SERCOM4__W { w : self } }
# [ doc = "Bit 6 - SERCOM5" ] # [ inline ( always ) ] pub fn sercom5_ ( & mut self ) -> SERCOM5__W { SERCOM5__W { w : self } }
# [ doc = "Bit 7 - CAN0" ] # [ inline ( always ) ] pub fn can0_ ( & mut self ) -> CAN0__W { CAN0__W { w : self } }
# [ doc = "Bit 8 - CAN1" ] # [ inline ( always ) ] pub fn can1_ ( & mut self ) -> CAN1__W { CAN1__W { w : self } }
# [ doc = "Bit 9 - TCC0" ] # [ inline ( always ) ] pub fn tcc0_ ( & mut self ) -> TCC0__W { TCC0__W { w : self } }
# [ doc = "Bit 10 - TCC1" ] # [ inline ( always ) ] pub fn tcc1_ ( & mut self ) -> TCC1__W { TCC1__W { w : self } }
# [ doc = "Bit 11 - TCC2" ] # [ inline ( always ) ] pub fn tcc2_ ( & mut self ) -> TCC2__W { TCC2__W { w : self } }
# [ doc = "Bit 12 - TC0" ] # [ inline ( always ) ] pub fn tc0_ ( & mut self ) -> TC0__W { TC0__W { w : self } }
# [ doc = "Bit 13 - TC1" ] # [ inline ( always ) ] pub fn tc1_ ( & mut self ) -> TC1__W { TC1__W { w : self } }
# [ doc = "Bit 14 - TC2" ] # [ inline ( always ) ] pub fn tc2_ ( & mut self ) -> TC2__W { TC2__W { w : self } }
# [ doc = "Bit 15 - TC3" ] # [ inline ( always ) ] pub fn tc3_ ( & mut self ) -> TC3__W { TC3__W { w : self } }
# [ doc = "Bit 16 - TC4" ] # [ inline ( always ) ] pub fn tc4_ ( & mut self ) -> TC4__W { TC4__W { w : self } }
# [ doc = "Bit 17 - ADC0" ] # [ inline ( always ) ] pub fn adc0_ ( & mut self ) -> ADC0__W { ADC0__W { w : self } }
# [ doc = "Bit 18 - ADC1" ] # [ inline ( always ) ] pub fn adc1_ ( & mut self ) -> ADC1__W { ADC1__W { w : self } }
# [ doc = "Bit 19 - SDADC" ] # [ inline ( always ) ] pub fn sdadc_ ( & mut self ) -> SDADC__W { SDADC__W { w : self } }
# [ doc = "Bit 20 - AC" ] # [ inline ( always ) ] pub fn ac_ ( & mut self ) -> AC__W { AC__W { w : self } }
# [ doc = "Bit 21 - DAC" ] # [ inline ( always ) ] pub fn dac_ ( & mut self ) -> DAC__W { DAC__W { w : self } }
# [ doc = "Bit 22 - PTC" ] # [ inline ( always ) ] pub fn ptc_ ( & mut self ) -> PTC__W { PTC__W { w : self } }
# [ doc = "Bit 23 - CCL" ] # [ inline ( always ) ] pub fn ccl_ ( & mut self ) -> CCL__W { CCL__W { w : self } }
}
}
# [ doc = "Peripheral interrupt flag status - Bridge D\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflagd](intflagd) module" ] pub type INTFLAGD = crate :: Reg < u32 , _INTFLAGD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAGD ;
# [ doc = "`read()` method returns [intflagd::R](intflagd::R) reader structure" ] impl crate :: Readable for INTFLAGD { }
# [ doc = "`write(|w| ..)` method takes [intflagd::W](intflagd::W) writer structure" ] impl crate :: Writable for INTFLAGD { }
# [ doc = "Peripheral interrupt flag status - Bridge D" ] pub mod intflagd {
# [ doc = "Reader of register INTFLAGD" ] pub type R = crate :: R < u32 , super :: INTFLAGD > ;
# [ doc = "Writer for register INTFLAGD" ] pub type W = crate :: W < u32 , super :: INTFLAGD > ;
# [ doc = "Register INTFLAGD `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAGD { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SERCOM6_`" ] pub type SERCOM6__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM6_`" ] pub struct SERCOM6__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM6__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `SERCOM7_`" ] pub type SERCOM7__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SERCOM7_`" ] pub struct SERCOM7__W < 'a > { w : & 'a mut W , } impl < 'a > SERCOM7__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `TC5_`" ] pub type TC5__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC5_`" ] pub struct TC5__W < 'a > { w : & 'a mut W , } impl < 'a > TC5__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `TC6_`" ] pub type TC6__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC6_`" ] pub struct TC6__W < 'a > { w : & 'a mut W , } impl < 'a > TC6__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `TC7_`" ] pub type TC7__R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TC7_`" ] pub struct TC7__W < 'a > { w : & 'a mut W , } impl < 'a > TC7__W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SERCOM6" ] # [ inline ( always ) ] pub fn sercom6_ ( & self ) -> SERCOM6__R { SERCOM6__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SERCOM7" ] # [ inline ( always ) ] pub fn sercom7_ ( & self ) -> SERCOM7__R { SERCOM7__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TC5" ] # [ inline ( always ) ] pub fn tc5_ ( & self ) -> TC5__R { TC5__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - TC6" ] # [ inline ( always ) ] pub fn tc6_ ( & self ) -> TC6__R { TC6__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - TC7" ] # [ inline ( always ) ] pub fn tc7_ ( & self ) -> TC7__R { TC7__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SERCOM6" ] # [ inline ( always ) ] pub fn sercom6_ ( & mut self ) -> SERCOM6__W { SERCOM6__W { w : self } }
# [ doc = "Bit 1 - SERCOM7" ] # [ inline ( always ) ] pub fn sercom7_ ( & mut self ) -> SERCOM7__W { SERCOM7__W { w : self } }
# [ doc = "Bit 2 - TC5" ] # [ inline ( always ) ] pub fn tc5_ ( & mut self ) -> TC5__W { TC5__W { w : self } }
# [ doc = "Bit 3 - TC6" ] # [ inline ( always ) ] pub fn tc6_ ( & mut self ) -> TC6__W { TC6__W { w : self } }
# [ doc = "Bit 4 - TC7" ] # [ inline ( always ) ] pub fn tc7_ ( & mut self ) -> TC7__W { TC7__W { w : self } }
}
}
# [ doc = "Peripheral write protection status - Bridge A\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [statusa](statusa) module" ] pub type STATUSA = crate :: Reg < u32 , _STATUSA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUSA ;
# [ doc = "`read()` method returns [statusa::R](statusa::R) reader structure" ] impl crate :: Readable for STATUSA { }
# [ doc = "Peripheral write protection status - Bridge A" ] pub mod statusa {
# [ doc = "Reader of register STATUSA" ] pub type R = crate :: R < u32 , super :: STATUSA > ;
# [ doc = "Reader of field `PAC_`" ] pub type PAC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PM_`" ] pub type PM__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `MCLK_`" ] pub type MCLK__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `RSTC_`" ] pub type RSTC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `OSCCTRL_`" ] pub type OSCCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `OSC32KCTRL_`" ] pub type OSC32KCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SUPC_`" ] pub type SUPC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `GCLK_`" ] pub type GCLK__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WDT_`" ] pub type WDT__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `RTC_`" ] pub type RTC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `EIC_`" ] pub type EIC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `FREQM_`" ] pub type FREQM__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TSENS_`" ] pub type TSENS__R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - PAC APB Protect Enable" ] # [ inline ( always ) ] pub fn pac_ ( & self ) -> PAC__R { PAC__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - PM APB Protect Enable" ] # [ inline ( always ) ] pub fn pm_ ( & self ) -> PM__R { PM__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - MCLK APB Protect Enable" ] # [ inline ( always ) ] pub fn mclk_ ( & self ) -> MCLK__R { MCLK__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - RSTC APB Protect Enable" ] # [ inline ( always ) ] pub fn rstc_ ( & self ) -> RSTC__R { RSTC__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - OSCCTRL APB Protect Enable" ] # [ inline ( always ) ] pub fn oscctrl_ ( & self ) -> OSCCTRL__R { OSCCTRL__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - OSC32KCTRL APB Protect Enable" ] # [ inline ( always ) ] pub fn osc32kctrl_ ( & self ) -> OSC32KCTRL__R { OSC32KCTRL__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SUPC APB Protect Enable" ] # [ inline ( always ) ] pub fn supc_ ( & self ) -> SUPC__R { SUPC__R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - GCLK APB Protect Enable" ] # [ inline ( always ) ] pub fn gclk_ ( & self ) -> GCLK__R { GCLK__R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - WDT APB Protect Enable" ] # [ inline ( always ) ] pub fn wdt_ ( & self ) -> WDT__R { WDT__R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - RTC APB Protect Enable" ] # [ inline ( always ) ] pub fn rtc_ ( & self ) -> RTC__R { RTC__R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - EIC APB Protect Enable" ] # [ inline ( always ) ] pub fn eic_ ( & self ) -> EIC__R { EIC__R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - FREQM APB Protect Enable" ] # [ inline ( always ) ] pub fn freqm_ ( & self ) -> FREQM__R { FREQM__R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - TSENS APB Protect Enable" ] # [ inline ( always ) ] pub fn tsens_ ( & self ) -> TSENS__R { TSENS__R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Peripheral write protection status - Bridge B\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [statusb](statusb) module" ] pub type STATUSB = crate :: Reg < u32 , _STATUSB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUSB ;
# [ doc = "`read()` method returns [statusb::R](statusb::R) reader structure" ] impl crate :: Readable for STATUSB { }
# [ doc = "Peripheral write protection status - Bridge B" ] pub mod statusb {
# [ doc = "Reader of register STATUSB" ] pub type R = crate :: R < u32 , super :: STATUSB > ;
# [ doc = "Reader of field `PORT_`" ] pub type PORT__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DSU_`" ] pub type DSU__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `NVMCTRL_`" ] pub type NVMCTRL__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DMAC_`" ] pub type DMAC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `MTB_`" ] pub type MTB__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `HMATRIXHS_`" ] pub type HMATRIXHS__R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - PORT APB Protect Enable" ] # [ inline ( always ) ] pub fn port_ ( & self ) -> PORT__R { PORT__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - DSU APB Protect Enable" ] # [ inline ( always ) ] pub fn dsu_ ( & self ) -> DSU__R { DSU__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - NVMCTRL APB Protect Enable" ] # [ inline ( always ) ] pub fn nvmctrl_ ( & self ) -> NVMCTRL__R { NVMCTRL__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - DMAC APB Protect Enable" ] # [ inline ( always ) ] pub fn dmac_ ( & self ) -> DMAC__R { DMAC__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - MTB APB Protect Enable" ] # [ inline ( always ) ] pub fn mtb_ ( & self ) -> MTB__R { MTB__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - HMATRIXHS APB Protect Enable" ] # [ inline ( always ) ] pub fn hmatrixhs_ ( & self ) -> HMATRIXHS__R { HMATRIXHS__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Peripheral write protection status - Bridge C\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [statusc](statusc) module" ] pub type STATUSC = crate :: Reg < u32 , _STATUSC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUSC ;
# [ doc = "`read()` method returns [statusc::R](statusc::R) reader structure" ] impl crate :: Readable for STATUSC { }
# [ doc = "Peripheral write protection status - Bridge C" ] pub mod statusc {
# [ doc = "Reader of register STATUSC" ] pub type R = crate :: R < u32 , super :: STATUSC > ;
# [ doc = "Reader of field `EVSYS_`" ] pub type EVSYS__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SERCOM0_`" ] pub type SERCOM0__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SERCOM1_`" ] pub type SERCOM1__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SERCOM2_`" ] pub type SERCOM2__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SERCOM3_`" ] pub type SERCOM3__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SERCOM4_`" ] pub type SERCOM4__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SERCOM5_`" ] pub type SERCOM5__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CAN0_`" ] pub type CAN0__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CAN1_`" ] pub type CAN1__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TCC0_`" ] pub type TCC0__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TCC1_`" ] pub type TCC1__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TCC2_`" ] pub type TCC2__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TC0_`" ] pub type TC0__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TC1_`" ] pub type TC1__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TC2_`" ] pub type TC2__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TC3_`" ] pub type TC3__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TC4_`" ] pub type TC4__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ADC0_`" ] pub type ADC0__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ADC1_`" ] pub type ADC1__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SDADC_`" ] pub type SDADC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `AC_`" ] pub type AC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `DAC_`" ] pub type DAC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PTC_`" ] pub type PTC__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CCL_`" ] pub type CCL__R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - EVSYS APB Protect Enable" ] # [ inline ( always ) ] pub fn evsys_ ( & self ) -> EVSYS__R { EVSYS__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SERCOM0 APB Protect Enable" ] # [ inline ( always ) ] pub fn sercom0_ ( & self ) -> SERCOM0__R { SERCOM0__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - SERCOM1 APB Protect Enable" ] # [ inline ( always ) ] pub fn sercom1_ ( & self ) -> SERCOM1__R { SERCOM1__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - SERCOM2 APB Protect Enable" ] # [ inline ( always ) ] pub fn sercom2_ ( & self ) -> SERCOM2__R { SERCOM2__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - SERCOM3 APB Protect Enable" ] # [ inline ( always ) ] pub fn sercom3_ ( & self ) -> SERCOM3__R { SERCOM3__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - SERCOM4 APB Protect Enable" ] # [ inline ( always ) ] pub fn sercom4_ ( & self ) -> SERCOM4__R { SERCOM4__R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - SERCOM5 APB Protect Enable" ] # [ inline ( always ) ] pub fn sercom5_ ( & self ) -> SERCOM5__R { SERCOM5__R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - CAN0 APB Protect Enable" ] # [ inline ( always ) ] pub fn can0_ ( & self ) -> CAN0__R { CAN0__R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - CAN1 APB Protect Enable" ] # [ inline ( always ) ] pub fn can1_ ( & self ) -> CAN1__R { CAN1__R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - TCC0 APB Protect Enable" ] # [ inline ( always ) ] pub fn tcc0_ ( & self ) -> TCC0__R { TCC0__R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - TCC1 APB Protect Enable" ] # [ inline ( always ) ] pub fn tcc1_ ( & self ) -> TCC1__R { TCC1__R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - TCC2 APB Protect Enable" ] # [ inline ( always ) ] pub fn tcc2_ ( & self ) -> TCC2__R { TCC2__R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - TC0 APB Protect Enable" ] # [ inline ( always ) ] pub fn tc0_ ( & self ) -> TC0__R { TC0__R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - TC1 APB Protect Enable" ] # [ inline ( always ) ] pub fn tc1_ ( & self ) -> TC1__R { TC1__R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - TC2 APB Protect Enable" ] # [ inline ( always ) ] pub fn tc2_ ( & self ) -> TC2__R { TC2__R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - TC3 APB Protect Enable" ] # [ inline ( always ) ] pub fn tc3_ ( & self ) -> TC3__R { TC3__R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - TC4 APB Protect Enable" ] # [ inline ( always ) ] pub fn tc4_ ( & self ) -> TC4__R { TC4__R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - ADC0 APB Protect Enable" ] # [ inline ( always ) ] pub fn adc0_ ( & self ) -> ADC0__R { ADC0__R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - ADC1 APB Protect Enable" ] # [ inline ( always ) ] pub fn adc1_ ( & self ) -> ADC1__R { ADC1__R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - SDADC APB Protect Enable" ] # [ inline ( always ) ] pub fn sdadc_ ( & self ) -> SDADC__R { SDADC__R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - AC APB Protect Enable" ] # [ inline ( always ) ] pub fn ac_ ( & self ) -> AC__R { AC__R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - DAC APB Protect Enable" ] # [ inline ( always ) ] pub fn dac_ ( & self ) -> DAC__R { DAC__R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - PTC APB Protect Enable" ] # [ inline ( always ) ] pub fn ptc_ ( & self ) -> PTC__R { PTC__R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - CCL APB Protect Enable" ] # [ inline ( always ) ] pub fn ccl_ ( & self ) -> CCL__R { CCL__R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Peripheral write protection status - Bridge D\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [statusd](statusd) module" ] pub type STATUSD = crate :: Reg < u32 , _STATUSD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUSD ;
# [ doc = "`read()` method returns [statusd::R](statusd::R) reader structure" ] impl crate :: Readable for STATUSD { }
# [ doc = "Peripheral write protection status - Bridge D" ] pub mod statusd {
# [ doc = "Reader of register STATUSD" ] pub type R = crate :: R < u32 , super :: STATUSD > ;
# [ doc = "Reader of field `SERCOM6_`" ] pub type SERCOM6__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SERCOM7_`" ] pub type SERCOM7__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TC5_`" ] pub type TC5__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TC6_`" ] pub type TC6__R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `TC7_`" ] pub type TC7__R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - SERCOM6 APB Protect Enable" ] # [ inline ( always ) ] pub fn sercom6_ ( & self ) -> SERCOM6__R { SERCOM6__R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SERCOM7 APB Protect Enable" ] # [ inline ( always ) ] pub fn sercom7_ ( & self ) -> SERCOM7__R { SERCOM7__R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - TC5 APB Protect Enable" ] # [ inline ( always ) ] pub fn tc5_ ( & self ) -> TC5__R { TC5__R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - TC6 APB Protect Enable" ] # [ inline ( always ) ] pub fn tc6_ ( & self ) -> TC6__R { TC6__R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - TC7 APB Protect Enable" ] # [ inline ( always ) ] pub fn tc7_ ( & self ) -> TC7__R { TC7__R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
}
}
# [ doc = "Power Manager" ] pub struct PM { _marker : PhantomData < * const ( ) > } unsafe impl Send for PM { } impl PM { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const pm :: RegisterBlock { 0x4000_0400 as * const _ } } impl Deref for PM { type Target = pm :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * PM :: ptr ( ) } } }
# [ doc = "Power Manager" ] pub mod pm {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 1usize ] , # [ doc = "0x01 - Sleep Configuration" ] pub sleepcfg : SLEEPCFG , _reserved1 : [ u8 ; 6usize ] , # [ doc = "0x08 - Standby Configuration" ] pub stdbycfg : STDBYCFG , }
# [ doc = "Sleep Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [sleepcfg](sleepcfg) module" ] pub type SLEEPCFG = crate :: Reg < u8 , _SLEEPCFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SLEEPCFG ;
# [ doc = "`read()` method returns [sleepcfg::R](sleepcfg::R) reader structure" ] impl crate :: Readable for SLEEPCFG { }
# [ doc = "`write(|w| ..)` method takes [sleepcfg::W](sleepcfg::W) writer structure" ] impl crate :: Writable for SLEEPCFG { }
# [ doc = "Sleep Configuration" ] pub mod sleepcfg {
# [ doc = "Reader of register SLEEPCFG" ] pub type R = crate :: R < u8 , super :: SLEEPCFG > ;
# [ doc = "Writer for register SLEEPCFG" ] pub type W = crate :: W < u8 , super :: SLEEPCFG > ;
# [ doc = "Register SLEEPCFG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SLEEPCFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `SLEEPMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SLEEPMODE_A { # [ doc = "CPU clock is OFF" ] IDLE0 , # [ doc = "AHB clock is OFF" ] IDLE1 , # [ doc = "APB clock are OFF" ] IDLE2 , # [ doc = "All Clocks are OFF" ] STANDBY , # [ doc = "Only Backup domain is powered ON" ] BACKUP , # [ doc = "All power domains are powered OFF" ] OFF }
impl crate :: ToBits < u8 > for SLEEPMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SLEEPMODE_A :: IDLE0 => 0 , SLEEPMODE_A :: IDLE1 => 1 , SLEEPMODE_A :: IDLE2 => 2 , SLEEPMODE_A :: STANDBY => 4 , SLEEPMODE_A :: BACKUP => 5 , SLEEPMODE_A :: OFF => 6 } } }
# [ doc = "Reader of field `SLEEPMODE`" ] pub type SLEEPMODE_R = crate :: R < u8 , SLEEPMODE_A > ; impl SLEEPMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SLEEPMODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SLEEPMODE_A :: IDLE0 ) , 1 => Val ( SLEEPMODE_A :: IDLE1 ) , 2 => Val ( SLEEPMODE_A :: IDLE2 ) , 4 => Val ( SLEEPMODE_A :: STANDBY ) , 5 => Val ( SLEEPMODE_A :: BACKUP ) , 6 => Val ( SLEEPMODE_A :: OFF ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `IDLE0`" ] # [ inline ( always ) ] pub fn is_idle0 ( & self ) -> bool { * self == SLEEPMODE_A :: IDLE0 } # [ doc = "Checks if the value of the field is `IDLE1`" ] # [ inline ( always ) ] pub fn is_idle1 ( & self ) -> bool { * self == SLEEPMODE_A :: IDLE1 } # [ doc = "Checks if the value of the field is `IDLE2`" ] # [ inline ( always ) ] pub fn is_idle2 ( & self ) -> bool { * self == SLEEPMODE_A :: IDLE2 } # [ doc = "Checks if the value of the field is `STANDBY`" ] # [ inline ( always ) ] pub fn is_standby ( & self ) -> bool { * self == SLEEPMODE_A :: STANDBY } # [ doc = "Checks if the value of the field is `BACKUP`" ] # [ inline ( always ) ] pub fn is_backup ( & self ) -> bool { * self == SLEEPMODE_A :: BACKUP } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == SLEEPMODE_A :: OFF } }
# [ doc = "Write proxy for field `SLEEPMODE`" ] pub struct SLEEPMODE_W < 'a > { w : & 'a mut W , } impl < 'a > SLEEPMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SLEEPMODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CPU clock is OFF" ] # [ inline ( always ) ] pub fn idle0 ( self ) -> & 'a mut W { self . variant ( SLEEPMODE_A :: IDLE0 ) } # [ doc = "AHB clock is OFF" ] # [ inline ( always ) ] pub fn idle1 ( self ) -> & 'a mut W { self . variant ( SLEEPMODE_A :: IDLE1 ) } # [ doc = "APB clock are OFF" ] # [ inline ( always ) ] pub fn idle2 ( self ) -> & 'a mut W { self . variant ( SLEEPMODE_A :: IDLE2 ) } # [ doc = "All Clocks are OFF" ] # [ inline ( always ) ] pub fn standby ( self ) -> & 'a mut W { self . variant ( SLEEPMODE_A :: STANDBY ) } # [ doc = "Only Backup domain is powered ON" ] # [ inline ( always ) ] pub fn backup ( self ) -> & 'a mut W { self . variant ( SLEEPMODE_A :: BACKUP ) } # [ doc = "All power domains are powered OFF" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( SLEEPMODE_A :: OFF ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u8 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Sleep Mode" ] # [ inline ( always ) ] pub fn sleepmode ( & self ) -> SLEEPMODE_R { SLEEPMODE_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Sleep Mode" ] # [ inline ( always ) ] pub fn sleepmode ( & mut self ) -> SLEEPMODE_W { SLEEPMODE_W { w : self } }
}
}
# [ doc = "Standby Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [stdbycfg](stdbycfg) module" ] pub type STDBYCFG = crate :: Reg < u16 , _STDBYCFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STDBYCFG ;
# [ doc = "`read()` method returns [stdbycfg::R](stdbycfg::R) reader structure" ] impl crate :: Readable for STDBYCFG { }
# [ doc = "`write(|w| ..)` method takes [stdbycfg::W](stdbycfg::W) writer structure" ] impl crate :: Writable for STDBYCFG { }
# [ doc = "Standby Configuration" ] pub mod stdbycfg {
# [ doc = "Reader of register STDBYCFG" ] pub type R = crate :: R < u16 , super :: STDBYCFG > ;
# [ doc = "Writer for register STDBYCFG" ] pub type W = crate :: W < u16 , super :: STDBYCFG > ;
# [ doc = "Register STDBYCFG `reset()`'s with value 0x0400" ] impl crate :: ResetValue for super :: STDBYCFG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x0400 } }
# [ doc = "Possible values of the field `VREGSMOD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum VREGSMOD_A { # [ doc = "Automatic mode" ] AUTO , # [ doc = "Performance oriented" ] PERFORMANCE , # [ doc = "Low Power oriented" ] LP }
impl crate :: ToBits < u8 > for VREGSMOD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { VREGSMOD_A :: AUTO => 0 , VREGSMOD_A :: PERFORMANCE => 1 , VREGSMOD_A :: LP => 2 } } }
# [ doc = "Reader of field `VREGSMOD`" ] pub type VREGSMOD_R = crate :: R < u8 , VREGSMOD_A > ; impl VREGSMOD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , VREGSMOD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( VREGSMOD_A :: AUTO ) , 1 => Val ( VREGSMOD_A :: PERFORMANCE ) , 2 => Val ( VREGSMOD_A :: LP ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `AUTO`" ] # [ inline ( always ) ] pub fn is_auto ( & self ) -> bool { * self == VREGSMOD_A :: AUTO } # [ doc = "Checks if the value of the field is `PERFORMANCE`" ] # [ inline ( always ) ] pub fn is_performance ( & self ) -> bool { * self == VREGSMOD_A :: PERFORMANCE } # [ doc = "Checks if the value of the field is `LP`" ] # [ inline ( always ) ] pub fn is_lp ( & self ) -> bool { * self == VREGSMOD_A :: LP } }
# [ doc = "Write proxy for field `VREGSMOD`" ] pub struct VREGSMOD_W < 'a > { w : & 'a mut W , } impl < 'a > VREGSMOD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : VREGSMOD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Automatic mode" ] # [ inline ( always ) ] pub fn auto ( self ) -> & 'a mut W { self . variant ( VREGSMOD_A :: AUTO ) } # [ doc = "Performance oriented" ] # [ inline ( always ) ] pub fn performance ( self ) -> & 'a mut W { self . variant ( VREGSMOD_A :: PERFORMANCE ) } # [ doc = "Low Power oriented" ] # [ inline ( always ) ] pub fn lp ( self ) -> & 'a mut W { self . variant ( VREGSMOD_A :: LP ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u16 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `BBIASHS`" ] pub type BBIASHS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `BBIASHS`" ] pub struct BBIASHS_W < 'a > { w : & 'a mut W , } impl < 'a > BBIASHS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u16 ) & 0x03 ) << 10 ) ; self . w } }
impl R {
# [ doc = "Bits 6:7 - Voltage Regulator Standby mode" ] # [ inline ( always ) ] pub fn vregsmod ( & self ) -> VREGSMOD_R { VREGSMOD_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Back Bias for HMCRAMCHS" ] # [ inline ( always ) ] pub fn bbiashs ( & self ) -> BBIASHS_R { BBIASHS_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
}
impl W {
# [ doc = "Bits 6:7 - Voltage Regulator Standby mode" ] # [ inline ( always ) ] pub fn vregsmod ( & mut self ) -> VREGSMOD_W { VREGSMOD_W { w : self } }
# [ doc = "Bits 10:11 - Back Bias for HMCRAMCHS" ] # [ inline ( always ) ] pub fn bbiashs ( & mut self ) -> BBIASHS_W { BBIASHS_W { w : self } }
}
}
}
# [ doc = "Port Module" ] pub struct PORT { _marker : PhantomData < * const ( ) > } unsafe impl Send for PORT { } impl PORT { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const port :: RegisterBlock { 0x4100_0000 as * const _ } } impl Deref for PORT { type Target = port :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * PORT :: ptr ( ) } } }
# [ doc = "Port Module" ] pub mod port {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - cluster" ] pub group0 : GROUP , _reserved1 : [ u8 ; 32usize ] , # [ doc = "0x80 - cluster" ] pub group1 : GROUP , _reserved2 : [ u8 ; 32usize ] , # [ doc = "0x100 - cluster" ] pub group2 : GROUP , }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct GROUP { # [ doc = "0x00 - Data Direction" ] pub dir : self::group::DIR , # [ doc = "0x04 - Data Direction Clear" ] pub dirclr : self::group::DIRCLR , # [ doc = "0x08 - Data Direction Set" ] pub dirset : self::group::DIRSET , # [ doc = "0x0c - Data Direction Toggle" ] pub dirtgl : self::group::DIRTGL , # [ doc = "0x10 - Data Output Value" ] pub out : self::group::OUT , # [ doc = "0x14 - Data Output Value Clear" ] pub outclr : self::group::OUTCLR , # [ doc = "0x18 - Data Output Value Set" ] pub outset : self::group::OUTSET , # [ doc = "0x1c - Data Output Value Toggle" ] pub outtgl : self::group::OUTTGL , # [ doc = "0x20 - Data Input Value" ] pub in_ : self::group::IN , # [ doc = "0x24 - Control" ] pub ctrl : self::group::CTRL , # [ doc = "0x28 - Write Configuration" ] pub wrconfig : self::group::WRCONFIG , # [ doc = "0x2c - Event Input Control" ] pub evctrl : self::group::EVCTRL , # [ doc = "0x30 - Peripheral Multiplexing n" ] pub pmux : [ self::group::PMUX ; 16 ] , # [ doc = "0x40 - Pin Configuration n" ] pub pincfg : [ self::group::PINCFG ; 32 ] , } # [ doc = r"Register block" ] # [ doc = "cluster" ] pub mod group { # [ doc = "Data Direction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dir](dir) module" ] pub type DIR = crate :: Reg < u32 , _DIR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DIR ; # [ doc = "`read()` method returns [dir::R](dir::R) reader structure" ] impl crate :: Readable for DIR { } # [ doc = "`write(|w| ..)` method takes [dir::W](dir::W) writer structure" ] impl crate :: Writable for DIR { } # [ doc = "Data Direction" ] pub mod dir { # [ doc = "Reader of register DIR" ] pub type R = crate :: R < u32 , super :: DIR > ; # [ doc = "Writer for register DIR" ] pub type W = crate :: W < u32 , super :: DIR > ; # [ doc = "Register DIR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DIR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Data Direction Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dirclr](dirclr) module" ] pub type DIRCLR = crate :: Reg < u32 , _DIRCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DIRCLR ; # [ doc = "`read()` method returns [dirclr::R](dirclr::R) reader structure" ] impl crate :: Readable for DIRCLR { } # [ doc = "`write(|w| ..)` method takes [dirclr::W](dirclr::W) writer structure" ] impl crate :: Writable for DIRCLR { } # [ doc = "Data Direction Clear" ] pub mod dirclr { # [ doc = "Reader of register DIRCLR" ] pub type R = crate :: R < u32 , super :: DIRCLR > ; # [ doc = "Writer for register DIRCLR" ] pub type W = crate :: W < u32 , super :: DIRCLR > ; # [ doc = "Register DIRCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DIRCLR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Data Direction Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dirset](dirset) module" ] pub type DIRSET = crate :: Reg < u32 , _DIRSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DIRSET ; # [ doc = "`read()` method returns [dirset::R](dirset::R) reader structure" ] impl crate :: Readable for DIRSET { } # [ doc = "`write(|w| ..)` method takes [dirset::W](dirset::W) writer structure" ] impl crate :: Writable for DIRSET { } # [ doc = "Data Direction Set" ] pub mod dirset { # [ doc = "Reader of register DIRSET" ] pub type R = crate :: R < u32 , super :: DIRSET > ; # [ doc = "Writer for register DIRSET" ] pub type W = crate :: W < u32 , super :: DIRSET > ; # [ doc = "Register DIRSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DIRSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Data Direction Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dirtgl](dirtgl) module" ] pub type DIRTGL = crate :: Reg < u32 , _DIRTGL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DIRTGL ; # [ doc = "`read()` method returns [dirtgl::R](dirtgl::R) reader structure" ] impl crate :: Readable for DIRTGL { } # [ doc = "`write(|w| ..)` method takes [dirtgl::W](dirtgl::W) writer structure" ] impl crate :: Writable for DIRTGL { } # [ doc = "Data Direction Toggle" ] pub mod dirtgl { # [ doc = "Reader of register DIRTGL" ] pub type R = crate :: R < u32 , super :: DIRTGL > ; # [ doc = "Writer for register DIRTGL" ] pub type W = crate :: W < u32 , super :: DIRTGL > ; # [ doc = "Register DIRTGL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DIRTGL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Data Output Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [out](out) module" ] pub type OUT = crate :: Reg < u32 , _OUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OUT ; # [ doc = "`read()` method returns [out::R](out::R) reader structure" ] impl crate :: Readable for OUT { } # [ doc = "`write(|w| ..)` method takes [out::W](out::W) writer structure" ] impl crate :: Writable for OUT { } # [ doc = "Data Output Value" ] pub mod out { # [ doc = "Reader of register OUT" ] pub type R = crate :: R < u32 , super :: OUT > ; # [ doc = "Writer for register OUT" ] pub type W = crate :: W < u32 , super :: OUT > ; # [ doc = "Register OUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OUT { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Data Output Value Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [outclr](outclr) module" ] pub type OUTCLR = crate :: Reg < u32 , _OUTCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OUTCLR ; # [ doc = "`read()` method returns [outclr::R](outclr::R) reader structure" ] impl crate :: Readable for OUTCLR { } # [ doc = "`write(|w| ..)` method takes [outclr::W](outclr::W) writer structure" ] impl crate :: Writable for OUTCLR { } # [ doc = "Data Output Value Clear" ] pub mod outclr { # [ doc = "Reader of register OUTCLR" ] pub type R = crate :: R < u32 , super :: OUTCLR > ; # [ doc = "Writer for register OUTCLR" ] pub type W = crate :: W < u32 , super :: OUTCLR > ; # [ doc = "Register OUTCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OUTCLR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Data Output Value Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [outset](outset) module" ] pub type OUTSET = crate :: Reg < u32 , _OUTSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OUTSET ; # [ doc = "`read()` method returns [outset::R](outset::R) reader structure" ] impl crate :: Readable for OUTSET { } # [ doc = "`write(|w| ..)` method takes [outset::W](outset::W) writer structure" ] impl crate :: Writable for OUTSET { } # [ doc = "Data Output Value Set" ] pub mod outset { # [ doc = "Reader of register OUTSET" ] pub type R = crate :: R < u32 , super :: OUTSET > ; # [ doc = "Writer for register OUTSET" ] pub type W = crate :: W < u32 , super :: OUTSET > ; # [ doc = "Register OUTSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OUTSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Data Output Value Toggle\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [outtgl](outtgl) module" ] pub type OUTTGL = crate :: Reg < u32 , _OUTTGL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OUTTGL ; # [ doc = "`read()` method returns [outtgl::R](outtgl::R) reader structure" ] impl crate :: Readable for OUTTGL { } # [ doc = "`write(|w| ..)` method takes [outtgl::W](outtgl::W) writer structure" ] impl crate :: Writable for OUTTGL { } # [ doc = "Data Output Value Toggle" ] pub mod outtgl { # [ doc = "Reader of register OUTTGL" ] pub type R = crate :: R < u32 , super :: OUTTGL > ; # [ doc = "Writer for register OUTTGL" ] pub type W = crate :: W < u32 , super :: OUTTGL > ; # [ doc = "Register OUTTGL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OUTTGL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } impl R { } impl W { } } # [ doc = "Data Input Value\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [in_](in_) module" ] pub type IN = crate :: Reg < u32 , _IN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _IN ; # [ doc = "`read()` method returns [in_::R](in_::R) reader structure" ] impl crate :: Readable for IN { } # [ doc = "Data Input Value" ] pub mod in_ { # [ doc = "Reader of register IN" ] pub type R = crate :: R < u32 , super :: IN > ; impl R { } } # [ doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrl](ctrl) module" ] pub type CTRL = crate :: Reg < u32 , _CTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRL ; # [ doc = "`read()` method returns [ctrl::R](ctrl::R) reader structure" ] impl crate :: Readable for CTRL { } # [ doc = "`write(|w| ..)` method takes [ctrl::W](ctrl::W) writer structure" ] impl crate :: Writable for CTRL { } # [ doc = "Control" ] pub mod ctrl { # [ doc = "Reader of register CTRL" ] pub type R = crate :: R < u32 , super :: CTRL > ; # [ doc = "Writer for register CTRL" ] pub type W = crate :: W < u32 , super :: CTRL > ; # [ doc = "Register CTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SAMPLING`" ] pub type SAMPLING_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `SAMPLING`" ] pub struct SAMPLING_W < 'a > { w : & 'a mut W , } impl < 'a > SAMPLING_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Input Sampling Mode" ] # [ inline ( always ) ] pub fn sampling ( & self ) -> SAMPLING_R { SAMPLING_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Input Sampling Mode" ] # [ inline ( always ) ] pub fn sampling ( & mut self ) -> SAMPLING_W { SAMPLING_W { w : self } } } } # [ doc = "Write Configuration\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [wrconfig](wrconfig) module" ] pub type WRCONFIG = crate :: Reg < u32 , _WRCONFIG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WRCONFIG ; # [ doc = "`write(|w| ..)` method takes [wrconfig::W](wrconfig::W) writer structure" ] impl crate :: Writable for WRCONFIG { } # [ doc = "Write Configuration" ] pub mod wrconfig { # [ doc = "Writer for register WRCONFIG" ] pub type W = crate :: W < u32 , super :: WRCONFIG > ; # [ doc = "Register WRCONFIG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WRCONFIG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Write proxy for field `PINMASK`" ] pub struct PINMASK_W < 'a > { w : & 'a mut W , } impl < 'a > PINMASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u32 ) & 0xffff ) ; self . w } } # [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Write proxy for field `INEN`" ] pub struct INEN_W < 'a > { w : & 'a mut W , } impl < 'a > INEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Write proxy for field `PULLEN`" ] pub struct PULLEN_W < 'a > { w : & 'a mut W , } impl < 'a > PULLEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } } # [ doc = "Write proxy for field `DRVSTR`" ] pub struct DRVSTR_W < 'a > { w : & 'a mut W , } impl < 'a > DRVSTR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } } # [ doc = "Write proxy for field `PMUX`" ] pub struct PMUX_W < 'a > { w : & 'a mut W , } impl < 'a > PMUX_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } } # [ doc = "Write proxy for field `WRPMUX`" ] pub struct WRPMUX_W < 'a > { w : & 'a mut W , } impl < 'a > WRPMUX_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } } # [ doc = "Write proxy for field `WRPINCFG`" ] pub struct WRPINCFG_W < 'a > { w : & 'a mut W , } impl < 'a > WRPINCFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } # [ doc = "Write proxy for field `HWSEL`" ] pub struct HWSEL_W < 'a > { w : & 'a mut W , } impl < 'a > HWSEL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } } impl W { # [ doc = "Bits 0:15 - Pin Mask for Multiple Pin Configuration" ] # [ inline ( always ) ] pub fn pinmask ( & mut self ) -> PINMASK_W { PINMASK_W { w : self } } # [ doc = "Bit 16 - Select Peripheral Multiplexer" ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } } # [ doc = "Bit 17 - Input Enable" ] # [ inline ( always ) ] pub fn inen ( & mut self ) -> INEN_W { INEN_W { w : self } } # [ doc = "Bit 18 - Pull Enable" ] # [ inline ( always ) ] pub fn pullen ( & mut self ) -> PULLEN_W { PULLEN_W { w : self } } # [ doc = "Bit 22 - Output Driver Strength Selection" ] # [ inline ( always ) ] pub fn drvstr ( & mut self ) -> DRVSTR_W { DRVSTR_W { w : self } } # [ doc = "Bits 24:27 - Peripheral Multiplexing Template" ] # [ inline ( always ) ] pub fn pmux ( & mut self ) -> PMUX_W { PMUX_W { w : self } } # [ doc = "Bit 28 - Write PMUX Registers" ] # [ inline ( always ) ] pub fn wrpmux ( & mut self ) -> WRPMUX_W { WRPMUX_W { w : self } } # [ doc = "Bit 30 - Write PINCFG Registers" ] # [ inline ( always ) ] pub fn wrpincfg ( & mut self ) -> WRPINCFG_W { WRPINCFG_W { w : self } } # [ doc = "Bit 31 - Half-Word Select" ] # [ inline ( always ) ] pub fn hwsel ( & mut self ) -> HWSEL_W { HWSEL_W { w : self } } } } # [ doc = "Event Input Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u32 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ; # [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { } # [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { } # [ doc = "Event Input Control" ] pub mod evctrl { # [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u32 , super :: EVCTRL > ; # [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u32 , super :: EVCTRL > ; # [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PID0`" ] pub type PID0_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `PID0`" ] pub struct PID0_W < 'a > { w : & 'a mut W , } impl < 'a > PID0_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u32 ) & 0x1f ) ; self . w } } # [ doc = "Possible values of the field `EVACT0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EVACT0_A { # [ doc = "Event output to pin" ] OUT , # [ doc = "Set output register of pin on event" ] SET , # [ doc = "Clear output register of pin on event" ] CLR , # [ doc = "Toggle output register of pin on event" ] TGL } impl crate :: ToBits < u8 > for EVACT0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { EVACT0_A :: OUT => 0 , EVACT0_A :: SET => 1 , EVACT0_A :: CLR => 2 , EVACT0_A :: TGL => 3 } } } # [ doc = "Reader of field `EVACT0`" ] pub type EVACT0_R = crate :: R < u8 , EVACT0_A > ; impl EVACT0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EVACT0_A { match self . bits { 0 => EVACT0_A :: OUT , 1 => EVACT0_A :: SET , 2 => EVACT0_A :: CLR , 3 => EVACT0_A :: TGL , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OUT`" ] # [ inline ( always ) ] pub fn is_out ( & self ) -> bool { * self == EVACT0_A :: OUT } # [ doc = "Checks if the value of the field is `SET`" ] # [ inline ( always ) ] pub fn is_set ( & self ) -> bool { * self == EVACT0_A :: SET } # [ doc = "Checks if the value of the field is `CLR`" ] # [ inline ( always ) ] pub fn is_clr ( & self ) -> bool { * self == EVACT0_A :: CLR } # [ doc = "Checks if the value of the field is `TGL`" ] # [ inline ( always ) ] pub fn is_tgl ( & self ) -> bool { * self == EVACT0_A :: TGL } } # [ doc = "Write proxy for field `EVACT0`" ] pub struct EVACT0_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EVACT0_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Event output to pin" ] # [ inline ( always ) ] pub fn out ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: OUT ) } # [ doc = "Set output register of pin on event" ] # [ inline ( always ) ] pub fn set ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: SET ) } # [ doc = "Clear output register of pin on event" ] # [ inline ( always ) ] pub fn clr ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: CLR ) } # [ doc = "Toggle output register of pin on event" ] # [ inline ( always ) ] pub fn tgl ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: TGL ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 5 ) ) | ( ( ( value as u32 ) & 0x03 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PORTEI0`" ] pub type PORTEI0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PORTEI0`" ] pub struct PORTEI0_W < 'a > { w : & 'a mut W , } impl < 'a > PORTEI0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `PID1`" ] pub type PID1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `PID1`" ] pub struct PID1_W < 'a > { w : & 'a mut W , } impl < 'a > PID1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 8 ) ) | ( ( ( value as u32 ) & 0x1f ) << 8 ) ; self . w } } # [ doc = "Reader of field `EVACT1`" ] pub type EVACT1_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `EVACT1`" ] pub struct EVACT1_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 13 ) ) | ( ( ( value as u32 ) & 0x03 ) << 13 ) ; self . w } } # [ doc = "Reader of field `PORTEI1`" ] pub type PORTEI1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PORTEI1`" ] pub struct PORTEI1_W < 'a > { w : & 'a mut W , } impl < 'a > PORTEI1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } # [ doc = "Reader of field `PID2`" ] pub type PID2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `PID2`" ] pub struct PID2_W < 'a > { w : & 'a mut W , } impl < 'a > PID2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 16 ) ) | ( ( ( value as u32 ) & 0x1f ) << 16 ) ; self . w } } # [ doc = "Reader of field `EVACT2`" ] pub type EVACT2_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `EVACT2`" ] pub struct EVACT2_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT2_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 21 ) ) | ( ( ( value as u32 ) & 0x03 ) << 21 ) ; self . w } } # [ doc = "Reader of field `PORTEI2`" ] pub type PORTEI2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PORTEI2`" ] pub struct PORTEI2_W < 'a > { w : & 'a mut W , } impl < 'a > PORTEI2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } } # [ doc = "Reader of field `PID3`" ] pub type PID3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `PID3`" ] pub struct PID3_W < 'a > { w : & 'a mut W , } impl < 'a > PID3_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 24 ) ) | ( ( ( value as u32 ) & 0x1f ) << 24 ) ; self . w } } # [ doc = "Reader of field `EVACT3`" ] pub type EVACT3_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `EVACT3`" ] pub struct EVACT3_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT3_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 29 ) ) | ( ( ( value as u32 ) & 0x03 ) << 29 ) ; self . w } } # [ doc = "Reader of field `PORTEI3`" ] pub type PORTEI3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PORTEI3`" ] pub struct PORTEI3_W < 'a > { w : & 'a mut W , } impl < 'a > PORTEI3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } } impl R { # [ doc = "Bits 0:4 - Port Event Pin Identifier 0" ] # [ inline ( always ) ] pub fn pid0 ( & self ) -> PID0_R { PID0_R :: new ( ( self . bits & 0x1f ) as u8 ) } # [ doc = "Bits 5:6 - Port Event Action 0" ] # [ inline ( always ) ] pub fn evact0 ( & self ) -> EVACT0_R { EVACT0_R :: new ( ( ( self . bits >> 5 ) & 0x03 ) as u8 ) } # [ doc = "Bit 7 - Port Event Enable Input 0" ] # [ inline ( always ) ] pub fn portei0 ( & self ) -> PORTEI0_R { PORTEI0_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bits 8:12 - Port Event Pin Identifier 1" ] # [ inline ( always ) ] pub fn pid1 ( & self ) -> PID1_R { PID1_R :: new ( ( ( self . bits >> 8 ) & 0x1f ) as u8 ) } # [ doc = "Bits 13:14 - Port Event Action 1" ] # [ inline ( always ) ] pub fn evact1 ( & self ) -> EVACT1_R { EVACT1_R :: new ( ( ( self . bits >> 13 ) & 0x03 ) as u8 ) } # [ doc = "Bit 15 - Port Event Enable Input 1" ] # [ inline ( always ) ] pub fn portei1 ( & self ) -> PORTEI1_R { PORTEI1_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } # [ doc = "Bits 16:20 - Port Event Pin Identifier 2" ] # [ inline ( always ) ] pub fn pid2 ( & self ) -> PID2_R { PID2_R :: new ( ( ( self . bits >> 16 ) & 0x1f ) as u8 ) } # [ doc = "Bits 21:22 - Port Event Action 2" ] # [ inline ( always ) ] pub fn evact2 ( & self ) -> EVACT2_R { EVACT2_R :: new ( ( ( self . bits >> 21 ) & 0x03 ) as u8 ) } # [ doc = "Bit 23 - Port Event Enable Input 2" ] # [ inline ( always ) ] pub fn portei2 ( & self ) -> PORTEI2_R { PORTEI2_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) } # [ doc = "Bits 24:28 - Port Event Pin Identifier 3" ] # [ inline ( always ) ] pub fn pid3 ( & self ) -> PID3_R { PID3_R :: new ( ( ( self . bits >> 24 ) & 0x1f ) as u8 ) } # [ doc = "Bits 29:30 - Port Event Action 3" ] # [ inline ( always ) ] pub fn evact3 ( & self ) -> EVACT3_R { EVACT3_R :: new ( ( ( self . bits >> 29 ) & 0x03 ) as u8 ) } # [ doc = "Bit 31 - Port Event Enable Input 3" ] # [ inline ( always ) ] pub fn portei3 ( & self ) -> PORTEI3_R { PORTEI3_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:4 - Port Event Pin Identifier 0" ] # [ inline ( always ) ] pub fn pid0 ( & mut self ) -> PID0_W { PID0_W { w : self } } # [ doc = "Bits 5:6 - Port Event Action 0" ] # [ inline ( always ) ] pub fn evact0 ( & mut self ) -> EVACT0_W { EVACT0_W { w : self } } # [ doc = "Bit 7 - Port Event Enable Input 0" ] # [ inline ( always ) ] pub fn portei0 ( & mut self ) -> PORTEI0_W { PORTEI0_W { w : self } } # [ doc = "Bits 8:12 - Port Event Pin Identifier 1" ] # [ inline ( always ) ] pub fn pid1 ( & mut self ) -> PID1_W { PID1_W { w : self } } # [ doc = "Bits 13:14 - Port Event Action 1" ] # [ inline ( always ) ] pub fn evact1 ( & mut self ) -> EVACT1_W { EVACT1_W { w : self } } # [ doc = "Bit 15 - Port Event Enable Input 1" ] # [ inline ( always ) ] pub fn portei1 ( & mut self ) -> PORTEI1_W { PORTEI1_W { w : self } } # [ doc = "Bits 16:20 - Port Event Pin Identifier 2" ] # [ inline ( always ) ] pub fn pid2 ( & mut self ) -> PID2_W { PID2_W { w : self } } # [ doc = "Bits 21:22 - Port Event Action 2" ] # [ inline ( always ) ] pub fn evact2 ( & mut self ) -> EVACT2_W { EVACT2_W { w : self } } # [ doc = "Bit 23 - Port Event Enable Input 2" ] # [ inline ( always ) ] pub fn portei2 ( & mut self ) -> PORTEI2_W { PORTEI2_W { w : self } } # [ doc = "Bits 24:28 - Port Event Pin Identifier 3" ] # [ inline ( always ) ] pub fn pid3 ( & mut self ) -> PID3_W { PID3_W { w : self } } # [ doc = "Bits 29:30 - Port Event Action 3" ] # [ inline ( always ) ] pub fn evact3 ( & mut self ) -> EVACT3_W { EVACT3_W { w : self } } # [ doc = "Bit 31 - Port Event Enable Input 3" ] # [ inline ( always ) ] pub fn portei3 ( & mut self ) -> PORTEI3_W { PORTEI3_W { w : self } } } } # [ doc = "Peripheral Multiplexing n\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pmux](pmux) module" ] pub type PMUX = crate :: Reg < u8 , _PMUX > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PMUX ; # [ doc = "`read()` method returns [pmux::R](pmux::R) reader structure" ] impl crate :: Readable for PMUX { } # [ doc = "`write(|w| ..)` method takes [pmux::W](pmux::W) writer structure" ] impl crate :: Writable for PMUX { } # [ doc = "Peripheral Multiplexing n" ] pub mod pmux { # [ doc = "Reader of register PMUX[%s]" ] pub type R = crate :: R < u8 , super :: PMUX > ; # [ doc = "Writer for register PMUX[%s]" ] pub type W = crate :: W < u8 , super :: PMUX > ; # [ doc = "Register PMUX[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PMUX { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PMUXE`" ] pub type PMUXE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `PMUXE`" ] pub struct PMUXE_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } } # [ doc = "Reader of field `PMUXO`" ] pub type PMUXO_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `PMUXO`" ] pub struct PMUXO_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXO_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 4 ) ) | ( ( ( value as u8 ) & 0x0f ) << 4 ) ; self . w } } impl R { # [ doc = "Bits 0:3 - Peripheral Multiplexing for Even-Numbered Pin" ] # [ inline ( always ) ] pub fn pmuxe ( & self ) -> PMUXE_R { PMUXE_R :: new ( ( self . bits & 0x0f ) as u8 ) } # [ doc = "Bits 4:7 - Peripheral Multiplexing for Odd-Numbered Pin" ] # [ inline ( always ) ] pub fn pmuxo ( & self ) -> PMUXO_R { PMUXO_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) } } impl W { # [ doc = "Bits 0:3 - Peripheral Multiplexing for Even-Numbered Pin" ] # [ inline ( always ) ] pub fn pmuxe ( & mut self ) -> PMUXE_W { PMUXE_W { w : self } } # [ doc = "Bits 4:7 - Peripheral Multiplexing for Odd-Numbered Pin" ] # [ inline ( always ) ] pub fn pmuxo ( & mut self ) -> PMUXO_W { PMUXO_W { w : self } } } } # [ doc = "Pin Configuration n\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pincfg](pincfg) module" ] pub type PINCFG = crate :: Reg < u8 , _PINCFG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PINCFG ; # [ doc = "`read()` method returns [pincfg::R](pincfg::R) reader structure" ] impl crate :: Readable for PINCFG { } # [ doc = "`write(|w| ..)` method takes [pincfg::W](pincfg::W) writer structure" ] impl crate :: Writable for PINCFG { } # [ doc = "Pin Configuration n" ] pub mod pincfg { # [ doc = "Reader of register PINCFG[%s]" ] pub type R = crate :: R < u8 , super :: PINCFG > ; # [ doc = "Writer for register PINCFG[%s]" ] pub type W = crate :: W < u8 , super :: PINCFG > ; # [ doc = "Register PINCFG[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PINCFG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PMUXEN`" ] pub type PMUXEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PMUXEN`" ] pub struct PMUXEN_W < 'a > { w : & 'a mut W , } impl < 'a > PMUXEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `INEN`" ] pub type INEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `INEN`" ] pub struct INEN_W < 'a > { w : & 'a mut W , } impl < 'a > INEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PULLEN`" ] pub type PULLEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PULLEN`" ] pub struct PULLEN_W < 'a > { w : & 'a mut W , } impl < 'a > PULLEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `DRVSTR`" ] pub type DRVSTR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRVSTR`" ] pub struct DRVSTR_W < 'a > { w : & 'a mut W , } impl < 'a > DRVSTR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } } impl R { # [ doc = "Bit 0 - Select Peripheral Multiplexer" ] # [ inline ( always ) ] pub fn pmuxen ( & self ) -> PMUXEN_R { PMUXEN_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Input Enable" ] # [ inline ( always ) ] pub fn inen ( & self ) -> INEN_R { INEN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Pull Enable" ] # [ inline ( always ) ] pub fn pullen ( & self ) -> PULLEN_R { PULLEN_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Output Driver Strength Selection" ] # [ inline ( always ) ] pub fn drvstr ( & self ) -> DRVSTR_R { DRVSTR_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Select Peripheral Multiplexer" ] # [ inline ( always ) ] pub fn pmuxen ( & mut self ) -> PMUXEN_W { PMUXEN_W { w : self } } # [ doc = "Bit 1 - Input Enable" ] # [ inline ( always ) ] pub fn inen ( & mut self ) -> INEN_W { INEN_W { w : self } } # [ doc = "Bit 2 - Pull Enable" ] # [ inline ( always ) ] pub fn pullen ( & mut self ) -> PULLEN_W { PULLEN_W { w : self } } # [ doc = "Bit 6 - Output Driver Strength Selection" ] # [ inline ( always ) ] pub fn drvstr ( & mut self ) -> DRVSTR_W { DRVSTR_W { w : self } } } } }
}
# [ doc = "Port Module" ] pub struct PORT_IOBUS { _marker : PhantomData < * const ( ) > } unsafe impl Send for PORT_IOBUS { } impl PORT_IOBUS { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const port :: RegisterBlock { 0x6000_0000 as * const _ } } impl Deref for PORT_IOBUS { type Target = port :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * PORT_IOBUS :: ptr ( ) } } }
# [ doc = "Reset Controller" ] pub struct RSTC { _marker : PhantomData < * const ( ) > } unsafe impl Send for RSTC { } impl RSTC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const rstc :: RegisterBlock { 0x4000_0c00 as * const _ } } impl Deref for RSTC { type Target = rstc :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * RSTC :: ptr ( ) } } }
# [ doc = "Reset Controller" ] pub mod rstc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Reset Cause" ] pub rcause : RCAUSE , }
# [ doc = "Reset Cause\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rcause](rcause) module" ] pub type RCAUSE = crate :: Reg < u8 , _RCAUSE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RCAUSE ;
# [ doc = "`read()` method returns [rcause::R](rcause::R) reader structure" ] impl crate :: Readable for RCAUSE { }
# [ doc = "Reset Cause" ] pub mod rcause {
# [ doc = "Reader of register RCAUSE" ] pub type R = crate :: R < u8 , super :: RCAUSE > ;
# [ doc = "Reader of field `POR`" ] pub type POR_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BODCORE`" ] pub type BODCORE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BODVDD`" ] pub type BODVDD_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `EXT`" ] pub type EXT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WDT`" ] pub type WDT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SYST`" ] pub type SYST_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Power On Reset" ] # [ inline ( always ) ] pub fn por ( & self ) -> POR_R { POR_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Brown Out CORE Detector Reset" ] # [ inline ( always ) ] pub fn bodcore ( & self ) -> BODCORE_R { BODCORE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Brown Out VDD Detector Reset" ] # [ inline ( always ) ] pub fn bodvdd ( & self ) -> BODVDD_R { BODVDD_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - External Reset" ] # [ inline ( always ) ] pub fn ext ( & self ) -> EXT_R { EXT_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Watchdog Reset" ] # [ inline ( always ) ] pub fn wdt ( & self ) -> WDT_R { WDT_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - System Reset Request" ] # [ inline ( always ) ] pub fn syst ( & self ) -> SYST_R { SYST_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
}
}
# [ doc = "Real-Time Counter" ] pub struct RTC { _marker : PhantomData < * const ( ) > } unsafe impl Send for RTC { } impl RTC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const rtc :: RegisterBlock { 0x4000_2400 as * const _ } } impl Deref for RTC { type Target = rtc :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * RTC :: ptr ( ) } } }
# [ doc = "Real-Time Counter" ] pub mod rtc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_mode0 : [ u8 ; 37usize ] , } impl RegisterBlock { # [ doc = "0x00 - Clock/Calendar with Alarm" ] # [ inline ( always ) ] pub fn mode2 ( & self ) -> & MODE2 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const MODE2 ) } } # [ doc = "0x00 - Clock/Calendar with Alarm" ] # [ inline ( always ) ] pub fn mode2_mut ( & self ) -> & mut MODE2 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut MODE2 ) } } # [ doc = "0x00 - 16-bit Counter with Two 16-bit Compares" ] # [ inline ( always ) ] pub fn mode1 ( & self ) -> & MODE1 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const MODE1 ) } } # [ doc = "0x00 - 16-bit Counter with Two 16-bit Compares" ] # [ inline ( always ) ] pub fn mode1_mut ( & self ) -> & mut MODE1 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut MODE1 ) } } # [ doc = "0x00 - 32-bit Counter with Single 32-bit Compare" ] # [ inline ( always ) ] pub fn mode0 ( & self ) -> & MODE0 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const MODE0 ) } } # [ doc = "0x00 - 32-bit Counter with Single 32-bit Compare" ] # [ inline ( always ) ] pub fn mode0_mut ( & self ) -> & mut MODE0 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut MODE0 ) } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct MODE0 { # [ doc = "0x00 - MODE0 Control A" ] pub ctrla : self::mode0::CTRLA , _reserved1 : [ u8 ; 2usize ] , # [ doc = "0x04 - MODE0 Event Control" ] pub evctrl : self::mode0::EVCTRL , # [ doc = "0x08 - MODE0 Interrupt Enable Clear" ] pub intenclr : self::mode0::INTENCLR , # [ doc = "0x0a - MODE0 Interrupt Enable Set" ] pub intenset : self::mode0::INTENSET , # [ doc = "0x0c - MODE0 Interrupt Flag Status and Clear" ] pub intflag : self::mode0::INTFLAG , # [ doc = "0x0e - Debug Control" ] pub dbgctrl : self::mode0::DBGCTRL , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x10 - MODE0 Synchronization Busy Status" ] pub syncbusy : self::mode0::SYNCBUSY , # [ doc = "0x14 - Frequency Correction" ] pub freqcorr : self::mode0::FREQCORR , _reserved8 : [ u8 ; 3usize ] , # [ doc = "0x18 - MODE0 Counter Value" ] pub count : self::mode0::COUNT , _reserved9 : [ u8 ; 4usize ] , # [ doc = "0x20 - MODE0 Compare n Value" ] pub comp : self::mode0::COMP , } # [ doc = r"Register block" ] # [ doc = "32-bit Counter with Single 32-bit Compare" ] pub mod mode0 { # [ doc = "MODE0 Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u16 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "MODE0 Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u16 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u16 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "Mode 0: 32-bit Counter" ] COUNT32 , # [ doc = "Mode 1: 16-bit Counter" ] COUNT16 , # [ doc = "Mode 2: Clock/Calendar" ] CLOCK } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: COUNT32 => 0 , MODE_A :: COUNT16 => 1 , MODE_A :: CLOCK => 2 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: COUNT32 ) , 1 => Val ( MODE_A :: COUNT16 ) , 2 => Val ( MODE_A :: CLOCK ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `COUNT32`" ] # [ inline ( always ) ] pub fn is_count32 ( & self ) -> bool { * self == MODE_A :: COUNT32 } # [ doc = "Checks if the value of the field is `COUNT16`" ] # [ inline ( always ) ] pub fn is_count16 ( & self ) -> bool { * self == MODE_A :: COUNT16 } # [ doc = "Checks if the value of the field is `CLOCK`" ] # [ inline ( always ) ] pub fn is_clock ( & self ) -> bool { * self == MODE_A :: CLOCK } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Mode 0: 32-bit Counter" ] # [ inline ( always ) ] pub fn count32 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT32 ) } # [ doc = "Mode 1: 16-bit Counter" ] # [ inline ( always ) ] pub fn count16 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT16 ) } # [ doc = "Mode 2: Clock/Calendar" ] # [ inline ( always ) ] pub fn clock ( self ) -> & 'a mut W { self . variant ( MODE_A :: CLOCK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } } # [ doc = "Reader of field `MATCHCLR`" ] pub type MATCHCLR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MATCHCLR`" ] pub struct MATCHCLR_W < 'a > { w : & 'a mut W , } impl < 'a > MATCHCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Possible values of the field `PRESCALER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER_A { # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] OFF , # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] DIV1 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/2" ] DIV2 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/4" ] DIV4 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/8" ] DIV8 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/16" ] DIV16 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/32" ] DIV32 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/64" ] DIV64 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/128" ] DIV128 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/256" ] DIV256 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/512" ] DIV512 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/1024" ] DIV1024 } impl crate :: ToBits < u8 > for PRESCALER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER_A :: OFF => 0 , PRESCALER_A :: DIV1 => 1 , PRESCALER_A :: DIV2 => 2 , PRESCALER_A :: DIV4 => 3 , PRESCALER_A :: DIV8 => 4 , PRESCALER_A :: DIV16 => 5 , PRESCALER_A :: DIV32 => 6 , PRESCALER_A :: DIV64 => 7 , PRESCALER_A :: DIV128 => 8 , PRESCALER_A :: DIV256 => 9 , PRESCALER_A :: DIV512 => 10 , PRESCALER_A :: DIV1024 => 11 } } } # [ doc = "Reader of field `PRESCALER`" ] pub type PRESCALER_R = crate :: R < u8 , PRESCALER_A > ; impl PRESCALER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PRESCALER_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PRESCALER_A :: OFF ) , 1 => Val ( PRESCALER_A :: DIV1 ) , 2 => Val ( PRESCALER_A :: DIV2 ) , 3 => Val ( PRESCALER_A :: DIV4 ) , 4 => Val ( PRESCALER_A :: DIV8 ) , 5 => Val ( PRESCALER_A :: DIV16 ) , 6 => Val ( PRESCALER_A :: DIV32 ) , 7 => Val ( PRESCALER_A :: DIV64 ) , 8 => Val ( PRESCALER_A :: DIV128 ) , 9 => Val ( PRESCALER_A :: DIV256 ) , 10 => Val ( PRESCALER_A :: DIV512 ) , 11 => Val ( PRESCALER_A :: DIV1024 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == PRESCALER_A :: OFF } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == PRESCALER_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == PRESCALER_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == PRESCALER_A :: DIV128 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER_A :: DIV256 } # [ doc = "Checks if the value of the field is `DIV512`" ] # [ inline ( always ) ] pub fn is_div512 ( & self ) -> bool { * self == PRESCALER_A :: DIV512 } # [ doc = "Checks if the value of the field is `DIV1024`" ] # [ inline ( always ) ] pub fn is_div1024 ( & self ) -> bool { * self == PRESCALER_A :: DIV1024 } } # [ doc = "Write proxy for field `PRESCALER`" ] pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: OFF ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV2 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV4 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV8 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV16 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/32" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV32 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV64 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/128" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV128 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV256 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/512" ] # [ inline ( always ) ] pub fn div512 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV512 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/1024" ] # [ inline ( always ) ] pub fn div1024 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u16 ) & 0x0f ) << 8 ) ; self . w } } # [ doc = "Reader of field `COUNTSYNC`" ] pub type COUNTSYNC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COUNTSYNC`" ] pub struct COUNTSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > COUNTSYNC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:3 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) } # [ doc = "Bit 7 - Clear on Match" ] # [ inline ( always ) ] pub fn matchclr ( & self ) -> MATCHCLR_R { MATCHCLR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bits 8:11 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) } # [ doc = "Bit 15 - Count Read Synchronization Enable" ] # [ inline ( always ) ] pub fn countsync ( & self ) -> COUNTSYNC_R { COUNTSYNC_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:3 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bit 7 - Clear on Match" ] # [ inline ( always ) ] pub fn matchclr ( & mut self ) -> MATCHCLR_W { MATCHCLR_W { w : self } } # [ doc = "Bits 8:11 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } } # [ doc = "Bit 15 - Count Read Synchronization Enable" ] # [ inline ( always ) ] pub fn countsync ( & mut self ) -> COUNTSYNC_W { COUNTSYNC_W { w : self } } } } # [ doc = "MODE0 Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u32 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ; # [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { } # [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { } # [ doc = "MODE0 Event Control" ] pub mod evctrl { # [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u32 , super :: EVCTRL > ; # [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u32 , super :: EVCTRL > ; # [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PEREO0`" ] pub type PEREO0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO0`" ] pub struct PEREO0_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PEREO1`" ] pub type PEREO1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO1`" ] pub struct PEREO1_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PEREO2`" ] pub type PEREO2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO2`" ] pub struct PEREO2_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PEREO3`" ] pub type PEREO3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO3`" ] pub struct PEREO3_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PEREO4`" ] pub type PEREO4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO4`" ] pub struct PEREO4_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PEREO5`" ] pub type PEREO5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO5`" ] pub struct PEREO5_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PEREO6`" ] pub type PEREO6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO6`" ] pub struct PEREO6_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PEREO7`" ] pub type PEREO7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO7`" ] pub struct PEREO7_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `CMPEO0`" ] pub type CMPEO0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMPEO0`" ] pub struct CMPEO0_W < 'a > { w : & 'a mut W , } impl < 'a > CMPEO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `OVFEO`" ] pub type OVFEO_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVFEO`" ] pub struct OVFEO_W < 'a > { w : & 'a mut W , } impl < 'a > OVFEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo0 ( & self ) -> PEREO0_R { PEREO0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo1 ( & self ) -> PEREO1_R { PEREO1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo2 ( & self ) -> PEREO2_R { PEREO2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo3 ( & self ) -> PEREO3_R { PEREO3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo4 ( & self ) -> PEREO4_R { PEREO4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo5 ( & self ) -> PEREO5_R { PEREO5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo6 ( & self ) -> PEREO6_R { PEREO6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo7 ( & self ) -> PEREO7_R { PEREO7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Compare 0 Event Output Enable" ] # [ inline ( always ) ] pub fn cmpeo0 ( & self ) -> CMPEO0_R { CMPEO0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & self ) -> OVFEO_R { OVFEO_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo0 ( & mut self ) -> PEREO0_W { PEREO0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo1 ( & mut self ) -> PEREO1_W { PEREO1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo2 ( & mut self ) -> PEREO2_W { PEREO2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo3 ( & mut self ) -> PEREO3_W { PEREO3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo4 ( & mut self ) -> PEREO4_W { PEREO4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo5 ( & mut self ) -> PEREO5_W { PEREO5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo6 ( & mut self ) -> PEREO6_W { PEREO6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo7 ( & mut self ) -> PEREO7_W { PEREO7_W { w : self } } # [ doc = "Bit 8 - Compare 0 Event Output Enable" ] # [ inline ( always ) ] pub fn cmpeo0 ( & mut self ) -> CMPEO0_W { CMPEO0_W { w : self } } # [ doc = "Bit 15 - Overflow Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & mut self ) -> OVFEO_W { OVFEO_W { w : self } } } } # [ doc = "MODE0 Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u16 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "MODE0 Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u16 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u16 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER0`" ] pub type PER0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER0`" ] pub struct PER0_W < 'a > { w : & 'a mut W , } impl < 'a > PER0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PER1`" ] pub type PER1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER1`" ] pub struct PER1_W < 'a > { w : & 'a mut W , } impl < 'a > PER1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PER2`" ] pub type PER2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER2`" ] pub struct PER2_W < 'a > { w : & 'a mut W , } impl < 'a > PER2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PER3`" ] pub type PER3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER3`" ] pub struct PER3_W < 'a > { w : & 'a mut W , } impl < 'a > PER3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PER4`" ] pub type PER4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER4`" ] pub struct PER4_W < 'a > { w : & 'a mut W , } impl < 'a > PER4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PER5`" ] pub type PER5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER5`" ] pub struct PER5_W < 'a > { w : & 'a mut W , } impl < 'a > PER5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PER6`" ] pub type PER6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER6`" ] pub struct PER6_W < 'a > { w : & 'a mut W , } impl < 'a > PER6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PER7`" ] pub type PER7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER7`" ] pub struct PER7_W < 'a > { w : & 'a mut W , } impl < 'a > PER7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `CMP0`" ] pub type CMP0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMP0`" ] pub struct CMP0_W < 'a > { w : & 'a mut W , } impl < 'a > CMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & self ) -> PER0_R { PER0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & self ) -> PER1_R { PER1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & self ) -> PER2_R { PER2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & self ) -> PER3_R { PER3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & self ) -> PER4_R { PER4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & self ) -> PER5_R { PER5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & self ) -> PER6_R { PER6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & self ) -> PER7_R { PER7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Compare 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp0 ( & self ) -> CMP0_R { CMP0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & mut self ) -> PER0_W { PER0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & mut self ) -> PER1_W { PER1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & mut self ) -> PER2_W { PER2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & mut self ) -> PER3_W { PER3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & mut self ) -> PER4_W { PER4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & mut self ) -> PER5_W { PER5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & mut self ) -> PER6_W { PER6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & mut self ) -> PER7_W { PER7_W { w : self } } # [ doc = "Bit 8 - Compare 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp0 ( & mut self ) -> CMP0_W { CMP0_W { w : self } } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } } } # [ doc = "MODE0 Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u16 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "MODE0 Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u16 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u16 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER0`" ] pub type PER0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER0`" ] pub struct PER0_W < 'a > { w : & 'a mut W , } impl < 'a > PER0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PER1`" ] pub type PER1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER1`" ] pub struct PER1_W < 'a > { w : & 'a mut W , } impl < 'a > PER1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PER2`" ] pub type PER2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER2`" ] pub struct PER2_W < 'a > { w : & 'a mut W , } impl < 'a > PER2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PER3`" ] pub type PER3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER3`" ] pub struct PER3_W < 'a > { w : & 'a mut W , } impl < 'a > PER3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PER4`" ] pub type PER4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER4`" ] pub struct PER4_W < 'a > { w : & 'a mut W , } impl < 'a > PER4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PER5`" ] pub type PER5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER5`" ] pub struct PER5_W < 'a > { w : & 'a mut W , } impl < 'a > PER5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PER6`" ] pub type PER6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER6`" ] pub struct PER6_W < 'a > { w : & 'a mut W , } impl < 'a > PER6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PER7`" ] pub type PER7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER7`" ] pub struct PER7_W < 'a > { w : & 'a mut W , } impl < 'a > PER7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `CMP0`" ] pub type CMP0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMP0`" ] pub struct CMP0_W < 'a > { w : & 'a mut W , } impl < 'a > CMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & self ) -> PER0_R { PER0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & self ) -> PER1_R { PER1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & self ) -> PER2_R { PER2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & self ) -> PER3_R { PER3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & self ) -> PER4_R { PER4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & self ) -> PER5_R { PER5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & self ) -> PER6_R { PER6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & self ) -> PER7_R { PER7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Compare 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp0 ( & self ) -> CMP0_R { CMP0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & mut self ) -> PER0_W { PER0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & mut self ) -> PER1_W { PER1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & mut self ) -> PER2_W { PER2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & mut self ) -> PER3_W { PER3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & mut self ) -> PER4_W { PER4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & mut self ) -> PER5_W { PER5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & mut self ) -> PER6_W { PER6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & mut self ) -> PER7_W { PER7_W { w : self } } # [ doc = "Bit 8 - Compare 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp0 ( & mut self ) -> CMP0_W { CMP0_W { w : self } } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } } } # [ doc = "MODE0 Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u16 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "MODE0 Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u16 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u16 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER0`" ] pub type PER0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER0`" ] pub struct PER0_W < 'a > { w : & 'a mut W , } impl < 'a > PER0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PER1`" ] pub type PER1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER1`" ] pub struct PER1_W < 'a > { w : & 'a mut W , } impl < 'a > PER1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PER2`" ] pub type PER2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER2`" ] pub struct PER2_W < 'a > { w : & 'a mut W , } impl < 'a > PER2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PER3`" ] pub type PER3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER3`" ] pub struct PER3_W < 'a > { w : & 'a mut W , } impl < 'a > PER3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PER4`" ] pub type PER4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER4`" ] pub struct PER4_W < 'a > { w : & 'a mut W , } impl < 'a > PER4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PER5`" ] pub type PER5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER5`" ] pub struct PER5_W < 'a > { w : & 'a mut W , } impl < 'a > PER5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PER6`" ] pub type PER6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER6`" ] pub struct PER6_W < 'a > { w : & 'a mut W , } impl < 'a > PER6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PER7`" ] pub type PER7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER7`" ] pub struct PER7_W < 'a > { w : & 'a mut W , } impl < 'a > PER7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `CMP0`" ] pub type CMP0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMP0`" ] pub struct CMP0_W < 'a > { w : & 'a mut W , } impl < 'a > CMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0" ] # [ inline ( always ) ] pub fn per0 ( & self ) -> PER0_R { PER0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1" ] # [ inline ( always ) ] pub fn per1 ( & self ) -> PER1_R { PER1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2" ] # [ inline ( always ) ] pub fn per2 ( & self ) -> PER2_R { PER2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3" ] # [ inline ( always ) ] pub fn per3 ( & self ) -> PER3_R { PER3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4" ] # [ inline ( always ) ] pub fn per4 ( & self ) -> PER4_R { PER4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5" ] # [ inline ( always ) ] pub fn per5 ( & self ) -> PER5_R { PER5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6" ] # [ inline ( always ) ] pub fn per6 ( & self ) -> PER6_R { PER6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7" ] # [ inline ( always ) ] pub fn per7 ( & self ) -> PER7_R { PER7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Compare 0" ] # [ inline ( always ) ] pub fn cmp0 ( & self ) -> CMP0_R { CMP0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0" ] # [ inline ( always ) ] pub fn per0 ( & mut self ) -> PER0_W { PER0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1" ] # [ inline ( always ) ] pub fn per1 ( & mut self ) -> PER1_W { PER1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2" ] # [ inline ( always ) ] pub fn per2 ( & mut self ) -> PER2_W { PER2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3" ] # [ inline ( always ) ] pub fn per3 ( & mut self ) -> PER3_W { PER3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4" ] # [ inline ( always ) ] pub fn per4 ( & mut self ) -> PER4_W { PER4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5" ] # [ inline ( always ) ] pub fn per5 ( & mut self ) -> PER5_W { PER5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6" ] # [ inline ( always ) ] pub fn per6 ( & mut self ) -> PER6_W { PER6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7" ] # [ inline ( always ) ] pub fn per7 ( & mut self ) -> PER7_W { PER7_W { w : self } } # [ doc = "Bit 8 - Compare 0" ] # [ inline ( always ) ] pub fn cmp0 ( & mut self ) -> CMP0_W { CMP0_W { w : self } } # [ doc = "Bit 15 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } } } # [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } } } } # [ doc = "MODE0 Synchronization Busy Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "MODE0 Synchronization Busy Status" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `FREQCORR`" ] pub type FREQCORR_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COMP0`" ] pub type COMP0_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COUNTSYNC`" ] pub type COUNTSYNC_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Software Reset Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable Bit Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - FREQCORR Register Busy" ] # [ inline ( always ) ] pub fn freqcorr ( & self ) -> FREQCORR_R { FREQCORR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - COUNT Register Busy" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - COMP 0 Register Busy" ] # [ inline ( always ) ] pub fn comp0 ( & self ) -> COMP0_R { COMP0_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Count Read Synchronization Enable Bit Busy" ] # [ inline ( always ) ] pub fn countsync ( & self ) -> COUNTSYNC_R { COUNTSYNC_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } } # [ doc = "Frequency Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [freqcorr](freqcorr) module" ] pub type FREQCORR = crate :: Reg < u8 , _FREQCORR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _FREQCORR ; # [ doc = "`read()` method returns [freqcorr::R](freqcorr::R) reader structure" ] impl crate :: Readable for FREQCORR { } # [ doc = "`write(|w| ..)` method takes [freqcorr::W](freqcorr::W) writer structure" ] impl crate :: Writable for FREQCORR { } # [ doc = "Frequency Correction" ] pub mod freqcorr { # [ doc = "Reader of register FREQCORR" ] pub type R = crate :: R < u8 , super :: FREQCORR > ; # [ doc = "Writer for register FREQCORR" ] pub type W = crate :: W < u8 , super :: FREQCORR > ; # [ doc = "Register FREQCORR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: FREQCORR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `VALUE`" ] pub type VALUE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `VALUE`" ] pub struct VALUE_W < 'a > { w : & 'a mut W , } impl < 'a > VALUE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x7f ) | ( ( value as u8 ) & 0x7f ) ; self . w } } # [ doc = "Reader of field `SIGN`" ] pub type SIGN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SIGN`" ] pub struct SIGN_W < 'a > { w : & 'a mut W , } impl < 'a > SIGN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bits 0:6 - Correction Value" ] # [ inline ( always ) ] pub fn value ( & self ) -> VALUE_R { VALUE_R :: new ( ( self . bits & 0x7f ) as u8 ) } # [ doc = "Bit 7 - Correction Sign" ] # [ inline ( always ) ] pub fn sign ( & self ) -> SIGN_R { SIGN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:6 - Correction Value" ] # [ inline ( always ) ] pub fn value ( & mut self ) -> VALUE_W { VALUE_W { w : self } } # [ doc = "Bit 7 - Correction Sign" ] # [ inline ( always ) ] pub fn sign ( & mut self ) -> SIGN_W { SIGN_W { w : self } } } } # [ doc = "MODE0 Counter Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [count](count) module" ] pub type COUNT = crate :: Reg < u32 , _COUNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COUNT ; # [ doc = "`read()` method returns [count::R](count::R) reader structure" ] impl crate :: Readable for COUNT { } # [ doc = "`write(|w| ..)` method takes [count::W](count::W) writer structure" ] impl crate :: Writable for COUNT { } # [ doc = "MODE0 Counter Value" ] pub mod count { # [ doc = "Reader of register COUNT" ] pub type R = crate :: R < u32 , super :: COUNT > ; # [ doc = "Writer for register COUNT" ] pub type W = crate :: W < u32 , super :: COUNT > ; # [ doc = "Register COUNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COUNT { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `COUNT`" ] pub struct COUNT_W < 'a > { w : & 'a mut W , } impl < 'a > COUNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & mut self ) -> COUNT_W { COUNT_W { w : self } } } } # [ doc = "MODE0 Compare n Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [comp](comp) module" ] pub type COMP = crate :: Reg < u32 , _COMP > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COMP ; # [ doc = "`read()` method returns [comp::R](comp::R) reader structure" ] impl crate :: Readable for COMP { } # [ doc = "`write(|w| ..)` method takes [comp::W](comp::W) writer structure" ] impl crate :: Writable for COMP { } # [ doc = "MODE0 Compare n Value" ] pub mod comp { # [ doc = "Reader of register COMP" ] pub type R = crate :: R < u32 , super :: COMP > ; # [ doc = "Writer for register COMP" ] pub type W = crate :: W < u32 , super :: COMP > ; # [ doc = "Register COMP `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COMP { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `COMP`" ] pub type COMP_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `COMP`" ] pub struct COMP_W < 'a > { w : & 'a mut W , } impl < 'a > COMP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Compare Value" ] # [ inline ( always ) ] pub fn comp ( & self ) -> COMP_R { COMP_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Compare Value" ] # [ inline ( always ) ] pub fn comp ( & mut self ) -> COMP_W { COMP_W { w : self } } } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct MODE1 { # [ doc = "0x00 - MODE1 Control A" ] pub ctrla : self::mode1::CTRLA , _reserved1 : [ u8 ; 2usize ] , # [ doc = "0x04 - MODE1 Event Control" ] pub evctrl : self::mode1::EVCTRL , # [ doc = "0x08 - MODE1 Interrupt Enable Clear" ] pub intenclr : self::mode1::INTENCLR , # [ doc = "0x0a - MODE1 Interrupt Enable Set" ] pub intenset : self::mode1::INTENSET , # [ doc = "0x0c - MODE1 Interrupt Flag Status and Clear" ] pub intflag : self::mode1::INTFLAG , # [ doc = "0x0e - Debug Control" ] pub dbgctrl : self::mode1::DBGCTRL , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x10 - MODE1 Synchronization Busy Status" ] pub syncbusy : self::mode1::SYNCBUSY , # [ doc = "0x14 - Frequency Correction" ] pub freqcorr : self::mode1::FREQCORR , _reserved8 : [ u8 ; 3usize ] , # [ doc = "0x18 - MODE1 Counter Value" ] pub count : self::mode1::COUNT , _reserved9 : [ u8 ; 2usize ] , # [ doc = "0x1c - MODE1 Counter Period" ] pub per : self::mode1::PER , _reserved10 : [ u8 ; 2usize ] , # [ doc = "0x20 - MODE1 Compare n Value" ] pub comp : [ self::mode1::COMP ; 2 ] , } # [ doc = r"Register block" ] # [ doc = "16-bit Counter with Two 16-bit Compares" ] pub mod mode1 { # [ doc = "MODE1 Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u16 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "MODE1 Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u16 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u16 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "Mode 0: 32-bit Counter" ] COUNT32 , # [ doc = "Mode 1: 16-bit Counter" ] COUNT16 , # [ doc = "Mode 2: Clock/Calendar" ] CLOCK } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: COUNT32 => 0 , MODE_A :: COUNT16 => 1 , MODE_A :: CLOCK => 2 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: COUNT32 ) , 1 => Val ( MODE_A :: COUNT16 ) , 2 => Val ( MODE_A :: CLOCK ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `COUNT32`" ] # [ inline ( always ) ] pub fn is_count32 ( & self ) -> bool { * self == MODE_A :: COUNT32 } # [ doc = "Checks if the value of the field is `COUNT16`" ] # [ inline ( always ) ] pub fn is_count16 ( & self ) -> bool { * self == MODE_A :: COUNT16 } # [ doc = "Checks if the value of the field is `CLOCK`" ] # [ inline ( always ) ] pub fn is_clock ( & self ) -> bool { * self == MODE_A :: CLOCK } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Mode 0: 32-bit Counter" ] # [ inline ( always ) ] pub fn count32 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT32 ) } # [ doc = "Mode 1: 16-bit Counter" ] # [ inline ( always ) ] pub fn count16 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT16 ) } # [ doc = "Mode 2: Clock/Calendar" ] # [ inline ( always ) ] pub fn clock ( self ) -> & 'a mut W { self . variant ( MODE_A :: CLOCK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `PRESCALER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER_A { # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] OFF , # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] DIV1 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/2" ] DIV2 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/4" ] DIV4 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/8" ] DIV8 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/16" ] DIV16 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/32" ] DIV32 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/64" ] DIV64 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/128" ] DIV128 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/256" ] DIV256 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/512" ] DIV512 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/1024" ] DIV1024 } impl crate :: ToBits < u8 > for PRESCALER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER_A :: OFF => 0 , PRESCALER_A :: DIV1 => 1 , PRESCALER_A :: DIV2 => 2 , PRESCALER_A :: DIV4 => 3 , PRESCALER_A :: DIV8 => 4 , PRESCALER_A :: DIV16 => 5 , PRESCALER_A :: DIV32 => 6 , PRESCALER_A :: DIV64 => 7 , PRESCALER_A :: DIV128 => 8 , PRESCALER_A :: DIV256 => 9 , PRESCALER_A :: DIV512 => 10 , PRESCALER_A :: DIV1024 => 11 } } } # [ doc = "Reader of field `PRESCALER`" ] pub type PRESCALER_R = crate :: R < u8 , PRESCALER_A > ; impl PRESCALER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PRESCALER_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PRESCALER_A :: OFF ) , 1 => Val ( PRESCALER_A :: DIV1 ) , 2 => Val ( PRESCALER_A :: DIV2 ) , 3 => Val ( PRESCALER_A :: DIV4 ) , 4 => Val ( PRESCALER_A :: DIV8 ) , 5 => Val ( PRESCALER_A :: DIV16 ) , 6 => Val ( PRESCALER_A :: DIV32 ) , 7 => Val ( PRESCALER_A :: DIV64 ) , 8 => Val ( PRESCALER_A :: DIV128 ) , 9 => Val ( PRESCALER_A :: DIV256 ) , 10 => Val ( PRESCALER_A :: DIV512 ) , 11 => Val ( PRESCALER_A :: DIV1024 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == PRESCALER_A :: OFF } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == PRESCALER_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == PRESCALER_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == PRESCALER_A :: DIV128 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER_A :: DIV256 } # [ doc = "Checks if the value of the field is `DIV512`" ] # [ inline ( always ) ] pub fn is_div512 ( & self ) -> bool { * self == PRESCALER_A :: DIV512 } # [ doc = "Checks if the value of the field is `DIV1024`" ] # [ inline ( always ) ] pub fn is_div1024 ( & self ) -> bool { * self == PRESCALER_A :: DIV1024 } } # [ doc = "Write proxy for field `PRESCALER`" ] pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: OFF ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV2 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV4 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV8 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV16 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/32" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV32 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV64 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/128" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV128 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV256 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/512" ] # [ inline ( always ) ] pub fn div512 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV512 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/1024" ] # [ inline ( always ) ] pub fn div1024 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u16 ) & 0x0f ) << 8 ) ; self . w } } # [ doc = "Reader of field `COUNTSYNC`" ] pub type COUNTSYNC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COUNTSYNC`" ] pub struct COUNTSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > COUNTSYNC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:3 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) } # [ doc = "Bits 8:11 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) } # [ doc = "Bit 15 - Count Read Synchronization Enable" ] # [ inline ( always ) ] pub fn countsync ( & self ) -> COUNTSYNC_R { COUNTSYNC_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:3 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bits 8:11 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } } # [ doc = "Bit 15 - Count Read Synchronization Enable" ] # [ inline ( always ) ] pub fn countsync ( & mut self ) -> COUNTSYNC_W { COUNTSYNC_W { w : self } } } } # [ doc = "MODE1 Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u32 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ; # [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { } # [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { } # [ doc = "MODE1 Event Control" ] pub mod evctrl { # [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u32 , super :: EVCTRL > ; # [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u32 , super :: EVCTRL > ; # [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PEREO0`" ] pub type PEREO0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO0`" ] pub struct PEREO0_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PEREO1`" ] pub type PEREO1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO1`" ] pub struct PEREO1_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PEREO2`" ] pub type PEREO2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO2`" ] pub struct PEREO2_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PEREO3`" ] pub type PEREO3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO3`" ] pub struct PEREO3_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PEREO4`" ] pub type PEREO4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO4`" ] pub struct PEREO4_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PEREO5`" ] pub type PEREO5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO5`" ] pub struct PEREO5_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PEREO6`" ] pub type PEREO6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO6`" ] pub struct PEREO6_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PEREO7`" ] pub type PEREO7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO7`" ] pub struct PEREO7_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `CMPEO0`" ] pub type CMPEO0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMPEO0`" ] pub struct CMPEO0_W < 'a > { w : & 'a mut W , } impl < 'a > CMPEO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `CMPEO1`" ] pub type CMPEO1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMPEO1`" ] pub struct CMPEO1_W < 'a > { w : & 'a mut W , } impl < 'a > CMPEO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `OVFEO`" ] pub type OVFEO_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVFEO`" ] pub struct OVFEO_W < 'a > { w : & 'a mut W , } impl < 'a > OVFEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo0 ( & self ) -> PEREO0_R { PEREO0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo1 ( & self ) -> PEREO1_R { PEREO1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo2 ( & self ) -> PEREO2_R { PEREO2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo3 ( & self ) -> PEREO3_R { PEREO3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo4 ( & self ) -> PEREO4_R { PEREO4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo5 ( & self ) -> PEREO5_R { PEREO5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo6 ( & self ) -> PEREO6_R { PEREO6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo7 ( & self ) -> PEREO7_R { PEREO7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Compare 0 Event Output Enable" ] # [ inline ( always ) ] pub fn cmpeo0 ( & self ) -> CMPEO0_R { CMPEO0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Compare 1 Event Output Enable" ] # [ inline ( always ) ] pub fn cmpeo1 ( & self ) -> CMPEO1_R { CMPEO1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & self ) -> OVFEO_R { OVFEO_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo0 ( & mut self ) -> PEREO0_W { PEREO0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo1 ( & mut self ) -> PEREO1_W { PEREO1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo2 ( & mut self ) -> PEREO2_W { PEREO2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo3 ( & mut self ) -> PEREO3_W { PEREO3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo4 ( & mut self ) -> PEREO4_W { PEREO4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo5 ( & mut self ) -> PEREO5_W { PEREO5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo6 ( & mut self ) -> PEREO6_W { PEREO6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo7 ( & mut self ) -> PEREO7_W { PEREO7_W { w : self } } # [ doc = "Bit 8 - Compare 0 Event Output Enable" ] # [ inline ( always ) ] pub fn cmpeo0 ( & mut self ) -> CMPEO0_W { CMPEO0_W { w : self } } # [ doc = "Bit 9 - Compare 1 Event Output Enable" ] # [ inline ( always ) ] pub fn cmpeo1 ( & mut self ) -> CMPEO1_W { CMPEO1_W { w : self } } # [ doc = "Bit 15 - Overflow Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & mut self ) -> OVFEO_W { OVFEO_W { w : self } } } } # [ doc = "MODE1 Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u16 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "MODE1 Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u16 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u16 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER0`" ] pub type PER0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER0`" ] pub struct PER0_W < 'a > { w : & 'a mut W , } impl < 'a > PER0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PER1`" ] pub type PER1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER1`" ] pub struct PER1_W < 'a > { w : & 'a mut W , } impl < 'a > PER1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PER2`" ] pub type PER2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER2`" ] pub struct PER2_W < 'a > { w : & 'a mut W , } impl < 'a > PER2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PER3`" ] pub type PER3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER3`" ] pub struct PER3_W < 'a > { w : & 'a mut W , } impl < 'a > PER3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PER4`" ] pub type PER4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER4`" ] pub struct PER4_W < 'a > { w : & 'a mut W , } impl < 'a > PER4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PER5`" ] pub type PER5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER5`" ] pub struct PER5_W < 'a > { w : & 'a mut W , } impl < 'a > PER5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PER6`" ] pub type PER6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER6`" ] pub struct PER6_W < 'a > { w : & 'a mut W , } impl < 'a > PER6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PER7`" ] pub type PER7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER7`" ] pub struct PER7_W < 'a > { w : & 'a mut W , } impl < 'a > PER7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `CMP0`" ] pub type CMP0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMP0`" ] pub struct CMP0_W < 'a > { w : & 'a mut W , } impl < 'a > CMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `CMP1`" ] pub type CMP1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMP1`" ] pub struct CMP1_W < 'a > { w : & 'a mut W , } impl < 'a > CMP1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & self ) -> PER0_R { PER0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & self ) -> PER1_R { PER1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & self ) -> PER2_R { PER2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & self ) -> PER3_R { PER3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & self ) -> PER4_R { PER4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & self ) -> PER5_R { PER5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & self ) -> PER6_R { PER6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & self ) -> PER7_R { PER7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Compare 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp0 ( & self ) -> CMP0_R { CMP0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Compare 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp1 ( & self ) -> CMP1_R { CMP1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & mut self ) -> PER0_W { PER0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & mut self ) -> PER1_W { PER1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & mut self ) -> PER2_W { PER2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & mut self ) -> PER3_W { PER3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & mut self ) -> PER4_W { PER4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & mut self ) -> PER5_W { PER5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & mut self ) -> PER6_W { PER6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & mut self ) -> PER7_W { PER7_W { w : self } } # [ doc = "Bit 8 - Compare 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp0 ( & mut self ) -> CMP0_W { CMP0_W { w : self } } # [ doc = "Bit 9 - Compare 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp1 ( & mut self ) -> CMP1_W { CMP1_W { w : self } } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } } } # [ doc = "MODE1 Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u16 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "MODE1 Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u16 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u16 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER0`" ] pub type PER0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER0`" ] pub struct PER0_W < 'a > { w : & 'a mut W , } impl < 'a > PER0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PER1`" ] pub type PER1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER1`" ] pub struct PER1_W < 'a > { w : & 'a mut W , } impl < 'a > PER1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PER2`" ] pub type PER2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER2`" ] pub struct PER2_W < 'a > { w : & 'a mut W , } impl < 'a > PER2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PER3`" ] pub type PER3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER3`" ] pub struct PER3_W < 'a > { w : & 'a mut W , } impl < 'a > PER3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PER4`" ] pub type PER4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER4`" ] pub struct PER4_W < 'a > { w : & 'a mut W , } impl < 'a > PER4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PER5`" ] pub type PER5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER5`" ] pub struct PER5_W < 'a > { w : & 'a mut W , } impl < 'a > PER5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PER6`" ] pub type PER6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER6`" ] pub struct PER6_W < 'a > { w : & 'a mut W , } impl < 'a > PER6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PER7`" ] pub type PER7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER7`" ] pub struct PER7_W < 'a > { w : & 'a mut W , } impl < 'a > PER7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `CMP0`" ] pub type CMP0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMP0`" ] pub struct CMP0_W < 'a > { w : & 'a mut W , } impl < 'a > CMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `CMP1`" ] pub type CMP1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMP1`" ] pub struct CMP1_W < 'a > { w : & 'a mut W , } impl < 'a > CMP1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & self ) -> PER0_R { PER0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & self ) -> PER1_R { PER1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & self ) -> PER2_R { PER2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & self ) -> PER3_R { PER3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & self ) -> PER4_R { PER4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & self ) -> PER5_R { PER5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & self ) -> PER6_R { PER6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & self ) -> PER7_R { PER7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Compare 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp0 ( & self ) -> CMP0_R { CMP0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Compare 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp1 ( & self ) -> CMP1_R { CMP1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & mut self ) -> PER0_W { PER0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & mut self ) -> PER1_W { PER1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & mut self ) -> PER2_W { PER2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & mut self ) -> PER3_W { PER3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & mut self ) -> PER4_W { PER4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & mut self ) -> PER5_W { PER5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & mut self ) -> PER6_W { PER6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & mut self ) -> PER7_W { PER7_W { w : self } } # [ doc = "Bit 8 - Compare 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp0 ( & mut self ) -> CMP0_W { CMP0_W { w : self } } # [ doc = "Bit 9 - Compare 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn cmp1 ( & mut self ) -> CMP1_W { CMP1_W { w : self } } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } } } # [ doc = "MODE1 Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u16 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "MODE1 Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u16 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u16 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER0`" ] pub type PER0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER0`" ] pub struct PER0_W < 'a > { w : & 'a mut W , } impl < 'a > PER0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PER1`" ] pub type PER1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER1`" ] pub struct PER1_W < 'a > { w : & 'a mut W , } impl < 'a > PER1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PER2`" ] pub type PER2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER2`" ] pub struct PER2_W < 'a > { w : & 'a mut W , } impl < 'a > PER2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PER3`" ] pub type PER3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER3`" ] pub struct PER3_W < 'a > { w : & 'a mut W , } impl < 'a > PER3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PER4`" ] pub type PER4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER4`" ] pub struct PER4_W < 'a > { w : & 'a mut W , } impl < 'a > PER4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PER5`" ] pub type PER5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER5`" ] pub struct PER5_W < 'a > { w : & 'a mut W , } impl < 'a > PER5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PER6`" ] pub type PER6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER6`" ] pub struct PER6_W < 'a > { w : & 'a mut W , } impl < 'a > PER6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PER7`" ] pub type PER7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER7`" ] pub struct PER7_W < 'a > { w : & 'a mut W , } impl < 'a > PER7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `CMP0`" ] pub type CMP0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMP0`" ] pub struct CMP0_W < 'a > { w : & 'a mut W , } impl < 'a > CMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `CMP1`" ] pub type CMP1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CMP1`" ] pub struct CMP1_W < 'a > { w : & 'a mut W , } impl < 'a > CMP1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0" ] # [ inline ( always ) ] pub fn per0 ( & self ) -> PER0_R { PER0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1" ] # [ inline ( always ) ] pub fn per1 ( & self ) -> PER1_R { PER1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2" ] # [ inline ( always ) ] pub fn per2 ( & self ) -> PER2_R { PER2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3" ] # [ inline ( always ) ] pub fn per3 ( & self ) -> PER3_R { PER3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4" ] # [ inline ( always ) ] pub fn per4 ( & self ) -> PER4_R { PER4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5" ] # [ inline ( always ) ] pub fn per5 ( & self ) -> PER5_R { PER5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6" ] # [ inline ( always ) ] pub fn per6 ( & self ) -> PER6_R { PER6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7" ] # [ inline ( always ) ] pub fn per7 ( & self ) -> PER7_R { PER7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Compare 0" ] # [ inline ( always ) ] pub fn cmp0 ( & self ) -> CMP0_R { CMP0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Compare 1" ] # [ inline ( always ) ] pub fn cmp1 ( & self ) -> CMP1_R { CMP1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0" ] # [ inline ( always ) ] pub fn per0 ( & mut self ) -> PER0_W { PER0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1" ] # [ inline ( always ) ] pub fn per1 ( & mut self ) -> PER1_W { PER1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2" ] # [ inline ( always ) ] pub fn per2 ( & mut self ) -> PER2_W { PER2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3" ] # [ inline ( always ) ] pub fn per3 ( & mut self ) -> PER3_W { PER3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4" ] # [ inline ( always ) ] pub fn per4 ( & mut self ) -> PER4_W { PER4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5" ] # [ inline ( always ) ] pub fn per5 ( & mut self ) -> PER5_W { PER5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6" ] # [ inline ( always ) ] pub fn per6 ( & mut self ) -> PER6_W { PER6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7" ] # [ inline ( always ) ] pub fn per7 ( & mut self ) -> PER7_W { PER7_W { w : self } } # [ doc = "Bit 8 - Compare 0" ] # [ inline ( always ) ] pub fn cmp0 ( & mut self ) -> CMP0_W { CMP0_W { w : self } } # [ doc = "Bit 9 - Compare 1" ] # [ inline ( always ) ] pub fn cmp1 ( & mut self ) -> CMP1_W { CMP1_W { w : self } } # [ doc = "Bit 15 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } } } # [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } } } } # [ doc = "MODE1 Synchronization Busy Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "MODE1 Synchronization Busy Status" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `FREQCORR`" ] pub type FREQCORR_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COMP0`" ] pub type COMP0_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COMP1`" ] pub type COMP1_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COUNTSYNC`" ] pub type COUNTSYNC_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Software Reset Bit Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable Bit Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - FREQCORR Register Busy" ] # [ inline ( always ) ] pub fn freqcorr ( & self ) -> FREQCORR_R { FREQCORR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - COUNT Register Busy" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - PER Register Busy" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - COMP 0 Register Busy" ] # [ inline ( always ) ] pub fn comp0 ( & self ) -> COMP0_R { COMP0_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - COMP 1 Register Busy" ] # [ inline ( always ) ] pub fn comp1 ( & self ) -> COMP1_R { COMP1_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Count Read Synchronization Enable Bit Busy" ] # [ inline ( always ) ] pub fn countsync ( & self ) -> COUNTSYNC_R { COUNTSYNC_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } } # [ doc = "Frequency Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [freqcorr](freqcorr) module" ] pub type FREQCORR = crate :: Reg < u8 , _FREQCORR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _FREQCORR ; # [ doc = "`read()` method returns [freqcorr::R](freqcorr::R) reader structure" ] impl crate :: Readable for FREQCORR { } # [ doc = "`write(|w| ..)` method takes [freqcorr::W](freqcorr::W) writer structure" ] impl crate :: Writable for FREQCORR { } # [ doc = "Frequency Correction" ] pub mod freqcorr { # [ doc = "Reader of register FREQCORR" ] pub type R = crate :: R < u8 , super :: FREQCORR > ; # [ doc = "Writer for register FREQCORR" ] pub type W = crate :: W < u8 , super :: FREQCORR > ; # [ doc = "Register FREQCORR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: FREQCORR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `VALUE`" ] pub type VALUE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `VALUE`" ] pub struct VALUE_W < 'a > { w : & 'a mut W , } impl < 'a > VALUE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x7f ) | ( ( value as u8 ) & 0x7f ) ; self . w } } # [ doc = "Reader of field `SIGN`" ] pub type SIGN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SIGN`" ] pub struct SIGN_W < 'a > { w : & 'a mut W , } impl < 'a > SIGN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bits 0:6 - Correction Value" ] # [ inline ( always ) ] pub fn value ( & self ) -> VALUE_R { VALUE_R :: new ( ( self . bits & 0x7f ) as u8 ) } # [ doc = "Bit 7 - Correction Sign" ] # [ inline ( always ) ] pub fn sign ( & self ) -> SIGN_R { SIGN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:6 - Correction Value" ] # [ inline ( always ) ] pub fn value ( & mut self ) -> VALUE_W { VALUE_W { w : self } } # [ doc = "Bit 7 - Correction Sign" ] # [ inline ( always ) ] pub fn sign ( & mut self ) -> SIGN_W { SIGN_W { w : self } } } } # [ doc = "MODE1 Counter Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [count](count) module" ] pub type COUNT = crate :: Reg < u16 , _COUNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COUNT ; # [ doc = "`read()` method returns [count::R](count::R) reader structure" ] impl crate :: Readable for COUNT { } # [ doc = "`write(|w| ..)` method takes [count::W](count::W) writer structure" ] impl crate :: Writable for COUNT { } # [ doc = "MODE1 Counter Value" ] pub mod count { # [ doc = "Reader of register COUNT" ] pub type R = crate :: R < u16 , super :: COUNT > ; # [ doc = "Writer for register COUNT" ] pub type W = crate :: W < u16 , super :: COUNT > ; # [ doc = "Register COUNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COUNT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `COUNT`" ] pub struct COUNT_W < 'a > { w : & 'a mut W , } impl < 'a > COUNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & mut self ) -> COUNT_W { COUNT_W { w : self } } } } # [ doc = "MODE1 Counter Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [per](per) module" ] pub type PER = crate :: Reg < u16 , _PER > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PER ; # [ doc = "`read()` method returns [per::R](per::R) reader structure" ] impl crate :: Readable for PER { } # [ doc = "`write(|w| ..)` method takes [per::W](per::W) writer structure" ] impl crate :: Writable for PER { } # [ doc = "MODE1 Counter Period" ] pub mod per { # [ doc = "Reader of register PER" ] pub type R = crate :: R < u16 , super :: PER > ; # [ doc = "Writer for register PER" ] pub type W = crate :: W < u16 , super :: PER > ; # [ doc = "Register PER `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PER { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `PER`" ] pub struct PER_W < 'a > { w : & 'a mut W , } impl < 'a > PER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Counter Period" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Counter Period" ] # [ inline ( always ) ] pub fn per ( & mut self ) -> PER_W { PER_W { w : self } } } } # [ doc = "MODE1 Compare n Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [comp](comp) module" ] pub type COMP = crate :: Reg < u16 , _COMP > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COMP ; # [ doc = "`read()` method returns [comp::R](comp::R) reader structure" ] impl crate :: Readable for COMP { } # [ doc = "`write(|w| ..)` method takes [comp::W](comp::W) writer structure" ] impl crate :: Writable for COMP { } # [ doc = "MODE1 Compare n Value" ] pub mod comp { # [ doc = "Reader of register COMP[%s]" ] pub type R = crate :: R < u16 , super :: COMP > ; # [ doc = "Writer for register COMP[%s]" ] pub type W = crate :: W < u16 , super :: COMP > ; # [ doc = "Register COMP[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COMP { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `COMP`" ] pub type COMP_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `COMP`" ] pub struct COMP_W < 'a > { w : & 'a mut W , } impl < 'a > COMP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Compare Value" ] # [ inline ( always ) ] pub fn comp ( & self ) -> COMP_R { COMP_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Compare Value" ] # [ inline ( always ) ] pub fn comp ( & mut self ) -> COMP_W { COMP_W { w : self } } } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct MODE2 { # [ doc = "0x00 - MODE2 Control A" ] pub ctrla : self::mode2::CTRLA , _reserved1 : [ u8 ; 2usize ] , # [ doc = "0x04 - MODE2 Event Control" ] pub evctrl : self::mode2::EVCTRL , # [ doc = "0x08 - MODE2 Interrupt Enable Clear" ] pub intenclr : self::mode2::INTENCLR , # [ doc = "0x0a - MODE2 Interrupt Enable Set" ] pub intenset : self::mode2::INTENSET , # [ doc = "0x0c - MODE2 Interrupt Flag Status and Clear" ] pub intflag : self::mode2::INTFLAG , # [ doc = "0x0e - Debug Control" ] pub dbgctrl : self::mode2::DBGCTRL , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x10 - MODE2 Synchronization Busy Status" ] pub syncbusy : self::mode2::SYNCBUSY , # [ doc = "0x14 - Frequency Correction" ] pub freqcorr : self::mode2::FREQCORR , _reserved8 : [ u8 ; 3usize ] , # [ doc = "0x18 - MODE2 Clock Value" ] pub clock : self::mode2::CLOCK , _reserved9 : [ u8 ; 4usize ] , # [ doc = "0x20 - MODE2_ALARM Alarm n Value" ] pub alarm : self::mode2::ALARM , # [ doc = "0x24 - MODE2_ALARM Alarm n Mask" ] pub mask : self::mode2::MASK , } # [ doc = r"Register block" ] # [ doc = "Clock/Calendar with Alarm" ] pub mod mode2 { # [ doc = "MODE2 Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u16 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "MODE2 Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u16 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u16 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "Mode 0: 32-bit Counter" ] COUNT32 , # [ doc = "Mode 1: 16-bit Counter" ] COUNT16 , # [ doc = "Mode 2: Clock/Calendar" ] CLOCK } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: COUNT32 => 0 , MODE_A :: COUNT16 => 1 , MODE_A :: CLOCK => 2 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: COUNT32 ) , 1 => Val ( MODE_A :: COUNT16 ) , 2 => Val ( MODE_A :: CLOCK ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `COUNT32`" ] # [ inline ( always ) ] pub fn is_count32 ( & self ) -> bool { * self == MODE_A :: COUNT32 } # [ doc = "Checks if the value of the field is `COUNT16`" ] # [ inline ( always ) ] pub fn is_count16 ( & self ) -> bool { * self == MODE_A :: COUNT16 } # [ doc = "Checks if the value of the field is `CLOCK`" ] # [ inline ( always ) ] pub fn is_clock ( & self ) -> bool { * self == MODE_A :: CLOCK } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Mode 0: 32-bit Counter" ] # [ inline ( always ) ] pub fn count32 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT32 ) } # [ doc = "Mode 1: 16-bit Counter" ] # [ inline ( always ) ] pub fn count16 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT16 ) } # [ doc = "Mode 2: Clock/Calendar" ] # [ inline ( always ) ] pub fn clock ( self ) -> & 'a mut W { self . variant ( MODE_A :: CLOCK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u16 ) & 0x03 ) << 2 ) ; self . w } } # [ doc = "Reader of field `CLKREP`" ] pub type CLKREP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CLKREP`" ] pub struct CLKREP_W < 'a > { w : & 'a mut W , } impl < 'a > CLKREP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `MATCHCLR`" ] pub type MATCHCLR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MATCHCLR`" ] pub struct MATCHCLR_W < 'a > { w : & 'a mut W , } impl < 'a > MATCHCLR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Possible values of the field `PRESCALER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER_A { # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] OFF , # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] DIV1 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/2" ] DIV2 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/4" ] DIV4 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/8" ] DIV8 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/16" ] DIV16 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/32" ] DIV32 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/64" ] DIV64 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/128" ] DIV128 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/256" ] DIV256 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/512" ] DIV512 , # [ doc = "CLK_RTC_CNT = GCLK_RTC/1024" ] DIV1024 } impl crate :: ToBits < u8 > for PRESCALER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER_A :: OFF => 0 , PRESCALER_A :: DIV1 => 1 , PRESCALER_A :: DIV2 => 2 , PRESCALER_A :: DIV4 => 3 , PRESCALER_A :: DIV8 => 4 , PRESCALER_A :: DIV16 => 5 , PRESCALER_A :: DIV32 => 6 , PRESCALER_A :: DIV64 => 7 , PRESCALER_A :: DIV128 => 8 , PRESCALER_A :: DIV256 => 9 , PRESCALER_A :: DIV512 => 10 , PRESCALER_A :: DIV1024 => 11 } } } # [ doc = "Reader of field `PRESCALER`" ] pub type PRESCALER_R = crate :: R < u8 , PRESCALER_A > ; impl PRESCALER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PRESCALER_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PRESCALER_A :: OFF ) , 1 => Val ( PRESCALER_A :: DIV1 ) , 2 => Val ( PRESCALER_A :: DIV2 ) , 3 => Val ( PRESCALER_A :: DIV4 ) , 4 => Val ( PRESCALER_A :: DIV8 ) , 5 => Val ( PRESCALER_A :: DIV16 ) , 6 => Val ( PRESCALER_A :: DIV32 ) , 7 => Val ( PRESCALER_A :: DIV64 ) , 8 => Val ( PRESCALER_A :: DIV128 ) , 9 => Val ( PRESCALER_A :: DIV256 ) , 10 => Val ( PRESCALER_A :: DIV512 ) , 11 => Val ( PRESCALER_A :: DIV1024 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == PRESCALER_A :: OFF } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == PRESCALER_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == PRESCALER_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == PRESCALER_A :: DIV128 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER_A :: DIV256 } # [ doc = "Checks if the value of the field is `DIV512`" ] # [ inline ( always ) ] pub fn is_div512 ( & self ) -> bool { * self == PRESCALER_A :: DIV512 } # [ doc = "Checks if the value of the field is `DIV1024`" ] # [ inline ( always ) ] pub fn is_div1024 ( & self ) -> bool { * self == PRESCALER_A :: DIV1024 } } # [ doc = "Write proxy for field `PRESCALER`" ] pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: OFF ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/1" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV2 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV4 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV8 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV16 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/32" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV32 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV64 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/128" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV128 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV256 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/512" ] # [ inline ( always ) ] pub fn div512 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV512 ) } # [ doc = "CLK_RTC_CNT = GCLK_RTC/1024" ] # [ inline ( always ) ] pub fn div1024 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 8 ) ) | ( ( ( value as u16 ) & 0x0f ) << 8 ) ; self . w } } # [ doc = "Reader of field `CLOCKSYNC`" ] pub type CLOCKSYNC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CLOCKSYNC`" ] pub struct CLOCKSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > CLOCKSYNC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:3 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) } # [ doc = "Bit 6 - Clock Representation" ] # [ inline ( always ) ] pub fn clkrep ( & self ) -> CLKREP_R { CLKREP_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Clear on Match" ] # [ inline ( always ) ] pub fn matchclr ( & self ) -> MATCHCLR_R { MATCHCLR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bits 8:11 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( ( self . bits >> 8 ) & 0x0f ) as u8 ) } # [ doc = "Bit 15 - Clock Read Synchronization Enable" ] # [ inline ( always ) ] pub fn clocksync ( & self ) -> CLOCKSYNC_R { CLOCKSYNC_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:3 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bit 6 - Clock Representation" ] # [ inline ( always ) ] pub fn clkrep ( & mut self ) -> CLKREP_W { CLKREP_W { w : self } } # [ doc = "Bit 7 - Clear on Match" ] # [ inline ( always ) ] pub fn matchclr ( & mut self ) -> MATCHCLR_W { MATCHCLR_W { w : self } } # [ doc = "Bits 8:11 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } } # [ doc = "Bit 15 - Clock Read Synchronization Enable" ] # [ inline ( always ) ] pub fn clocksync ( & mut self ) -> CLOCKSYNC_W { CLOCKSYNC_W { w : self } } } } # [ doc = "MODE2 Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u32 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ; # [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { } # [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { } # [ doc = "MODE2 Event Control" ] pub mod evctrl { # [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u32 , super :: EVCTRL > ; # [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u32 , super :: EVCTRL > ; # [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PEREO0`" ] pub type PEREO0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO0`" ] pub struct PEREO0_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PEREO1`" ] pub type PEREO1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO1`" ] pub struct PEREO1_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PEREO2`" ] pub type PEREO2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO2`" ] pub struct PEREO2_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PEREO3`" ] pub type PEREO3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO3`" ] pub struct PEREO3_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PEREO4`" ] pub type PEREO4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO4`" ] pub struct PEREO4_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PEREO5`" ] pub type PEREO5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO5`" ] pub struct PEREO5_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PEREO6`" ] pub type PEREO6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO6`" ] pub struct PEREO6_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PEREO7`" ] pub type PEREO7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PEREO7`" ] pub struct PEREO7_W < 'a > { w : & 'a mut W , } impl < 'a > PEREO7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `ALARMEO0`" ] pub type ALARMEO0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ALARMEO0`" ] pub struct ALARMEO0_W < 'a > { w : & 'a mut W , } impl < 'a > ALARMEO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `OVFEO`" ] pub type OVFEO_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVFEO`" ] pub struct OVFEO_W < 'a > { w : & 'a mut W , } impl < 'a > OVFEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo0 ( & self ) -> PEREO0_R { PEREO0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo1 ( & self ) -> PEREO1_R { PEREO1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo2 ( & self ) -> PEREO2_R { PEREO2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo3 ( & self ) -> PEREO3_R { PEREO3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo4 ( & self ) -> PEREO4_R { PEREO4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo5 ( & self ) -> PEREO5_R { PEREO5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo6 ( & self ) -> PEREO6_R { PEREO6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo7 ( & self ) -> PEREO7_R { PEREO7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Alarm 0 Event Output Enable" ] # [ inline ( always ) ] pub fn alarmeo0 ( & self ) -> ALARMEO0_R { ALARMEO0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & self ) -> OVFEO_R { OVFEO_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo0 ( & mut self ) -> PEREO0_W { PEREO0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo1 ( & mut self ) -> PEREO1_W { PEREO1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo2 ( & mut self ) -> PEREO2_W { PEREO2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo3 ( & mut self ) -> PEREO3_W { PEREO3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo4 ( & mut self ) -> PEREO4_W { PEREO4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo5 ( & mut self ) -> PEREO5_W { PEREO5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo6 ( & mut self ) -> PEREO6_W { PEREO6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7 Event Output Enable" ] # [ inline ( always ) ] pub fn pereo7 ( & mut self ) -> PEREO7_W { PEREO7_W { w : self } } # [ doc = "Bit 8 - Alarm 0 Event Output Enable" ] # [ inline ( always ) ] pub fn alarmeo0 ( & mut self ) -> ALARMEO0_W { ALARMEO0_W { w : self } } # [ doc = "Bit 15 - Overflow Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & mut self ) -> OVFEO_W { OVFEO_W { w : self } } } } # [ doc = "MODE2 Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u16 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "MODE2 Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u16 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u16 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER0`" ] pub type PER0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER0`" ] pub struct PER0_W < 'a > { w : & 'a mut W , } impl < 'a > PER0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PER1`" ] pub type PER1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER1`" ] pub struct PER1_W < 'a > { w : & 'a mut W , } impl < 'a > PER1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PER2`" ] pub type PER2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER2`" ] pub struct PER2_W < 'a > { w : & 'a mut W , } impl < 'a > PER2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PER3`" ] pub type PER3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER3`" ] pub struct PER3_W < 'a > { w : & 'a mut W , } impl < 'a > PER3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PER4`" ] pub type PER4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER4`" ] pub struct PER4_W < 'a > { w : & 'a mut W , } impl < 'a > PER4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PER5`" ] pub type PER5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER5`" ] pub struct PER5_W < 'a > { w : & 'a mut W , } impl < 'a > PER5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PER6`" ] pub type PER6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER6`" ] pub struct PER6_W < 'a > { w : & 'a mut W , } impl < 'a > PER6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PER7`" ] pub type PER7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER7`" ] pub struct PER7_W < 'a > { w : & 'a mut W , } impl < 'a > PER7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `ALARM0`" ] pub type ALARM0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ALARM0`" ] pub struct ALARM0_W < 'a > { w : & 'a mut W , } impl < 'a > ALARM0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & self ) -> PER0_R { PER0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & self ) -> PER1_R { PER1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & self ) -> PER2_R { PER2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & self ) -> PER3_R { PER3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & self ) -> PER4_R { PER4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & self ) -> PER5_R { PER5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & self ) -> PER6_R { PER6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & self ) -> PER7_R { PER7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Alarm 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn alarm0 ( & self ) -> ALARM0_R { ALARM0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn per0 ( & mut self ) -> PER0_W { PER0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn per1 ( & mut self ) -> PER1_W { PER1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn per2 ( & mut self ) -> PER2_W { PER2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn per3 ( & mut self ) -> PER3_W { PER3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4 Interrupt Enable" ] # [ inline ( always ) ] pub fn per4 ( & mut self ) -> PER4_W { PER4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5 Interrupt Enable" ] # [ inline ( always ) ] pub fn per5 ( & mut self ) -> PER5_W { PER5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6 Interrupt Enable" ] # [ inline ( always ) ] pub fn per6 ( & mut self ) -> PER6_W { PER6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7 Interrupt Enable" ] # [ inline ( always ) ] pub fn per7 ( & mut self ) -> PER7_W { PER7_W { w : self } } # [ doc = "Bit 8 - Alarm 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn alarm0 ( & mut self ) -> ALARM0_W { ALARM0_W { w : self } } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } } } # [ doc = "MODE2 Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u16 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "MODE2 Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u16 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u16 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER0`" ] pub type PER0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER0`" ] pub struct PER0_W < 'a > { w : & 'a mut W , } impl < 'a > PER0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PER1`" ] pub type PER1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER1`" ] pub struct PER1_W < 'a > { w : & 'a mut W , } impl < 'a > PER1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PER2`" ] pub type PER2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER2`" ] pub struct PER2_W < 'a > { w : & 'a mut W , } impl < 'a > PER2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PER3`" ] pub type PER3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER3`" ] pub struct PER3_W < 'a > { w : & 'a mut W , } impl < 'a > PER3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PER4`" ] pub type PER4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER4`" ] pub struct PER4_W < 'a > { w : & 'a mut W , } impl < 'a > PER4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PER5`" ] pub type PER5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER5`" ] pub struct PER5_W < 'a > { w : & 'a mut W , } impl < 'a > PER5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PER6`" ] pub type PER6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER6`" ] pub struct PER6_W < 'a > { w : & 'a mut W , } impl < 'a > PER6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PER7`" ] pub type PER7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER7`" ] pub struct PER7_W < 'a > { w : & 'a mut W , } impl < 'a > PER7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `ALARM0`" ] pub type ALARM0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ALARM0`" ] pub struct ALARM0_W < 'a > { w : & 'a mut W , } impl < 'a > ALARM0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0 Enable" ] # [ inline ( always ) ] pub fn per0 ( & self ) -> PER0_R { PER0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1 Enable" ] # [ inline ( always ) ] pub fn per1 ( & self ) -> PER1_R { PER1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2 Enable" ] # [ inline ( always ) ] pub fn per2 ( & self ) -> PER2_R { PER2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3 Enable" ] # [ inline ( always ) ] pub fn per3 ( & self ) -> PER3_R { PER3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4 Enable" ] # [ inline ( always ) ] pub fn per4 ( & self ) -> PER4_R { PER4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5 Enable" ] # [ inline ( always ) ] pub fn per5 ( & self ) -> PER5_R { PER5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6 Enable" ] # [ inline ( always ) ] pub fn per6 ( & self ) -> PER6_R { PER6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7 Enable" ] # [ inline ( always ) ] pub fn per7 ( & self ) -> PER7_R { PER7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Alarm 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn alarm0 ( & self ) -> ALARM0_R { ALARM0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0 Enable" ] # [ inline ( always ) ] pub fn per0 ( & mut self ) -> PER0_W { PER0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1 Enable" ] # [ inline ( always ) ] pub fn per1 ( & mut self ) -> PER1_W { PER1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2 Enable" ] # [ inline ( always ) ] pub fn per2 ( & mut self ) -> PER2_W { PER2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3 Enable" ] # [ inline ( always ) ] pub fn per3 ( & mut self ) -> PER3_W { PER3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4 Enable" ] # [ inline ( always ) ] pub fn per4 ( & mut self ) -> PER4_W { PER4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5 Enable" ] # [ inline ( always ) ] pub fn per5 ( & mut self ) -> PER5_W { PER5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6 Enable" ] # [ inline ( always ) ] pub fn per6 ( & mut self ) -> PER6_W { PER6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7 Enable" ] # [ inline ( always ) ] pub fn per7 ( & mut self ) -> PER7_W { PER7_W { w : self } } # [ doc = "Bit 8 - Alarm 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn alarm0 ( & mut self ) -> ALARM0_W { ALARM0_W { w : self } } # [ doc = "Bit 15 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } } } # [ doc = "MODE2 Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u16 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "MODE2 Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u16 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u16 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PER0`" ] pub type PER0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER0`" ] pub struct PER0_W < 'a > { w : & 'a mut W , } impl < 'a > PER0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `PER1`" ] pub type PER1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER1`" ] pub struct PER1_W < 'a > { w : & 'a mut W , } impl < 'a > PER1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PER2`" ] pub type PER2_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER2`" ] pub struct PER2_W < 'a > { w : & 'a mut W , } impl < 'a > PER2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `PER3`" ] pub type PER3_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER3`" ] pub struct PER3_W < 'a > { w : & 'a mut W , } impl < 'a > PER3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `PER4`" ] pub type PER4_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER4`" ] pub struct PER4_W < 'a > { w : & 'a mut W , } impl < 'a > PER4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `PER5`" ] pub type PER5_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER5`" ] pub struct PER5_W < 'a > { w : & 'a mut W , } impl < 'a > PER5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `PER6`" ] pub type PER6_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER6`" ] pub struct PER6_W < 'a > { w : & 'a mut W , } impl < 'a > PER6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `PER7`" ] pub type PER7_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PER7`" ] pub struct PER7_W < 'a > { w : & 'a mut W , } impl < 'a > PER7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `ALARM0`" ] pub type ALARM0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ALARM0`" ] pub struct ALARM0_W < 'a > { w : & 'a mut W , } impl < 'a > ALARM0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } } impl R { # [ doc = "Bit 0 - Periodic Interval 0" ] # [ inline ( always ) ] pub fn per0 ( & self ) -> PER0_R { PER0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Periodic Interval 1" ] # [ inline ( always ) ] pub fn per1 ( & self ) -> PER1_R { PER1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Periodic Interval 2" ] # [ inline ( always ) ] pub fn per2 ( & self ) -> PER2_R { PER2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Periodic Interval 3" ] # [ inline ( always ) ] pub fn per3 ( & self ) -> PER3_R { PER3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Periodic Interval 4" ] # [ inline ( always ) ] pub fn per4 ( & self ) -> PER4_R { PER4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Periodic Interval 5" ] # [ inline ( always ) ] pub fn per5 ( & self ) -> PER5_R { PER5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Periodic Interval 6" ] # [ inline ( always ) ] pub fn per6 ( & self ) -> PER6_R { PER6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Periodic Interval 7" ] # [ inline ( always ) ] pub fn per7 ( & self ) -> PER7_R { PER7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Alarm 0" ] # [ inline ( always ) ] pub fn alarm0 ( & self ) -> ALARM0_R { ALARM0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Periodic Interval 0" ] # [ inline ( always ) ] pub fn per0 ( & mut self ) -> PER0_W { PER0_W { w : self } } # [ doc = "Bit 1 - Periodic Interval 1" ] # [ inline ( always ) ] pub fn per1 ( & mut self ) -> PER1_W { PER1_W { w : self } } # [ doc = "Bit 2 - Periodic Interval 2" ] # [ inline ( always ) ] pub fn per2 ( & mut self ) -> PER2_W { PER2_W { w : self } } # [ doc = "Bit 3 - Periodic Interval 3" ] # [ inline ( always ) ] pub fn per3 ( & mut self ) -> PER3_W { PER3_W { w : self } } # [ doc = "Bit 4 - Periodic Interval 4" ] # [ inline ( always ) ] pub fn per4 ( & mut self ) -> PER4_W { PER4_W { w : self } } # [ doc = "Bit 5 - Periodic Interval 5" ] # [ inline ( always ) ] pub fn per5 ( & mut self ) -> PER5_W { PER5_W { w : self } } # [ doc = "Bit 6 - Periodic Interval 6" ] # [ inline ( always ) ] pub fn per6 ( & mut self ) -> PER6_W { PER6_W { w : self } } # [ doc = "Bit 7 - Periodic Interval 7" ] # [ inline ( always ) ] pub fn per7 ( & mut self ) -> PER7_W { PER7_W { w : self } } # [ doc = "Bit 8 - Alarm 0" ] # [ inline ( always ) ] pub fn alarm0 ( & mut self ) -> ALARM0_W { ALARM0_W { w : self } } # [ doc = "Bit 15 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } } } # [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } } } } # [ doc = "MODE2 Synchronization Busy Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "MODE2 Synchronization Busy Status" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `FREQCORR`" ] pub type FREQCORR_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CLOCK`" ] pub type CLOCK_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ALARM0`" ] pub type ALARM0_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `MASK0`" ] pub type MASK0_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CLOCKSYNC`" ] pub type CLOCKSYNC_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Software Reset Bit Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable Bit Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - FREQCORR Register Busy" ] # [ inline ( always ) ] pub fn freqcorr ( & self ) -> FREQCORR_R { FREQCORR_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - CLOCK Register Busy" ] # [ inline ( always ) ] pub fn clock ( & self ) -> CLOCK_R { CLOCK_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - ALARM 0 Register Busy" ] # [ inline ( always ) ] pub fn alarm0 ( & self ) -> ALARM0_R { ALARM0_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 11 - MASK 0 Register Busy" ] # [ inline ( always ) ] pub fn mask0 ( & self ) -> MASK0_R { MASK0_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Clock Read Synchronization Enable Bit Busy" ] # [ inline ( always ) ] pub fn clocksync ( & self ) -> CLOCKSYNC_R { CLOCKSYNC_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } } } # [ doc = "Frequency Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [freqcorr](freqcorr) module" ] pub type FREQCORR = crate :: Reg < u8 , _FREQCORR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _FREQCORR ; # [ doc = "`read()` method returns [freqcorr::R](freqcorr::R) reader structure" ] impl crate :: Readable for FREQCORR { } # [ doc = "`write(|w| ..)` method takes [freqcorr::W](freqcorr::W) writer structure" ] impl crate :: Writable for FREQCORR { } # [ doc = "Frequency Correction" ] pub mod freqcorr { # [ doc = "Reader of register FREQCORR" ] pub type R = crate :: R < u8 , super :: FREQCORR > ; # [ doc = "Writer for register FREQCORR" ] pub type W = crate :: W < u8 , super :: FREQCORR > ; # [ doc = "Register FREQCORR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: FREQCORR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `VALUE`" ] pub type VALUE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `VALUE`" ] pub struct VALUE_W < 'a > { w : & 'a mut W , } impl < 'a > VALUE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x7f ) | ( ( value as u8 ) & 0x7f ) ; self . w } } # [ doc = "Reader of field `SIGN`" ] pub type SIGN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SIGN`" ] pub struct SIGN_W < 'a > { w : & 'a mut W , } impl < 'a > SIGN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bits 0:6 - Correction Value" ] # [ inline ( always ) ] pub fn value ( & self ) -> VALUE_R { VALUE_R :: new ( ( self . bits & 0x7f ) as u8 ) } # [ doc = "Bit 7 - Correction Sign" ] # [ inline ( always ) ] pub fn sign ( & self ) -> SIGN_R { SIGN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:6 - Correction Value" ] # [ inline ( always ) ] pub fn value ( & mut self ) -> VALUE_W { VALUE_W { w : self } } # [ doc = "Bit 7 - Correction Sign" ] # [ inline ( always ) ] pub fn sign ( & mut self ) -> SIGN_W { SIGN_W { w : self } } } } # [ doc = "MODE2 Clock Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [clock](clock) module" ] pub type CLOCK = crate :: Reg < u32 , _CLOCK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CLOCK ; # [ doc = "`read()` method returns [clock::R](clock::R) reader structure" ] impl crate :: Readable for CLOCK { } # [ doc = "`write(|w| ..)` method takes [clock::W](clock::W) writer structure" ] impl crate :: Writable for CLOCK { } # [ doc = "MODE2 Clock Value" ] pub mod clock { # [ doc = "Reader of register CLOCK" ] pub type R = crate :: R < u32 , super :: CLOCK > ; # [ doc = "Writer for register CLOCK" ] pub type W = crate :: W < u32 , super :: CLOCK > ; # [ doc = "Register CLOCK `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CLOCK { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SECOND`" ] pub type SECOND_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `SECOND`" ] pub struct SECOND_W < 'a > { w : & 'a mut W , } impl < 'a > SECOND_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `MINUTE`" ] pub type MINUTE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MINUTE`" ] pub struct MINUTE_W < 'a > { w : & 'a mut W , } impl < 'a > MINUTE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Possible values of the field `HOUR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HOUR_A { # [ doc = "AM when CLKREP in 12-hour" ] AM , # [ doc = "PM when CLKREP in 12-hour" ] PM } impl crate :: ToBits < u8 > for HOUR_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { HOUR_A :: AM => 0 , HOUR_A :: PM => 16 } } } # [ doc = "Reader of field `HOUR`" ] pub type HOUR_R = crate :: R < u8 , HOUR_A > ; impl HOUR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , HOUR_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( HOUR_A :: AM ) , 16 => Val ( HOUR_A :: PM ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `AM`" ] # [ inline ( always ) ] pub fn is_am ( & self ) -> bool { * self == HOUR_A :: AM } # [ doc = "Checks if the value of the field is `PM`" ] # [ inline ( always ) ] pub fn is_pm ( & self ) -> bool { * self == HOUR_A :: PM } } # [ doc = "Write proxy for field `HOUR`" ] pub struct HOUR_W < 'a > { w : & 'a mut W , } impl < 'a > HOUR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : HOUR_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "AM when CLKREP in 12-hour" ] # [ inline ( always ) ] pub fn am ( self ) -> & 'a mut W { self . variant ( HOUR_A :: AM ) } # [ doc = "PM when CLKREP in 12-hour" ] # [ inline ( always ) ] pub fn pm ( self ) -> & 'a mut W { self . variant ( HOUR_A :: PM ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 12 ) ) | ( ( ( value as u32 ) & 0x1f ) << 12 ) ; self . w } } # [ doc = "Reader of field `DAY`" ] pub type DAY_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `DAY`" ] pub struct DAY_W < 'a > { w : & 'a mut W , } impl < 'a > DAY_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 17 ) ) | ( ( ( value as u32 ) & 0x1f ) << 17 ) ; self . w } } # [ doc = "Reader of field `MONTH`" ] pub type MONTH_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MONTH`" ] pub struct MONTH_W < 'a > { w : & 'a mut W , } impl < 'a > MONTH_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 22 ) ) | ( ( ( value as u32 ) & 0x0f ) << 22 ) ; self . w } } # [ doc = "Reader of field `YEAR`" ] pub type YEAR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `YEAR`" ] pub struct YEAR_W < 'a > { w : & 'a mut W , } impl < 'a > YEAR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 26 ) ) | ( ( ( value as u32 ) & 0x3f ) << 26 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - Second" ] # [ inline ( always ) ] pub fn second ( & self ) -> SECOND_R { SECOND_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - Minute" ] # [ inline ( always ) ] pub fn minute ( & self ) -> MINUTE_R { MINUTE_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:16 - Hour" ] # [ inline ( always ) ] pub fn hour ( & self ) -> HOUR_R { HOUR_R :: new ( ( ( self . bits >> 12 ) & 0x1f ) as u8 ) } # [ doc = "Bits 17:21 - Day" ] # [ inline ( always ) ] pub fn day ( & self ) -> DAY_R { DAY_R :: new ( ( ( self . bits >> 17 ) & 0x1f ) as u8 ) } # [ doc = "Bits 22:25 - Month" ] # [ inline ( always ) ] pub fn month ( & self ) -> MONTH_R { MONTH_R :: new ( ( ( self . bits >> 22 ) & 0x0f ) as u8 ) } # [ doc = "Bits 26:31 - Year" ] # [ inline ( always ) ] pub fn year ( & self ) -> YEAR_R { YEAR_R :: new ( ( ( self . bits >> 26 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - Second" ] # [ inline ( always ) ] pub fn second ( & mut self ) -> SECOND_W { SECOND_W { w : self } } # [ doc = "Bits 6:11 - Minute" ] # [ inline ( always ) ] pub fn minute ( & mut self ) -> MINUTE_W { MINUTE_W { w : self } } # [ doc = "Bits 12:16 - Hour" ] # [ inline ( always ) ] pub fn hour ( & mut self ) -> HOUR_W { HOUR_W { w : self } } # [ doc = "Bits 17:21 - Day" ] # [ inline ( always ) ] pub fn day ( & mut self ) -> DAY_W { DAY_W { w : self } } # [ doc = "Bits 22:25 - Month" ] # [ inline ( always ) ] pub fn month ( & mut self ) -> MONTH_W { MONTH_W { w : self } } # [ doc = "Bits 26:31 - Year" ] # [ inline ( always ) ] pub fn year ( & mut self ) -> YEAR_W { YEAR_W { w : self } } } } # [ doc = "MODE2_ALARM Alarm n Value\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [alarm](alarm) module" ] pub type ALARM = crate :: Reg < u32 , _ALARM > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ALARM ; # [ doc = "`read()` method returns [alarm::R](alarm::R) reader structure" ] impl crate :: Readable for ALARM { } # [ doc = "`write(|w| ..)` method takes [alarm::W](alarm::W) writer structure" ] impl crate :: Writable for ALARM { } # [ doc = "MODE2_ALARM Alarm n Value" ] pub mod alarm { # [ doc = "Reader of register ALARM" ] pub type R = crate :: R < u32 , super :: ALARM > ; # [ doc = "Writer for register ALARM" ] pub type W = crate :: W < u32 , super :: ALARM > ; # [ doc = "Register ALARM `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ALARM { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SECOND`" ] pub type SECOND_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `SECOND`" ] pub struct SECOND_W < 'a > { w : & 'a mut W , } impl < 'a > SECOND_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } } # [ doc = "Reader of field `MINUTE`" ] pub type MINUTE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MINUTE`" ] pub struct MINUTE_W < 'a > { w : & 'a mut W , } impl < 'a > MINUTE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 6 ) ) | ( ( ( value as u32 ) & 0x3f ) << 6 ) ; self . w } } # [ doc = "Possible values of the field `HOUR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HOUR_A { # [ doc = "Morning hour" ] AM , # [ doc = "Afternoon hour" ] PM } impl crate :: ToBits < u8 > for HOUR_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { HOUR_A :: AM => 0 , HOUR_A :: PM => 16 } } } # [ doc = "Reader of field `HOUR`" ] pub type HOUR_R = crate :: R < u8 , HOUR_A > ; impl HOUR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , HOUR_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( HOUR_A :: AM ) , 16 => Val ( HOUR_A :: PM ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `AM`" ] # [ inline ( always ) ] pub fn is_am ( & self ) -> bool { * self == HOUR_A :: AM } # [ doc = "Checks if the value of the field is `PM`" ] # [ inline ( always ) ] pub fn is_pm ( & self ) -> bool { * self == HOUR_A :: PM } } # [ doc = "Write proxy for field `HOUR`" ] pub struct HOUR_W < 'a > { w : & 'a mut W , } impl < 'a > HOUR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : HOUR_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Morning hour" ] # [ inline ( always ) ] pub fn am ( self ) -> & 'a mut W { self . variant ( HOUR_A :: AM ) } # [ doc = "Afternoon hour" ] # [ inline ( always ) ] pub fn pm ( self ) -> & 'a mut W { self . variant ( HOUR_A :: PM ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 12 ) ) | ( ( ( value as u32 ) & 0x1f ) << 12 ) ; self . w } } # [ doc = "Reader of field `DAY`" ] pub type DAY_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `DAY`" ] pub struct DAY_W < 'a > { w : & 'a mut W , } impl < 'a > DAY_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x1f << 17 ) ) | ( ( ( value as u32 ) & 0x1f ) << 17 ) ; self . w } } # [ doc = "Reader of field `MONTH`" ] pub type MONTH_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `MONTH`" ] pub struct MONTH_W < 'a > { w : & 'a mut W , } impl < 'a > MONTH_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 22 ) ) | ( ( ( value as u32 ) & 0x0f ) << 22 ) ; self . w } } # [ doc = "Reader of field `YEAR`" ] pub type YEAR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `YEAR`" ] pub struct YEAR_W < 'a > { w : & 'a mut W , } impl < 'a > YEAR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 26 ) ) | ( ( ( value as u32 ) & 0x3f ) << 26 ) ; self . w } } impl R { # [ doc = "Bits 0:5 - Second" ] # [ inline ( always ) ] pub fn second ( & self ) -> SECOND_R { SECOND_R :: new ( ( self . bits & 0x3f ) as u8 ) } # [ doc = "Bits 6:11 - Minute" ] # [ inline ( always ) ] pub fn minute ( & self ) -> MINUTE_R { MINUTE_R :: new ( ( ( self . bits >> 6 ) & 0x3f ) as u8 ) } # [ doc = "Bits 12:16 - Hour" ] # [ inline ( always ) ] pub fn hour ( & self ) -> HOUR_R { HOUR_R :: new ( ( ( self . bits >> 12 ) & 0x1f ) as u8 ) } # [ doc = "Bits 17:21 - Day" ] # [ inline ( always ) ] pub fn day ( & self ) -> DAY_R { DAY_R :: new ( ( ( self . bits >> 17 ) & 0x1f ) as u8 ) } # [ doc = "Bits 22:25 - Month" ] # [ inline ( always ) ] pub fn month ( & self ) -> MONTH_R { MONTH_R :: new ( ( ( self . bits >> 22 ) & 0x0f ) as u8 ) } # [ doc = "Bits 26:31 - Year" ] # [ inline ( always ) ] pub fn year ( & self ) -> YEAR_R { YEAR_R :: new ( ( ( self . bits >> 26 ) & 0x3f ) as u8 ) } } impl W { # [ doc = "Bits 0:5 - Second" ] # [ inline ( always ) ] pub fn second ( & mut self ) -> SECOND_W { SECOND_W { w : self } } # [ doc = "Bits 6:11 - Minute" ] # [ inline ( always ) ] pub fn minute ( & mut self ) -> MINUTE_W { MINUTE_W { w : self } } # [ doc = "Bits 12:16 - Hour" ] # [ inline ( always ) ] pub fn hour ( & mut self ) -> HOUR_W { HOUR_W { w : self } } # [ doc = "Bits 17:21 - Day" ] # [ inline ( always ) ] pub fn day ( & mut self ) -> DAY_W { DAY_W { w : self } } # [ doc = "Bits 22:25 - Month" ] # [ inline ( always ) ] pub fn month ( & mut self ) -> MONTH_W { MONTH_W { w : self } } # [ doc = "Bits 26:31 - Year" ] # [ inline ( always ) ] pub fn year ( & mut self ) -> YEAR_W { YEAR_W { w : self } } } } # [ doc = "MODE2_ALARM Alarm n Mask\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [mask](mask) module" ] pub type MASK = crate :: Reg < u8 , _MASK > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _MASK ; # [ doc = "`read()` method returns [mask::R](mask::R) reader structure" ] impl crate :: Readable for MASK { } # [ doc = "`write(|w| ..)` method takes [mask::W](mask::W) writer structure" ] impl crate :: Writable for MASK { } # [ doc = "MODE2_ALARM Alarm n Mask" ] pub mod mask { # [ doc = "Reader of register MASK" ] pub type R = crate :: R < u8 , super :: MASK > ; # [ doc = "Writer for register MASK" ] pub type W = crate :: W < u8 , super :: MASK > ; # [ doc = "Register MASK `reset()`'s with value 0" ] impl crate :: ResetValue for super :: MASK { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `SEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SEL_A { # [ doc = "Alarm Disabled" ] OFF , # [ doc = "Match seconds only" ] SS , # [ doc = "Match seconds and minutes only" ] MMSS , # [ doc = "Match seconds, minutes, and hours only" ] HHMMSS , # [ doc = "Match seconds, minutes, hours, and days only" ] DDHHMMSS , # [ doc = "Match seconds, minutes, hours, days, and months only" ] MMDDHHMMSS , # [ doc = "Match seconds, minutes, hours, days, months, and years" ] YYMMDDHHMMSS } impl crate :: ToBits < u8 > for SEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SEL_A :: OFF => 0 , SEL_A :: SS => 1 , SEL_A :: MMSS => 2 , SEL_A :: HHMMSS => 3 , SEL_A :: DDHHMMSS => 4 , SEL_A :: MMDDHHMMSS => 5 , SEL_A :: YYMMDDHHMMSS => 6 } } } # [ doc = "Reader of field `SEL`" ] pub type SEL_R = crate :: R < u8 , SEL_A > ; impl SEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SEL_A :: OFF ) , 1 => Val ( SEL_A :: SS ) , 2 => Val ( SEL_A :: MMSS ) , 3 => Val ( SEL_A :: HHMMSS ) , 4 => Val ( SEL_A :: DDHHMMSS ) , 5 => Val ( SEL_A :: MMDDHHMMSS ) , 6 => Val ( SEL_A :: YYMMDDHHMMSS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == SEL_A :: OFF } # [ doc = "Checks if the value of the field is `SS`" ] # [ inline ( always ) ] pub fn is_ss ( & self ) -> bool { * self == SEL_A :: SS } # [ doc = "Checks if the value of the field is `MMSS`" ] # [ inline ( always ) ] pub fn is_mmss ( & self ) -> bool { * self == SEL_A :: MMSS } # [ doc = "Checks if the value of the field is `HHMMSS`" ] # [ inline ( always ) ] pub fn is_hhmmss ( & self ) -> bool { * self == SEL_A :: HHMMSS } # [ doc = "Checks if the value of the field is `DDHHMMSS`" ] # [ inline ( always ) ] pub fn is_ddhhmmss ( & self ) -> bool { * self == SEL_A :: DDHHMMSS } # [ doc = "Checks if the value of the field is `MMDDHHMMSS`" ] # [ inline ( always ) ] pub fn is_mmddhhmmss ( & self ) -> bool { * self == SEL_A :: MMDDHHMMSS } # [ doc = "Checks if the value of the field is `YYMMDDHHMMSS`" ] # [ inline ( always ) ] pub fn is_yymmddhhmmss ( & self ) -> bool { * self == SEL_A :: YYMMDDHHMMSS } } # [ doc = "Write proxy for field `SEL`" ] pub struct SEL_W < 'a > { w : & 'a mut W , } impl < 'a > SEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SEL_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Alarm Disabled" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( SEL_A :: OFF ) } # [ doc = "Match seconds only" ] # [ inline ( always ) ] pub fn ss ( self ) -> & 'a mut W { self . variant ( SEL_A :: SS ) } # [ doc = "Match seconds and minutes only" ] # [ inline ( always ) ] pub fn mmss ( self ) -> & 'a mut W { self . variant ( SEL_A :: MMSS ) } # [ doc = "Match seconds, minutes, and hours only" ] # [ inline ( always ) ] pub fn hhmmss ( self ) -> & 'a mut W { self . variant ( SEL_A :: HHMMSS ) } # [ doc = "Match seconds, minutes, hours, and days only" ] # [ inline ( always ) ] pub fn ddhhmmss ( self ) -> & 'a mut W { self . variant ( SEL_A :: DDHHMMSS ) } # [ doc = "Match seconds, minutes, hours, days, and months only" ] # [ inline ( always ) ] pub fn mmddhhmmss ( self ) -> & 'a mut W { self . variant ( SEL_A :: MMDDHHMMSS ) } # [ doc = "Match seconds, minutes, hours, days, months, and years" ] # [ inline ( always ) ] pub fn yymmddhhmmss ( self ) -> & 'a mut W { self . variant ( SEL_A :: YYMMDDHHMMSS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u8 ) & 0x07 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - Alarm Mask Selection" ] # [ inline ( always ) ] pub fn sel ( & self ) -> SEL_R { SEL_R :: new ( ( self . bits & 0x07 ) as u8 ) } } impl W { # [ doc = "Bits 0:2 - Alarm Mask Selection" ] # [ inline ( always ) ] pub fn sel ( & mut self ) -> SEL_W { SEL_W { w : self } } } } }
}
# [ doc = "Sigma-Delta Analog Digital Converter" ] pub struct SDADC { _marker : PhantomData < * const ( ) > } unsafe impl Send for SDADC { } impl SDADC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sdadc :: RegisterBlock { 0x4200_4c00 as * const _ } } impl Deref for SDADC { type Target = sdadc :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SDADC :: ptr ( ) } } }
# [ doc = "Sigma-Delta Analog Digital Converter" ] pub mod sdadc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control A" ] pub ctrla : CTRLA , # [ doc = "0x01 - Reference Control" ] pub refctrl : REFCTRL , # [ doc = "0x02 - Control B" ] pub ctrlb : CTRLB , # [ doc = "0x04 - Event Control" ] pub evctrl : EVCTRL , # [ doc = "0x05 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x06 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x07 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x08 - Sequence Status" ] pub seqstatus : SEQSTATUS , # [ doc = "0x09 - Input Control" ] pub inputctrl : INPUTCTRL , # [ doc = "0x0a - Control C" ] pub ctrlc : CTRLC , # [ doc = "0x0b - Window Monitor Control" ] pub winctrl : WINCTRL , # [ doc = "0x0c - Window Monitor Lower Threshold" ] pub winlt : WINLT , # [ doc = "0x10 - Window Monitor Upper Threshold" ] pub winut : WINUT , # [ doc = "0x14 - Offset Correction" ] pub offsetcorr : OFFSETCORR , # [ doc = "0x18 - Gain Correction" ] pub gaincorr : GAINCORR , # [ doc = "0x1a - Shift Correction" ] pub shiftcorr : SHIFTCORR , _reserved16 : [ u8 ; 1usize ] , # [ doc = "0x1c - Software Trigger" ] pub swtrig : SWTRIG , _reserved17 : [ u8 ; 3usize ] , # [ doc = "0x20 - Synchronization Busy" ] pub syncbusy : SYNCBUSY , # [ doc = "0x24 - Result" ] pub result : RESULT , # [ doc = "0x28 - Sequence Control" ] pub seqctrl : SEQCTRL , _reserved20 : [ u8 ; 3usize ] , # [ doc = "0x2c - Analog Control" ] pub anactrl : ANACTRL , _reserved21 : [ u8 ; 1usize ] , # [ doc = "0x2e - Debug Control" ] pub dbgctrl : DBGCTRL , }
# [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control A" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } }
}
}
# [ doc = "Reference Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [refctrl](refctrl) module" ] pub type REFCTRL = crate :: Reg < u8 , _REFCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _REFCTRL ;
# [ doc = "`read()` method returns [refctrl::R](refctrl::R) reader structure" ] impl crate :: Readable for REFCTRL { }
# [ doc = "`write(|w| ..)` method takes [refctrl::W](refctrl::W) writer structure" ] impl crate :: Writable for REFCTRL { }
# [ doc = "Reference Control" ] pub mod refctrl {
# [ doc = "Reader of register REFCTRL" ] pub type R = crate :: R < u8 , super :: REFCTRL > ;
# [ doc = "Writer for register REFCTRL" ] pub type W = crate :: W < u8 , super :: REFCTRL > ;
# [ doc = "Register REFCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: REFCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `REFSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum REFSEL_A { # [ doc = "Internal Bandgap Reference" ] INTREF , # [ doc = "External Reference" ] AREFB , # [ doc = "Internal DAC Output" ] DAC , # [ doc = "VDDANA" ] INTVCC }
impl crate :: ToBits < u8 > for REFSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { REFSEL_A :: INTREF => 0 , REFSEL_A :: AREFB => 1 , REFSEL_A :: DAC => 2 , REFSEL_A :: INTVCC => 3 } } }
# [ doc = "Reader of field `REFSEL`" ] pub type REFSEL_R = crate :: R < u8 , REFSEL_A > ; impl REFSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> REFSEL_A { match self . bits { 0 => REFSEL_A :: INTREF , 1 => REFSEL_A :: AREFB , 2 => REFSEL_A :: DAC , 3 => REFSEL_A :: INTVCC , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `INTREF`" ] # [ inline ( always ) ] pub fn is_intref ( & self ) -> bool { * self == REFSEL_A :: INTREF } # [ doc = "Checks if the value of the field is `AREFB`" ] # [ inline ( always ) ] pub fn is_arefb ( & self ) -> bool { * self == REFSEL_A :: AREFB } # [ doc = "Checks if the value of the field is `DAC`" ] # [ inline ( always ) ] pub fn is_dac ( & self ) -> bool { * self == REFSEL_A :: DAC } # [ doc = "Checks if the value of the field is `INTVCC`" ] # [ inline ( always ) ] pub fn is_intvcc ( & self ) -> bool { * self == REFSEL_A :: INTVCC } }
# [ doc = "Write proxy for field `REFSEL`" ] pub struct REFSEL_W < 'a > { w : & 'a mut W , } impl < 'a > REFSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : REFSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Internal Bandgap Reference" ] # [ inline ( always ) ] pub fn intref ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: INTREF ) } # [ doc = "External Reference" ] # [ inline ( always ) ] pub fn arefb ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: AREFB ) } # [ doc = "Internal DAC Output" ] # [ inline ( always ) ] pub fn dac ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: DAC ) } # [ doc = "VDDANA" ] # [ inline ( always ) ] pub fn intvcc ( self ) -> & 'a mut W { self . variant ( REFSEL_A :: INTVCC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u8 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `REFRANGE`" ] pub type REFRANGE_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `REFRANGE`" ] pub struct REFRANGE_W < 'a > { w : & 'a mut W , } impl < 'a > REFRANGE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u8 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `ONREFBUF`" ] pub type ONREFBUF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONREFBUF`" ] pub struct ONREFBUF_W < 'a > { w : & 'a mut W , } impl < 'a > ONREFBUF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Reference Selection" ] # [ inline ( always ) ] pub fn refsel ( & self ) -> REFSEL_R { REFSEL_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bits 4:5 - Reference Range" ] # [ inline ( always ) ] pub fn refrange ( & self ) -> REFRANGE_R { REFRANGE_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - Reference Buffer" ] # [ inline ( always ) ] pub fn onrefbuf ( & self ) -> ONREFBUF_R { ONREFBUF_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:1 - Reference Selection" ] # [ inline ( always ) ] pub fn refsel ( & mut self ) -> REFSEL_W { REFSEL_W { w : self } }
# [ doc = "Bits 4:5 - Reference Range" ] # [ inline ( always ) ] pub fn refrange ( & mut self ) -> REFRANGE_W { REFRANGE_W { w : self } }
# [ doc = "Bit 7 - Reference Buffer" ] # [ inline ( always ) ] pub fn onrefbuf ( & mut self ) -> ONREFBUF_W { ONREFBUF_W { w : self } }
}
}
# [ doc = "Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u16 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ;
# [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { }
# [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { }
# [ doc = "Control B" ] pub mod ctrlb {
# [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u16 , super :: CTRLB > ;
# [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u16 , super :: CTRLB > ;
# [ doc = "Register CTRLB `reset()`'s with value 0x2000" ] impl crate :: ResetValue for super :: CTRLB { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x2000 } }
# [ doc = "Possible values of the field `PRESCALER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER_A { # [ doc = "Peripheral clock divided by 2" ] DIV2 , # [ doc = "Peripheral clock divided by 4" ] DIV4 , # [ doc = "Peripheral clock divided by 8" ] DIV8 , # [ doc = "Peripheral clock divided by 16" ] DIV16 , # [ doc = "Peripheral clock divided by 32" ] DIV32 , # [ doc = "Peripheral clock divided by 64" ] DIV64 , # [ doc = "Peripheral clock divided by 128" ] DIV128 , # [ doc = "Peripheral clock divided by 256" ] DIV256 }
impl crate :: ToBits < u8 > for PRESCALER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER_A :: DIV2 => 0 , PRESCALER_A :: DIV4 => 1 , PRESCALER_A :: DIV8 => 2 , PRESCALER_A :: DIV16 => 3 , PRESCALER_A :: DIV32 => 4 , PRESCALER_A :: DIV64 => 5 , PRESCALER_A :: DIV128 => 6 , PRESCALER_A :: DIV256 => 7 } } }
# [ doc = "Reader of field `PRESCALER`" ] pub type PRESCALER_R = crate :: R < u8 , PRESCALER_A > ; impl PRESCALER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PRESCALER_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PRESCALER_A :: DIV2 ) , 1 => Val ( PRESCALER_A :: DIV4 ) , 2 => Val ( PRESCALER_A :: DIV8 ) , 3 => Val ( PRESCALER_A :: DIV16 ) , 4 => Val ( PRESCALER_A :: DIV32 ) , 5 => Val ( PRESCALER_A :: DIV64 ) , 6 => Val ( PRESCALER_A :: DIV128 ) , 7 => Val ( PRESCALER_A :: DIV256 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == PRESCALER_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == PRESCALER_A :: DIV128 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER_A :: DIV256 } }
# [ doc = "Write proxy for field `PRESCALER`" ] pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Peripheral clock divided by 2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV2 ) } # [ doc = "Peripheral clock divided by 4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV4 ) } # [ doc = "Peripheral clock divided by 8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV8 ) } # [ doc = "Peripheral clock divided by 16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV16 ) } # [ doc = "Peripheral clock divided by 32" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV32 ) } # [ doc = "Peripheral clock divided by 64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV64 ) } # [ doc = "Peripheral clock divided by 128" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV128 ) } # [ doc = "Peripheral clock divided by 256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV256 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u16 ) & 0xff ) ; self . w } }
# [ doc = "Possible values of the field `OSR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum OSR_A { # [ doc = "Over Sampling Ratio is 64" ] OSR64 , # [ doc = "Over Sampling Ratio is 128" ] OSR128 , # [ doc = "Over Sampling Ratio is 256" ] OSR256 , # [ doc = "Over Sampling Ratio is 512" ] OSR512 , # [ doc = "Over Sampling Ratio is 1024" ] OSR1024 }
impl crate :: ToBits < u8 > for OSR_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { OSR_A :: OSR64 => 0 , OSR_A :: OSR128 => 1 , OSR_A :: OSR256 => 2 , OSR_A :: OSR512 => 3 , OSR_A :: OSR1024 => 4 } } }
# [ doc = "Reader of field `OSR`" ] pub type OSR_R = crate :: R < u8 , OSR_A > ; impl OSR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , OSR_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( OSR_A :: OSR64 ) , 1 => Val ( OSR_A :: OSR128 ) , 2 => Val ( OSR_A :: OSR256 ) , 3 => Val ( OSR_A :: OSR512 ) , 4 => Val ( OSR_A :: OSR1024 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `OSR64`" ] # [ inline ( always ) ] pub fn is_osr64 ( & self ) -> bool { * self == OSR_A :: OSR64 } # [ doc = "Checks if the value of the field is `OSR128`" ] # [ inline ( always ) ] pub fn is_osr128 ( & self ) -> bool { * self == OSR_A :: OSR128 } # [ doc = "Checks if the value of the field is `OSR256`" ] # [ inline ( always ) ] pub fn is_osr256 ( & self ) -> bool { * self == OSR_A :: OSR256 } # [ doc = "Checks if the value of the field is `OSR512`" ] # [ inline ( always ) ] pub fn is_osr512 ( & self ) -> bool { * self == OSR_A :: OSR512 } # [ doc = "Checks if the value of the field is `OSR1024`" ] # [ inline ( always ) ] pub fn is_osr1024 ( & self ) -> bool { * self == OSR_A :: OSR1024 } }
# [ doc = "Write proxy for field `OSR`" ] pub struct OSR_W < 'a > { w : & 'a mut W , } impl < 'a > OSR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : OSR_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Over Sampling Ratio is 64" ] # [ inline ( always ) ] pub fn osr64 ( self ) -> & 'a mut W { self . variant ( OSR_A :: OSR64 ) } # [ doc = "Over Sampling Ratio is 128" ] # [ inline ( always ) ] pub fn osr128 ( self ) -> & 'a mut W { self . variant ( OSR_A :: OSR128 ) } # [ doc = "Over Sampling Ratio is 256" ] # [ inline ( always ) ] pub fn osr256 ( self ) -> & 'a mut W { self . variant ( OSR_A :: OSR256 ) } # [ doc = "Over Sampling Ratio is 512" ] # [ inline ( always ) ] pub fn osr512 ( self ) -> & 'a mut W { self . variant ( OSR_A :: OSR512 ) } # [ doc = "Over Sampling Ratio is 1024" ] # [ inline ( always ) ] pub fn osr1024 ( self ) -> & 'a mut W { self . variant ( OSR_A :: OSR1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u16 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `SKPCNT`" ] pub type SKPCNT_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `SKPCNT`" ] pub struct SKPCNT_W < 'a > { w : & 'a mut W , } impl < 'a > SKPCNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 12 ) ) | ( ( ( value as u16 ) & 0x0f ) << 12 ) ; self . w } }
impl R {
# [ doc = "Bits 0:7 - Prescaler Configuration" ] # [ inline ( always ) ] pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( self . bits & 0xff ) as u8 ) }
# [ doc = "Bits 8:10 - Over Sampling Ratio" ] # [ inline ( always ) ] pub fn osr ( & self ) -> OSR_R { OSR_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 12:15 - Skip Sample Count" ] # [ inline ( always ) ] pub fn skpcnt ( & self ) -> SKPCNT_R { SKPCNT_R :: new ( ( ( self . bits >> 12 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:7 - Prescaler Configuration" ] # [ inline ( always ) ] pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } }
# [ doc = "Bits 8:10 - Over Sampling Ratio" ] # [ inline ( always ) ] pub fn osr ( & mut self ) -> OSR_W { OSR_W { w : self } }
# [ doc = "Bits 12:15 - Skip Sample Count" ] # [ inline ( always ) ] pub fn skpcnt ( & mut self ) -> SKPCNT_W { SKPCNT_W { w : self } }
}
}
# [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u8 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event Control" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u8 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u8 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FLUSHEI`" ] pub type FLUSHEI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FLUSHEI`" ] pub struct FLUSHEI_W < 'a > { w : & 'a mut W , } impl < 'a > FLUSHEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `STARTEI`" ] pub type STARTEI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `STARTEI`" ] pub struct STARTEI_W < 'a > { w : & 'a mut W , } impl < 'a > STARTEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `FLUSHINV`" ] pub type FLUSHINV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FLUSHINV`" ] pub struct FLUSHINV_W < 'a > { w : & 'a mut W , } impl < 'a > FLUSHINV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `STARTINV`" ] pub type STARTINV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `STARTINV`" ] pub struct STARTINV_W < 'a > { w : & 'a mut W , } impl < 'a > STARTINV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `RESRDYEO`" ] pub type RESRDYEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDYEO`" ] pub struct RESRDYEO_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDYEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `WINMONEO`" ] pub type WINMONEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMONEO`" ] pub struct WINMONEO_W < 'a > { w : & 'a mut W , } impl < 'a > WINMONEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Flush Event Input Enable" ] # [ inline ( always ) ] pub fn flushei ( & self ) -> FLUSHEI_R { FLUSHEI_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Start Conversion Event Input Enable" ] # [ inline ( always ) ] pub fn startei ( & self ) -> STARTEI_R { STARTEI_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Flush Event Invert Enable" ] # [ inline ( always ) ] pub fn flushinv ( & self ) -> FLUSHINV_R { FLUSHINV_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Satrt Event Invert Enable" ] # [ inline ( always ) ] pub fn startinv ( & self ) -> STARTINV_R { STARTINV_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Result Ready Event Out" ] # [ inline ( always ) ] pub fn resrdyeo ( & self ) -> RESRDYEO_R { RESRDYEO_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Window Monitor Event Out" ] # [ inline ( always ) ] pub fn winmoneo ( & self ) -> WINMONEO_R { WINMONEO_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Flush Event Input Enable" ] # [ inline ( always ) ] pub fn flushei ( & mut self ) -> FLUSHEI_W { FLUSHEI_W { w : self } }
# [ doc = "Bit 1 - Start Conversion Event Input Enable" ] # [ inline ( always ) ] pub fn startei ( & mut self ) -> STARTEI_W { STARTEI_W { w : self } }
# [ doc = "Bit 2 - Flush Event Invert Enable" ] # [ inline ( always ) ] pub fn flushinv ( & mut self ) -> FLUSHINV_W { FLUSHINV_W { w : self } }
# [ doc = "Bit 3 - Satrt Event Invert Enable" ] # [ inline ( always ) ] pub fn startinv ( & mut self ) -> STARTINV_W { STARTINV_W { w : self } }
# [ doc = "Bit 4 - Result Ready Event Out" ] # [ inline ( always ) ] pub fn resrdyeo ( & mut self ) -> RESRDYEO_W { RESRDYEO_W { w : self } }
# [ doc = "Bit 5 - Window Monitor Event Out" ] # [ inline ( always ) ] pub fn winmoneo ( & mut self ) -> WINMONEO_W { WINMONEO_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RESRDY`" ] pub type RESRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDY`" ] pub struct RESRDY_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVERRUN`" ] pub type OVERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVERRUN`" ] pub struct OVERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > OVERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINMON`" ] pub type WINMON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMON`" ] pub struct WINMON_W < 'a > { w : & 'a mut W , } impl < 'a > WINMON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Result Ready Interrupt Disable" ] # [ inline ( always ) ] pub fn resrdy ( & self ) -> RESRDY_R { RESRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Overrun Interrupt Disable" ] # [ inline ( always ) ] pub fn overrun ( & self ) -> OVERRUN_R { OVERRUN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor Interrupt Disable" ] # [ inline ( always ) ] pub fn winmon ( & self ) -> WINMON_R { WINMON_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Result Ready Interrupt Disable" ] # [ inline ( always ) ] pub fn resrdy ( & mut self ) -> RESRDY_W { RESRDY_W { w : self } }
# [ doc = "Bit 1 - Overrun Interrupt Disable" ] # [ inline ( always ) ] pub fn overrun ( & mut self ) -> OVERRUN_W { OVERRUN_W { w : self } }
# [ doc = "Bit 2 - Window Monitor Interrupt Disable" ] # [ inline ( always ) ] pub fn winmon ( & mut self ) -> WINMON_W { WINMON_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RESRDY`" ] pub type RESRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDY`" ] pub struct RESRDY_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVERRUN`" ] pub type OVERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVERRUN`" ] pub struct OVERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > OVERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINMON`" ] pub type WINMON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMON`" ] pub struct WINMON_W < 'a > { w : & 'a mut W , } impl < 'a > WINMON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Result Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn resrdy ( & self ) -> RESRDY_R { RESRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn overrun ( & self ) -> OVERRUN_R { OVERRUN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor Interrupt Enable" ] # [ inline ( always ) ] pub fn winmon ( & self ) -> WINMON_R { WINMON_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Result Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn resrdy ( & mut self ) -> RESRDY_W { RESRDY_W { w : self } }
# [ doc = "Bit 1 - Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn overrun ( & mut self ) -> OVERRUN_W { OVERRUN_W { w : self } }
# [ doc = "Bit 2 - Window Monitor Interrupt Enable" ] # [ inline ( always ) ] pub fn winmon ( & mut self ) -> WINMON_W { WINMON_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RESRDY`" ] pub type RESRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDY`" ] pub struct RESRDY_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVERRUN`" ] pub type OVERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVERRUN`" ] pub struct OVERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > OVERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINMON`" ] pub type WINMON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMON`" ] pub struct WINMON_W < 'a > { w : & 'a mut W , } impl < 'a > WINMON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Result Ready Interrupt Flag" ] # [ inline ( always ) ] pub fn resrdy ( & self ) -> RESRDY_R { RESRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Overrun Interrupt Flag" ] # [ inline ( always ) ] pub fn overrun ( & self ) -> OVERRUN_R { OVERRUN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor Interrupt Flag" ] # [ inline ( always ) ] pub fn winmon ( & self ) -> WINMON_R { WINMON_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Result Ready Interrupt Flag" ] # [ inline ( always ) ] pub fn resrdy ( & mut self ) -> RESRDY_W { RESRDY_W { w : self } }
# [ doc = "Bit 1 - Overrun Interrupt Flag" ] # [ inline ( always ) ] pub fn overrun ( & mut self ) -> OVERRUN_W { OVERRUN_W { w : self } }
# [ doc = "Bit 2 - Window Monitor Interrupt Flag" ] # [ inline ( always ) ] pub fn winmon ( & mut self ) -> WINMON_W { WINMON_W { w : self } }
}
}
# [ doc = "Sequence Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [seqstatus](seqstatus) module" ] pub type SEQSTATUS = crate :: Reg < u8 , _SEQSTATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SEQSTATUS ;
# [ doc = "`read()` method returns [seqstatus::R](seqstatus::R) reader structure" ] impl crate :: Readable for SEQSTATUS { }
# [ doc = "Sequence Status" ] pub mod seqstatus {
# [ doc = "Reader of register SEQSTATUS" ] pub type R = crate :: R < u8 , super :: SEQSTATUS > ;
# [ doc = "Reader of field `SEQSTATE`" ] pub type SEQSTATE_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `SEQBUSY`" ] pub type SEQBUSY_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bits 0:3 - Sequence State" ] # [ inline ( always ) ] pub fn seqstate ( & self ) -> SEQSTATE_R { SEQSTATE_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bit 7 - Sequence Busy" ] # [ inline ( always ) ] pub fn seqbusy ( & self ) -> SEQBUSY_R { SEQBUSY_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Input Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [inputctrl](inputctrl) module" ] pub type INPUTCTRL = crate :: Reg < u8 , _INPUTCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INPUTCTRL ;
# [ doc = "`read()` method returns [inputctrl::R](inputctrl::R) reader structure" ] impl crate :: Readable for INPUTCTRL { }
# [ doc = "`write(|w| ..)` method takes [inputctrl::W](inputctrl::W) writer structure" ] impl crate :: Writable for INPUTCTRL { }
# [ doc = "Input Control" ] pub mod inputctrl {
# [ doc = "Reader of register INPUTCTRL" ] pub type R = crate :: R < u8 , super :: INPUTCTRL > ;
# [ doc = "Writer for register INPUTCTRL" ] pub type W = crate :: W < u8 , super :: INPUTCTRL > ;
# [ doc = "Register INPUTCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INPUTCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `MUXSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MUXSEL_A { # [ doc = "SDADC AIN0 Pin" ] AIN0 , # [ doc = "SDADC AIN1 Pin" ] AIN1 , # [ doc = "SDADC AIN2 Pin" ] AIN2 }
impl crate :: ToBits < u8 > for MUXSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MUXSEL_A :: AIN0 => 0 , MUXSEL_A :: AIN1 => 1 , MUXSEL_A :: AIN2 => 2 } } }
# [ doc = "Reader of field `MUXSEL`" ] pub type MUXSEL_R = crate :: R < u8 , MUXSEL_A > ; impl MUXSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MUXSEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MUXSEL_A :: AIN0 ) , 1 => Val ( MUXSEL_A :: AIN1 ) , 2 => Val ( MUXSEL_A :: AIN2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `AIN0`" ] # [ inline ( always ) ] pub fn is_ain0 ( & self ) -> bool { * self == MUXSEL_A :: AIN0 } # [ doc = "Checks if the value of the field is `AIN1`" ] # [ inline ( always ) ] pub fn is_ain1 ( & self ) -> bool { * self == MUXSEL_A :: AIN1 } # [ doc = "Checks if the value of the field is `AIN2`" ] # [ inline ( always ) ] pub fn is_ain2 ( & self ) -> bool { * self == MUXSEL_A :: AIN2 } }
# [ doc = "Write proxy for field `MUXSEL`" ] pub struct MUXSEL_W < 'a > { w : & 'a mut W , } impl < 'a > MUXSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MUXSEL_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SDADC AIN0 Pin" ] # [ inline ( always ) ] pub fn ain0 ( self ) -> & 'a mut W { self . variant ( MUXSEL_A :: AIN0 ) } # [ doc = "SDADC AIN1 Pin" ] # [ inline ( always ) ] pub fn ain1 ( self ) -> & 'a mut W { self . variant ( MUXSEL_A :: AIN1 ) } # [ doc = "SDADC AIN2 Pin" ] # [ inline ( always ) ] pub fn ain2 ( self ) -> & 'a mut W { self . variant ( MUXSEL_A :: AIN2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - SDADC Input Selection" ] # [ inline ( always ) ] pub fn muxsel ( & self ) -> MUXSEL_R { MUXSEL_R :: new ( ( self . bits & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:3 - SDADC Input Selection" ] # [ inline ( always ) ] pub fn muxsel ( & mut self ) -> MUXSEL_W { MUXSEL_W { w : self } }
}
}
# [ doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlc](ctrlc) module" ] pub type CTRLC = crate :: Reg < u8 , _CTRLC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLC ;
# [ doc = "`read()` method returns [ctrlc::R](ctrlc::R) reader structure" ] impl crate :: Readable for CTRLC { }
# [ doc = "`write(|w| ..)` method takes [ctrlc::W](ctrlc::W) writer structure" ] impl crate :: Writable for CTRLC { }
# [ doc = "Control C" ] pub mod ctrlc {
# [ doc = "Reader of register CTRLC" ] pub type R = crate :: R < u8 , super :: CTRLC > ;
# [ doc = "Writer for register CTRLC" ] pub type W = crate :: W < u8 , super :: CTRLC > ;
# [ doc = "Register CTRLC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FREERUN`" ] pub type FREERUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FREERUN`" ] pub struct FREERUN_W < 'a > { w : & 'a mut W , } impl < 'a > FREERUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Free Running Mode" ] # [ inline ( always ) ] pub fn freerun ( & self ) -> FREERUN_R { FREERUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Free Running Mode" ] # [ inline ( always ) ] pub fn freerun ( & mut self ) -> FREERUN_W { FREERUN_W { w : self } }
}
}
# [ doc = "Window Monitor Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [winctrl](winctrl) module" ] pub type WINCTRL = crate :: Reg < u8 , _WINCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WINCTRL ;
# [ doc = "`read()` method returns [winctrl::R](winctrl::R) reader structure" ] impl crate :: Readable for WINCTRL { }
# [ doc = "`write(|w| ..)` method takes [winctrl::W](winctrl::W) writer structure" ] impl crate :: Writable for WINCTRL { }
# [ doc = "Window Monitor Control" ] pub mod winctrl {
# [ doc = "Reader of register WINCTRL" ] pub type R = crate :: R < u8 , super :: WINCTRL > ;
# [ doc = "Writer for register WINCTRL" ] pub type W = crate :: W < u8 , super :: WINCTRL > ;
# [ doc = "Register WINCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WINCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WINMODE`" ] pub type WINMODE_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `WINMODE`" ] pub struct WINMODE_W < 'a > { w : & 'a mut W , } impl < 'a > WINMODE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u8 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Window Monitor Mode" ] # [ inline ( always ) ] pub fn winmode ( & self ) -> WINMODE_R { WINMODE_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Window Monitor Mode" ] # [ inline ( always ) ] pub fn winmode ( & mut self ) -> WINMODE_W { WINMODE_W { w : self } }
}
}
# [ doc = "Window Monitor Lower Threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [winlt](winlt) module" ] pub type WINLT = crate :: Reg < u32 , _WINLT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WINLT ;
# [ doc = "`read()` method returns [winlt::R](winlt::R) reader structure" ] impl crate :: Readable for WINLT { }
# [ doc = "`write(|w| ..)` method takes [winlt::W](winlt::W) writer structure" ] impl crate :: Writable for WINLT { }
# [ doc = "Window Monitor Lower Threshold" ] pub mod winlt {
# [ doc = "Reader of register WINLT" ] pub type R = crate :: R < u32 , super :: WINLT > ;
# [ doc = "Writer for register WINLT" ] pub type W = crate :: W < u32 , super :: WINLT > ;
# [ doc = "Register WINLT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WINLT { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WINLT`" ] pub type WINLT_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `WINLT`" ] pub struct WINLT_W < 'a > { w : & 'a mut W , } impl < 'a > WINLT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Window Lower Threshold" ] # [ inline ( always ) ] pub fn winlt ( & self ) -> WINLT_R { WINLT_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Window Lower Threshold" ] # [ inline ( always ) ] pub fn winlt ( & mut self ) -> WINLT_W { WINLT_W { w : self } }
}
}
# [ doc = "Window Monitor Upper Threshold\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [winut](winut) module" ] pub type WINUT = crate :: Reg < u32 , _WINUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WINUT ;
# [ doc = "`read()` method returns [winut::R](winut::R) reader structure" ] impl crate :: Readable for WINUT { }
# [ doc = "`write(|w| ..)` method takes [winut::W](winut::W) writer structure" ] impl crate :: Writable for WINUT { }
# [ doc = "Window Monitor Upper Threshold" ] pub mod winut {
# [ doc = "Reader of register WINUT" ] pub type R = crate :: R < u32 , super :: WINUT > ;
# [ doc = "Writer for register WINUT" ] pub type W = crate :: W < u32 , super :: WINUT > ;
# [ doc = "Register WINUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WINUT { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WINUT`" ] pub type WINUT_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `WINUT`" ] pub struct WINUT_W < 'a > { w : & 'a mut W , } impl < 'a > WINUT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Window Upper Threshold" ] # [ inline ( always ) ] pub fn winut ( & self ) -> WINUT_R { WINUT_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Window Upper Threshold" ] # [ inline ( always ) ] pub fn winut ( & mut self ) -> WINUT_W { WINUT_W { w : self } }
}
}
# [ doc = "Offset Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [offsetcorr](offsetcorr) module" ] pub type OFFSETCORR = crate :: Reg < u32 , _OFFSETCORR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OFFSETCORR ;
# [ doc = "`read()` method returns [offsetcorr::R](offsetcorr::R) reader structure" ] impl crate :: Readable for OFFSETCORR { }
# [ doc = "`write(|w| ..)` method takes [offsetcorr::W](offsetcorr::W) writer structure" ] impl crate :: Writable for OFFSETCORR { }
# [ doc = "Offset Correction" ] pub mod offsetcorr {
# [ doc = "Reader of register OFFSETCORR" ] pub type R = crate :: R < u32 , super :: OFFSETCORR > ;
# [ doc = "Writer for register OFFSETCORR" ] pub type W = crate :: W < u32 , super :: OFFSETCORR > ;
# [ doc = "Register OFFSETCORR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OFFSETCORR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OFFSETCORR`" ] pub type OFFSETCORR_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `OFFSETCORR`" ] pub struct OFFSETCORR_W < 'a > { w : & 'a mut W , } impl < 'a > OFFSETCORR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Offset Correction Value" ] # [ inline ( always ) ] pub fn offsetcorr ( & self ) -> OFFSETCORR_R { OFFSETCORR_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Offset Correction Value" ] # [ inline ( always ) ] pub fn offsetcorr ( & mut self ) -> OFFSETCORR_W { OFFSETCORR_W { w : self } }
}
}
# [ doc = "Gain Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [gaincorr](gaincorr) module" ] pub type GAINCORR = crate :: Reg < u16 , _GAINCORR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _GAINCORR ;
# [ doc = "`read()` method returns [gaincorr::R](gaincorr::R) reader structure" ] impl crate :: Readable for GAINCORR { }
# [ doc = "`write(|w| ..)` method takes [gaincorr::W](gaincorr::W) writer structure" ] impl crate :: Writable for GAINCORR { }
# [ doc = "Gain Correction" ] pub mod gaincorr {
# [ doc = "Reader of register GAINCORR" ] pub type R = crate :: R < u16 , super :: GAINCORR > ;
# [ doc = "Writer for register GAINCORR" ] pub type W = crate :: W < u16 , super :: GAINCORR > ;
# [ doc = "Register GAINCORR `reset()`'s with value 0x01" ] impl crate :: ResetValue for super :: GAINCORR { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x01 } }
# [ doc = "Reader of field `GAINCORR`" ] pub type GAINCORR_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `GAINCORR`" ] pub struct GAINCORR_W < 'a > { w : & 'a mut W , } impl < 'a > GAINCORR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3fff ) | ( ( value as u16 ) & 0x3fff ) ; self . w } }
impl R {
# [ doc = "Bits 0:13 - Gain Correction Value" ] # [ inline ( always ) ] pub fn gaincorr ( & self ) -> GAINCORR_R { GAINCORR_R :: new ( ( self . bits & 0x3fff ) as u16 ) }
}
impl W {
# [ doc = "Bits 0:13 - Gain Correction Value" ] # [ inline ( always ) ] pub fn gaincorr ( & mut self ) -> GAINCORR_W { GAINCORR_W { w : self } }
}
}
# [ doc = "Shift Correction\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [shiftcorr](shiftcorr) module" ] pub type SHIFTCORR = crate :: Reg < u8 , _SHIFTCORR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SHIFTCORR ;
# [ doc = "`read()` method returns [shiftcorr::R](shiftcorr::R) reader structure" ] impl crate :: Readable for SHIFTCORR { }
# [ doc = "`write(|w| ..)` method takes [shiftcorr::W](shiftcorr::W) writer structure" ] impl crate :: Writable for SHIFTCORR { }
# [ doc = "Shift Correction" ] pub mod shiftcorr {
# [ doc = "Reader of register SHIFTCORR" ] pub type R = crate :: R < u8 , super :: SHIFTCORR > ;
# [ doc = "Writer for register SHIFTCORR" ] pub type W = crate :: W < u8 , super :: SHIFTCORR > ;
# [ doc = "Register SHIFTCORR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SHIFTCORR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SHIFTCORR`" ] pub type SHIFTCORR_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `SHIFTCORR`" ] pub struct SHIFTCORR_W < 'a > { w : & 'a mut W , } impl < 'a > SHIFTCORR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Shift Correction Value" ] # [ inline ( always ) ] pub fn shiftcorr ( & self ) -> SHIFTCORR_R { SHIFTCORR_R :: new ( ( self . bits & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:3 - Shift Correction Value" ] # [ inline ( always ) ] pub fn shiftcorr ( & mut self ) -> SHIFTCORR_W { SHIFTCORR_W { w : self } }
}
}
# [ doc = "Software Trigger\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [swtrig](swtrig) module" ] pub type SWTRIG = crate :: Reg < u8 , _SWTRIG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SWTRIG ;
# [ doc = "`read()` method returns [swtrig::R](swtrig::R) reader structure" ] impl crate :: Readable for SWTRIG { }
# [ doc = "`write(|w| ..)` method takes [swtrig::W](swtrig::W) writer structure" ] impl crate :: Writable for SWTRIG { }
# [ doc = "Software Trigger" ] pub mod swtrig {
# [ doc = "Reader of register SWTRIG" ] pub type R = crate :: R < u8 , super :: SWTRIG > ;
# [ doc = "Writer for register SWTRIG" ] pub type W = crate :: W < u8 , super :: SWTRIG > ;
# [ doc = "Register SWTRIG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SWTRIG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FLUSH`" ] pub type FLUSH_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FLUSH`" ] pub struct FLUSH_W < 'a > { w : & 'a mut W , } impl < 'a > FLUSH_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `START`" ] pub type START_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `START`" ] pub struct START_W < 'a > { w : & 'a mut W , } impl < 'a > START_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SDADC Flush" ] # [ inline ( always ) ] pub fn flush ( & self ) -> FLUSH_R { FLUSH_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Start SDADC Conversion" ] # [ inline ( always ) ] pub fn start ( & self ) -> START_R { START_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SDADC Flush" ] # [ inline ( always ) ] pub fn flush ( & mut self ) -> FLUSH_W { FLUSH_W { w : self } }
# [ doc = "Bit 1 - Start SDADC Conversion" ] # [ inline ( always ) ] pub fn start ( & mut self ) -> START_W { START_W { w : self } }
}
}
# [ doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CTRLC`" ] pub type CTRLC_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `INPUTCTRL`" ] pub type INPUTCTRL_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WINCTRL`" ] pub type WINCTRL_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WINLT`" ] pub type WINLT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WINUT`" ] pub type WINUT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `OFFSETCORR`" ] pub type OFFSETCORR_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `GAINCORR`" ] pub type GAINCORR_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SHIFTCORR`" ] pub type SHIFTCORR_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `SWTRIG`" ] pub type SWTRIG_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ANACTRL`" ] pub type ANACTRL_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - SWRST Synchronization Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - ENABLE Synchronization Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - CTRLC Synchronization Busy" ] # [ inline ( always ) ] pub fn ctrlc ( & self ) -> CTRLC_R { CTRLC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - INPUTCTRL Synchronization Busy" ] # [ inline ( always ) ] pub fn inputctrl ( & self ) -> INPUTCTRL_R { INPUTCTRL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - WINCTRL Synchronization Busy" ] # [ inline ( always ) ] pub fn winctrl ( & self ) -> WINCTRL_R { WINCTRL_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - WINLT Synchronization Busy" ] # [ inline ( always ) ] pub fn winlt ( & self ) -> WINLT_R { WINLT_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - WINUT Synchronization Busy" ] # [ inline ( always ) ] pub fn winut ( & self ) -> WINUT_R { WINUT_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - OFFSETCTRL Synchronization Busy" ] # [ inline ( always ) ] pub fn offsetcorr ( & self ) -> OFFSETCORR_R { OFFSETCORR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - GAINCORR Synchronization Busy" ] # [ inline ( always ) ] pub fn gaincorr ( & self ) -> GAINCORR_R { GAINCORR_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - SHIFTCORR Synchronization Busy" ] # [ inline ( always ) ] pub fn shiftcorr ( & self ) -> SHIFTCORR_R { SHIFTCORR_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - SWTRG Synchronization Busy" ] # [ inline ( always ) ] pub fn swtrig ( & self ) -> SWTRIG_R { SWTRIG_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - ANACTRL Synchronization Busy" ] # [ inline ( always ) ] pub fn anactrl ( & self ) -> ANACTRL_R { ANACTRL_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Result\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [result](result) module" ] pub type RESULT = crate :: Reg < u32 , _RESULT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RESULT ;
# [ doc = "`read()` method returns [result::R](result::R) reader structure" ] impl crate :: Readable for RESULT { }
# [ doc = "Result" ] pub mod result {
# [ doc = "Reader of register RESULT" ] pub type R = crate :: R < u32 , super :: RESULT > ;
# [ doc = "Reader of field `RESULT`" ] pub type RESULT_R = crate :: R < u32 , u32 > ;
impl R {
# [ doc = "Bits 0:23 - Result Value" ] # [ inline ( always ) ] pub fn result ( & self ) -> RESULT_R { RESULT_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
}
# [ doc = "Sequence Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [seqctrl](seqctrl) module" ] pub type SEQCTRL = crate :: Reg < u8 , _SEQCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SEQCTRL ;
# [ doc = "`read()` method returns [seqctrl::R](seqctrl::R) reader structure" ] impl crate :: Readable for SEQCTRL { }
# [ doc = "`write(|w| ..)` method takes [seqctrl::W](seqctrl::W) writer structure" ] impl crate :: Writable for SEQCTRL { }
# [ doc = "Sequence Control" ] pub mod seqctrl {
# [ doc = "Reader of register SEQCTRL" ] pub type R = crate :: R < u8 , super :: SEQCTRL > ;
# [ doc = "Writer for register SEQCTRL" ] pub type W = crate :: W < u8 , super :: SEQCTRL > ;
# [ doc = "Register SEQCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SEQCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SEQEN`" ] pub type SEQEN_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `SEQEN`" ] pub struct SEQEN_W < 'a > { w : & 'a mut W , } impl < 'a > SEQEN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u8 ) & 0x07 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Enable Positive Input in the Sequence" ] # [ inline ( always ) ] pub fn seqen ( & self ) -> SEQEN_R { SEQEN_R :: new ( ( self . bits & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:2 - Enable Positive Input in the Sequence" ] # [ inline ( always ) ] pub fn seqen ( & mut self ) -> SEQEN_W { SEQEN_W { w : self } }
}
}
# [ doc = "Analog Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [anactrl](anactrl) module" ] pub type ANACTRL = crate :: Reg < u8 , _ANACTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ANACTRL ;
# [ doc = "`read()` method returns [anactrl::R](anactrl::R) reader structure" ] impl crate :: Readable for ANACTRL { }
# [ doc = "`write(|w| ..)` method takes [anactrl::W](anactrl::W) writer structure" ] impl crate :: Writable for ANACTRL { }
# [ doc = "Analog Control" ] pub mod anactrl {
# [ doc = "Reader of register ANACTRL" ] pub type R = crate :: R < u8 , super :: ANACTRL > ;
# [ doc = "Writer for register ANACTRL" ] pub type W = crate :: W < u8 , super :: ANACTRL > ;
# [ doc = "Register ANACTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ANACTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CTRSDADC`" ] pub type CTRSDADC_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `CTRSDADC`" ] pub struct CTRSDADC_W < 'a > { w : & 'a mut W , } impl < 'a > CTRSDADC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u8 ) & 0x3f ) ; self . w } }
# [ doc = "Reader of field `ONCHOP`" ] pub type ONCHOP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONCHOP`" ] pub struct ONCHOP_W < 'a > { w : & 'a mut W , } impl < 'a > ONCHOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `BUFTEST`" ] pub type BUFTEST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BUFTEST`" ] pub struct BUFTEST_W < 'a > { w : & 'a mut W , } impl < 'a > BUFTEST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - SDADC Control" ] # [ inline ( always ) ] pub fn ctrsdadc ( & self ) -> CTRSDADC_R { CTRSDADC_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bit 6 - Chopper" ] # [ inline ( always ) ] pub fn onchop ( & self ) -> ONCHOP_R { ONCHOP_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - BUFTEST" ] # [ inline ( always ) ] pub fn buftest ( & self ) -> BUFTEST_R { BUFTEST_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:5 - SDADC Control" ] # [ inline ( always ) ] pub fn ctrsdadc ( & mut self ) -> CTRSDADC_W { CTRSDADC_W { w : self } }
# [ doc = "Bit 6 - Chopper" ] # [ inline ( always ) ] pub fn onchop ( & mut self ) -> ONCHOP_W { ONCHOP_W { w : self } }
# [ doc = "Bit 7 - BUFTEST" ] # [ inline ( always ) ] pub fn buftest ( & mut self ) -> BUFTEST_W { BUFTEST_W { w : self } }
}
}
# [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ;
# [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { }
# [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { }
# [ doc = "Debug Control" ] pub mod dbgctrl {
# [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ;
# [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ;
# [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } }
}
}
}
# [ doc = "Serial Communication Interface" ] pub struct SERCOM0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SERCOM0 { } impl SERCOM0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sercom0 :: RegisterBlock { 0x4200_0400 as * const _ } } impl Deref for SERCOM0 { type Target = sercom0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SERCOM0 :: ptr ( ) } } }
# [ doc = "Serial Communication Interface" ] pub mod sercom0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_i2cm : [ u8 ; 49usize ] , } impl RegisterBlock { # [ doc = "0x00 - USART INTERNAL CLOCK Mode" ] # [ inline ( always ) ] pub fn usart_int ( & self ) -> & USART_INT { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const USART_INT ) } } # [ doc = "0x00 - USART INTERNAL CLOCK Mode" ] # [ inline ( always ) ] pub fn usart_int_mut ( & self ) -> & mut USART_INT { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut USART_INT ) } } # [ doc = "0x00 - USART EXTERNAL CLOCK Mode" ] # [ inline ( always ) ] pub fn usart_ext ( & self ) -> & USART_EXT { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const USART_EXT ) } } # [ doc = "0x00 - USART EXTERNAL CLOCK Mode" ] # [ inline ( always ) ] pub fn usart_ext_mut ( & self ) -> & mut USART_EXT { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut USART_EXT ) } } # [ doc = "0x00 - SPI Master Mode" ] # [ inline ( always ) ] pub fn spim ( & self ) -> & SPIM { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const SPIM ) } } # [ doc = "0x00 - SPI Master Mode" ] # [ inline ( always ) ] pub fn spim_mut ( & self ) -> & mut SPIM { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut SPIM ) } } # [ doc = "0x00 - SPI Slave Mode" ] # [ inline ( always ) ] pub fn spis ( & self ) -> & SPIS { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const SPIS ) } } # [ doc = "0x00 - SPI Slave Mode" ] # [ inline ( always ) ] pub fn spis_mut ( & self ) -> & mut SPIS { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut SPIS ) } } # [ doc = "0x00 - I2C Slave Mode" ] # [ inline ( always ) ] pub fn i2cs ( & self ) -> & I2CS { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const I2CS ) } } # [ doc = "0x00 - I2C Slave Mode" ] # [ inline ( always ) ] pub fn i2cs_mut ( & self ) -> & mut I2CS { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut I2CS ) } } # [ doc = "0x00 - I2C Master Mode" ] # [ inline ( always ) ] pub fn i2cm ( & self ) -> & I2CM { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const I2CM ) } } # [ doc = "0x00 - I2C Master Mode" ] # [ inline ( always ) ] pub fn i2cm_mut ( & self ) -> & mut I2CM { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut I2CM ) } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct I2CM { # [ doc = "0x00 - I2CM Control A" ] pub ctrla : self::i2cm::CTRLA , # [ doc = "0x04 - I2CM Control B" ] pub ctrlb : self::i2cm::CTRLB , _reserved2 : [ u8 ; 4usize ] , # [ doc = "0x0c - I2CM Baud Rate" ] pub baud : self::i2cm::BAUD , _reserved3 : [ u8 ; 4usize ] , # [ doc = "0x14 - I2CM Interrupt Enable Clear" ] pub intenclr : self::i2cm::INTENCLR , _reserved4 : [ u8 ; 1usize ] , # [ doc = "0x16 - I2CM Interrupt Enable Set" ] pub intenset : self::i2cm::INTENSET , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x18 - I2CM Interrupt Flag Status and Clear" ] pub intflag : self::i2cm::INTFLAG , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x1a - I2CM Status" ] pub status : self::i2cm::STATUS , # [ doc = "0x1c - I2CM Synchronization Busy" ] pub syncbusy : self::i2cm::SYNCBUSY , _reserved8 : [ u8 ; 4usize ] , # [ doc = "0x24 - I2CM Address" ] pub addr : self::i2cm::ADDR , # [ doc = "0x28 - I2CM Data" ] pub data : self::i2cm::DATA , _reserved10 : [ u8 ; 7usize ] , # [ doc = "0x30 - I2CM Debug Control" ] pub dbgctrl : self::i2cm::DBGCTRL , } # [ doc = r"Register block" ] # [ doc = "I2C Master Mode" ] pub mod i2cm { # [ doc = "I2CM Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "I2CM Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "USART with external clock" ] USART_EXT_CLK , # [ doc = "USART with internal clock" ] USART_INT_CLK , # [ doc = "SPI in slave operation" ] SPI_SLAVE , # [ doc = "SPI in master operation" ] SPI_MASTER , # [ doc = "I2C slave operation" ] I2C_SLAVE , # [ doc = "I2C master operation" ] I2C_MASTER } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: USART_EXT_CLK => 0 , MODE_A :: USART_INT_CLK => 1 , MODE_A :: SPI_SLAVE => 2 , MODE_A :: SPI_MASTER => 3 , MODE_A :: I2C_SLAVE => 4 , MODE_A :: I2C_MASTER => 5 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: USART_EXT_CLK ) , 1 => Val ( MODE_A :: USART_INT_CLK ) , 2 => Val ( MODE_A :: SPI_SLAVE ) , 3 => Val ( MODE_A :: SPI_MASTER ) , 4 => Val ( MODE_A :: I2C_SLAVE ) , 5 => Val ( MODE_A :: I2C_MASTER ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `USART_EXT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_ext_clk ( & self ) -> bool { * self == MODE_A :: USART_EXT_CLK } # [ doc = "Checks if the value of the field is `USART_INT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_int_clk ( & self ) -> bool { * self == MODE_A :: USART_INT_CLK } # [ doc = "Checks if the value of the field is `SPI_SLAVE`" ] # [ inline ( always ) ] pub fn is_spi_slave ( & self ) -> bool { * self == MODE_A :: SPI_SLAVE } # [ doc = "Checks if the value of the field is `SPI_MASTER`" ] # [ inline ( always ) ] pub fn is_spi_master ( & self ) -> bool { * self == MODE_A :: SPI_MASTER } # [ doc = "Checks if the value of the field is `I2C_SLAVE`" ] # [ inline ( always ) ] pub fn is_i2c_slave ( & self ) -> bool { * self == MODE_A :: I2C_SLAVE } # [ doc = "Checks if the value of the field is `I2C_MASTER`" ] # [ inline ( always ) ] pub fn is_i2c_master ( & self ) -> bool { * self == MODE_A :: I2C_MASTER } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "USART with external clock" ] # [ inline ( always ) ] pub fn usart_ext_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_EXT_CLK ) } # [ doc = "USART with internal clock" ] # [ inline ( always ) ] pub fn usart_int_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_INT_CLK ) } # [ doc = "SPI in slave operation" ] # [ inline ( always ) ] pub fn spi_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_SLAVE ) } # [ doc = "SPI in master operation" ] # [ inline ( always ) ] pub fn spi_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_MASTER ) } # [ doc = "I2C slave operation" ] # [ inline ( always ) ] pub fn i2c_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_SLAVE ) } # [ doc = "I2C master operation" ] # [ inline ( always ) ] pub fn i2c_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_MASTER ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 2 ) ) | ( ( ( value as u32 ) & 0x07 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `PINOUT`" ] pub type PINOUT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PINOUT`" ] pub struct PINOUT_W < 'a > { w : & 'a mut W , } impl < 'a > PINOUT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Possible values of the field `SDAHOLD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SDAHOLD_A { # [ doc = "Disabled" ] DISABLE , # [ doc = "50-100ns hold time" ] _75NS , # [ doc = "300-600ns hold time" ] _450NS , # [ doc = "400-800ns hold time" ] _600NS } impl crate :: ToBits < u8 > for SDAHOLD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SDAHOLD_A :: DISABLE => 0 , SDAHOLD_A :: _75NS => 1 , SDAHOLD_A :: _450NS => 2 , SDAHOLD_A :: _600NS => 3 } } } # [ doc = "Reader of field `SDAHOLD`" ] pub type SDAHOLD_R = crate :: R < u8 , SDAHOLD_A > ; impl SDAHOLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SDAHOLD_A { match self . bits { 0 => SDAHOLD_A :: DISABLE , 1 => SDAHOLD_A :: _75NS , 2 => SDAHOLD_A :: _450NS , 3 => SDAHOLD_A :: _600NS , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == SDAHOLD_A :: DISABLE } # [ doc = "Checks if the value of the field is `_75NS`" ] # [ inline ( always ) ] pub fn is_75ns ( & self ) -> bool { * self == SDAHOLD_A :: _75NS } # [ doc = "Checks if the value of the field is `_450NS`" ] # [ inline ( always ) ] pub fn is_450ns ( & self ) -> bool { * self == SDAHOLD_A :: _450NS } # [ doc = "Checks if the value of the field is `_600NS`" ] # [ inline ( always ) ] pub fn is_600ns ( & self ) -> bool { * self == SDAHOLD_A :: _600NS } } # [ doc = "Write proxy for field `SDAHOLD`" ] pub struct SDAHOLD_W < 'a > { w : & 'a mut W , } impl < 'a > SDAHOLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SDAHOLD_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( SDAHOLD_A :: DISABLE ) } # [ doc = "50-100ns hold time" ] # [ inline ( always ) ] pub fn _75ns ( self ) -> & 'a mut W { self . variant ( SDAHOLD_A :: _75NS ) } # [ doc = "300-600ns hold time" ] # [ inline ( always ) ] pub fn _450ns ( self ) -> & 'a mut W { self . variant ( SDAHOLD_A :: _450NS ) } # [ doc = "400-800ns hold time" ] # [ inline ( always ) ] pub fn _600ns ( self ) -> & 'a mut W { self . variant ( SDAHOLD_A :: _600NS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 20 ) ) | ( ( ( value as u32 ) & 0x03 ) << 20 ) ; self . w } } # [ doc = "Reader of field `MEXTTOEN`" ] pub type MEXTTOEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MEXTTOEN`" ] pub struct MEXTTOEN_W < 'a > { w : & 'a mut W , } impl < 'a > MEXTTOEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } } # [ doc = "Reader of field `SEXTTOEN`" ] pub type SEXTTOEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SEXTTOEN`" ] pub struct SEXTTOEN_W < 'a > { w : & 'a mut W , } impl < 'a > SEXTTOEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } } # [ doc = "Possible values of the field `SPEED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SPEED_A { # [ doc = "Standard Mode(Sm) Upto 100kHz and Fast Mode(Fm) Upto 400kHz " ] STANDARD_AND_FAST_MODE , # [ doc = "Fast-mode Plus Upto 1MHz" ] FASTPLUS_MODE , # [ doc = "High-speed mode Upto 3.4MHz" ] HIGH_SPEED_MODE } impl crate :: ToBits < u8 > for SPEED_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SPEED_A :: STANDARD_AND_FAST_MODE => 0 , SPEED_A :: FASTPLUS_MODE => 1 , SPEED_A :: HIGH_SPEED_MODE => 2 } } } # [ doc = "Reader of field `SPEED`" ] pub type SPEED_R = crate :: R < u8 , SPEED_A > ; impl SPEED_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SPEED_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SPEED_A :: STANDARD_AND_FAST_MODE ) , 1 => Val ( SPEED_A :: FASTPLUS_MODE ) , 2 => Val ( SPEED_A :: HIGH_SPEED_MODE ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `STANDARD_AND_FAST_MODE`" ] # [ inline ( always ) ] pub fn is_standard_and_fast_mode ( & self ) -> bool { * self == SPEED_A :: STANDARD_AND_FAST_MODE } # [ doc = "Checks if the value of the field is `FASTPLUS_MODE`" ] # [ inline ( always ) ] pub fn is_fastplus_mode ( & self ) -> bool { * self == SPEED_A :: FASTPLUS_MODE } # [ doc = "Checks if the value of the field is `HIGH_SPEED_MODE`" ] # [ inline ( always ) ] pub fn is_high_speed_mode ( & self ) -> bool { * self == SPEED_A :: HIGH_SPEED_MODE } } # [ doc = "Write proxy for field `SPEED`" ] pub struct SPEED_W < 'a > { w : & 'a mut W , } impl < 'a > SPEED_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SPEED_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Standard Mode(Sm) Upto 100kHz and Fast Mode(Fm) Upto 400kHz" ] # [ inline ( always ) ] pub fn standard_and_fast_mode ( self ) -> & 'a mut W { self . variant ( SPEED_A :: STANDARD_AND_FAST_MODE ) } # [ doc = "Fast-mode Plus Upto 1MHz" ] # [ inline ( always ) ] pub fn fastplus_mode ( self ) -> & 'a mut W { self . variant ( SPEED_A :: FASTPLUS_MODE ) } # [ doc = "High-speed mode Upto 3.4MHz" ] # [ inline ( always ) ] pub fn high_speed_mode ( self ) -> & 'a mut W { self . variant ( SPEED_A :: HIGH_SPEED_MODE ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 24 ) ) | ( ( ( value as u32 ) & 0x03 ) << 24 ) ; self . w } } # [ doc = "Reader of field `SCLSM`" ] pub type SCLSM_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SCLSM`" ] pub struct SCLSM_W < 'a > { w : & 'a mut W , } impl < 'a > SCLSM_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } } # [ doc = "Possible values of the field `INACTOUT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum INACTOUT_A { # [ doc = "Disabled" ] DISABLE , # [ doc = "5-6 SCL Time-Out(50-60us)" ] _55US , # [ doc = "10-11 SCL Time-Out(100-110us)" ] _105US , # [ doc = "20-21 SCL Time-Out(200-210us)" ] _205US } impl crate :: ToBits < u8 > for INACTOUT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { INACTOUT_A :: DISABLE => 0 , INACTOUT_A :: _55US => 1 , INACTOUT_A :: _105US => 2 , INACTOUT_A :: _205US => 3 } } } # [ doc = "Reader of field `INACTOUT`" ] pub type INACTOUT_R = crate :: R < u8 , INACTOUT_A > ; impl INACTOUT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> INACTOUT_A { match self . bits { 0 => INACTOUT_A :: DISABLE , 1 => INACTOUT_A :: _55US , 2 => INACTOUT_A :: _105US , 3 => INACTOUT_A :: _205US , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == INACTOUT_A :: DISABLE } # [ doc = "Checks if the value of the field is `_55US`" ] # [ inline ( always ) ] pub fn is_55us ( & self ) -> bool { * self == INACTOUT_A :: _55US } # [ doc = "Checks if the value of the field is `_105US`" ] # [ inline ( always ) ] pub fn is_105us ( & self ) -> bool { * self == INACTOUT_A :: _105US } # [ doc = "Checks if the value of the field is `_205US`" ] # [ inline ( always ) ] pub fn is_205us ( & self ) -> bool { * self == INACTOUT_A :: _205US } } # [ doc = "Write proxy for field `INACTOUT`" ] pub struct INACTOUT_W < 'a > { w : & 'a mut W , } impl < 'a > INACTOUT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : INACTOUT_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( INACTOUT_A :: DISABLE ) } # [ doc = "5-6 SCL Time-Out(50-60us)" ] # [ inline ( always ) ] pub fn _55us ( self ) -> & 'a mut W { self . variant ( INACTOUT_A :: _55US ) } # [ doc = "10-11 SCL Time-Out(100-110us)" ] # [ inline ( always ) ] pub fn _105us ( self ) -> & 'a mut W { self . variant ( INACTOUT_A :: _105US ) } # [ doc = "20-21 SCL Time-Out(200-210us)" ] # [ inline ( always ) ] pub fn _205us ( self ) -> & 'a mut W { self . variant ( INACTOUT_A :: _205US ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 28 ) ) | ( ( ( value as u32 ) & 0x03 ) << 28 ) ; self . w } } # [ doc = "Reader of field `LOWTOUTEN`" ] pub type LOWTOUTEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LOWTOUTEN`" ] pub struct LOWTOUTEN_W < 'a > { w : & 'a mut W , } impl < 'a > LOWTOUTEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x07 ) as u8 ) } # [ doc = "Bit 7 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - Pin Usage" ] # [ inline ( always ) ] pub fn pinout ( & self ) -> PINOUT_R { PINOUT_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bits 20:21 - SDA Hold Time" ] # [ inline ( always ) ] pub fn sdahold ( & self ) -> SDAHOLD_R { SDAHOLD_R :: new ( ( ( self . bits >> 20 ) & 0x03 ) as u8 ) } # [ doc = "Bit 22 - Master SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn mexttoen ( & self ) -> MEXTTOEN_R { MEXTTOEN_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) } # [ doc = "Bit 23 - Slave SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn sexttoen ( & self ) -> SEXTTOEN_R { SEXTTOEN_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) } # [ doc = "Bits 24:25 - Transfer Speed" ] # [ inline ( always ) ] pub fn speed ( & self ) -> SPEED_R { SPEED_R :: new ( ( ( self . bits >> 24 ) & 0x03 ) as u8 ) } # [ doc = "Bit 27 - SCL Clock Stretch Mode" ] # [ inline ( always ) ] pub fn sclsm ( & self ) -> SCLSM_R { SCLSM_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) } # [ doc = "Bits 28:29 - Inactive Time-Out" ] # [ inline ( always ) ] pub fn inactout ( & self ) -> INACTOUT_R { INACTOUT_R :: new ( ( ( self . bits >> 28 ) & 0x03 ) as u8 ) } # [ doc = "Bit 30 - SCL Low Timeout Enable" ] # [ inline ( always ) ] pub fn lowtouten ( & self ) -> LOWTOUTEN_R { LOWTOUTEN_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bit 7 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } } # [ doc = "Bit 16 - Pin Usage" ] # [ inline ( always ) ] pub fn pinout ( & mut self ) -> PINOUT_W { PINOUT_W { w : self } } # [ doc = "Bits 20:21 - SDA Hold Time" ] # [ inline ( always ) ] pub fn sdahold ( & mut self ) -> SDAHOLD_W { SDAHOLD_W { w : self } } # [ doc = "Bit 22 - Master SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn mexttoen ( & mut self ) -> MEXTTOEN_W { MEXTTOEN_W { w : self } } # [ doc = "Bit 23 - Slave SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn sexttoen ( & mut self ) -> SEXTTOEN_W { SEXTTOEN_W { w : self } } # [ doc = "Bits 24:25 - Transfer Speed" ] # [ inline ( always ) ] pub fn speed ( & mut self ) -> SPEED_W { SPEED_W { w : self } } # [ doc = "Bit 27 - SCL Clock Stretch Mode" ] # [ inline ( always ) ] pub fn sclsm ( & mut self ) -> SCLSM_W { SCLSM_W { w : self } } # [ doc = "Bits 28:29 - Inactive Time-Out" ] # [ inline ( always ) ] pub fn inactout ( & mut self ) -> INACTOUT_W { INACTOUT_W { w : self } } # [ doc = "Bit 30 - SCL Low Timeout Enable" ] # [ inline ( always ) ] pub fn lowtouten ( & mut self ) -> LOWTOUTEN_W { LOWTOUTEN_W { w : self } } } } # [ doc = "I2CM Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u32 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ; # [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { } # [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { } # [ doc = "I2CM Control B" ] pub mod ctrlb { # [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u32 , super :: CTRLB > ; # [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u32 , super :: CTRLB > ; # [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SMEN`" ] pub type SMEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SMEN`" ] pub struct SMEN_W < 'a > { w : & 'a mut W , } impl < 'a > SMEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `QCEN`" ] pub type QCEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `QCEN`" ] pub struct QCEN_W < 'a > { w : & 'a mut W , } impl < 'a > QCEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 16 ) ) | ( ( ( value as u32 ) & 0x03 ) << 16 ) ; self . w } } # [ doc = "Reader of field `ACKACT`" ] pub type ACKACT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ACKACT`" ] pub struct ACKACT_W < 'a > { w : & 'a mut W , } impl < 'a > ACKACT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } } impl R { # [ doc = "Bit 8 - Smart Mode Enable" ] # [ inline ( always ) ] pub fn smen ( & self ) -> SMEN_R { SMEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Quick Command Enable" ] # [ inline ( always ) ] pub fn qcen ( & self ) -> QCEN_R { QCEN_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bits 16:17 - Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 16 ) & 0x03 ) as u8 ) } # [ doc = "Bit 18 - Acknowledge Action" ] # [ inline ( always ) ] pub fn ackact ( & self ) -> ACKACT_R { ACKACT_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 8 - Smart Mode Enable" ] # [ inline ( always ) ] pub fn smen ( & mut self ) -> SMEN_W { SMEN_W { w : self } } # [ doc = "Bit 9 - Quick Command Enable" ] # [ inline ( always ) ] pub fn qcen ( & mut self ) -> QCEN_W { QCEN_W { w : self } } # [ doc = "Bits 16:17 - Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } } # [ doc = "Bit 18 - Acknowledge Action" ] # [ inline ( always ) ] pub fn ackact ( & mut self ) -> ACKACT_W { ACKACT_W { w : self } } } } # [ doc = "I2CM Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud](baud) module" ] pub type BAUD = crate :: Reg < u32 , _BAUD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD ; # [ doc = "`read()` method returns [baud::R](baud::R) reader structure" ] impl crate :: Readable for BAUD { } # [ doc = "`write(|w| ..)` method takes [baud::W](baud::W) writer structure" ] impl crate :: Writable for BAUD { } # [ doc = "I2CM Baud Rate" ] pub mod baud { # [ doc = "Reader of register BAUD" ] pub type R = crate :: R < u32 , super :: BAUD > ; # [ doc = "Writer for register BAUD" ] pub type W = crate :: W < u32 , super :: BAUD > ; # [ doc = "Register BAUD `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u32 ) & 0xff ) ; self . w } } # [ doc = "Reader of field `BAUDLOW`" ] pub type BAUDLOW_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `BAUDLOW`" ] pub struct BAUDLOW_W < 'a > { w : & 'a mut W , } impl < 'a > BAUDLOW_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 8 ) ) | ( ( ( value as u32 ) & 0xff ) << 8 ) ; self . w } } # [ doc = "Reader of field `HSBAUD`" ] pub type HSBAUD_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `HSBAUD`" ] pub struct HSBAUD_W < 'a > { w : & 'a mut W , } impl < 'a > HSBAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } } # [ doc = "Reader of field `HSBAUDLOW`" ] pub type HSBAUDLOW_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `HSBAUDLOW`" ] pub struct HSBAUDLOW_W < 'a > { w : & 'a mut W , } impl < 'a > HSBAUDLOW_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 24 ) ) | ( ( ( value as u32 ) & 0xff ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0xff ) as u8 ) } # [ doc = "Bits 8:15 - Baud Rate Value Low" ] # [ inline ( always ) ] pub fn baudlow ( & self ) -> BAUDLOW_R { BAUDLOW_R :: new ( ( ( self . bits >> 8 ) & 0xff ) as u8 ) } # [ doc = "Bits 16:23 - High Speed Baud Rate Value" ] # [ inline ( always ) ] pub fn hsbaud ( & self ) -> HSBAUD_R { HSBAUD_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) } # [ doc = "Bits 24:31 - High Speed Baud Rate Value Low" ] # [ inline ( always ) ] pub fn hsbaudlow ( & self ) -> HSBAUDLOW_R { HSBAUDLOW_R :: new ( ( ( self . bits >> 24 ) & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } # [ doc = "Bits 8:15 - Baud Rate Value Low" ] # [ inline ( always ) ] pub fn baudlow ( & mut self ) -> BAUDLOW_W { BAUDLOW_W { w : self } } # [ doc = "Bits 16:23 - High Speed Baud Rate Value" ] # [ inline ( always ) ] pub fn hsbaud ( & mut self ) -> HSBAUD_W { HSBAUD_W { w : self } } # [ doc = "Bits 24:31 - High Speed Baud Rate Value Low" ] # [ inline ( always ) ] pub fn hsbaudlow ( & mut self ) -> HSBAUDLOW_W { HSBAUDLOW_W { w : self } } } } # [ doc = "I2CM Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "I2CM Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `MB`" ] pub type MB_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MB`" ] pub struct MB_W < 'a > { w : & 'a mut W , } impl < 'a > MB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `SB`" ] pub type SB_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SB`" ] pub struct SB_W < 'a > { w : & 'a mut W , } impl < 'a > SB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Master On Bus Interrupt Disable" ] # [ inline ( always ) ] pub fn mb ( & self ) -> MB_R { MB_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Slave On Bus Interrupt Disable" ] # [ inline ( always ) ] pub fn sb ( & self ) -> SB_R { SB_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Master On Bus Interrupt Disable" ] # [ inline ( always ) ] pub fn mb ( & mut self ) -> MB_W { MB_W { w : self } } # [ doc = "Bit 1 - Slave On Bus Interrupt Disable" ] # [ inline ( always ) ] pub fn sb ( & mut self ) -> SB_W { SB_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "I2CM Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "I2CM Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `MB`" ] pub type MB_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MB`" ] pub struct MB_W < 'a > { w : & 'a mut W , } impl < 'a > MB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `SB`" ] pub type SB_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SB`" ] pub struct SB_W < 'a > { w : & 'a mut W , } impl < 'a > SB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Master On Bus Interrupt Enable" ] # [ inline ( always ) ] pub fn mb ( & self ) -> MB_R { MB_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Slave On Bus Interrupt Enable" ] # [ inline ( always ) ] pub fn sb ( & self ) -> SB_R { SB_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Master On Bus Interrupt Enable" ] # [ inline ( always ) ] pub fn mb ( & mut self ) -> MB_W { MB_W { w : self } } # [ doc = "Bit 1 - Slave On Bus Interrupt Enable" ] # [ inline ( always ) ] pub fn sb ( & mut self ) -> SB_W { SB_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "I2CM Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "I2CM Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `MB`" ] pub type MB_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MB`" ] pub struct MB_W < 'a > { w : & 'a mut W , } impl < 'a > MB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `SB`" ] pub type SB_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SB`" ] pub struct SB_W < 'a > { w : & 'a mut W , } impl < 'a > SB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Master On Bus Interrupt" ] # [ inline ( always ) ] pub fn mb ( & self ) -> MB_R { MB_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Slave On Bus Interrupt" ] # [ inline ( always ) ] pub fn sb ( & self ) -> SB_R { SB_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Master On Bus Interrupt" ] # [ inline ( always ) ] pub fn mb ( & mut self ) -> MB_W { MB_W { w : self } } # [ doc = "Bit 1 - Slave On Bus Interrupt" ] # [ inline ( always ) ] pub fn sb ( & mut self ) -> SB_W { SB_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "I2CM Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u16 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { } # [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { } # [ doc = "I2CM Status" ] pub mod status { # [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u16 , super :: STATUS > ; # [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u16 , super :: STATUS > ; # [ doc = "Register STATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BUSERR`" ] pub type BUSERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `BUSERR`" ] pub struct BUSERR_W < 'a > { w : & 'a mut W , } impl < 'a > BUSERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ARBLOST`" ] pub type ARBLOST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ARBLOST`" ] pub struct ARBLOST_W < 'a > { w : & 'a mut W , } impl < 'a > ARBLOST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXNACK`" ] pub type RXNACK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXNACK`" ] pub struct RXNACK_W < 'a > { w : & 'a mut W , } impl < 'a > RXNACK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `BUSSTATE`" ] pub type BUSSTATE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `BUSSTATE`" ] pub struct BUSSTATE_W < 'a > { w : & 'a mut W , } impl < 'a > BUSSTATE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u16 ) & 0x03 ) << 4 ) ; self . w } } # [ doc = "Reader of field `LOWTOUT`" ] pub type LOWTOUT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LOWTOUT`" ] pub struct LOWTOUT_W < 'a > { w : & 'a mut W , } impl < 'a > LOWTOUT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `CLKHOLD`" ] pub type CLKHOLD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CLKHOLD`" ] pub struct CLKHOLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLKHOLD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `MEXTTOUT`" ] pub type MEXTTOUT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MEXTTOUT`" ] pub struct MEXTTOUT_W < 'a > { w : & 'a mut W , } impl < 'a > MEXTTOUT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `SEXTTOUT`" ] pub type SEXTTOUT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SEXTTOUT`" ] pub struct SEXTTOUT_W < 'a > { w : & 'a mut W , } impl < 'a > SEXTTOUT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `LENERR`" ] pub type LENERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LENERR`" ] pub struct LENERR_W < 'a > { w : & 'a mut W , } impl < 'a > LENERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } } impl R { # [ doc = "Bit 0 - Bus Error" ] # [ inline ( always ) ] pub fn buserr ( & self ) -> BUSERR_R { BUSERR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Arbitration Lost" ] # [ inline ( always ) ] pub fn arblost ( & self ) -> ARBLOST_R { ARBLOST_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Received Not Acknowledge" ] # [ inline ( always ) ] pub fn rxnack ( & self ) -> RXNACK_R { RXNACK_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bits 4:5 - Bus State" ] # [ inline ( always ) ] pub fn busstate ( & self ) -> BUSSTATE_R { BUSSTATE_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) } # [ doc = "Bit 6 - SCL Low Timeout" ] # [ inline ( always ) ] pub fn lowtout ( & self ) -> LOWTOUT_R { LOWTOUT_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Clock Hold" ] # [ inline ( always ) ] pub fn clkhold ( & self ) -> CLKHOLD_R { CLKHOLD_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Master SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn mexttout ( & self ) -> MEXTTOUT_R { MEXTTOUT_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Slave SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn sexttout ( & self ) -> SEXTTOUT_R { SEXTTOUT_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - Length Error" ] # [ inline ( always ) ] pub fn lenerr ( & self ) -> LENERR_R { LENERR_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Bus Error" ] # [ inline ( always ) ] pub fn buserr ( & mut self ) -> BUSERR_W { BUSERR_W { w : self } } # [ doc = "Bit 1 - Arbitration Lost" ] # [ inline ( always ) ] pub fn arblost ( & mut self ) -> ARBLOST_W { ARBLOST_W { w : self } } # [ doc = "Bit 2 - Received Not Acknowledge" ] # [ inline ( always ) ] pub fn rxnack ( & mut self ) -> RXNACK_W { RXNACK_W { w : self } } # [ doc = "Bits 4:5 - Bus State" ] # [ inline ( always ) ] pub fn busstate ( & mut self ) -> BUSSTATE_W { BUSSTATE_W { w : self } } # [ doc = "Bit 6 - SCL Low Timeout" ] # [ inline ( always ) ] pub fn lowtout ( & mut self ) -> LOWTOUT_W { LOWTOUT_W { w : self } } # [ doc = "Bit 7 - Clock Hold" ] # [ inline ( always ) ] pub fn clkhold ( & mut self ) -> CLKHOLD_W { CLKHOLD_W { w : self } } # [ doc = "Bit 8 - Master SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn mexttout ( & mut self ) -> MEXTTOUT_W { MEXTTOUT_W { w : self } } # [ doc = "Bit 9 - Slave SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn sexttout ( & mut self ) -> SEXTTOUT_W { SEXTTOUT_W { w : self } } # [ doc = "Bit 10 - Length Error" ] # [ inline ( always ) ] pub fn lenerr ( & mut self ) -> LENERR_W { LENERR_W { w : self } } } } # [ doc = "I2CM Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "I2CM Synchronization Busy" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `SYSOP`" ] pub type SYSOP_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Software Reset Synchronization Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - SERCOM Enable Synchronization Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - System Operation Synchronization Busy" ] # [ inline ( always ) ] pub fn sysop ( & self ) -> SYSOP_R { SYSOP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } } # [ doc = "I2CM Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [addr](addr) module" ] pub type ADDR = crate :: Reg < u32 , _ADDR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADDR ; # [ doc = "`read()` method returns [addr::R](addr::R) reader structure" ] impl crate :: Readable for ADDR { } # [ doc = "`write(|w| ..)` method takes [addr::W](addr::W) writer structure" ] impl crate :: Writable for ADDR { } # [ doc = "I2CM Address" ] pub mod addr { # [ doc = "Reader of register ADDR" ] pub type R = crate :: R < u32 , super :: ADDR > ; # [ doc = "Writer for register ADDR" ] pub type W = crate :: W < u32 , super :: ADDR > ; # [ doc = "Register ADDR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADDR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `ADDR`" ] pub type ADDR_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `ADDR`" ] pub struct ADDR_W < 'a > { w : & 'a mut W , } impl < 'a > ADDR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07ff ) | ( ( value as u32 ) & 0x07ff ) ; self . w } } # [ doc = "Reader of field `LENEN`" ] pub type LENEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LENEN`" ] pub struct LENEN_W < 'a > { w : & 'a mut W , } impl < 'a > LENEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } } # [ doc = "Reader of field `HS`" ] pub type HS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `HS`" ] pub struct HS_W < 'a > { w : & 'a mut W , } impl < 'a > HS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } } # [ doc = "Reader of field `TENBITEN`" ] pub type TENBITEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TENBITEN`" ] pub struct TENBITEN_W < 'a > { w : & 'a mut W , } impl < 'a > TENBITEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } # [ doc = "Reader of field `LEN`" ] pub type LEN_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `LEN`" ] pub struct LEN_W < 'a > { w : & 'a mut W , } impl < 'a > LEN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:10 - Address Value" ] # [ inline ( always ) ] pub fn addr ( & self ) -> ADDR_R { ADDR_R :: new ( ( self . bits & 0x07ff ) as u16 ) } # [ doc = "Bit 13 - Length Enable" ] # [ inline ( always ) ] pub fn lenen ( & self ) -> LENEN_R { LENEN_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bit 14 - High Speed Mode" ] # [ inline ( always ) ] pub fn hs ( & self ) -> HS_R { HS_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) } # [ doc = "Bit 15 - Ten Bit Addressing Enable" ] # [ inline ( always ) ] pub fn tenbiten ( & self ) -> TENBITEN_R { TENBITEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } # [ doc = "Bits 16:23 - Length" ] # [ inline ( always ) ] pub fn len ( & self ) -> LEN_R { LEN_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:10 - Address Value" ] # [ inline ( always ) ] pub fn addr ( & mut self ) -> ADDR_W { ADDR_W { w : self } } # [ doc = "Bit 13 - Length Enable" ] # [ inline ( always ) ] pub fn lenen ( & mut self ) -> LENEN_W { LENEN_W { w : self } } # [ doc = "Bit 14 - High Speed Mode" ] # [ inline ( always ) ] pub fn hs ( & mut self ) -> HS_W { HS_W { w : self } } # [ doc = "Bit 15 - Ten Bit Addressing Enable" ] # [ inline ( always ) ] pub fn tenbiten ( & mut self ) -> TENBITEN_W { TENBITEN_W { w : self } } # [ doc = "Bits 16:23 - Length" ] # [ inline ( always ) ] pub fn len ( & mut self ) -> LEN_W { LEN_W { w : self } } } } # [ doc = "I2CM Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [data](data) module" ] pub type DATA = crate :: Reg < u8 , _DATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DATA ; # [ doc = "`read()` method returns [data::R](data::R) reader structure" ] impl crate :: Readable for DATA { } # [ doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure" ] impl crate :: Writable for DATA { } # [ doc = "I2CM Data" ] pub mod data { # [ doc = "Reader of register DATA" ] pub type R = crate :: R < u8 , super :: DATA > ; # [ doc = "Writer for register DATA" ] pub type W = crate :: W < u8 , super :: DATA > ; # [ doc = "Register DATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DATA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DATA`" ] pub type DATA_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `DATA`" ] pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Data Value" ] # [ inline ( always ) ] pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Data Value" ] # [ inline ( always ) ] pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } } } # [ doc = "I2CM Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "I2CM Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGSTOP`" ] pub type DBGSTOP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGSTOP`" ] pub struct DBGSTOP_W < 'a > { w : & 'a mut W , } impl < 'a > DBGSTOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & self ) -> DBGSTOP_R { DBGSTOP_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & mut self ) -> DBGSTOP_W { DBGSTOP_W { w : self } } } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct I2CS { # [ doc = "0x00 - I2CS Control A" ] pub ctrla : self::i2cs::CTRLA , # [ doc = "0x04 - I2CS Control B" ] pub ctrlb : self::i2cs::CTRLB , _reserved2 : [ u8 ; 12usize ] , # [ doc = "0x14 - I2CS Interrupt Enable Clear" ] pub intenclr : self::i2cs::INTENCLR , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x16 - I2CS Interrupt Enable Set" ] pub intenset : self::i2cs::INTENSET , _reserved4 : [ u8 ; 1usize ] , # [ doc = "0x18 - I2CS Interrupt Flag Status and Clear" ] pub intflag : self::i2cs::INTFLAG , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x1a - I2CS Status" ] pub status : self::i2cs::STATUS , # [ doc = "0x1c - I2CS Synchronization Busy" ] pub syncbusy : self::i2cs::SYNCBUSY , _reserved7 : [ u8 ; 4usize ] , # [ doc = "0x24 - I2CS Address" ] pub addr : self::i2cs::ADDR , # [ doc = "0x28 - I2CS Data" ] pub data : self::i2cs::DATA , } # [ doc = r"Register block" ] # [ doc = "I2C Slave Mode" ] pub mod i2cs { # [ doc = "I2CS Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "I2CS Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "USART with external clock" ] USART_EXT_CLK , # [ doc = "USART with internal clock" ] USART_INT_CLK , # [ doc = "SPI in slave operation" ] SPI_SLAVE , # [ doc = "SPI in master operation" ] SPI_MASTER , # [ doc = "I2C slave operation" ] I2C_SLAVE , # [ doc = "I2C master operation" ] I2C_MASTER } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: USART_EXT_CLK => 0 , MODE_A :: USART_INT_CLK => 1 , MODE_A :: SPI_SLAVE => 2 , MODE_A :: SPI_MASTER => 3 , MODE_A :: I2C_SLAVE => 4 , MODE_A :: I2C_MASTER => 5 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: USART_EXT_CLK ) , 1 => Val ( MODE_A :: USART_INT_CLK ) , 2 => Val ( MODE_A :: SPI_SLAVE ) , 3 => Val ( MODE_A :: SPI_MASTER ) , 4 => Val ( MODE_A :: I2C_SLAVE ) , 5 => Val ( MODE_A :: I2C_MASTER ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `USART_EXT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_ext_clk ( & self ) -> bool { * self == MODE_A :: USART_EXT_CLK } # [ doc = "Checks if the value of the field is `USART_INT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_int_clk ( & self ) -> bool { * self == MODE_A :: USART_INT_CLK } # [ doc = "Checks if the value of the field is `SPI_SLAVE`" ] # [ inline ( always ) ] pub fn is_spi_slave ( & self ) -> bool { * self == MODE_A :: SPI_SLAVE } # [ doc = "Checks if the value of the field is `SPI_MASTER`" ] # [ inline ( always ) ] pub fn is_spi_master ( & self ) -> bool { * self == MODE_A :: SPI_MASTER } # [ doc = "Checks if the value of the field is `I2C_SLAVE`" ] # [ inline ( always ) ] pub fn is_i2c_slave ( & self ) -> bool { * self == MODE_A :: I2C_SLAVE } # [ doc = "Checks if the value of the field is `I2C_MASTER`" ] # [ inline ( always ) ] pub fn is_i2c_master ( & self ) -> bool { * self == MODE_A :: I2C_MASTER } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "USART with external clock" ] # [ inline ( always ) ] pub fn usart_ext_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_EXT_CLK ) } # [ doc = "USART with internal clock" ] # [ inline ( always ) ] pub fn usart_int_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_INT_CLK ) } # [ doc = "SPI in slave operation" ] # [ inline ( always ) ] pub fn spi_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_SLAVE ) } # [ doc = "SPI in master operation" ] # [ inline ( always ) ] pub fn spi_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_MASTER ) } # [ doc = "I2C slave operation" ] # [ inline ( always ) ] pub fn i2c_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_SLAVE ) } # [ doc = "I2C master operation" ] # [ inline ( always ) ] pub fn i2c_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_MASTER ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 2 ) ) | ( ( ( value as u32 ) & 0x07 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `PINOUT`" ] pub type PINOUT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PINOUT`" ] pub struct PINOUT_W < 'a > { w : & 'a mut W , } impl < 'a > PINOUT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Possible values of the field `SDAHOLD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SDAHOLD_A { # [ doc = "Disabled" ] DISABLE , # [ doc = "50-100ns hold time" ] _75NS , # [ doc = "300-600ns hold time" ] _450NS , # [ doc = "400-800ns hold time" ] _600NS } impl crate :: ToBits < u8 > for SDAHOLD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SDAHOLD_A :: DISABLE => 0 , SDAHOLD_A :: _75NS => 1 , SDAHOLD_A :: _450NS => 2 , SDAHOLD_A :: _600NS => 3 } } } # [ doc = "Reader of field `SDAHOLD`" ] pub type SDAHOLD_R = crate :: R < u8 , SDAHOLD_A > ; impl SDAHOLD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SDAHOLD_A { match self . bits { 0 => SDAHOLD_A :: DISABLE , 1 => SDAHOLD_A :: _75NS , 2 => SDAHOLD_A :: _450NS , 3 => SDAHOLD_A :: _600NS , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == SDAHOLD_A :: DISABLE } # [ doc = "Checks if the value of the field is `_75NS`" ] # [ inline ( always ) ] pub fn is_75ns ( & self ) -> bool { * self == SDAHOLD_A :: _75NS } # [ doc = "Checks if the value of the field is `_450NS`" ] # [ inline ( always ) ] pub fn is_450ns ( & self ) -> bool { * self == SDAHOLD_A :: _450NS } # [ doc = "Checks if the value of the field is `_600NS`" ] # [ inline ( always ) ] pub fn is_600ns ( & self ) -> bool { * self == SDAHOLD_A :: _600NS } } # [ doc = "Write proxy for field `SDAHOLD`" ] pub struct SDAHOLD_W < 'a > { w : & 'a mut W , } impl < 'a > SDAHOLD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SDAHOLD_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( SDAHOLD_A :: DISABLE ) } # [ doc = "50-100ns hold time" ] # [ inline ( always ) ] pub fn _75ns ( self ) -> & 'a mut W { self . variant ( SDAHOLD_A :: _75NS ) } # [ doc = "300-600ns hold time" ] # [ inline ( always ) ] pub fn _450ns ( self ) -> & 'a mut W { self . variant ( SDAHOLD_A :: _450NS ) } # [ doc = "400-800ns hold time" ] # [ inline ( always ) ] pub fn _600ns ( self ) -> & 'a mut W { self . variant ( SDAHOLD_A :: _600NS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 20 ) ) | ( ( ( value as u32 ) & 0x03 ) << 20 ) ; self . w } } # [ doc = "Reader of field `SEXTTOEN`" ] pub type SEXTTOEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SEXTTOEN`" ] pub struct SEXTTOEN_W < 'a > { w : & 'a mut W , } impl < 'a > SEXTTOEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } } # [ doc = "Possible values of the field `SPEED`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SPEED_A { # [ doc = "Standard Mode(Sm) Upto 100kHz and Fast Mode(Fm) Upto 400kHz " ] STANDARD_AND_FAST_MODE , # [ doc = "Fast-mode Plus Upto 1MHz" ] FASTPLUS_MODE , # [ doc = "High-speed mode Upto 3.4MHz" ] HIGH_SPEED_MODE } impl crate :: ToBits < u8 > for SPEED_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SPEED_A :: STANDARD_AND_FAST_MODE => 0 , SPEED_A :: FASTPLUS_MODE => 1 , SPEED_A :: HIGH_SPEED_MODE => 2 } } } # [ doc = "Reader of field `SPEED`" ] pub type SPEED_R = crate :: R < u8 , SPEED_A > ; impl SPEED_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SPEED_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SPEED_A :: STANDARD_AND_FAST_MODE ) , 1 => Val ( SPEED_A :: FASTPLUS_MODE ) , 2 => Val ( SPEED_A :: HIGH_SPEED_MODE ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `STANDARD_AND_FAST_MODE`" ] # [ inline ( always ) ] pub fn is_standard_and_fast_mode ( & self ) -> bool { * self == SPEED_A :: STANDARD_AND_FAST_MODE } # [ doc = "Checks if the value of the field is `FASTPLUS_MODE`" ] # [ inline ( always ) ] pub fn is_fastplus_mode ( & self ) -> bool { * self == SPEED_A :: FASTPLUS_MODE } # [ doc = "Checks if the value of the field is `HIGH_SPEED_MODE`" ] # [ inline ( always ) ] pub fn is_high_speed_mode ( & self ) -> bool { * self == SPEED_A :: HIGH_SPEED_MODE } } # [ doc = "Write proxy for field `SPEED`" ] pub struct SPEED_W < 'a > { w : & 'a mut W , } impl < 'a > SPEED_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SPEED_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Standard Mode(Sm) Upto 100kHz and Fast Mode(Fm) Upto 400kHz" ] # [ inline ( always ) ] pub fn standard_and_fast_mode ( self ) -> & 'a mut W { self . variant ( SPEED_A :: STANDARD_AND_FAST_MODE ) } # [ doc = "Fast-mode Plus Upto 1MHz" ] # [ inline ( always ) ] pub fn fastplus_mode ( self ) -> & 'a mut W { self . variant ( SPEED_A :: FASTPLUS_MODE ) } # [ doc = "High-speed mode Upto 3.4MHz" ] # [ inline ( always ) ] pub fn high_speed_mode ( self ) -> & 'a mut W { self . variant ( SPEED_A :: HIGH_SPEED_MODE ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 24 ) ) | ( ( ( value as u32 ) & 0x03 ) << 24 ) ; self . w } } # [ doc = "Reader of field `SCLSM`" ] pub type SCLSM_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SCLSM`" ] pub struct SCLSM_W < 'a > { w : & 'a mut W , } impl < 'a > SCLSM_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } } # [ doc = "Reader of field `LOWTOUTEN`" ] pub type LOWTOUTEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LOWTOUTEN`" ] pub struct LOWTOUTEN_W < 'a > { w : & 'a mut W , } impl < 'a > LOWTOUTEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x07 ) as u8 ) } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - Pin Usage" ] # [ inline ( always ) ] pub fn pinout ( & self ) -> PINOUT_R { PINOUT_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bits 20:21 - SDA Hold Time" ] # [ inline ( always ) ] pub fn sdahold ( & self ) -> SDAHOLD_R { SDAHOLD_R :: new ( ( ( self . bits >> 20 ) & 0x03 ) as u8 ) } # [ doc = "Bit 23 - Slave SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn sexttoen ( & self ) -> SEXTTOEN_R { SEXTTOEN_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) } # [ doc = "Bits 24:25 - Transfer Speed" ] # [ inline ( always ) ] pub fn speed ( & self ) -> SPEED_R { SPEED_R :: new ( ( ( self . bits >> 24 ) & 0x03 ) as u8 ) } # [ doc = "Bit 27 - SCL Clock Stretch Mode" ] # [ inline ( always ) ] pub fn sclsm ( & self ) -> SCLSM_R { SCLSM_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - SCL Low Timeout Enable" ] # [ inline ( always ) ] pub fn lowtouten ( & self ) -> LOWTOUTEN_R { LOWTOUTEN_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } } # [ doc = "Bit 16 - Pin Usage" ] # [ inline ( always ) ] pub fn pinout ( & mut self ) -> PINOUT_W { PINOUT_W { w : self } } # [ doc = "Bits 20:21 - SDA Hold Time" ] # [ inline ( always ) ] pub fn sdahold ( & mut self ) -> SDAHOLD_W { SDAHOLD_W { w : self } } # [ doc = "Bit 23 - Slave SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn sexttoen ( & mut self ) -> SEXTTOEN_W { SEXTTOEN_W { w : self } } # [ doc = "Bits 24:25 - Transfer Speed" ] # [ inline ( always ) ] pub fn speed ( & mut self ) -> SPEED_W { SPEED_W { w : self } } # [ doc = "Bit 27 - SCL Clock Stretch Mode" ] # [ inline ( always ) ] pub fn sclsm ( & mut self ) -> SCLSM_W { SCLSM_W { w : self } } # [ doc = "Bit 30 - SCL Low Timeout Enable" ] # [ inline ( always ) ] pub fn lowtouten ( & mut self ) -> LOWTOUTEN_W { LOWTOUTEN_W { w : self } } } } # [ doc = "I2CS Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u32 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ; # [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { } # [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { } # [ doc = "I2CS Control B" ] pub mod ctrlb { # [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u32 , super :: CTRLB > ; # [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u32 , super :: CTRLB > ; # [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SMEN`" ] pub type SMEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SMEN`" ] pub struct SMEN_W < 'a > { w : & 'a mut W , } impl < 'a > SMEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `GCMD`" ] pub type GCMD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `GCMD`" ] pub struct GCMD_W < 'a > { w : & 'a mut W , } impl < 'a > GCMD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `AACKEN`" ] pub type AACKEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `AACKEN`" ] pub struct AACKEN_W < 'a > { w : & 'a mut W , } impl < 'a > AACKEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } } # [ doc = "Reader of field `AMODE`" ] pub type AMODE_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `AMODE`" ] pub struct AMODE_W < 'a > { w : & 'a mut W , } impl < 'a > AMODE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u32 ) & 0x03 ) << 14 ) ; self . w } } # [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 16 ) ) | ( ( ( value as u32 ) & 0x03 ) << 16 ) ; self . w } } # [ doc = "Reader of field `ACKACT`" ] pub type ACKACT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ACKACT`" ] pub struct ACKACT_W < 'a > { w : & 'a mut W , } impl < 'a > ACKACT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } } impl R { # [ doc = "Bit 8 - Smart Mode Enable" ] # [ inline ( always ) ] pub fn smen ( & self ) -> SMEN_R { SMEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - PMBus Group Command" ] # [ inline ( always ) ] pub fn gcmd ( & self ) -> GCMD_R { GCMD_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - Automatic Address Acknowledge" ] # [ inline ( always ) ] pub fn aacken ( & self ) -> AACKEN_R { AACKEN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } # [ doc = "Bits 14:15 - Address Mode" ] # [ inline ( always ) ] pub fn amode ( & self ) -> AMODE_R { AMODE_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) } # [ doc = "Bits 16:17 - Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 16 ) & 0x03 ) as u8 ) } # [ doc = "Bit 18 - Acknowledge Action" ] # [ inline ( always ) ] pub fn ackact ( & self ) -> ACKACT_R { ACKACT_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 8 - Smart Mode Enable" ] # [ inline ( always ) ] pub fn smen ( & mut self ) -> SMEN_W { SMEN_W { w : self } } # [ doc = "Bit 9 - PMBus Group Command" ] # [ inline ( always ) ] pub fn gcmd ( & mut self ) -> GCMD_W { GCMD_W { w : self } } # [ doc = "Bit 10 - Automatic Address Acknowledge" ] # [ inline ( always ) ] pub fn aacken ( & mut self ) -> AACKEN_W { AACKEN_W { w : self } } # [ doc = "Bits 14:15 - Address Mode" ] # [ inline ( always ) ] pub fn amode ( & mut self ) -> AMODE_W { AMODE_W { w : self } } # [ doc = "Bits 16:17 - Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } } # [ doc = "Bit 18 - Acknowledge Action" ] # [ inline ( always ) ] pub fn ackact ( & mut self ) -> ACKACT_W { ACKACT_W { w : self } } } } # [ doc = "I2CS Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "I2CS Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PREC`" ] pub type PREC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PREC`" ] pub struct PREC_W < 'a > { w : & 'a mut W , } impl < 'a > PREC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `AMATCH`" ] pub type AMATCH_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `AMATCH`" ] pub struct AMATCH_W < 'a > { w : & 'a mut W , } impl < 'a > AMATCH_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `DRDY`" ] pub type DRDY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRDY`" ] pub struct DRDY_W < 'a > { w : & 'a mut W , } impl < 'a > DRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Stop Received Interrupt Disable" ] # [ inline ( always ) ] pub fn prec ( & self ) -> PREC_R { PREC_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Address Match Interrupt Disable" ] # [ inline ( always ) ] pub fn amatch ( & self ) -> AMATCH_R { AMATCH_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Data Interrupt Disable" ] # [ inline ( always ) ] pub fn drdy ( & self ) -> DRDY_R { DRDY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Stop Received Interrupt Disable" ] # [ inline ( always ) ] pub fn prec ( & mut self ) -> PREC_W { PREC_W { w : self } } # [ doc = "Bit 1 - Address Match Interrupt Disable" ] # [ inline ( always ) ] pub fn amatch ( & mut self ) -> AMATCH_W { AMATCH_W { w : self } } # [ doc = "Bit 2 - Data Interrupt Disable" ] # [ inline ( always ) ] pub fn drdy ( & mut self ) -> DRDY_W { DRDY_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "I2CS Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "I2CS Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PREC`" ] pub type PREC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PREC`" ] pub struct PREC_W < 'a > { w : & 'a mut W , } impl < 'a > PREC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `AMATCH`" ] pub type AMATCH_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `AMATCH`" ] pub struct AMATCH_W < 'a > { w : & 'a mut W , } impl < 'a > AMATCH_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `DRDY`" ] pub type DRDY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRDY`" ] pub struct DRDY_W < 'a > { w : & 'a mut W , } impl < 'a > DRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Stop Received Interrupt Enable" ] # [ inline ( always ) ] pub fn prec ( & self ) -> PREC_R { PREC_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Address Match Interrupt Enable" ] # [ inline ( always ) ] pub fn amatch ( & self ) -> AMATCH_R { AMATCH_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Data Interrupt Enable" ] # [ inline ( always ) ] pub fn drdy ( & self ) -> DRDY_R { DRDY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Stop Received Interrupt Enable" ] # [ inline ( always ) ] pub fn prec ( & mut self ) -> PREC_W { PREC_W { w : self } } # [ doc = "Bit 1 - Address Match Interrupt Enable" ] # [ inline ( always ) ] pub fn amatch ( & mut self ) -> AMATCH_W { AMATCH_W { w : self } } # [ doc = "Bit 2 - Data Interrupt Enable" ] # [ inline ( always ) ] pub fn drdy ( & mut self ) -> DRDY_W { DRDY_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "I2CS Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "I2CS Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PREC`" ] pub type PREC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PREC`" ] pub struct PREC_W < 'a > { w : & 'a mut W , } impl < 'a > PREC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `AMATCH`" ] pub type AMATCH_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `AMATCH`" ] pub struct AMATCH_W < 'a > { w : & 'a mut W , } impl < 'a > AMATCH_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `DRDY`" ] pub type DRDY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRDY`" ] pub struct DRDY_W < 'a > { w : & 'a mut W , } impl < 'a > DRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Stop Received Interrupt" ] # [ inline ( always ) ] pub fn prec ( & self ) -> PREC_R { PREC_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Address Match Interrupt" ] # [ inline ( always ) ] pub fn amatch ( & self ) -> AMATCH_R { AMATCH_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Data Interrupt" ] # [ inline ( always ) ] pub fn drdy ( & self ) -> DRDY_R { DRDY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Stop Received Interrupt" ] # [ inline ( always ) ] pub fn prec ( & mut self ) -> PREC_W { PREC_W { w : self } } # [ doc = "Bit 1 - Address Match Interrupt" ] # [ inline ( always ) ] pub fn amatch ( & mut self ) -> AMATCH_W { AMATCH_W { w : self } } # [ doc = "Bit 2 - Data Interrupt" ] # [ inline ( always ) ] pub fn drdy ( & mut self ) -> DRDY_W { DRDY_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "I2CS Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u16 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { } # [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { } # [ doc = "I2CS Status" ] pub mod status { # [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u16 , super :: STATUS > ; # [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u16 , super :: STATUS > ; # [ doc = "Register STATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BUSERR`" ] pub type BUSERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `BUSERR`" ] pub struct BUSERR_W < 'a > { w : & 'a mut W , } impl < 'a > BUSERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `COLL`" ] pub type COLL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COLL`" ] pub struct COLL_W < 'a > { w : & 'a mut W , } impl < 'a > COLL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXNACK`" ] pub type RXNACK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXNACK`" ] pub struct RXNACK_W < 'a > { w : & 'a mut W , } impl < 'a > RXNACK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `DIR`" ] pub type DIR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DIR`" ] pub struct DIR_W < 'a > { w : & 'a mut W , } impl < 'a > DIR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `SR`" ] pub type SR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SR`" ] pub struct SR_W < 'a > { w : & 'a mut W , } impl < 'a > SR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `LOWTOUT`" ] pub type LOWTOUT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LOWTOUT`" ] pub struct LOWTOUT_W < 'a > { w : & 'a mut W , } impl < 'a > LOWTOUT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `CLKHOLD`" ] pub type CLKHOLD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CLKHOLD`" ] pub struct CLKHOLD_W < 'a > { w : & 'a mut W , } impl < 'a > CLKHOLD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `SEXTTOUT`" ] pub type SEXTTOUT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SEXTTOUT`" ] pub struct SEXTTOUT_W < 'a > { w : & 'a mut W , } impl < 'a > SEXTTOUT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `HS`" ] pub type HS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `HS`" ] pub struct HS_W < 'a > { w : & 'a mut W , } impl < 'a > HS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } } impl R { # [ doc = "Bit 0 - Bus Error" ] # [ inline ( always ) ] pub fn buserr ( & self ) -> BUSERR_R { BUSERR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Collision" ] # [ inline ( always ) ] pub fn coll ( & self ) -> COLL_R { COLL_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Received Not Acknowledge" ] # [ inline ( always ) ] pub fn rxnack ( & self ) -> RXNACK_R { RXNACK_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Read/Write Direction" ] # [ inline ( always ) ] pub fn dir ( & self ) -> DIR_R { DIR_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Repeated Start" ] # [ inline ( always ) ] pub fn sr ( & self ) -> SR_R { SR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - SCL Low Timeout" ] # [ inline ( always ) ] pub fn lowtout ( & self ) -> LOWTOUT_R { LOWTOUT_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Clock Hold" ] # [ inline ( always ) ] pub fn clkhold ( & self ) -> CLKHOLD_R { CLKHOLD_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Slave SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn sexttout ( & self ) -> SEXTTOUT_R { SEXTTOUT_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - High Speed" ] # [ inline ( always ) ] pub fn hs ( & self ) -> HS_R { HS_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Bus Error" ] # [ inline ( always ) ] pub fn buserr ( & mut self ) -> BUSERR_W { BUSERR_W { w : self } } # [ doc = "Bit 1 - Transmit Collision" ] # [ inline ( always ) ] pub fn coll ( & mut self ) -> COLL_W { COLL_W { w : self } } # [ doc = "Bit 2 - Received Not Acknowledge" ] # [ inline ( always ) ] pub fn rxnack ( & mut self ) -> RXNACK_W { RXNACK_W { w : self } } # [ doc = "Bit 3 - Read/Write Direction" ] # [ inline ( always ) ] pub fn dir ( & mut self ) -> DIR_W { DIR_W { w : self } } # [ doc = "Bit 4 - Repeated Start" ] # [ inline ( always ) ] pub fn sr ( & mut self ) -> SR_W { SR_W { w : self } } # [ doc = "Bit 6 - SCL Low Timeout" ] # [ inline ( always ) ] pub fn lowtout ( & mut self ) -> LOWTOUT_W { LOWTOUT_W { w : self } } # [ doc = "Bit 7 - Clock Hold" ] # [ inline ( always ) ] pub fn clkhold ( & mut self ) -> CLKHOLD_W { CLKHOLD_W { w : self } } # [ doc = "Bit 9 - Slave SCL Low Extend Timeout" ] # [ inline ( always ) ] pub fn sexttout ( & mut self ) -> SEXTTOUT_W { SEXTTOUT_W { w : self } } # [ doc = "Bit 10 - High Speed" ] # [ inline ( always ) ] pub fn hs ( & mut self ) -> HS_W { HS_W { w : self } } } } # [ doc = "I2CS Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "I2CS Synchronization Busy" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Software Reset Synchronization Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - SERCOM Enable Synchronization Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } } } # [ doc = "I2CS Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [addr](addr) module" ] pub type ADDR = crate :: Reg < u32 , _ADDR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADDR ; # [ doc = "`read()` method returns [addr::R](addr::R) reader structure" ] impl crate :: Readable for ADDR { } # [ doc = "`write(|w| ..)` method takes [addr::W](addr::W) writer structure" ] impl crate :: Writable for ADDR { } # [ doc = "I2CS Address" ] pub mod addr { # [ doc = "Reader of register ADDR" ] pub type R = crate :: R < u32 , super :: ADDR > ; # [ doc = "Writer for register ADDR" ] pub type W = crate :: W < u32 , super :: ADDR > ; # [ doc = "Register ADDR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADDR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `GENCEN`" ] pub type GENCEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `GENCEN`" ] pub struct GENCEN_W < 'a > { w : & 'a mut W , } impl < 'a > GENCEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ADDR`" ] pub type ADDR_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `ADDR`" ] pub struct ADDR_W < 'a > { w : & 'a mut W , } impl < 'a > ADDR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03ff << 1 ) ) | ( ( ( value as u32 ) & 0x03ff ) << 1 ) ; self . w } } # [ doc = "Reader of field `TENBITEN`" ] pub type TENBITEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TENBITEN`" ] pub struct TENBITEN_W < 'a > { w : & 'a mut W , } impl < 'a > TENBITEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } } # [ doc = "Reader of field `ADDRMASK`" ] pub type ADDRMASK_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `ADDRMASK`" ] pub struct ADDRMASK_W < 'a > { w : & 'a mut W , } impl < 'a > ADDRMASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03ff << 17 ) ) | ( ( ( value as u32 ) & 0x03ff ) << 17 ) ; self . w } } impl R { # [ doc = "Bit 0 - General Call Address Enable" ] # [ inline ( always ) ] pub fn gencen ( & self ) -> GENCEN_R { GENCEN_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bits 1:10 - Address Value" ] # [ inline ( always ) ] pub fn addr ( & self ) -> ADDR_R { ADDR_R :: new ( ( ( self . bits >> 1 ) & 0x03ff ) as u16 ) } # [ doc = "Bit 15 - Ten Bit Addressing Enable" ] # [ inline ( always ) ] pub fn tenbiten ( & self ) -> TENBITEN_R { TENBITEN_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) } # [ doc = "Bits 17:26 - Address Mask" ] # [ inline ( always ) ] pub fn addrmask ( & self ) -> ADDRMASK_R { ADDRMASK_R :: new ( ( ( self . bits >> 17 ) & 0x03ff ) as u16 ) } } impl W { # [ doc = "Bit 0 - General Call Address Enable" ] # [ inline ( always ) ] pub fn gencen ( & mut self ) -> GENCEN_W { GENCEN_W { w : self } } # [ doc = "Bits 1:10 - Address Value" ] # [ inline ( always ) ] pub fn addr ( & mut self ) -> ADDR_W { ADDR_W { w : self } } # [ doc = "Bit 15 - Ten Bit Addressing Enable" ] # [ inline ( always ) ] pub fn tenbiten ( & mut self ) -> TENBITEN_W { TENBITEN_W { w : self } } # [ doc = "Bits 17:26 - Address Mask" ] # [ inline ( always ) ] pub fn addrmask ( & mut self ) -> ADDRMASK_W { ADDRMASK_W { w : self } } } } # [ doc = "I2CS Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [data](data) module" ] pub type DATA = crate :: Reg < u8 , _DATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DATA ; # [ doc = "`read()` method returns [data::R](data::R) reader structure" ] impl crate :: Readable for DATA { } # [ doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure" ] impl crate :: Writable for DATA { } # [ doc = "I2CS Data" ] pub mod data { # [ doc = "Reader of register DATA" ] pub type R = crate :: R < u8 , super :: DATA > ; # [ doc = "Writer for register DATA" ] pub type W = crate :: W < u8 , super :: DATA > ; # [ doc = "Register DATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DATA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DATA`" ] pub type DATA_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `DATA`" ] pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Data Value" ] # [ inline ( always ) ] pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Data Value" ] # [ inline ( always ) ] pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct SPIS { # [ doc = "0x00 - SPIS Control A" ] pub ctrla : self::spis::CTRLA , # [ doc = "0x04 - SPIS Control B" ] pub ctrlb : self::spis::CTRLB , _reserved2 : [ u8 ; 4usize ] , # [ doc = "0x0c - SPIS Baud Rate" ] pub baud : self::spis::BAUD , _reserved3 : [ u8 ; 7usize ] , # [ doc = "0x14 - SPIS Interrupt Enable Clear" ] pub intenclr : self::spis::INTENCLR , _reserved4 : [ u8 ; 1usize ] , # [ doc = "0x16 - SPIS Interrupt Enable Set" ] pub intenset : self::spis::INTENSET , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x18 - SPIS Interrupt Flag Status and Clear" ] pub intflag : self::spis::INTFLAG , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x1a - SPIS Status" ] pub status : self::spis::STATUS , # [ doc = "0x1c - SPIS Synchronization Busy" ] pub syncbusy : self::spis::SYNCBUSY , _reserved8 : [ u8 ; 4usize ] , # [ doc = "0x24 - SPIS Address" ] pub addr : self::spis::ADDR , # [ doc = "0x28 - SPIS Data" ] pub data : self::spis::DATA , _reserved10 : [ u8 ; 4usize ] , # [ doc = "0x30 - SPIS Debug Control" ] pub dbgctrl : self::spis::DBGCTRL , } # [ doc = r"Register block" ] # [ doc = "SPI Slave Mode" ] pub mod spis { # [ doc = "SPIS Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "SPIS Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "USART with external clock" ] USART_EXT_CLK , # [ doc = "USART with internal clock" ] USART_INT_CLK , # [ doc = "SPI in slave operation" ] SPI_SLAVE , # [ doc = "SPI in master operation" ] SPI_MASTER , # [ doc = "I2C slave operation" ] I2C_SLAVE , # [ doc = "I2C master operation" ] I2C_MASTER } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: USART_EXT_CLK => 0 , MODE_A :: USART_INT_CLK => 1 , MODE_A :: SPI_SLAVE => 2 , MODE_A :: SPI_MASTER => 3 , MODE_A :: I2C_SLAVE => 4 , MODE_A :: I2C_MASTER => 5 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: USART_EXT_CLK ) , 1 => Val ( MODE_A :: USART_INT_CLK ) , 2 => Val ( MODE_A :: SPI_SLAVE ) , 3 => Val ( MODE_A :: SPI_MASTER ) , 4 => Val ( MODE_A :: I2C_SLAVE ) , 5 => Val ( MODE_A :: I2C_MASTER ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `USART_EXT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_ext_clk ( & self ) -> bool { * self == MODE_A :: USART_EXT_CLK } # [ doc = "Checks if the value of the field is `USART_INT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_int_clk ( & self ) -> bool { * self == MODE_A :: USART_INT_CLK } # [ doc = "Checks if the value of the field is `SPI_SLAVE`" ] # [ inline ( always ) ] pub fn is_spi_slave ( & self ) -> bool { * self == MODE_A :: SPI_SLAVE } # [ doc = "Checks if the value of the field is `SPI_MASTER`" ] # [ inline ( always ) ] pub fn is_spi_master ( & self ) -> bool { * self == MODE_A :: SPI_MASTER } # [ doc = "Checks if the value of the field is `I2C_SLAVE`" ] # [ inline ( always ) ] pub fn is_i2c_slave ( & self ) -> bool { * self == MODE_A :: I2C_SLAVE } # [ doc = "Checks if the value of the field is `I2C_MASTER`" ] # [ inline ( always ) ] pub fn is_i2c_master ( & self ) -> bool { * self == MODE_A :: I2C_MASTER } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "USART with external clock" ] # [ inline ( always ) ] pub fn usart_ext_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_EXT_CLK ) } # [ doc = "USART with internal clock" ] # [ inline ( always ) ] pub fn usart_int_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_INT_CLK ) } # [ doc = "SPI in slave operation" ] # [ inline ( always ) ] pub fn spi_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_SLAVE ) } # [ doc = "SPI in master operation" ] # [ inline ( always ) ] pub fn spi_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_MASTER ) } # [ doc = "I2C slave operation" ] # [ inline ( always ) ] pub fn i2c_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_SLAVE ) } # [ doc = "I2C master operation" ] # [ inline ( always ) ] pub fn i2c_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_MASTER ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 2 ) ) | ( ( ( value as u32 ) & 0x07 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `IBON`" ] pub type IBON_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `IBON`" ] pub struct IBON_W < 'a > { w : & 'a mut W , } impl < 'a > IBON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Possible values of the field `DOPO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DOPO_A { # [ doc = "DO on PAD\\[0\\], SCK on PAD\\[1\\] and SS on PAD\\[2\\]" ] PAD0 , # [ doc = "DO on PAD\\[2\\], SCK on PAD\\[3\\] and SS on PAD\\[1\\]" ] PAD1 , # [ doc = "DO on PAD\\[3\\], SCK on PAD\\[1\\] and SS on PAD\\[2\\]" ] PAD2 , # [ doc = "DO on PAD\\[0\\], SCK on PAD\\[3\\] and SS on PAD\\[1\\]" ] PAD3 } impl crate :: ToBits < u8 > for DOPO_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DOPO_A :: PAD0 => 0 , DOPO_A :: PAD1 => 1 , DOPO_A :: PAD2 => 2 , DOPO_A :: PAD3 => 3 } } } # [ doc = "Reader of field `DOPO`" ] pub type DOPO_R = crate :: R < u8 , DOPO_A > ; impl DOPO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DOPO_A { match self . bits { 0 => DOPO_A :: PAD0 , 1 => DOPO_A :: PAD1 , 2 => DOPO_A :: PAD2 , 3 => DOPO_A :: PAD3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `PAD0`" ] # [ inline ( always ) ] pub fn is_pad0 ( & self ) -> bool { * self == DOPO_A :: PAD0 } # [ doc = "Checks if the value of the field is `PAD1`" ] # [ inline ( always ) ] pub fn is_pad1 ( & self ) -> bool { * self == DOPO_A :: PAD1 } # [ doc = "Checks if the value of the field is `PAD2`" ] # [ inline ( always ) ] pub fn is_pad2 ( & self ) -> bool { * self == DOPO_A :: PAD2 } # [ doc = "Checks if the value of the field is `PAD3`" ] # [ inline ( always ) ] pub fn is_pad3 ( & self ) -> bool { * self == DOPO_A :: PAD3 } } # [ doc = "Write proxy for field `DOPO`" ] pub struct DOPO_W < 'a > { w : & 'a mut W , } impl < 'a > DOPO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DOPO_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "DO on PAD\\[0\\], SCK on PAD\\[1\\] and SS on PAD\\[2\\]" ] # [ inline ( always ) ] pub fn pad0 ( self ) -> & 'a mut W { self . variant ( DOPO_A :: PAD0 ) } # [ doc = "DO on PAD\\[2\\], SCK on PAD\\[3\\] and SS on PAD\\[1\\]" ] # [ inline ( always ) ] pub fn pad1 ( self ) -> & 'a mut W { self . variant ( DOPO_A :: PAD1 ) } # [ doc = "DO on PAD\\[3\\], SCK on PAD\\[1\\] and SS on PAD\\[2\\]" ] # [ inline ( always ) ] pub fn pad2 ( self ) -> & 'a mut W { self . variant ( DOPO_A :: PAD2 ) } # [ doc = "DO on PAD\\[0\\], SCK on PAD\\[3\\] and SS on PAD\\[1\\]" ] # [ inline ( always ) ] pub fn pad3 ( self ) -> & 'a mut W { self . variant ( DOPO_A :: PAD3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 16 ) ) | ( ( ( value as u32 ) & 0x03 ) << 16 ) ; self . w } } # [ doc = "Possible values of the field `DIPO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DIPO_A { # [ doc = "SERCOM PAD\\[0\\]" ] PAD0 , # [ doc = "SERCOM PAD\\[1\\]" ] PAD1 , # [ doc = "SERCOM PAD\\[2\\]" ] PAD2 , # [ doc = "SERCOM PAD\\[3\\]" ] PAD3 } impl crate :: ToBits < u8 > for DIPO_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DIPO_A :: PAD0 => 0 , DIPO_A :: PAD1 => 1 , DIPO_A :: PAD2 => 2 , DIPO_A :: PAD3 => 3 } } } # [ doc = "Reader of field `DIPO`" ] pub type DIPO_R = crate :: R < u8 , DIPO_A > ; impl DIPO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DIPO_A { match self . bits { 0 => DIPO_A :: PAD0 , 1 => DIPO_A :: PAD1 , 2 => DIPO_A :: PAD2 , 3 => DIPO_A :: PAD3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `PAD0`" ] # [ inline ( always ) ] pub fn is_pad0 ( & self ) -> bool { * self == DIPO_A :: PAD0 } # [ doc = "Checks if the value of the field is `PAD1`" ] # [ inline ( always ) ] pub fn is_pad1 ( & self ) -> bool { * self == DIPO_A :: PAD1 } # [ doc = "Checks if the value of the field is `PAD2`" ] # [ inline ( always ) ] pub fn is_pad2 ( & self ) -> bool { * self == DIPO_A :: PAD2 } # [ doc = "Checks if the value of the field is `PAD3`" ] # [ inline ( always ) ] pub fn is_pad3 ( & self ) -> bool { * self == DIPO_A :: PAD3 } } # [ doc = "Write proxy for field `DIPO`" ] pub struct DIPO_W < 'a > { w : & 'a mut W , } impl < 'a > DIPO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DIPO_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "SERCOM PAD\\[0\\]" ] # [ inline ( always ) ] pub fn pad0 ( self ) -> & 'a mut W { self . variant ( DIPO_A :: PAD0 ) } # [ doc = "SERCOM PAD\\[1\\]" ] # [ inline ( always ) ] pub fn pad1 ( self ) -> & 'a mut W { self . variant ( DIPO_A :: PAD1 ) } # [ doc = "SERCOM PAD\\[2\\]" ] # [ inline ( always ) ] pub fn pad2 ( self ) -> & 'a mut W { self . variant ( DIPO_A :: PAD2 ) } # [ doc = "SERCOM PAD\\[3\\]" ] # [ inline ( always ) ] pub fn pad3 ( self ) -> & 'a mut W { self . variant ( DIPO_A :: PAD3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 20 ) ) | ( ( ( value as u32 ) & 0x03 ) << 20 ) ; self . w } } # [ doc = "Possible values of the field `FORM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FORM_A { # [ doc = "SPI Frame" ] SPI_FRAME , # [ doc = "SPI Frame with Addr" ] SPI_FRAME_WITH_ADDR } impl crate :: ToBits < u8 > for FORM_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { FORM_A :: SPI_FRAME => 0 , FORM_A :: SPI_FRAME_WITH_ADDR => 2 } } } # [ doc = "Reader of field `FORM`" ] pub type FORM_R = crate :: R < u8 , FORM_A > ; impl FORM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , FORM_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( FORM_A :: SPI_FRAME ) , 2 => Val ( FORM_A :: SPI_FRAME_WITH_ADDR ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SPI_FRAME`" ] # [ inline ( always ) ] pub fn is_spi_frame ( & self ) -> bool { * self == FORM_A :: SPI_FRAME } # [ doc = "Checks if the value of the field is `SPI_FRAME_WITH_ADDR`" ] # [ inline ( always ) ] pub fn is_spi_frame_with_addr ( & self ) -> bool { * self == FORM_A :: SPI_FRAME_WITH_ADDR } } # [ doc = "Write proxy for field `FORM`" ] pub struct FORM_W < 'a > { w : & 'a mut W , } impl < 'a > FORM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FORM_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SPI Frame" ] # [ inline ( always ) ] pub fn spi_frame ( self ) -> & 'a mut W { self . variant ( FORM_A :: SPI_FRAME ) } # [ doc = "SPI Frame with Addr" ] # [ inline ( always ) ] pub fn spi_frame_with_addr ( self ) -> & 'a mut W { self . variant ( FORM_A :: SPI_FRAME_WITH_ADDR ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } } # [ doc = "Possible values of the field `CPHA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPHA_A { # [ doc = "The data is sampled on a leading SCK edge and changed on a trailing SCK edge" ] LEADING_EDGE , # [ doc = "The data is sampled on a trailing SCK edge and changed on a leading SCK edge" ] TRAILING_EDGE } impl crate :: ToBits < bool > for CPHA_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CPHA_A :: LEADING_EDGE => false , CPHA_A :: TRAILING_EDGE => true } } } # [ doc = "Reader of field `CPHA`" ] pub type CPHA_R = crate :: R < bool , CPHA_A > ; impl CPHA_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPHA_A { match self . bits { false => CPHA_A :: LEADING_EDGE , true => CPHA_A :: TRAILING_EDGE } } # [ doc = "Checks if the value of the field is `LEADING_EDGE`" ] # [ inline ( always ) ] pub fn is_leading_edge ( & self ) -> bool { * self == CPHA_A :: LEADING_EDGE } # [ doc = "Checks if the value of the field is `TRAILING_EDGE`" ] # [ inline ( always ) ] pub fn is_trailing_edge ( & self ) -> bool { * self == CPHA_A :: TRAILING_EDGE } } # [ doc = "Write proxy for field `CPHA`" ] pub struct CPHA_W < 'a > { w : & 'a mut W , } impl < 'a > CPHA_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPHA_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "The data is sampled on a leading SCK edge and changed on a trailing SCK edge" ] # [ inline ( always ) ] pub fn leading_edge ( self ) -> & 'a mut W { self . variant ( CPHA_A :: LEADING_EDGE ) } # [ doc = "The data is sampled on a trailing SCK edge and changed on a leading SCK edge" ] # [ inline ( always ) ] pub fn trailing_edge ( self ) -> & 'a mut W { self . variant ( CPHA_A :: TRAILING_EDGE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } } # [ doc = "Possible values of the field `CPOL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPOL_A { # [ doc = "SCK is low when idle" ] IDLE_LOW , # [ doc = "SCK is high when idle" ] IDLE_HIGH } impl crate :: ToBits < bool > for CPOL_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CPOL_A :: IDLE_LOW => false , CPOL_A :: IDLE_HIGH => true } } } # [ doc = "Reader of field `CPOL`" ] pub type CPOL_R = crate :: R < bool , CPOL_A > ; impl CPOL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPOL_A { match self . bits { false => CPOL_A :: IDLE_LOW , true => CPOL_A :: IDLE_HIGH } } # [ doc = "Checks if the value of the field is `IDLE_LOW`" ] # [ inline ( always ) ] pub fn is_idle_low ( & self ) -> bool { * self == CPOL_A :: IDLE_LOW } # [ doc = "Checks if the value of the field is `IDLE_HIGH`" ] # [ inline ( always ) ] pub fn is_idle_high ( & self ) -> bool { * self == CPOL_A :: IDLE_HIGH } } # [ doc = "Write proxy for field `CPOL`" ] pub struct CPOL_W < 'a > { w : & 'a mut W , } impl < 'a > CPOL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPOL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "SCK is low when idle" ] # [ inline ( always ) ] pub fn idle_low ( self ) -> & 'a mut W { self . variant ( CPOL_A :: IDLE_LOW ) } # [ doc = "SCK is high when idle" ] # [ inline ( always ) ] pub fn idle_high ( self ) -> & 'a mut W { self . variant ( CPOL_A :: IDLE_HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } } # [ doc = "Possible values of the field `DORD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DORD_A { # [ doc = "MSB is transferred first" ] MSB , # [ doc = "LSB is transferred first" ] LSB } impl crate :: ToBits < bool > for DORD_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { DORD_A :: MSB => false , DORD_A :: LSB => true } } } # [ doc = "Reader of field `DORD`" ] pub type DORD_R = crate :: R < bool , DORD_A > ; impl DORD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DORD_A { match self . bits { false => DORD_A :: MSB , true => DORD_A :: LSB } } # [ doc = "Checks if the value of the field is `MSB`" ] # [ inline ( always ) ] pub fn is_msb ( & self ) -> bool { * self == DORD_A :: MSB } # [ doc = "Checks if the value of the field is `LSB`" ] # [ inline ( always ) ] pub fn is_lsb ( & self ) -> bool { * self == DORD_A :: LSB } } # [ doc = "Write proxy for field `DORD`" ] pub struct DORD_W < 'a > { w : & 'a mut W , } impl < 'a > DORD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DORD_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "MSB is transferred first" ] # [ inline ( always ) ] pub fn msb ( self ) -> & 'a mut W { self . variant ( DORD_A :: MSB ) } # [ doc = "LSB is transferred first" ] # [ inline ( always ) ] pub fn lsb ( self ) -> & 'a mut W { self . variant ( DORD_A :: LSB ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x07 ) as u8 ) } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Immediate Buffer Overflow Notification" ] # [ inline ( always ) ] pub fn ibon ( & self ) -> IBON_R { IBON_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bits 16:17 - Data Out Pinout" ] # [ inline ( always ) ] pub fn dopo ( & self ) -> DOPO_R { DOPO_R :: new ( ( ( self . bits >> 16 ) & 0x03 ) as u8 ) } # [ doc = "Bits 20:21 - Data In Pinout" ] # [ inline ( always ) ] pub fn dipo ( & self ) -> DIPO_R { DIPO_R :: new ( ( ( self . bits >> 20 ) & 0x03 ) as u8 ) } # [ doc = "Bits 24:27 - Frame Format" ] # [ inline ( always ) ] pub fn form ( & self ) -> FORM_R { FORM_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) } # [ doc = "Bit 28 - Clock Phase" ] # [ inline ( always ) ] pub fn cpha ( & self ) -> CPHA_R { CPHA_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - Clock Polarity" ] # [ inline ( always ) ] pub fn cpol ( & self ) -> CPOL_R { CPOL_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - Data Order" ] # [ inline ( always ) ] pub fn dord ( & self ) -> DORD_R { DORD_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } } # [ doc = "Bit 8 - Immediate Buffer Overflow Notification" ] # [ inline ( always ) ] pub fn ibon ( & mut self ) -> IBON_W { IBON_W { w : self } } # [ doc = "Bits 16:17 - Data Out Pinout" ] # [ inline ( always ) ] pub fn dopo ( & mut self ) -> DOPO_W { DOPO_W { w : self } } # [ doc = "Bits 20:21 - Data In Pinout" ] # [ inline ( always ) ] pub fn dipo ( & mut self ) -> DIPO_W { DIPO_W { w : self } } # [ doc = "Bits 24:27 - Frame Format" ] # [ inline ( always ) ] pub fn form ( & mut self ) -> FORM_W { FORM_W { w : self } } # [ doc = "Bit 28 - Clock Phase" ] # [ inline ( always ) ] pub fn cpha ( & mut self ) -> CPHA_W { CPHA_W { w : self } } # [ doc = "Bit 29 - Clock Polarity" ] # [ inline ( always ) ] pub fn cpol ( & mut self ) -> CPOL_W { CPOL_W { w : self } } # [ doc = "Bit 30 - Data Order" ] # [ inline ( always ) ] pub fn dord ( & mut self ) -> DORD_W { DORD_W { w : self } } } } # [ doc = "SPIS Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u32 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ; # [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { } # [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { } # [ doc = "SPIS Control B" ] pub mod ctrlb { # [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u32 , super :: CTRLB > ; # [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u32 , super :: CTRLB > ; # [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `CHSIZE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CHSIZE_A { # [ doc = "8 bits" ] _8_BIT , # [ doc = "9 bits" ] _9_BIT } impl crate :: ToBits < u8 > for CHSIZE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CHSIZE_A :: _8_BIT => 0 , CHSIZE_A :: _9_BIT => 1 } } } # [ doc = "Reader of field `CHSIZE`" ] pub type CHSIZE_R = crate :: R < u8 , CHSIZE_A > ; impl CHSIZE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CHSIZE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CHSIZE_A :: _8_BIT ) , 1 => Val ( CHSIZE_A :: _9_BIT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_8_BIT`" ] # [ inline ( always ) ] pub fn is_8_bit ( & self ) -> bool { * self == CHSIZE_A :: _8_BIT } # [ doc = "Checks if the value of the field is `_9_BIT`" ] # [ inline ( always ) ] pub fn is_9_bit ( & self ) -> bool { * self == CHSIZE_A :: _9_BIT } } # [ doc = "Write proxy for field `CHSIZE`" ] pub struct CHSIZE_W < 'a > { w : & 'a mut W , } impl < 'a > CHSIZE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CHSIZE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 bits" ] # [ inline ( always ) ] pub fn _8_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _8_BIT ) } # [ doc = "9 bits" ] # [ inline ( always ) ] pub fn _9_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _9_BIT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } } # [ doc = "Reader of field `PLOADEN`" ] pub type PLOADEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PLOADEN`" ] pub struct PLOADEN_W < 'a > { w : & 'a mut W , } impl < 'a > PLOADEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `SSDE`" ] pub type SSDE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SSDE`" ] pub struct SSDE_W < 'a > { w : & 'a mut W , } impl < 'a > SSDE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `MSSEN`" ] pub type MSSEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MSSEN`" ] pub struct MSSEN_W < 'a > { w : & 'a mut W , } impl < 'a > MSSEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } } # [ doc = "Possible values of the field `AMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum AMODE_A { # [ doc = "SPI Address mask " ] MASK , # [ doc = "Two unique Addressess" ] _2_ADDRESSES , # [ doc = "Address Range" ] RANGE } impl crate :: ToBits < u8 > for AMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { AMODE_A :: MASK => 0 , AMODE_A :: _2_ADDRESSES => 1 , AMODE_A :: RANGE => 2 } } } # [ doc = "Reader of field `AMODE`" ] pub type AMODE_R = crate :: R < u8 , AMODE_A > ; impl AMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , AMODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( AMODE_A :: MASK ) , 1 => Val ( AMODE_A :: _2_ADDRESSES ) , 2 => Val ( AMODE_A :: RANGE ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `MASK`" ] # [ inline ( always ) ] pub fn is_mask ( & self ) -> bool { * self == AMODE_A :: MASK } # [ doc = "Checks if the value of the field is `_2_ADDRESSES`" ] # [ inline ( always ) ] pub fn is_2_addresses ( & self ) -> bool { * self == AMODE_A :: _2_ADDRESSES } # [ doc = "Checks if the value of the field is `RANGE`" ] # [ inline ( always ) ] pub fn is_range ( & self ) -> bool { * self == AMODE_A :: RANGE } } # [ doc = "Write proxy for field `AMODE`" ] pub struct AMODE_W < 'a > { w : & 'a mut W , } impl < 'a > AMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : AMODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SPI Address mask" ] # [ inline ( always ) ] pub fn mask ( self ) -> & 'a mut W { self . variant ( AMODE_A :: MASK ) } # [ doc = "Two unique Addressess" ] # [ inline ( always ) ] pub fn _2_addresses ( self ) -> & 'a mut W { self . variant ( AMODE_A :: _2_ADDRESSES ) } # [ doc = "Address Range" ] # [ inline ( always ) ] pub fn range ( self ) -> & 'a mut W { self . variant ( AMODE_A :: RANGE ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u32 ) & 0x03 ) << 14 ) ; self . w } } # [ doc = "Reader of field `RXEN`" ] pub type RXEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXEN`" ] pub struct RXEN_W < 'a > { w : & 'a mut W , } impl < 'a > RXEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - Character Size" ] # [ inline ( always ) ] pub fn chsize ( & self ) -> CHSIZE_R { CHSIZE_R :: new ( ( self . bits & 0x07 ) as u8 ) } # [ doc = "Bit 6 - Data Preload Enable" ] # [ inline ( always ) ] pub fn ploaden ( & self ) -> PLOADEN_R { PLOADEN_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Slave Select Low Detect Enable" ] # [ inline ( always ) ] pub fn ssde ( & self ) -> SSDE_R { SSDE_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - Master Slave Select Enable" ] # [ inline ( always ) ] pub fn mssen ( & self ) -> MSSEN_R { MSSEN_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bits 14:15 - Address Mode" ] # [ inline ( always ) ] pub fn amode ( & self ) -> AMODE_R { AMODE_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) } # [ doc = "Bit 17 - Receiver Enable" ] # [ inline ( always ) ] pub fn rxen ( & self ) -> RXEN_R { RXEN_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:2 - Character Size" ] # [ inline ( always ) ] pub fn chsize ( & mut self ) -> CHSIZE_W { CHSIZE_W { w : self } } # [ doc = "Bit 6 - Data Preload Enable" ] # [ inline ( always ) ] pub fn ploaden ( & mut self ) -> PLOADEN_W { PLOADEN_W { w : self } } # [ doc = "Bit 9 - Slave Select Low Detect Enable" ] # [ inline ( always ) ] pub fn ssde ( & mut self ) -> SSDE_W { SSDE_W { w : self } } # [ doc = "Bit 13 - Master Slave Select Enable" ] # [ inline ( always ) ] pub fn mssen ( & mut self ) -> MSSEN_W { MSSEN_W { w : self } } # [ doc = "Bits 14:15 - Address Mode" ] # [ inline ( always ) ] pub fn amode ( & mut self ) -> AMODE_W { AMODE_W { w : self } } # [ doc = "Bit 17 - Receiver Enable" ] # [ inline ( always ) ] pub fn rxen ( & mut self ) -> RXEN_W { RXEN_W { w : self } } } } # [ doc = "SPIS Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud](baud) module" ] pub type BAUD = crate :: Reg < u8 , _BAUD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD ; # [ doc = "`read()` method returns [baud::R](baud::R) reader structure" ] impl crate :: Readable for BAUD { } # [ doc = "`write(|w| ..)` method takes [baud::W](baud::W) writer structure" ] impl crate :: Writable for BAUD { } # [ doc = "SPIS Baud Rate" ] pub mod baud { # [ doc = "Reader of register BAUD" ] pub type R = crate :: R < u8 , super :: BAUD > ; # [ doc = "Writer for register BAUD" ] pub type W = crate :: W < u8 , super :: BAUD > ; # [ doc = "Register BAUD `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } } } # [ doc = "SPIS Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "SPIS Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `SSL`" ] pub type SSL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SSL`" ] pub struct SSL_W < 'a > { w : & 'a mut W , } impl < 'a > SSL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt Disable" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Slave Select Low Interrupt Disable" ] # [ inline ( always ) ] pub fn ssl ( & self ) -> SSL_R { SSL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt Disable" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Slave Select Low Interrupt Disable" ] # [ inline ( always ) ] pub fn ssl ( & mut self ) -> SSL_W { SSL_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "SPIS Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "SPIS Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `SSL`" ] pub type SSL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SSL`" ] pub struct SSL_W < 'a > { w : & 'a mut W , } impl < 'a > SSL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Slave Select Low Interrupt Enable" ] # [ inline ( always ) ] pub fn ssl ( & self ) -> SSL_R { SSL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Slave Select Low Interrupt Enable" ] # [ inline ( always ) ] pub fn ssl ( & mut self ) -> SSL_W { SSL_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "SPIS Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "SPIS Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `SSL`" ] pub type SSL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SSL`" ] pub struct SSL_W < 'a > { w : & 'a mut W , } impl < 'a > SSL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Slave Select Low Interrupt Flag" ] # [ inline ( always ) ] pub fn ssl ( & self ) -> SSL_R { SSL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Slave Select Low Interrupt Flag" ] # [ inline ( always ) ] pub fn ssl ( & mut self ) -> SSL_W { SSL_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "SPIS Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u16 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { } # [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { } # [ doc = "SPIS Status" ] pub mod status { # [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u16 , super :: STATUS > ; # [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u16 , super :: STATUS > ; # [ doc = "Register STATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BUFOVF`" ] pub type BUFOVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `BUFOVF`" ] pub struct BUFOVF_W < 'a > { w : & 'a mut W , } impl < 'a > BUFOVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } impl R { # [ doc = "Bit 2 - Buffer Overflow" ] # [ inline ( always ) ] pub fn bufovf ( & self ) -> BUFOVF_R { BUFOVF_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 2 - Buffer Overflow" ] # [ inline ( always ) ] pub fn bufovf ( & mut self ) -> BUFOVF_W { BUFOVF_W { w : self } } } } # [ doc = "SPIS Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "SPIS Synchronization Busy" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CTRLB`" ] pub type CTRLB_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Software Reset Synchronization Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - SERCOM Enable Synchronization Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - CTRLB Synchronization Busy" ] # [ inline ( always ) ] pub fn ctrlb ( & self ) -> CTRLB_R { CTRLB_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } } # [ doc = "SPIS Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [addr](addr) module" ] pub type ADDR = crate :: Reg < u32 , _ADDR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADDR ; # [ doc = "`read()` method returns [addr::R](addr::R) reader structure" ] impl crate :: Readable for ADDR { } # [ doc = "`write(|w| ..)` method takes [addr::W](addr::W) writer structure" ] impl crate :: Writable for ADDR { } # [ doc = "SPIS Address" ] pub mod addr { # [ doc = "Reader of register ADDR" ] pub type R = crate :: R < u32 , super :: ADDR > ; # [ doc = "Writer for register ADDR" ] pub type W = crate :: W < u32 , super :: ADDR > ; # [ doc = "Register ADDR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADDR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `ADDR`" ] pub type ADDR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `ADDR`" ] pub struct ADDR_W < 'a > { w : & 'a mut W , } impl < 'a > ADDR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u32 ) & 0xff ) ; self . w } } # [ doc = "Reader of field `ADDRMASK`" ] pub type ADDRMASK_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `ADDRMASK`" ] pub struct ADDRMASK_W < 'a > { w : & 'a mut W , } impl < 'a > ADDRMASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Address Value" ] # [ inline ( always ) ] pub fn addr ( & self ) -> ADDR_R { ADDR_R :: new ( ( self . bits & 0xff ) as u8 ) } # [ doc = "Bits 16:23 - Address Mask" ] # [ inline ( always ) ] pub fn addrmask ( & self ) -> ADDRMASK_R { ADDRMASK_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Address Value" ] # [ inline ( always ) ] pub fn addr ( & mut self ) -> ADDR_W { ADDR_W { w : self } } # [ doc = "Bits 16:23 - Address Mask" ] # [ inline ( always ) ] pub fn addrmask ( & mut self ) -> ADDRMASK_W { ADDRMASK_W { w : self } } } } # [ doc = "SPIS Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [data](data) module" ] pub type DATA = crate :: Reg < u32 , _DATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DATA ; # [ doc = "`read()` method returns [data::R](data::R) reader structure" ] impl crate :: Readable for DATA { } # [ doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure" ] impl crate :: Writable for DATA { } # [ doc = "SPIS Data" ] pub mod data { # [ doc = "Reader of register DATA" ] pub type R = crate :: R < u32 , super :: DATA > ; # [ doc = "Writer for register DATA" ] pub type W = crate :: W < u32 , super :: DATA > ; # [ doc = "Register DATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DATA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DATA`" ] pub type DATA_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `DATA`" ] pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01ff ) | ( ( value as u32 ) & 0x01ff ) ; self . w } } impl R { # [ doc = "Bits 0:8 - Data Value" ] # [ inline ( always ) ] pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bits 0:8 - Data Value" ] # [ inline ( always ) ] pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } } } # [ doc = "SPIS Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "SPIS Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGSTOP`" ] pub type DBGSTOP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGSTOP`" ] pub struct DBGSTOP_W < 'a > { w : & 'a mut W , } impl < 'a > DBGSTOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & self ) -> DBGSTOP_R { DBGSTOP_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & mut self ) -> DBGSTOP_W { DBGSTOP_W { w : self } } } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct SPIM { # [ doc = "0x00 - SPIM Control A" ] pub ctrla : self::spim::CTRLA , # [ doc = "0x04 - SPIM Control B" ] pub ctrlb : self::spim::CTRLB , _reserved2 : [ u8 ; 4usize ] , # [ doc = "0x0c - SPIM Baud Rate" ] pub baud : self::spim::BAUD , _reserved3 : [ u8 ; 7usize ] , # [ doc = "0x14 - SPIM Interrupt Enable Clear" ] pub intenclr : self::spim::INTENCLR , _reserved4 : [ u8 ; 1usize ] , # [ doc = "0x16 - SPIM Interrupt Enable Set" ] pub intenset : self::spim::INTENSET , _reserved5 : [ u8 ; 1usize ] , # [ doc = "0x18 - SPIM Interrupt Flag Status and Clear" ] pub intflag : self::spim::INTFLAG , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x1a - SPIM Status" ] pub status : self::spim::STATUS , # [ doc = "0x1c - SPIM Synchronization Busy" ] pub syncbusy : self::spim::SYNCBUSY , _reserved8 : [ u8 ; 4usize ] , # [ doc = "0x24 - SPIM Address" ] pub addr : self::spim::ADDR , # [ doc = "0x28 - SPIM Data" ] pub data : self::spim::DATA , _reserved10 : [ u8 ; 4usize ] , # [ doc = "0x30 - SPIM Debug Control" ] pub dbgctrl : self::spim::DBGCTRL , } # [ doc = r"Register block" ] # [ doc = "SPI Master Mode" ] pub mod spim { # [ doc = "SPIM Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "SPIM Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "USART with external clock" ] USART_EXT_CLK , # [ doc = "USART with internal clock" ] USART_INT_CLK , # [ doc = "SPI in slave operation" ] SPI_SLAVE , # [ doc = "SPI in master operation" ] SPI_MASTER , # [ doc = "I2C slave operation" ] I2C_SLAVE , # [ doc = "I2C master operation" ] I2C_MASTER } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: USART_EXT_CLK => 0 , MODE_A :: USART_INT_CLK => 1 , MODE_A :: SPI_SLAVE => 2 , MODE_A :: SPI_MASTER => 3 , MODE_A :: I2C_SLAVE => 4 , MODE_A :: I2C_MASTER => 5 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: USART_EXT_CLK ) , 1 => Val ( MODE_A :: USART_INT_CLK ) , 2 => Val ( MODE_A :: SPI_SLAVE ) , 3 => Val ( MODE_A :: SPI_MASTER ) , 4 => Val ( MODE_A :: I2C_SLAVE ) , 5 => Val ( MODE_A :: I2C_MASTER ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `USART_EXT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_ext_clk ( & self ) -> bool { * self == MODE_A :: USART_EXT_CLK } # [ doc = "Checks if the value of the field is `USART_INT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_int_clk ( & self ) -> bool { * self == MODE_A :: USART_INT_CLK } # [ doc = "Checks if the value of the field is `SPI_SLAVE`" ] # [ inline ( always ) ] pub fn is_spi_slave ( & self ) -> bool { * self == MODE_A :: SPI_SLAVE } # [ doc = "Checks if the value of the field is `SPI_MASTER`" ] # [ inline ( always ) ] pub fn is_spi_master ( & self ) -> bool { * self == MODE_A :: SPI_MASTER } # [ doc = "Checks if the value of the field is `I2C_SLAVE`" ] # [ inline ( always ) ] pub fn is_i2c_slave ( & self ) -> bool { * self == MODE_A :: I2C_SLAVE } # [ doc = "Checks if the value of the field is `I2C_MASTER`" ] # [ inline ( always ) ] pub fn is_i2c_master ( & self ) -> bool { * self == MODE_A :: I2C_MASTER } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "USART with external clock" ] # [ inline ( always ) ] pub fn usart_ext_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_EXT_CLK ) } # [ doc = "USART with internal clock" ] # [ inline ( always ) ] pub fn usart_int_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_INT_CLK ) } # [ doc = "SPI in slave operation" ] # [ inline ( always ) ] pub fn spi_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_SLAVE ) } # [ doc = "SPI in master operation" ] # [ inline ( always ) ] pub fn spi_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_MASTER ) } # [ doc = "I2C slave operation" ] # [ inline ( always ) ] pub fn i2c_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_SLAVE ) } # [ doc = "I2C master operation" ] # [ inline ( always ) ] pub fn i2c_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_MASTER ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 2 ) ) | ( ( ( value as u32 ) & 0x07 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `IBON`" ] pub type IBON_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `IBON`" ] pub struct IBON_W < 'a > { w : & 'a mut W , } impl < 'a > IBON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Possible values of the field `DOPO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DOPO_A { # [ doc = "DO on PAD\\[0\\], SCK on PAD\\[1\\] and SS on PAD\\[2\\]" ] PAD0 , # [ doc = "DO on PAD\\[2\\], SCK on PAD\\[3\\] and SS on PAD\\[1\\]" ] PAD1 , # [ doc = "DO on PAD\\[3\\], SCK on PAD\\[1\\] and SS on PAD\\[2\\]" ] PAD2 , # [ doc = "DO on PAD\\[0\\], SCK on PAD\\[3\\] and SS on PAD\\[1\\]" ] PAD3 } impl crate :: ToBits < u8 > for DOPO_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DOPO_A :: PAD0 => 0 , DOPO_A :: PAD1 => 1 , DOPO_A :: PAD2 => 2 , DOPO_A :: PAD3 => 3 } } } # [ doc = "Reader of field `DOPO`" ] pub type DOPO_R = crate :: R < u8 , DOPO_A > ; impl DOPO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DOPO_A { match self . bits { 0 => DOPO_A :: PAD0 , 1 => DOPO_A :: PAD1 , 2 => DOPO_A :: PAD2 , 3 => DOPO_A :: PAD3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `PAD0`" ] # [ inline ( always ) ] pub fn is_pad0 ( & self ) -> bool { * self == DOPO_A :: PAD0 } # [ doc = "Checks if the value of the field is `PAD1`" ] # [ inline ( always ) ] pub fn is_pad1 ( & self ) -> bool { * self == DOPO_A :: PAD1 } # [ doc = "Checks if the value of the field is `PAD2`" ] # [ inline ( always ) ] pub fn is_pad2 ( & self ) -> bool { * self == DOPO_A :: PAD2 } # [ doc = "Checks if the value of the field is `PAD3`" ] # [ inline ( always ) ] pub fn is_pad3 ( & self ) -> bool { * self == DOPO_A :: PAD3 } } # [ doc = "Write proxy for field `DOPO`" ] pub struct DOPO_W < 'a > { w : & 'a mut W , } impl < 'a > DOPO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DOPO_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "DO on PAD\\[0\\], SCK on PAD\\[1\\] and SS on PAD\\[2\\]" ] # [ inline ( always ) ] pub fn pad0 ( self ) -> & 'a mut W { self . variant ( DOPO_A :: PAD0 ) } # [ doc = "DO on PAD\\[2\\], SCK on PAD\\[3\\] and SS on PAD\\[1\\]" ] # [ inline ( always ) ] pub fn pad1 ( self ) -> & 'a mut W { self . variant ( DOPO_A :: PAD1 ) } # [ doc = "DO on PAD\\[3\\], SCK on PAD\\[1\\] and SS on PAD\\[2\\]" ] # [ inline ( always ) ] pub fn pad2 ( self ) -> & 'a mut W { self . variant ( DOPO_A :: PAD2 ) } # [ doc = "DO on PAD\\[0\\], SCK on PAD\\[3\\] and SS on PAD\\[1\\]" ] # [ inline ( always ) ] pub fn pad3 ( self ) -> & 'a mut W { self . variant ( DOPO_A :: PAD3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 16 ) ) | ( ( ( value as u32 ) & 0x03 ) << 16 ) ; self . w } } # [ doc = "Possible values of the field `DIPO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DIPO_A { # [ doc = "SERCOM PAD\\[0\\]" ] PAD0 , # [ doc = "SERCOM PAD\\[1\\]" ] PAD1 , # [ doc = "SERCOM PAD\\[2\\]" ] PAD2 , # [ doc = "SERCOM PAD\\[3\\]" ] PAD3 } impl crate :: ToBits < u8 > for DIPO_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { DIPO_A :: PAD0 => 0 , DIPO_A :: PAD1 => 1 , DIPO_A :: PAD2 => 2 , DIPO_A :: PAD3 => 3 } } } # [ doc = "Reader of field `DIPO`" ] pub type DIPO_R = crate :: R < u8 , DIPO_A > ; impl DIPO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DIPO_A { match self . bits { 0 => DIPO_A :: PAD0 , 1 => DIPO_A :: PAD1 , 2 => DIPO_A :: PAD2 , 3 => DIPO_A :: PAD3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `PAD0`" ] # [ inline ( always ) ] pub fn is_pad0 ( & self ) -> bool { * self == DIPO_A :: PAD0 } # [ doc = "Checks if the value of the field is `PAD1`" ] # [ inline ( always ) ] pub fn is_pad1 ( & self ) -> bool { * self == DIPO_A :: PAD1 } # [ doc = "Checks if the value of the field is `PAD2`" ] # [ inline ( always ) ] pub fn is_pad2 ( & self ) -> bool { * self == DIPO_A :: PAD2 } # [ doc = "Checks if the value of the field is `PAD3`" ] # [ inline ( always ) ] pub fn is_pad3 ( & self ) -> bool { * self == DIPO_A :: PAD3 } } # [ doc = "Write proxy for field `DIPO`" ] pub struct DIPO_W < 'a > { w : & 'a mut W , } impl < 'a > DIPO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DIPO_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "SERCOM PAD\\[0\\]" ] # [ inline ( always ) ] pub fn pad0 ( self ) -> & 'a mut W { self . variant ( DIPO_A :: PAD0 ) } # [ doc = "SERCOM PAD\\[1\\]" ] # [ inline ( always ) ] pub fn pad1 ( self ) -> & 'a mut W { self . variant ( DIPO_A :: PAD1 ) } # [ doc = "SERCOM PAD\\[2\\]" ] # [ inline ( always ) ] pub fn pad2 ( self ) -> & 'a mut W { self . variant ( DIPO_A :: PAD2 ) } # [ doc = "SERCOM PAD\\[3\\]" ] # [ inline ( always ) ] pub fn pad3 ( self ) -> & 'a mut W { self . variant ( DIPO_A :: PAD3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 20 ) ) | ( ( ( value as u32 ) & 0x03 ) << 20 ) ; self . w } } # [ doc = "Possible values of the field `FORM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FORM_A { # [ doc = "SPI Frame" ] SPI_FRAME , # [ doc = "SPI Frame with Addr" ] SPI_FRAME_WITH_ADDR } impl crate :: ToBits < u8 > for FORM_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { FORM_A :: SPI_FRAME => 0 , FORM_A :: SPI_FRAME_WITH_ADDR => 2 } } } # [ doc = "Reader of field `FORM`" ] pub type FORM_R = crate :: R < u8 , FORM_A > ; impl FORM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , FORM_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( FORM_A :: SPI_FRAME ) , 2 => Val ( FORM_A :: SPI_FRAME_WITH_ADDR ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `SPI_FRAME`" ] # [ inline ( always ) ] pub fn is_spi_frame ( & self ) -> bool { * self == FORM_A :: SPI_FRAME } # [ doc = "Checks if the value of the field is `SPI_FRAME_WITH_ADDR`" ] # [ inline ( always ) ] pub fn is_spi_frame_with_addr ( & self ) -> bool { * self == FORM_A :: SPI_FRAME_WITH_ADDR } } # [ doc = "Write proxy for field `FORM`" ] pub struct FORM_W < 'a > { w : & 'a mut W , } impl < 'a > FORM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FORM_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SPI Frame" ] # [ inline ( always ) ] pub fn spi_frame ( self ) -> & 'a mut W { self . variant ( FORM_A :: SPI_FRAME ) } # [ doc = "SPI Frame with Addr" ] # [ inline ( always ) ] pub fn spi_frame_with_addr ( self ) -> & 'a mut W { self . variant ( FORM_A :: SPI_FRAME_WITH_ADDR ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } } # [ doc = "Possible values of the field `CPHA`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPHA_A { # [ doc = "The data is sampled on a leading SCK edge and changed on a trailing SCK edge" ] LEADING_EDGE , # [ doc = "The data is sampled on a trailing SCK edge and changed on a leading SCK edge" ] TRAILING_EDGE } impl crate :: ToBits < bool > for CPHA_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CPHA_A :: LEADING_EDGE => false , CPHA_A :: TRAILING_EDGE => true } } } # [ doc = "Reader of field `CPHA`" ] pub type CPHA_R = crate :: R < bool , CPHA_A > ; impl CPHA_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPHA_A { match self . bits { false => CPHA_A :: LEADING_EDGE , true => CPHA_A :: TRAILING_EDGE } } # [ doc = "Checks if the value of the field is `LEADING_EDGE`" ] # [ inline ( always ) ] pub fn is_leading_edge ( & self ) -> bool { * self == CPHA_A :: LEADING_EDGE } # [ doc = "Checks if the value of the field is `TRAILING_EDGE`" ] # [ inline ( always ) ] pub fn is_trailing_edge ( & self ) -> bool { * self == CPHA_A :: TRAILING_EDGE } } # [ doc = "Write proxy for field `CPHA`" ] pub struct CPHA_W < 'a > { w : & 'a mut W , } impl < 'a > CPHA_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPHA_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "The data is sampled on a leading SCK edge and changed on a trailing SCK edge" ] # [ inline ( always ) ] pub fn leading_edge ( self ) -> & 'a mut W { self . variant ( CPHA_A :: LEADING_EDGE ) } # [ doc = "The data is sampled on a trailing SCK edge and changed on a leading SCK edge" ] # [ inline ( always ) ] pub fn trailing_edge ( self ) -> & 'a mut W { self . variant ( CPHA_A :: TRAILING_EDGE ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } } # [ doc = "Possible values of the field `CPOL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPOL_A { # [ doc = "SCK is low when idle" ] IDLE_LOW , # [ doc = "SCK is high when idle" ] IDLE_HIGH } impl crate :: ToBits < bool > for CPOL_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CPOL_A :: IDLE_LOW => false , CPOL_A :: IDLE_HIGH => true } } } # [ doc = "Reader of field `CPOL`" ] pub type CPOL_R = crate :: R < bool , CPOL_A > ; impl CPOL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPOL_A { match self . bits { false => CPOL_A :: IDLE_LOW , true => CPOL_A :: IDLE_HIGH } } # [ doc = "Checks if the value of the field is `IDLE_LOW`" ] # [ inline ( always ) ] pub fn is_idle_low ( & self ) -> bool { * self == CPOL_A :: IDLE_LOW } # [ doc = "Checks if the value of the field is `IDLE_HIGH`" ] # [ inline ( always ) ] pub fn is_idle_high ( & self ) -> bool { * self == CPOL_A :: IDLE_HIGH } } # [ doc = "Write proxy for field `CPOL`" ] pub struct CPOL_W < 'a > { w : & 'a mut W , } impl < 'a > CPOL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPOL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "SCK is low when idle" ] # [ inline ( always ) ] pub fn idle_low ( self ) -> & 'a mut W { self . variant ( CPOL_A :: IDLE_LOW ) } # [ doc = "SCK is high when idle" ] # [ inline ( always ) ] pub fn idle_high ( self ) -> & 'a mut W { self . variant ( CPOL_A :: IDLE_HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } } # [ doc = "Possible values of the field `DORD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DORD_A { # [ doc = "MSB is transferred first" ] MSB , # [ doc = "LSB is transferred first" ] LSB } impl crate :: ToBits < bool > for DORD_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { DORD_A :: MSB => false , DORD_A :: LSB => true } } } # [ doc = "Reader of field `DORD`" ] pub type DORD_R = crate :: R < bool , DORD_A > ; impl DORD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DORD_A { match self . bits { false => DORD_A :: MSB , true => DORD_A :: LSB } } # [ doc = "Checks if the value of the field is `MSB`" ] # [ inline ( always ) ] pub fn is_msb ( & self ) -> bool { * self == DORD_A :: MSB } # [ doc = "Checks if the value of the field is `LSB`" ] # [ inline ( always ) ] pub fn is_lsb ( & self ) -> bool { * self == DORD_A :: LSB } } # [ doc = "Write proxy for field `DORD`" ] pub struct DORD_W < 'a > { w : & 'a mut W , } impl < 'a > DORD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DORD_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "MSB is transferred first" ] # [ inline ( always ) ] pub fn msb ( self ) -> & 'a mut W { self . variant ( DORD_A :: MSB ) } # [ doc = "LSB is transferred first" ] # [ inline ( always ) ] pub fn lsb ( self ) -> & 'a mut W { self . variant ( DORD_A :: LSB ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x07 ) as u8 ) } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Immediate Buffer Overflow Notification" ] # [ inline ( always ) ] pub fn ibon ( & self ) -> IBON_R { IBON_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bits 16:17 - Data Out Pinout" ] # [ inline ( always ) ] pub fn dopo ( & self ) -> DOPO_R { DOPO_R :: new ( ( ( self . bits >> 16 ) & 0x03 ) as u8 ) } # [ doc = "Bits 20:21 - Data In Pinout" ] # [ inline ( always ) ] pub fn dipo ( & self ) -> DIPO_R { DIPO_R :: new ( ( ( self . bits >> 20 ) & 0x03 ) as u8 ) } # [ doc = "Bits 24:27 - Frame Format" ] # [ inline ( always ) ] pub fn form ( & self ) -> FORM_R { FORM_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) } # [ doc = "Bit 28 - Clock Phase" ] # [ inline ( always ) ] pub fn cpha ( & self ) -> CPHA_R { CPHA_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - Clock Polarity" ] # [ inline ( always ) ] pub fn cpol ( & self ) -> CPOL_R { CPOL_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - Data Order" ] # [ inline ( always ) ] pub fn dord ( & self ) -> DORD_R { DORD_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } } # [ doc = "Bit 8 - Immediate Buffer Overflow Notification" ] # [ inline ( always ) ] pub fn ibon ( & mut self ) -> IBON_W { IBON_W { w : self } } # [ doc = "Bits 16:17 - Data Out Pinout" ] # [ inline ( always ) ] pub fn dopo ( & mut self ) -> DOPO_W { DOPO_W { w : self } } # [ doc = "Bits 20:21 - Data In Pinout" ] # [ inline ( always ) ] pub fn dipo ( & mut self ) -> DIPO_W { DIPO_W { w : self } } # [ doc = "Bits 24:27 - Frame Format" ] # [ inline ( always ) ] pub fn form ( & mut self ) -> FORM_W { FORM_W { w : self } } # [ doc = "Bit 28 - Clock Phase" ] # [ inline ( always ) ] pub fn cpha ( & mut self ) -> CPHA_W { CPHA_W { w : self } } # [ doc = "Bit 29 - Clock Polarity" ] # [ inline ( always ) ] pub fn cpol ( & mut self ) -> CPOL_W { CPOL_W { w : self } } # [ doc = "Bit 30 - Data Order" ] # [ inline ( always ) ] pub fn dord ( & mut self ) -> DORD_W { DORD_W { w : self } } } } # [ doc = "SPIM Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u32 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ; # [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { } # [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { } # [ doc = "SPIM Control B" ] pub mod ctrlb { # [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u32 , super :: CTRLB > ; # [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u32 , super :: CTRLB > ; # [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `CHSIZE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CHSIZE_A { # [ doc = "8 bits" ] _8_BIT , # [ doc = "9 bits" ] _9_BIT } impl crate :: ToBits < u8 > for CHSIZE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CHSIZE_A :: _8_BIT => 0 , CHSIZE_A :: _9_BIT => 1 } } } # [ doc = "Reader of field `CHSIZE`" ] pub type CHSIZE_R = crate :: R < u8 , CHSIZE_A > ; impl CHSIZE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CHSIZE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CHSIZE_A :: _8_BIT ) , 1 => Val ( CHSIZE_A :: _9_BIT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_8_BIT`" ] # [ inline ( always ) ] pub fn is_8_bit ( & self ) -> bool { * self == CHSIZE_A :: _8_BIT } # [ doc = "Checks if the value of the field is `_9_BIT`" ] # [ inline ( always ) ] pub fn is_9_bit ( & self ) -> bool { * self == CHSIZE_A :: _9_BIT } } # [ doc = "Write proxy for field `CHSIZE`" ] pub struct CHSIZE_W < 'a > { w : & 'a mut W , } impl < 'a > CHSIZE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CHSIZE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 bits" ] # [ inline ( always ) ] pub fn _8_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _8_BIT ) } # [ doc = "9 bits" ] # [ inline ( always ) ] pub fn _9_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _9_BIT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } } # [ doc = "Reader of field `PLOADEN`" ] pub type PLOADEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PLOADEN`" ] pub struct PLOADEN_W < 'a > { w : & 'a mut W , } impl < 'a > PLOADEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `SSDE`" ] pub type SSDE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SSDE`" ] pub struct SSDE_W < 'a > { w : & 'a mut W , } impl < 'a > SSDE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `MSSEN`" ] pub type MSSEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MSSEN`" ] pub struct MSSEN_W < 'a > { w : & 'a mut W , } impl < 'a > MSSEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } } # [ doc = "Possible values of the field `AMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum AMODE_A { # [ doc = "SPI Address mask " ] MASK , # [ doc = "Two unique Addressess" ] _2_ADDRESSES , # [ doc = "Address Range" ] RANGE } impl crate :: ToBits < u8 > for AMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { AMODE_A :: MASK => 0 , AMODE_A :: _2_ADDRESSES => 1 , AMODE_A :: RANGE => 2 } } } # [ doc = "Reader of field `AMODE`" ] pub type AMODE_R = crate :: R < u8 , AMODE_A > ; impl AMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , AMODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( AMODE_A :: MASK ) , 1 => Val ( AMODE_A :: _2_ADDRESSES ) , 2 => Val ( AMODE_A :: RANGE ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `MASK`" ] # [ inline ( always ) ] pub fn is_mask ( & self ) -> bool { * self == AMODE_A :: MASK } # [ doc = "Checks if the value of the field is `_2_ADDRESSES`" ] # [ inline ( always ) ] pub fn is_2_addresses ( & self ) -> bool { * self == AMODE_A :: _2_ADDRESSES } # [ doc = "Checks if the value of the field is `RANGE`" ] # [ inline ( always ) ] pub fn is_range ( & self ) -> bool { * self == AMODE_A :: RANGE } } # [ doc = "Write proxy for field `AMODE`" ] pub struct AMODE_W < 'a > { w : & 'a mut W , } impl < 'a > AMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : AMODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SPI Address mask" ] # [ inline ( always ) ] pub fn mask ( self ) -> & 'a mut W { self . variant ( AMODE_A :: MASK ) } # [ doc = "Two unique Addressess" ] # [ inline ( always ) ] pub fn _2_addresses ( self ) -> & 'a mut W { self . variant ( AMODE_A :: _2_ADDRESSES ) } # [ doc = "Address Range" ] # [ inline ( always ) ] pub fn range ( self ) -> & 'a mut W { self . variant ( AMODE_A :: RANGE ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 14 ) ) | ( ( ( value as u32 ) & 0x03 ) << 14 ) ; self . w } } # [ doc = "Reader of field `RXEN`" ] pub type RXEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXEN`" ] pub struct RXEN_W < 'a > { w : & 'a mut W , } impl < 'a > RXEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - Character Size" ] # [ inline ( always ) ] pub fn chsize ( & self ) -> CHSIZE_R { CHSIZE_R :: new ( ( self . bits & 0x07 ) as u8 ) } # [ doc = "Bit 6 - Data Preload Enable" ] # [ inline ( always ) ] pub fn ploaden ( & self ) -> PLOADEN_R { PLOADEN_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Slave Select Low Detect Enable" ] # [ inline ( always ) ] pub fn ssde ( & self ) -> SSDE_R { SSDE_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - Master Slave Select Enable" ] # [ inline ( always ) ] pub fn mssen ( & self ) -> MSSEN_R { MSSEN_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bits 14:15 - Address Mode" ] # [ inline ( always ) ] pub fn amode ( & self ) -> AMODE_R { AMODE_R :: new ( ( ( self . bits >> 14 ) & 0x03 ) as u8 ) } # [ doc = "Bit 17 - Receiver Enable" ] # [ inline ( always ) ] pub fn rxen ( & self ) -> RXEN_R { RXEN_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:2 - Character Size" ] # [ inline ( always ) ] pub fn chsize ( & mut self ) -> CHSIZE_W { CHSIZE_W { w : self } } # [ doc = "Bit 6 - Data Preload Enable" ] # [ inline ( always ) ] pub fn ploaden ( & mut self ) -> PLOADEN_W { PLOADEN_W { w : self } } # [ doc = "Bit 9 - Slave Select Low Detect Enable" ] # [ inline ( always ) ] pub fn ssde ( & mut self ) -> SSDE_W { SSDE_W { w : self } } # [ doc = "Bit 13 - Master Slave Select Enable" ] # [ inline ( always ) ] pub fn mssen ( & mut self ) -> MSSEN_W { MSSEN_W { w : self } } # [ doc = "Bits 14:15 - Address Mode" ] # [ inline ( always ) ] pub fn amode ( & mut self ) -> AMODE_W { AMODE_W { w : self } } # [ doc = "Bit 17 - Receiver Enable" ] # [ inline ( always ) ] pub fn rxen ( & mut self ) -> RXEN_W { RXEN_W { w : self } } } } # [ doc = "SPIM Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud](baud) module" ] pub type BAUD = crate :: Reg < u8 , _BAUD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD ; # [ doc = "`read()` method returns [baud::R](baud::R) reader structure" ] impl crate :: Readable for BAUD { } # [ doc = "`write(|w| ..)` method takes [baud::W](baud::W) writer structure" ] impl crate :: Writable for BAUD { } # [ doc = "SPIM Baud Rate" ] pub mod baud { # [ doc = "Reader of register BAUD" ] pub type R = crate :: R < u8 , super :: BAUD > ; # [ doc = "Writer for register BAUD" ] pub type W = crate :: W < u8 , super :: BAUD > ; # [ doc = "Register BAUD `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } } } # [ doc = "SPIM Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "SPIM Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `SSL`" ] pub type SSL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SSL`" ] pub struct SSL_W < 'a > { w : & 'a mut W , } impl < 'a > SSL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt Disable" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Slave Select Low Interrupt Disable" ] # [ inline ( always ) ] pub fn ssl ( & self ) -> SSL_R { SSL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt Disable" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Slave Select Low Interrupt Disable" ] # [ inline ( always ) ] pub fn ssl ( & mut self ) -> SSL_W { SSL_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "SPIM Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "SPIM Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `SSL`" ] pub type SSL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SSL`" ] pub struct SSL_W < 'a > { w : & 'a mut W , } impl < 'a > SSL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Slave Select Low Interrupt Enable" ] # [ inline ( always ) ] pub fn ssl ( & self ) -> SSL_R { SSL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Slave Select Low Interrupt Enable" ] # [ inline ( always ) ] pub fn ssl ( & mut self ) -> SSL_W { SSL_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "SPIM Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "SPIM Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `SSL`" ] pub type SSL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SSL`" ] pub struct SSL_W < 'a > { w : & 'a mut W , } impl < 'a > SSL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Slave Select Low Interrupt Flag" ] # [ inline ( always ) ] pub fn ssl ( & self ) -> SSL_R { SSL_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Slave Select Low Interrupt Flag" ] # [ inline ( always ) ] pub fn ssl ( & mut self ) -> SSL_W { SSL_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "SPIM Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u16 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { } # [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { } # [ doc = "SPIM Status" ] pub mod status { # [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u16 , super :: STATUS > ; # [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u16 , super :: STATUS > ; # [ doc = "Register STATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BUFOVF`" ] pub type BUFOVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `BUFOVF`" ] pub struct BUFOVF_W < 'a > { w : & 'a mut W , } impl < 'a > BUFOVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } impl R { # [ doc = "Bit 2 - Buffer Overflow" ] # [ inline ( always ) ] pub fn bufovf ( & self ) -> BUFOVF_R { BUFOVF_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 2 - Buffer Overflow" ] # [ inline ( always ) ] pub fn bufovf ( & mut self ) -> BUFOVF_W { BUFOVF_W { w : self } } } } # [ doc = "SPIM Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "SPIM Synchronization Busy" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CTRLB`" ] pub type CTRLB_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Software Reset Synchronization Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - SERCOM Enable Synchronization Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - CTRLB Synchronization Busy" ] # [ inline ( always ) ] pub fn ctrlb ( & self ) -> CTRLB_R { CTRLB_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } } # [ doc = "SPIM Address\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [addr](addr) module" ] pub type ADDR = crate :: Reg < u32 , _ADDR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ADDR ; # [ doc = "`read()` method returns [addr::R](addr::R) reader structure" ] impl crate :: Readable for ADDR { } # [ doc = "`write(|w| ..)` method takes [addr::W](addr::W) writer structure" ] impl crate :: Writable for ADDR { } # [ doc = "SPIM Address" ] pub mod addr { # [ doc = "Reader of register ADDR" ] pub type R = crate :: R < u32 , super :: ADDR > ; # [ doc = "Writer for register ADDR" ] pub type W = crate :: W < u32 , super :: ADDR > ; # [ doc = "Register ADDR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ADDR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `ADDR`" ] pub type ADDR_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `ADDR`" ] pub struct ADDR_W < 'a > { w : & 'a mut W , } impl < 'a > ADDR_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u32 ) & 0xff ) ; self . w } } # [ doc = "Reader of field `ADDRMASK`" ] pub type ADDRMASK_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `ADDRMASK`" ] pub struct ADDRMASK_W < 'a > { w : & 'a mut W , } impl < 'a > ADDRMASK_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Address Value" ] # [ inline ( always ) ] pub fn addr ( & self ) -> ADDR_R { ADDR_R :: new ( ( self . bits & 0xff ) as u8 ) } # [ doc = "Bits 16:23 - Address Mask" ] # [ inline ( always ) ] pub fn addrmask ( & self ) -> ADDRMASK_R { ADDRMASK_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Address Value" ] # [ inline ( always ) ] pub fn addr ( & mut self ) -> ADDR_W { ADDR_W { w : self } } # [ doc = "Bits 16:23 - Address Mask" ] # [ inline ( always ) ] pub fn addrmask ( & mut self ) -> ADDRMASK_W { ADDRMASK_W { w : self } } } } # [ doc = "SPIM Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [data](data) module" ] pub type DATA = crate :: Reg < u32 , _DATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DATA ; # [ doc = "`read()` method returns [data::R](data::R) reader structure" ] impl crate :: Readable for DATA { } # [ doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure" ] impl crate :: Writable for DATA { } # [ doc = "SPIM Data" ] pub mod data { # [ doc = "Reader of register DATA" ] pub type R = crate :: R < u32 , super :: DATA > ; # [ doc = "Writer for register DATA" ] pub type W = crate :: W < u32 , super :: DATA > ; # [ doc = "Register DATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DATA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DATA`" ] pub type DATA_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `DATA`" ] pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01ff ) | ( ( value as u32 ) & 0x01ff ) ; self . w } } impl R { # [ doc = "Bits 0:8 - Data Value" ] # [ inline ( always ) ] pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bits 0:8 - Data Value" ] # [ inline ( always ) ] pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } } } # [ doc = "SPIM Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "SPIM Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGSTOP`" ] pub type DBGSTOP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGSTOP`" ] pub struct DBGSTOP_W < 'a > { w : & 'a mut W , } impl < 'a > DBGSTOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & self ) -> DBGSTOP_R { DBGSTOP_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & mut self ) -> DBGSTOP_W { DBGSTOP_W { w : self } } } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct USART_EXT { # [ doc = "0x00 - USART_EXT Control A" ] pub ctrla : self::usart_ext::CTRLA , # [ doc = "0x04 - USART_EXT Control B" ] pub ctrlb : self::usart_ext::CTRLB , # [ doc = "0x08 - USART_EXT Control C" ] pub ctrlc : self::usart_ext::CTRLC , _reserved_3_baud : [ u8 ; 2usize ] , # [ doc = "0x0e - USART_EXT Receive Pulse Length" ] pub rxpl : self::usart_ext::RXPL , _reserved5 : [ u8 ; 5usize ] , # [ doc = "0x14 - USART_EXT Interrupt Enable Clear" ] pub intenclr : self::usart_ext::INTENCLR , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x16 - USART_EXT Interrupt Enable Set" ] pub intenset : self::usart_ext::INTENSET , _reserved7 : [ u8 ; 1usize ] , # [ doc = "0x18 - USART_EXT Interrupt Flag Status and Clear" ] pub intflag : self::usart_ext::INTFLAG , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x1a - USART_EXT Status" ] pub status : self::usart_ext::STATUS , # [ doc = "0x1c - USART_EXT Synchronization Busy" ] pub syncbusy : self::usart_ext::SYNCBUSY , _reserved10 : [ u8 ; 8usize ] , # [ doc = "0x28 - USART_EXT Data" ] pub data : self::usart_ext::DATA , _reserved11 : [ u8 ; 6usize ] , # [ doc = "0x30 - USART_EXT Debug Control" ] pub dbgctrl : self::usart_ext::DBGCTRL , } impl USART_EXT { # [ doc = "0x0c - USART_EXT Baud Rate" ] # [ inline ( always ) ] pub fn baud_usartfp_mode ( & self ) -> & self::usart_ext::BAUD_USARTFP_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const self::usart_ext::BAUD_USARTFP_MODE ) } } # [ doc = "0x0c - USART_EXT Baud Rate" ] # [ inline ( always ) ] pub fn baud_usartfp_mode_mut ( & self ) -> & mut self::usart_ext::BAUD_USARTFP_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut self::usart_ext::BAUD_USARTFP_MODE ) } } # [ doc = "0x0c - USART_EXT Baud Rate" ] # [ inline ( always ) ] pub fn baud_fracfp_mode ( & self ) -> & self::usart_ext::BAUD_FRACFP_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const self::usart_ext::BAUD_FRACFP_MODE ) } } # [ doc = "0x0c - USART_EXT Baud Rate" ] # [ inline ( always ) ] pub fn baud_fracfp_mode_mut ( & self ) -> & mut self::usart_ext::BAUD_FRACFP_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut self::usart_ext::BAUD_FRACFP_MODE ) } } # [ doc = "0x0c - USART_EXT Baud Rate" ] # [ inline ( always ) ] pub fn baud_frac_mode ( & self ) -> & self::usart_ext::BAUD_FRAC_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const self::usart_ext::BAUD_FRAC_MODE ) } } # [ doc = "0x0c - USART_EXT Baud Rate" ] # [ inline ( always ) ] pub fn baud_frac_mode_mut ( & self ) -> & mut self::usart_ext::BAUD_FRAC_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut self::usart_ext::BAUD_FRAC_MODE ) } } # [ doc = "0x0c - USART_EXT Baud Rate" ] # [ inline ( always ) ] pub fn baud ( & self ) -> & self::usart_ext::BAUD { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const self::usart_ext::BAUD ) } } # [ doc = "0x0c - USART_EXT Baud Rate" ] # [ inline ( always ) ] pub fn baud_mut ( & self ) -> & mut self::usart_ext::BAUD { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut self::usart_ext::BAUD ) } } } # [ doc = r"Register block" ] # [ doc = "USART EXTERNAL CLOCK Mode" ] pub mod usart_ext { # [ doc = "USART_EXT Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "USART_EXT Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "USART with external clock" ] USART_EXT_CLK , # [ doc = "USART with internal clock" ] USART_INT_CLK , # [ doc = "SPI in slave operation" ] SPI_SLAVE , # [ doc = "SPI in master operation" ] SPI_MASTER , # [ doc = "I2C slave operation" ] I2C_SLAVE , # [ doc = "I2C master operation" ] I2C_MASTER } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: USART_EXT_CLK => 0 , MODE_A :: USART_INT_CLK => 1 , MODE_A :: SPI_SLAVE => 2 , MODE_A :: SPI_MASTER => 3 , MODE_A :: I2C_SLAVE => 4 , MODE_A :: I2C_MASTER => 5 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: USART_EXT_CLK ) , 1 => Val ( MODE_A :: USART_INT_CLK ) , 2 => Val ( MODE_A :: SPI_SLAVE ) , 3 => Val ( MODE_A :: SPI_MASTER ) , 4 => Val ( MODE_A :: I2C_SLAVE ) , 5 => Val ( MODE_A :: I2C_MASTER ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `USART_EXT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_ext_clk ( & self ) -> bool { * self == MODE_A :: USART_EXT_CLK } # [ doc = "Checks if the value of the field is `USART_INT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_int_clk ( & self ) -> bool { * self == MODE_A :: USART_INT_CLK } # [ doc = "Checks if the value of the field is `SPI_SLAVE`" ] # [ inline ( always ) ] pub fn is_spi_slave ( & self ) -> bool { * self == MODE_A :: SPI_SLAVE } # [ doc = "Checks if the value of the field is `SPI_MASTER`" ] # [ inline ( always ) ] pub fn is_spi_master ( & self ) -> bool { * self == MODE_A :: SPI_MASTER } # [ doc = "Checks if the value of the field is `I2C_SLAVE`" ] # [ inline ( always ) ] pub fn is_i2c_slave ( & self ) -> bool { * self == MODE_A :: I2C_SLAVE } # [ doc = "Checks if the value of the field is `I2C_MASTER`" ] # [ inline ( always ) ] pub fn is_i2c_master ( & self ) -> bool { * self == MODE_A :: I2C_MASTER } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "USART with external clock" ] # [ inline ( always ) ] pub fn usart_ext_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_EXT_CLK ) } # [ doc = "USART with internal clock" ] # [ inline ( always ) ] pub fn usart_int_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_INT_CLK ) } # [ doc = "SPI in slave operation" ] # [ inline ( always ) ] pub fn spi_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_SLAVE ) } # [ doc = "SPI in master operation" ] # [ inline ( always ) ] pub fn spi_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_MASTER ) } # [ doc = "I2C slave operation" ] # [ inline ( always ) ] pub fn i2c_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_SLAVE ) } # [ doc = "I2C master operation" ] # [ inline ( always ) ] pub fn i2c_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_MASTER ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 2 ) ) | ( ( ( value as u32 ) & 0x07 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `IBON`" ] pub type IBON_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `IBON`" ] pub struct IBON_W < 'a > { w : & 'a mut W , } impl < 'a > IBON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Possible values of the field `SAMPR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SAMPR_A { # [ doc = "16x over-sampling using arithmetic baudrate generation" ] _16X_ARITHMETIC , # [ doc = "16x over-sampling using fractional baudrate generation" ] _16X_FRACTIONAL , # [ doc = "8x over-sampling using arithmetic baudrate generation" ] _8X_ARITHMETIC , # [ doc = "8x over-sampling using fractional baudrate generation" ] _8X_FRACTIONAL , # [ doc = "3x over-sampling using arithmetic baudrate generation" ] _3X_ARITHMETIC } impl crate :: ToBits < u8 > for SAMPR_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SAMPR_A :: _16X_ARITHMETIC => 0 , SAMPR_A :: _16X_FRACTIONAL => 1 , SAMPR_A :: _8X_ARITHMETIC => 2 , SAMPR_A :: _8X_FRACTIONAL => 3 , SAMPR_A :: _3X_ARITHMETIC => 4 } } } # [ doc = "Reader of field `SAMPR`" ] pub type SAMPR_R = crate :: R < u8 , SAMPR_A > ; impl SAMPR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SAMPR_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SAMPR_A :: _16X_ARITHMETIC ) , 1 => Val ( SAMPR_A :: _16X_FRACTIONAL ) , 2 => Val ( SAMPR_A :: _8X_ARITHMETIC ) , 3 => Val ( SAMPR_A :: _8X_FRACTIONAL ) , 4 => Val ( SAMPR_A :: _3X_ARITHMETIC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_16X_ARITHMETIC`" ] # [ inline ( always ) ] pub fn is_16x_arithmetic ( & self ) -> bool { * self == SAMPR_A :: _16X_ARITHMETIC } # [ doc = "Checks if the value of the field is `_16X_FRACTIONAL`" ] # [ inline ( always ) ] pub fn is_16x_fractional ( & self ) -> bool { * self == SAMPR_A :: _16X_FRACTIONAL } # [ doc = "Checks if the value of the field is `_8X_ARITHMETIC`" ] # [ inline ( always ) ] pub fn is_8x_arithmetic ( & self ) -> bool { * self == SAMPR_A :: _8X_ARITHMETIC } # [ doc = "Checks if the value of the field is `_8X_FRACTIONAL`" ] # [ inline ( always ) ] pub fn is_8x_fractional ( & self ) -> bool { * self == SAMPR_A :: _8X_FRACTIONAL } # [ doc = "Checks if the value of the field is `_3X_ARITHMETIC`" ] # [ inline ( always ) ] pub fn is_3x_arithmetic ( & self ) -> bool { * self == SAMPR_A :: _3X_ARITHMETIC } } # [ doc = "Write proxy for field `SAMPR`" ] pub struct SAMPR_W < 'a > { w : & 'a mut W , } impl < 'a > SAMPR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SAMPR_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "16x over-sampling using arithmetic baudrate generation" ] # [ inline ( always ) ] pub fn _16x_arithmetic ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _16X_ARITHMETIC ) } # [ doc = "16x over-sampling using fractional baudrate generation" ] # [ inline ( always ) ] pub fn _16x_fractional ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _16X_FRACTIONAL ) } # [ doc = "8x over-sampling using arithmetic baudrate generation" ] # [ inline ( always ) ] pub fn _8x_arithmetic ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _8X_ARITHMETIC ) } # [ doc = "8x over-sampling using fractional baudrate generation" ] # [ inline ( always ) ] pub fn _8x_fractional ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _8X_FRACTIONAL ) } # [ doc = "3x over-sampling using arithmetic baudrate generation" ] # [ inline ( always ) ] pub fn _3x_arithmetic ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _3X_ARITHMETIC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 13 ) ) | ( ( ( value as u32 ) & 0x07 ) << 13 ) ; self . w } } # [ doc = "Possible values of the field `TXPO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TXPO_A { # [ doc = "SERCOM PAD\\[0\\] is used for data transmission" ] PAD0 , # [ doc = "SERCOM PAD\\[2\\] is used for data transmission" ] PAD2 } impl crate :: ToBits < u8 > for TXPO_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { TXPO_A :: PAD0 => 0 , TXPO_A :: PAD2 => 1 } } } # [ doc = "Reader of field `TXPO`" ] pub type TXPO_R = crate :: R < u8 , TXPO_A > ; impl TXPO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , TXPO_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TXPO_A :: PAD0 ) , 1 => Val ( TXPO_A :: PAD2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PAD0`" ] # [ inline ( always ) ] pub fn is_pad0 ( & self ) -> bool { * self == TXPO_A :: PAD0 } # [ doc = "Checks if the value of the field is `PAD2`" ] # [ inline ( always ) ] pub fn is_pad2 ( & self ) -> bool { * self == TXPO_A :: PAD2 } } # [ doc = "Write proxy for field `TXPO`" ] pub struct TXPO_W < 'a > { w : & 'a mut W , } impl < 'a > TXPO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TXPO_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SERCOM PAD\\[0\\] is used for data transmission" ] # [ inline ( always ) ] pub fn pad0 ( self ) -> & 'a mut W { self . variant ( TXPO_A :: PAD0 ) } # [ doc = "SERCOM PAD\\[2\\] is used for data transmission" ] # [ inline ( always ) ] pub fn pad2 ( self ) -> & 'a mut W { self . variant ( TXPO_A :: PAD2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 16 ) ) | ( ( ( value as u32 ) & 0x03 ) << 16 ) ; self . w } } # [ doc = "Possible values of the field `RXPO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXPO_A { # [ doc = "SERCOM PAD\\[0\\] is used for data reception" ] PAD0 , # [ doc = "SERCOM PAD\\[1\\] is used for data reception" ] PAD1 , # [ doc = "SERCOM PAD\\[2\\] is used for data reception" ] PAD2 , # [ doc = "SERCOM PAD\\[3\\] is used for data reception" ] PAD3 } impl crate :: ToBits < u8 > for RXPO_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { RXPO_A :: PAD0 => 0 , RXPO_A :: PAD1 => 1 , RXPO_A :: PAD2 => 2 , RXPO_A :: PAD3 => 3 } } } # [ doc = "Reader of field `RXPO`" ] pub type RXPO_R = crate :: R < u8 , RXPO_A > ; impl RXPO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RXPO_A { match self . bits { 0 => RXPO_A :: PAD0 , 1 => RXPO_A :: PAD1 , 2 => RXPO_A :: PAD2 , 3 => RXPO_A :: PAD3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `PAD0`" ] # [ inline ( always ) ] pub fn is_pad0 ( & self ) -> bool { * self == RXPO_A :: PAD0 } # [ doc = "Checks if the value of the field is `PAD1`" ] # [ inline ( always ) ] pub fn is_pad1 ( & self ) -> bool { * self == RXPO_A :: PAD1 } # [ doc = "Checks if the value of the field is `PAD2`" ] # [ inline ( always ) ] pub fn is_pad2 ( & self ) -> bool { * self == RXPO_A :: PAD2 } # [ doc = "Checks if the value of the field is `PAD3`" ] # [ inline ( always ) ] pub fn is_pad3 ( & self ) -> bool { * self == RXPO_A :: PAD3 } } # [ doc = "Write proxy for field `RXPO`" ] pub struct RXPO_W < 'a > { w : & 'a mut W , } impl < 'a > RXPO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RXPO_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "SERCOM PAD\\[0\\] is used for data reception" ] # [ inline ( always ) ] pub fn pad0 ( self ) -> & 'a mut W { self . variant ( RXPO_A :: PAD0 ) } # [ doc = "SERCOM PAD\\[1\\] is used for data reception" ] # [ inline ( always ) ] pub fn pad1 ( self ) -> & 'a mut W { self . variant ( RXPO_A :: PAD1 ) } # [ doc = "SERCOM PAD\\[2\\] is used for data reception" ] # [ inline ( always ) ] pub fn pad2 ( self ) -> & 'a mut W { self . variant ( RXPO_A :: PAD2 ) } # [ doc = "SERCOM PAD\\[3\\] is used for data reception" ] # [ inline ( always ) ] pub fn pad3 ( self ) -> & 'a mut W { self . variant ( RXPO_A :: PAD3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 20 ) ) | ( ( ( value as u32 ) & 0x03 ) << 20 ) ; self . w } } # [ doc = "Reader of field `SAMPA`" ] pub type SAMPA_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `SAMPA`" ] pub struct SAMPA_W < 'a > { w : & 'a mut W , } impl < 'a > SAMPA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 22 ) ) | ( ( ( value as u32 ) & 0x03 ) << 22 ) ; self . w } } # [ doc = "Possible values of the field `FORM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FORM_A { # [ doc = "USART frame" ] USART_FRAME_NO_PARITY , # [ doc = "USART frame with parity" ] USART_FRAME_WITH_PARITY , # [ doc = "LIN Master - Break and sync generation" ] USART_FRAME_LIN_MASTER_MODE , # [ doc = "Auto-baud - break detection and auto-baud" ] USART_FRAME_AUTO_BAUD_NO_PARITY , # [ doc = "Auto-baud - break detection and auto-baud with parity" ] USART_FRAME_AUTO_BAUD_WITH_PARITY } impl crate :: ToBits < u8 > for FORM_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { FORM_A :: USART_FRAME_NO_PARITY => 0 , FORM_A :: USART_FRAME_WITH_PARITY => 1 , FORM_A :: USART_FRAME_LIN_MASTER_MODE => 2 , FORM_A :: USART_FRAME_AUTO_BAUD_NO_PARITY => 4 , FORM_A :: USART_FRAME_AUTO_BAUD_WITH_PARITY => 5 } } } # [ doc = "Reader of field `FORM`" ] pub type FORM_R = crate :: R < u8 , FORM_A > ; impl FORM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , FORM_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( FORM_A :: USART_FRAME_NO_PARITY ) , 1 => Val ( FORM_A :: USART_FRAME_WITH_PARITY ) , 2 => Val ( FORM_A :: USART_FRAME_LIN_MASTER_MODE ) , 4 => Val ( FORM_A :: USART_FRAME_AUTO_BAUD_NO_PARITY ) , 5 => Val ( FORM_A :: USART_FRAME_AUTO_BAUD_WITH_PARITY ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `USART_FRAME_NO_PARITY`" ] # [ inline ( always ) ] pub fn is_usart_frame_no_parity ( & self ) -> bool { * self == FORM_A :: USART_FRAME_NO_PARITY } # [ doc = "Checks if the value of the field is `USART_FRAME_WITH_PARITY`" ] # [ inline ( always ) ] pub fn is_usart_frame_with_parity ( & self ) -> bool { * self == FORM_A :: USART_FRAME_WITH_PARITY } # [ doc = "Checks if the value of the field is `USART_FRAME_LIN_MASTER_MODE`" ] # [ inline ( always ) ] pub fn is_usart_frame_lin_master_mode ( & self ) -> bool { * self == FORM_A :: USART_FRAME_LIN_MASTER_MODE } # [ doc = "Checks if the value of the field is `USART_FRAME_AUTO_BAUD_NO_PARITY`" ] # [ inline ( always ) ] pub fn is_usart_frame_auto_baud_no_parity ( & self ) -> bool { * self == FORM_A :: USART_FRAME_AUTO_BAUD_NO_PARITY } # [ doc = "Checks if the value of the field is `USART_FRAME_AUTO_BAUD_WITH_PARITY`" ] # [ inline ( always ) ] pub fn is_usart_frame_auto_baud_with_parity ( & self ) -> bool { * self == FORM_A :: USART_FRAME_AUTO_BAUD_WITH_PARITY } } # [ doc = "Write proxy for field `FORM`" ] pub struct FORM_W < 'a > { w : & 'a mut W , } impl < 'a > FORM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FORM_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "USART frame" ] # [ inline ( always ) ] pub fn usart_frame_no_parity ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_NO_PARITY ) } # [ doc = "USART frame with parity" ] # [ inline ( always ) ] pub fn usart_frame_with_parity ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_WITH_PARITY ) } # [ doc = "LIN Master - Break and sync generation" ] # [ inline ( always ) ] pub fn usart_frame_lin_master_mode ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_LIN_MASTER_MODE ) } # [ doc = "Auto-baud - break detection and auto-baud" ] # [ inline ( always ) ] pub fn usart_frame_auto_baud_no_parity ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_AUTO_BAUD_NO_PARITY ) } # [ doc = "Auto-baud - break detection and auto-baud with parity" ] # [ inline ( always ) ] pub fn usart_frame_auto_baud_with_parity ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_AUTO_BAUD_WITH_PARITY ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } } # [ doc = "Possible values of the field `CMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMODE_A { # [ doc = "Asynchronous Communication" ] ASYNC , # [ doc = "Synchronous Communication" ] SYNC } impl crate :: ToBits < bool > for CMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CMODE_A :: ASYNC => false , CMODE_A :: SYNC => true } } } # [ doc = "Reader of field `CMODE`" ] pub type CMODE_R = crate :: R < bool , CMODE_A > ; impl CMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CMODE_A { match self . bits { false => CMODE_A :: ASYNC , true => CMODE_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == CMODE_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == CMODE_A :: SYNC } } # [ doc = "Write proxy for field `CMODE`" ] pub struct CMODE_W < 'a > { w : & 'a mut W , } impl < 'a > CMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMODE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Asynchronous Communication" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( CMODE_A :: ASYNC ) } # [ doc = "Synchronous Communication" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( CMODE_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } } # [ doc = "Possible values of the field `CPOL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPOL_A { # [ doc = "TxD Change:- Rising XCK edge, RxD Sample:- Falling XCK edge" ] IDLE_LOW , # [ doc = "TxD Change:- Falling XCK edge, RxD Sample:- Rising XCK edge" ] IDLE_HIGH } impl crate :: ToBits < bool > for CPOL_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CPOL_A :: IDLE_LOW => false , CPOL_A :: IDLE_HIGH => true } } } # [ doc = "Reader of field `CPOL`" ] pub type CPOL_R = crate :: R < bool , CPOL_A > ; impl CPOL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPOL_A { match self . bits { false => CPOL_A :: IDLE_LOW , true => CPOL_A :: IDLE_HIGH } } # [ doc = "Checks if the value of the field is `IDLE_LOW`" ] # [ inline ( always ) ] pub fn is_idle_low ( & self ) -> bool { * self == CPOL_A :: IDLE_LOW } # [ doc = "Checks if the value of the field is `IDLE_HIGH`" ] # [ inline ( always ) ] pub fn is_idle_high ( & self ) -> bool { * self == CPOL_A :: IDLE_HIGH } } # [ doc = "Write proxy for field `CPOL`" ] pub struct CPOL_W < 'a > { w : & 'a mut W , } impl < 'a > CPOL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPOL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "TxD Change:- Rising XCK edge, RxD Sample:- Falling XCK edge" ] # [ inline ( always ) ] pub fn idle_low ( self ) -> & 'a mut W { self . variant ( CPOL_A :: IDLE_LOW ) } # [ doc = "TxD Change:- Falling XCK edge, RxD Sample:- Rising XCK edge" ] # [ inline ( always ) ] pub fn idle_high ( self ) -> & 'a mut W { self . variant ( CPOL_A :: IDLE_HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } } # [ doc = "Possible values of the field `DORD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DORD_A { # [ doc = "MSB is transmitted first" ] MSB , # [ doc = "LSB is transmitted first" ] LSB } impl crate :: ToBits < bool > for DORD_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { DORD_A :: MSB => false , DORD_A :: LSB => true } } } # [ doc = "Reader of field `DORD`" ] pub type DORD_R = crate :: R < bool , DORD_A > ; impl DORD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DORD_A { match self . bits { false => DORD_A :: MSB , true => DORD_A :: LSB } } # [ doc = "Checks if the value of the field is `MSB`" ] # [ inline ( always ) ] pub fn is_msb ( & self ) -> bool { * self == DORD_A :: MSB } # [ doc = "Checks if the value of the field is `LSB`" ] # [ inline ( always ) ] pub fn is_lsb ( & self ) -> bool { * self == DORD_A :: LSB } } # [ doc = "Write proxy for field `DORD`" ] pub struct DORD_W < 'a > { w : & 'a mut W , } impl < 'a > DORD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DORD_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "MSB is transmitted first" ] # [ inline ( always ) ] pub fn msb ( self ) -> & 'a mut W { self . variant ( DORD_A :: MSB ) } # [ doc = "LSB is transmitted first" ] # [ inline ( always ) ] pub fn lsb ( self ) -> & 'a mut W { self . variant ( DORD_A :: LSB ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x07 ) as u8 ) } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Immediate Buffer Overflow Notification" ] # [ inline ( always ) ] pub fn ibon ( & self ) -> IBON_R { IBON_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bits 13:15 - Sample" ] # [ inline ( always ) ] pub fn sampr ( & self ) -> SAMPR_R { SAMPR_R :: new ( ( ( self . bits >> 13 ) & 0x07 ) as u8 ) } # [ doc = "Bits 16:17 - Transmit Data Pinout" ] # [ inline ( always ) ] pub fn txpo ( & self ) -> TXPO_R { TXPO_R :: new ( ( ( self . bits >> 16 ) & 0x03 ) as u8 ) } # [ doc = "Bits 20:21 - Receive Data Pinout" ] # [ inline ( always ) ] pub fn rxpo ( & self ) -> RXPO_R { RXPO_R :: new ( ( ( self . bits >> 20 ) & 0x03 ) as u8 ) } # [ doc = "Bits 22:23 - Sample Adjustment" ] # [ inline ( always ) ] pub fn sampa ( & self ) -> SAMPA_R { SAMPA_R :: new ( ( ( self . bits >> 22 ) & 0x03 ) as u8 ) } # [ doc = "Bits 24:27 - Frame Format" ] # [ inline ( always ) ] pub fn form ( & self ) -> FORM_R { FORM_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) } # [ doc = "Bit 28 - Communication Mode" ] # [ inline ( always ) ] pub fn cmode ( & self ) -> CMODE_R { CMODE_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - Clock Polarity" ] # [ inline ( always ) ] pub fn cpol ( & self ) -> CPOL_R { CPOL_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - Data Order" ] # [ inline ( always ) ] pub fn dord ( & self ) -> DORD_R { DORD_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } } # [ doc = "Bit 8 - Immediate Buffer Overflow Notification" ] # [ inline ( always ) ] pub fn ibon ( & mut self ) -> IBON_W { IBON_W { w : self } } # [ doc = "Bits 13:15 - Sample" ] # [ inline ( always ) ] pub fn sampr ( & mut self ) -> SAMPR_W { SAMPR_W { w : self } } # [ doc = "Bits 16:17 - Transmit Data Pinout" ] # [ inline ( always ) ] pub fn txpo ( & mut self ) -> TXPO_W { TXPO_W { w : self } } # [ doc = "Bits 20:21 - Receive Data Pinout" ] # [ inline ( always ) ] pub fn rxpo ( & mut self ) -> RXPO_W { RXPO_W { w : self } } # [ doc = "Bits 22:23 - Sample Adjustment" ] # [ inline ( always ) ] pub fn sampa ( & mut self ) -> SAMPA_W { SAMPA_W { w : self } } # [ doc = "Bits 24:27 - Frame Format" ] # [ inline ( always ) ] pub fn form ( & mut self ) -> FORM_W { FORM_W { w : self } } # [ doc = "Bit 28 - Communication Mode" ] # [ inline ( always ) ] pub fn cmode ( & mut self ) -> CMODE_W { CMODE_W { w : self } } # [ doc = "Bit 29 - Clock Polarity" ] # [ inline ( always ) ] pub fn cpol ( & mut self ) -> CPOL_W { CPOL_W { w : self } } # [ doc = "Bit 30 - Data Order" ] # [ inline ( always ) ] pub fn dord ( & mut self ) -> DORD_W { DORD_W { w : self } } } } # [ doc = "USART_EXT Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u32 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ; # [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { } # [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { } # [ doc = "USART_EXT Control B" ] pub mod ctrlb { # [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u32 , super :: CTRLB > ; # [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u32 , super :: CTRLB > ; # [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `CHSIZE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CHSIZE_A { # [ doc = "8 Bits" ] _8_BIT , # [ doc = "9 Bits" ] _9_BIT , # [ doc = "5 Bits" ] _5_BIT , # [ doc = "6 Bits" ] _6_BIT , # [ doc = "7 Bits" ] _7_BIT } impl crate :: ToBits < u8 > for CHSIZE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CHSIZE_A :: _8_BIT => 0 , CHSIZE_A :: _9_BIT => 1 , CHSIZE_A :: _5_BIT => 5 , CHSIZE_A :: _6_BIT => 6 , CHSIZE_A :: _7_BIT => 7 } } } # [ doc = "Reader of field `CHSIZE`" ] pub type CHSIZE_R = crate :: R < u8 , CHSIZE_A > ; impl CHSIZE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CHSIZE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CHSIZE_A :: _8_BIT ) , 1 => Val ( CHSIZE_A :: _9_BIT ) , 5 => Val ( CHSIZE_A :: _5_BIT ) , 6 => Val ( CHSIZE_A :: _6_BIT ) , 7 => Val ( CHSIZE_A :: _7_BIT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_8_BIT`" ] # [ inline ( always ) ] pub fn is_8_bit ( & self ) -> bool { * self == CHSIZE_A :: _8_BIT } # [ doc = "Checks if the value of the field is `_9_BIT`" ] # [ inline ( always ) ] pub fn is_9_bit ( & self ) -> bool { * self == CHSIZE_A :: _9_BIT } # [ doc = "Checks if the value of the field is `_5_BIT`" ] # [ inline ( always ) ] pub fn is_5_bit ( & self ) -> bool { * self == CHSIZE_A :: _5_BIT } # [ doc = "Checks if the value of the field is `_6_BIT`" ] # [ inline ( always ) ] pub fn is_6_bit ( & self ) -> bool { * self == CHSIZE_A :: _6_BIT } # [ doc = "Checks if the value of the field is `_7_BIT`" ] # [ inline ( always ) ] pub fn is_7_bit ( & self ) -> bool { * self == CHSIZE_A :: _7_BIT } } # [ doc = "Write proxy for field `CHSIZE`" ] pub struct CHSIZE_W < 'a > { w : & 'a mut W , } impl < 'a > CHSIZE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CHSIZE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 Bits" ] # [ inline ( always ) ] pub fn _8_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _8_BIT ) } # [ doc = "9 Bits" ] # [ inline ( always ) ] pub fn _9_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _9_BIT ) } # [ doc = "5 Bits" ] # [ inline ( always ) ] pub fn _5_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _5_BIT ) } # [ doc = "6 Bits" ] # [ inline ( always ) ] pub fn _6_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _6_BIT ) } # [ doc = "7 Bits" ] # [ inline ( always ) ] pub fn _7_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _7_BIT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } } # [ doc = "Possible values of the field `SBMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SBMODE_A { # [ doc = "One Stop Bit" ] _1_BIT , # [ doc = "Two Stop Bits" ] _2_BIT } impl crate :: ToBits < bool > for SBMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { SBMODE_A :: _1_BIT => false , SBMODE_A :: _2_BIT => true } } } # [ doc = "Reader of field `SBMODE`" ] pub type SBMODE_R = crate :: R < bool , SBMODE_A > ; impl SBMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SBMODE_A { match self . bits { false => SBMODE_A :: _1_BIT , true => SBMODE_A :: _2_BIT } } # [ doc = "Checks if the value of the field is `_1_BIT`" ] # [ inline ( always ) ] pub fn is_1_bit ( & self ) -> bool { * self == SBMODE_A :: _1_BIT } # [ doc = "Checks if the value of the field is `_2_BIT`" ] # [ inline ( always ) ] pub fn is_2_bit ( & self ) -> bool { * self == SBMODE_A :: _2_BIT } } # [ doc = "Write proxy for field `SBMODE`" ] pub struct SBMODE_W < 'a > { w : & 'a mut W , } impl < 'a > SBMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SBMODE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "One Stop Bit" ] # [ inline ( always ) ] pub fn _1_bit ( self ) -> & 'a mut W { self . variant ( SBMODE_A :: _1_BIT ) } # [ doc = "Two Stop Bits" ] # [ inline ( always ) ] pub fn _2_bit ( self ) -> & 'a mut W { self . variant ( SBMODE_A :: _2_BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `COLDEN`" ] pub type COLDEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COLDEN`" ] pub struct COLDEN_W < 'a > { w : & 'a mut W , } impl < 'a > COLDEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `SFDE`" ] pub type SFDE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SFDE`" ] pub struct SFDE_W < 'a > { w : & 'a mut W , } impl < 'a > SFDE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `ENC`" ] pub type ENC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENC`" ] pub struct ENC_W < 'a > { w : & 'a mut W , } impl < 'a > ENC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } } # [ doc = "Possible values of the field `PMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMODE_A { # [ doc = "Even Parity" ] EVEN , # [ doc = "Odd Parity" ] ODD } impl crate :: ToBits < bool > for PMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { PMODE_A :: EVEN => false , PMODE_A :: ODD => true } } } # [ doc = "Reader of field `PMODE`" ] pub type PMODE_R = crate :: R < bool , PMODE_A > ; impl PMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMODE_A { match self . bits { false => PMODE_A :: EVEN , true => PMODE_A :: ODD } } # [ doc = "Checks if the value of the field is `EVEN`" ] # [ inline ( always ) ] pub fn is_even ( & self ) -> bool { * self == PMODE_A :: EVEN } # [ doc = "Checks if the value of the field is `ODD`" ] # [ inline ( always ) ] pub fn is_odd ( & self ) -> bool { * self == PMODE_A :: ODD } } # [ doc = "Write proxy for field `PMODE`" ] pub struct PMODE_W < 'a > { w : & 'a mut W , } impl < 'a > PMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMODE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Even Parity" ] # [ inline ( always ) ] pub fn even ( self ) -> & 'a mut W { self . variant ( PMODE_A :: EVEN ) } # [ doc = "Odd Parity" ] # [ inline ( always ) ] pub fn odd ( self ) -> & 'a mut W { self . variant ( PMODE_A :: ODD ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } } # [ doc = "Reader of field `TXEN`" ] pub type TXEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXEN`" ] pub struct TXEN_W < 'a > { w : & 'a mut W , } impl < 'a > TXEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `RXEN`" ] pub type RXEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXEN`" ] pub struct RXEN_W < 'a > { w : & 'a mut W , } impl < 'a > RXEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Reader of field `LINCMD`" ] pub type LINCMD_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `LINCMD`" ] pub struct LINCMD_W < 'a > { w : & 'a mut W , } impl < 'a > LINCMD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 24 ) ) | ( ( ( value as u32 ) & 0x03 ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - Character Size" ] # [ inline ( always ) ] pub fn chsize ( & self ) -> CHSIZE_R { CHSIZE_R :: new ( ( self . bits & 0x07 ) as u8 ) } # [ doc = "Bit 6 - Stop Bit Mode" ] # [ inline ( always ) ] pub fn sbmode ( & self ) -> SBMODE_R { SBMODE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Collision Detection Enable" ] # [ inline ( always ) ] pub fn colden ( & self ) -> COLDEN_R { COLDEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Start of Frame Detection Enable" ] # [ inline ( always ) ] pub fn sfde ( & self ) -> SFDE_R { SFDE_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - Encoding Format" ] # [ inline ( always ) ] pub fn enc ( & self ) -> ENC_R { ENC_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - Parity Mode" ] # [ inline ( always ) ] pub fn pmode ( & self ) -> PMODE_R { PMODE_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - Transmitter Enable" ] # [ inline ( always ) ] pub fn txen ( & self ) -> TXEN_R { TXEN_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - Receiver Enable" ] # [ inline ( always ) ] pub fn rxen ( & self ) -> RXEN_R { RXEN_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bits 24:25 - LIN Command" ] # [ inline ( always ) ] pub fn lincmd ( & self ) -> LINCMD_R { LINCMD_R :: new ( ( ( self . bits >> 24 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:2 - Character Size" ] # [ inline ( always ) ] pub fn chsize ( & mut self ) -> CHSIZE_W { CHSIZE_W { w : self } } # [ doc = "Bit 6 - Stop Bit Mode" ] # [ inline ( always ) ] pub fn sbmode ( & mut self ) -> SBMODE_W { SBMODE_W { w : self } } # [ doc = "Bit 8 - Collision Detection Enable" ] # [ inline ( always ) ] pub fn colden ( & mut self ) -> COLDEN_W { COLDEN_W { w : self } } # [ doc = "Bit 9 - Start of Frame Detection Enable" ] # [ inline ( always ) ] pub fn sfde ( & mut self ) -> SFDE_W { SFDE_W { w : self } } # [ doc = "Bit 10 - Encoding Format" ] # [ inline ( always ) ] pub fn enc ( & mut self ) -> ENC_W { ENC_W { w : self } } # [ doc = "Bit 13 - Parity Mode" ] # [ inline ( always ) ] pub fn pmode ( & mut self ) -> PMODE_W { PMODE_W { w : self } } # [ doc = "Bit 16 - Transmitter Enable" ] # [ inline ( always ) ] pub fn txen ( & mut self ) -> TXEN_W { TXEN_W { w : self } } # [ doc = "Bit 17 - Receiver Enable" ] # [ inline ( always ) ] pub fn rxen ( & mut self ) -> RXEN_W { RXEN_W { w : self } } # [ doc = "Bits 24:25 - LIN Command" ] # [ inline ( always ) ] pub fn lincmd ( & mut self ) -> LINCMD_W { LINCMD_W { w : self } } } } # [ doc = "USART_EXT Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlc](ctrlc) module" ] pub type CTRLC = crate :: Reg < u32 , _CTRLC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLC ; # [ doc = "`read()` method returns [ctrlc::R](ctrlc::R) reader structure" ] impl crate :: Readable for CTRLC { } # [ doc = "`write(|w| ..)` method takes [ctrlc::W](ctrlc::W) writer structure" ] impl crate :: Writable for CTRLC { } # [ doc = "USART_EXT Control C" ] pub mod ctrlc { # [ doc = "Reader of register CTRLC" ] pub type R = crate :: R < u32 , super :: CTRLC > ; # [ doc = "Writer for register CTRLC" ] pub type W = crate :: W < u32 , super :: CTRLC > ; # [ doc = "Register CTRLC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `GTIME`" ] pub type GTIME_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `GTIME`" ] pub struct GTIME_W < 'a > { w : & 'a mut W , } impl < 'a > GTIME_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } } # [ doc = "Reader of field `BRKLEN`" ] pub type BRKLEN_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `BRKLEN`" ] pub struct BRKLEN_W < 'a > { w : & 'a mut W , } impl < 'a > BRKLEN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } } # [ doc = "Reader of field `HDRDLY`" ] pub type HDRDLY_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `HDRDLY`" ] pub struct HDRDLY_W < 'a > { w : & 'a mut W , } impl < 'a > HDRDLY_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u32 ) & 0x03 ) << 10 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - RS485 Guard Time" ] # [ inline ( always ) ] pub fn gtime ( & self ) -> GTIME_R { GTIME_R :: new ( ( self . bits & 0x07 ) as u8 ) } # [ doc = "Bits 8:9 - LIN Master Break Length" ] # [ inline ( always ) ] pub fn brklen ( & self ) -> BRKLEN_R { BRKLEN_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) } # [ doc = "Bits 10:11 - LIN Master Header Delay" ] # [ inline ( always ) ] pub fn hdrdly ( & self ) -> HDRDLY_R { HDRDLY_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:2 - RS485 Guard Time" ] # [ inline ( always ) ] pub fn gtime ( & mut self ) -> GTIME_W { GTIME_W { w : self } } # [ doc = "Bits 8:9 - LIN Master Break Length" ] # [ inline ( always ) ] pub fn brklen ( & mut self ) -> BRKLEN_W { BRKLEN_W { w : self } } # [ doc = "Bits 10:11 - LIN Master Header Delay" ] # [ inline ( always ) ] pub fn hdrdly ( & mut self ) -> HDRDLY_W { HDRDLY_W { w : self } } } } # [ doc = "USART_EXT Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud](baud) module" ] pub type BAUD = crate :: Reg < u16 , _BAUD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD ; # [ doc = "`read()` method returns [baud::R](baud::R) reader structure" ] impl crate :: Readable for BAUD { } # [ doc = "`write(|w| ..)` method takes [baud::W](baud::W) writer structure" ] impl crate :: Writable for BAUD { } # [ doc = "USART_EXT Baud Rate" ] pub mod baud { # [ doc = "Reader of register BAUD" ] pub type R = crate :: R < u16 , super :: BAUD > ; # [ doc = "Writer for register BAUD" ] pub type W = crate :: W < u16 , super :: BAUD > ; # [ doc = "Register BAUD `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } } } # [ doc = "USART_EXT Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud_frac_mode](baud_frac_mode) module" ] pub type BAUD_FRAC_MODE = crate :: Reg < u16 , _BAUD_FRAC_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD_FRAC_MODE ; # [ doc = "`read()` method returns [baud_frac_mode::R](baud_frac_mode::R) reader structure" ] impl crate :: Readable for BAUD_FRAC_MODE { } # [ doc = "`write(|w| ..)` method takes [baud_frac_mode::W](baud_frac_mode::W) writer structure" ] impl crate :: Writable for BAUD_FRAC_MODE { } # [ doc = "USART_EXT Baud Rate" ] pub mod baud_frac_mode { # [ doc = "Reader of register BAUD_FRAC_MODE" ] pub type R = crate :: R < u16 , super :: BAUD_FRAC_MODE > ; # [ doc = "Writer for register BAUD_FRAC_MODE" ] pub type W = crate :: W < u16 , super :: BAUD_FRAC_MODE > ; # [ doc = "Register BAUD_FRAC_MODE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD_FRAC_MODE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1fff ) | ( ( value as u16 ) & 0x1fff ) ; self . w } } # [ doc = "Reader of field `FP`" ] pub type FP_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `FP`" ] pub struct FP_W < 'a > { w : & 'a mut W , } impl < 'a > FP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 13 ) ) | ( ( ( value as u16 ) & 0x07 ) << 13 ) ; self . w } } impl R { # [ doc = "Bits 0:12 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0x1fff ) as u16 ) } # [ doc = "Bits 13:15 - Fractional Part" ] # [ inline ( always ) ] pub fn fp ( & self ) -> FP_R { FP_R :: new ( ( ( self . bits >> 13 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bits 0:12 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } # [ doc = "Bits 13:15 - Fractional Part" ] # [ inline ( always ) ] pub fn fp ( & mut self ) -> FP_W { FP_W { w : self } } } } # [ doc = "USART_EXT Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud_fracfp_mode](baud_fracfp_mode) module" ] pub type BAUD_FRACFP_MODE = crate :: Reg < u16 , _BAUD_FRACFP_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD_FRACFP_MODE ; # [ doc = "`read()` method returns [baud_fracfp_mode::R](baud_fracfp_mode::R) reader structure" ] impl crate :: Readable for BAUD_FRACFP_MODE { } # [ doc = "`write(|w| ..)` method takes [baud_fracfp_mode::W](baud_fracfp_mode::W) writer structure" ] impl crate :: Writable for BAUD_FRACFP_MODE { } # [ doc = "USART_EXT Baud Rate" ] pub mod baud_fracfp_mode { # [ doc = "Reader of register BAUD_FRACFP_MODE" ] pub type R = crate :: R < u16 , super :: BAUD_FRACFP_MODE > ; # [ doc = "Writer for register BAUD_FRACFP_MODE" ] pub type W = crate :: W < u16 , super :: BAUD_FRACFP_MODE > ; # [ doc = "Register BAUD_FRACFP_MODE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD_FRACFP_MODE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1fff ) | ( ( value as u16 ) & 0x1fff ) ; self . w } } # [ doc = "Reader of field `FP`" ] pub type FP_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `FP`" ] pub struct FP_W < 'a > { w : & 'a mut W , } impl < 'a > FP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 13 ) ) | ( ( ( value as u16 ) & 0x07 ) << 13 ) ; self . w } } impl R { # [ doc = "Bits 0:12 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0x1fff ) as u16 ) } # [ doc = "Bits 13:15 - Fractional Part" ] # [ inline ( always ) ] pub fn fp ( & self ) -> FP_R { FP_R :: new ( ( ( self . bits >> 13 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bits 0:12 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } # [ doc = "Bits 13:15 - Fractional Part" ] # [ inline ( always ) ] pub fn fp ( & mut self ) -> FP_W { FP_W { w : self } } } } # [ doc = "USART_EXT Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud_usartfp_mode](baud_usartfp_mode) module" ] pub type BAUD_USARTFP_MODE = crate :: Reg < u16 , _BAUD_USARTFP_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD_USARTFP_MODE ; # [ doc = "`read()` method returns [baud_usartfp_mode::R](baud_usartfp_mode::R) reader structure" ] impl crate :: Readable for BAUD_USARTFP_MODE { } # [ doc = "`write(|w| ..)` method takes [baud_usartfp_mode::W](baud_usartfp_mode::W) writer structure" ] impl crate :: Writable for BAUD_USARTFP_MODE { } # [ doc = "USART_EXT Baud Rate" ] pub mod baud_usartfp_mode { # [ doc = "Reader of register BAUD_USARTFP_MODE" ] pub type R = crate :: R < u16 , super :: BAUD_USARTFP_MODE > ; # [ doc = "Writer for register BAUD_USARTFP_MODE" ] pub type W = crate :: W < u16 , super :: BAUD_USARTFP_MODE > ; # [ doc = "Register BAUD_USARTFP_MODE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD_USARTFP_MODE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } } } # [ doc = "USART_EXT Receive Pulse Length\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxpl](rxpl) module" ] pub type RXPL = crate :: Reg < u8 , _RXPL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXPL ; # [ doc = "`read()` method returns [rxpl::R](rxpl::R) reader structure" ] impl crate :: Readable for RXPL { } # [ doc = "`write(|w| ..)` method takes [rxpl::W](rxpl::W) writer structure" ] impl crate :: Writable for RXPL { } # [ doc = "USART_EXT Receive Pulse Length" ] pub mod rxpl { # [ doc = "Reader of register RXPL" ] pub type R = crate :: R < u8 , super :: RXPL > ; # [ doc = "Writer for register RXPL" ] pub type W = crate :: W < u8 , super :: RXPL > ; # [ doc = "Register RXPL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RXPL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `RXPL`" ] pub type RXPL_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `RXPL`" ] pub struct RXPL_W < 'a > { w : & 'a mut W , } impl < 'a > RXPL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Receive Pulse Length" ] # [ inline ( always ) ] pub fn rxpl ( & self ) -> RXPL_R { RXPL_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Receive Pulse Length" ] # [ inline ( always ) ] pub fn rxpl ( & mut self ) -> RXPL_W { RXPL_W { w : self } } } } # [ doc = "USART_EXT Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "USART_EXT Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RXS`" ] pub type RXS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXS`" ] pub struct RXS_W < 'a > { w : & 'a mut W , } impl < 'a > RXS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `CTSIC`" ] pub type CTSIC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CTSIC`" ] pub struct CTSIC_W < 'a > { w : & 'a mut W , } impl < 'a > CTSIC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `RXBRK`" ] pub type RXBRK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXBRK`" ] pub struct RXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > RXBRK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt Disable" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Receive Start Interrupt Disable" ] # [ inline ( always ) ] pub fn rxs ( & self ) -> RXS_R { RXS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt Disable" ] # [ inline ( always ) ] pub fn ctsic ( & self ) -> CTSIC_R { CTSIC_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Break Received Interrupt Disable" ] # [ inline ( always ) ] pub fn rxbrk ( & self ) -> RXBRK_R { RXBRK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt Disable" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Receive Start Interrupt Disable" ] # [ inline ( always ) ] pub fn rxs ( & mut self ) -> RXS_W { RXS_W { w : self } } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt Disable" ] # [ inline ( always ) ] pub fn ctsic ( & mut self ) -> CTSIC_W { CTSIC_W { w : self } } # [ doc = "Bit 5 - Break Received Interrupt Disable" ] # [ inline ( always ) ] pub fn rxbrk ( & mut self ) -> RXBRK_W { RXBRK_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "USART_EXT Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "USART_EXT Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RXS`" ] pub type RXS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXS`" ] pub struct RXS_W < 'a > { w : & 'a mut W , } impl < 'a > RXS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `CTSIC`" ] pub type CTSIC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CTSIC`" ] pub struct CTSIC_W < 'a > { w : & 'a mut W , } impl < 'a > CTSIC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `RXBRK`" ] pub type RXBRK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXBRK`" ] pub struct RXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > RXBRK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Receive Start Interrupt Enable" ] # [ inline ( always ) ] pub fn rxs ( & self ) -> RXS_R { RXS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt Enable" ] # [ inline ( always ) ] pub fn ctsic ( & self ) -> CTSIC_R { CTSIC_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Break Received Interrupt Enable" ] # [ inline ( always ) ] pub fn rxbrk ( & self ) -> RXBRK_R { RXBRK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Receive Start Interrupt Enable" ] # [ inline ( always ) ] pub fn rxs ( & mut self ) -> RXS_W { RXS_W { w : self } } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt Enable" ] # [ inline ( always ) ] pub fn ctsic ( & mut self ) -> CTSIC_W { CTSIC_W { w : self } } # [ doc = "Bit 5 - Break Received Interrupt Enable" ] # [ inline ( always ) ] pub fn rxbrk ( & mut self ) -> RXBRK_W { RXBRK_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "USART_EXT Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "USART_EXT Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RXS`" ] pub type RXS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXS`" ] pub struct RXS_W < 'a > { w : & 'a mut W , } impl < 'a > RXS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `CTSIC`" ] pub type CTSIC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CTSIC`" ] pub struct CTSIC_W < 'a > { w : & 'a mut W , } impl < 'a > CTSIC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `RXBRK`" ] pub type RXBRK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXBRK`" ] pub struct RXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > RXBRK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Receive Start Interrupt" ] # [ inline ( always ) ] pub fn rxs ( & self ) -> RXS_R { RXS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt" ] # [ inline ( always ) ] pub fn ctsic ( & self ) -> CTSIC_R { CTSIC_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Break Received Interrupt" ] # [ inline ( always ) ] pub fn rxbrk ( & self ) -> RXBRK_R { RXBRK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Receive Start Interrupt" ] # [ inline ( always ) ] pub fn rxs ( & mut self ) -> RXS_W { RXS_W { w : self } } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt" ] # [ inline ( always ) ] pub fn ctsic ( & mut self ) -> CTSIC_W { CTSIC_W { w : self } } # [ doc = "Bit 5 - Break Received Interrupt" ] # [ inline ( always ) ] pub fn rxbrk ( & mut self ) -> RXBRK_W { RXBRK_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "USART_EXT Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u16 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { } # [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { } # [ doc = "USART_EXT Status" ] pub mod status { # [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u16 , super :: STATUS > ; # [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u16 , super :: STATUS > ; # [ doc = "Register STATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PERR`" ] pub type PERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PERR`" ] pub struct PERR_W < 'a > { w : & 'a mut W , } impl < 'a > PERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `FERR`" ] pub type FERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `FERR`" ] pub struct FERR_W < 'a > { w : & 'a mut W , } impl < 'a > FERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `BUFOVF`" ] pub type BUFOVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `BUFOVF`" ] pub struct BUFOVF_W < 'a > { w : & 'a mut W , } impl < 'a > BUFOVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `CTS`" ] pub type CTS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CTS`" ] pub struct CTS_W < 'a > { w : & 'a mut W , } impl < 'a > CTS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `ISF`" ] pub type ISF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ISF`" ] pub struct ISF_W < 'a > { w : & 'a mut W , } impl < 'a > ISF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `COLL`" ] pub type COLL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COLL`" ] pub struct COLL_W < 'a > { w : & 'a mut W , } impl < 'a > COLL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `TXE`" ] pub type TXE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXE`" ] pub struct TXE_W < 'a > { w : & 'a mut W , } impl < 'a > TXE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } impl R { # [ doc = "Bit 0 - Parity Error" ] # [ inline ( always ) ] pub fn perr ( & self ) -> PERR_R { PERR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Frame Error" ] # [ inline ( always ) ] pub fn ferr ( & self ) -> FERR_R { FERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Buffer Overflow" ] # [ inline ( always ) ] pub fn bufovf ( & self ) -> BUFOVF_R { BUFOVF_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Clear To Send" ] # [ inline ( always ) ] pub fn cts ( & self ) -> CTS_R { CTS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Inconsistent Sync Field" ] # [ inline ( always ) ] pub fn isf ( & self ) -> ISF_R { ISF_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Collision Detected" ] # [ inline ( always ) ] pub fn coll ( & self ) -> COLL_R { COLL_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Transmitter Empty" ] # [ inline ( always ) ] pub fn txe ( & self ) -> TXE_R { TXE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Parity Error" ] # [ inline ( always ) ] pub fn perr ( & mut self ) -> PERR_W { PERR_W { w : self } } # [ doc = "Bit 1 - Frame Error" ] # [ inline ( always ) ] pub fn ferr ( & mut self ) -> FERR_W { FERR_W { w : self } } # [ doc = "Bit 2 - Buffer Overflow" ] # [ inline ( always ) ] pub fn bufovf ( & mut self ) -> BUFOVF_W { BUFOVF_W { w : self } } # [ doc = "Bit 3 - Clear To Send" ] # [ inline ( always ) ] pub fn cts ( & mut self ) -> CTS_W { CTS_W { w : self } } # [ doc = "Bit 4 - Inconsistent Sync Field" ] # [ inline ( always ) ] pub fn isf ( & mut self ) -> ISF_W { ISF_W { w : self } } # [ doc = "Bit 5 - Collision Detected" ] # [ inline ( always ) ] pub fn coll ( & mut self ) -> COLL_W { COLL_W { w : self } } # [ doc = "Bit 6 - Transmitter Empty" ] # [ inline ( always ) ] pub fn txe ( & mut self ) -> TXE_W { TXE_W { w : self } } } } # [ doc = "USART_EXT Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "USART_EXT Synchronization Busy" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CTRLB`" ] pub type CTRLB_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Software Reset Synchronization Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - SERCOM Enable Synchronization Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - CTRLB Synchronization Busy" ] # [ inline ( always ) ] pub fn ctrlb ( & self ) -> CTRLB_R { CTRLB_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } } # [ doc = "USART_EXT Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [data](data) module" ] pub type DATA = crate :: Reg < u16 , _DATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DATA ; # [ doc = "`read()` method returns [data::R](data::R) reader structure" ] impl crate :: Readable for DATA { } # [ doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure" ] impl crate :: Writable for DATA { } # [ doc = "USART_EXT Data" ] pub mod data { # [ doc = "Reader of register DATA" ] pub type R = crate :: R < u16 , super :: DATA > ; # [ doc = "Writer for register DATA" ] pub type W = crate :: W < u16 , super :: DATA > ; # [ doc = "Register DATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DATA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DATA`" ] pub type DATA_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `DATA`" ] pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01ff ) | ( ( value as u16 ) & 0x01ff ) ; self . w } } impl R { # [ doc = "Bits 0:8 - Data Value" ] # [ inline ( always ) ] pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bits 0:8 - Data Value" ] # [ inline ( always ) ] pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } } } # [ doc = "USART_EXT Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "USART_EXT Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGSTOP`" ] pub type DBGSTOP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGSTOP`" ] pub struct DBGSTOP_W < 'a > { w : & 'a mut W , } impl < 'a > DBGSTOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & self ) -> DBGSTOP_R { DBGSTOP_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & mut self ) -> DBGSTOP_W { DBGSTOP_W { w : self } } } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct USART_INT { # [ doc = "0x00 - USART_INT Control A" ] pub ctrla : self::usart_int::CTRLA , # [ doc = "0x04 - USART_INT Control B" ] pub ctrlb : self::usart_int::CTRLB , # [ doc = "0x08 - USART_INT Control C" ] pub ctrlc : self::usart_int::CTRLC , _reserved_3_baud : [ u8 ; 2usize ] , # [ doc = "0x0e - USART_INT Receive Pulse Length" ] pub rxpl : self::usart_int::RXPL , _reserved5 : [ u8 ; 5usize ] , # [ doc = "0x14 - USART_INT Interrupt Enable Clear" ] pub intenclr : self::usart_int::INTENCLR , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x16 - USART_INT Interrupt Enable Set" ] pub intenset : self::usart_int::INTENSET , _reserved7 : [ u8 ; 1usize ] , # [ doc = "0x18 - USART_INT Interrupt Flag Status and Clear" ] pub intflag : self::usart_int::INTFLAG , _reserved8 : [ u8 ; 1usize ] , # [ doc = "0x1a - USART_INT Status" ] pub status : self::usart_int::STATUS , # [ doc = "0x1c - USART_INT Synchronization Busy" ] pub syncbusy : self::usart_int::SYNCBUSY , _reserved10 : [ u8 ; 8usize ] , # [ doc = "0x28 - USART_INT Data" ] pub data : self::usart_int::DATA , _reserved11 : [ u8 ; 6usize ] , # [ doc = "0x30 - USART_INT Debug Control" ] pub dbgctrl : self::usart_int::DBGCTRL , } impl USART_INT { # [ doc = "0x0c - USART_INT Baud Rate" ] # [ inline ( always ) ] pub fn baud_usartfp_mode ( & self ) -> & self::usart_int::BAUD_USARTFP_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const self::usart_int::BAUD_USARTFP_MODE ) } } # [ doc = "0x0c - USART_INT Baud Rate" ] # [ inline ( always ) ] pub fn baud_usartfp_mode_mut ( & self ) -> & mut self::usart_int::BAUD_USARTFP_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut self::usart_int::BAUD_USARTFP_MODE ) } } # [ doc = "0x0c - USART_INT Baud Rate" ] # [ inline ( always ) ] pub fn baud_fracfp_mode ( & self ) -> & self::usart_int::BAUD_FRACFP_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const self::usart_int::BAUD_FRACFP_MODE ) } } # [ doc = "0x0c - USART_INT Baud Rate" ] # [ inline ( always ) ] pub fn baud_fracfp_mode_mut ( & self ) -> & mut self::usart_int::BAUD_FRACFP_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut self::usart_int::BAUD_FRACFP_MODE ) } } # [ doc = "0x0c - USART_INT Baud Rate" ] # [ inline ( always ) ] pub fn baud_frac_mode ( & self ) -> & self::usart_int::BAUD_FRAC_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const self::usart_int::BAUD_FRAC_MODE ) } } # [ doc = "0x0c - USART_INT Baud Rate" ] # [ inline ( always ) ] pub fn baud_frac_mode_mut ( & self ) -> & mut self::usart_int::BAUD_FRAC_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut self::usart_int::BAUD_FRAC_MODE ) } } # [ doc = "0x0c - USART_INT Baud Rate" ] # [ inline ( always ) ] pub fn baud ( & self ) -> & self::usart_int::BAUD { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 12usize ) as * const self::usart_int::BAUD ) } } # [ doc = "0x0c - USART_INT Baud Rate" ] # [ inline ( always ) ] pub fn baud_mut ( & self ) -> & mut self::usart_int::BAUD { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 12usize ) as * mut self::usart_int::BAUD ) } } } # [ doc = r"Register block" ] # [ doc = "USART INTERNAL CLOCK Mode" ] pub mod usart_int { # [ doc = "USART_INT Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "USART_INT Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "USART with external clock" ] USART_EXT_CLK , # [ doc = "USART with internal clock" ] USART_INT_CLK , # [ doc = "SPI in slave operation" ] SPI_SLAVE , # [ doc = "SPI in master operation" ] SPI_MASTER , # [ doc = "I2C slave operation" ] I2C_SLAVE , # [ doc = "I2C master operation" ] I2C_MASTER } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: USART_EXT_CLK => 0 , MODE_A :: USART_INT_CLK => 1 , MODE_A :: SPI_SLAVE => 2 , MODE_A :: SPI_MASTER => 3 , MODE_A :: I2C_SLAVE => 4 , MODE_A :: I2C_MASTER => 5 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: USART_EXT_CLK ) , 1 => Val ( MODE_A :: USART_INT_CLK ) , 2 => Val ( MODE_A :: SPI_SLAVE ) , 3 => Val ( MODE_A :: SPI_MASTER ) , 4 => Val ( MODE_A :: I2C_SLAVE ) , 5 => Val ( MODE_A :: I2C_MASTER ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `USART_EXT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_ext_clk ( & self ) -> bool { * self == MODE_A :: USART_EXT_CLK } # [ doc = "Checks if the value of the field is `USART_INT_CLK`" ] # [ inline ( always ) ] pub fn is_usart_int_clk ( & self ) -> bool { * self == MODE_A :: USART_INT_CLK } # [ doc = "Checks if the value of the field is `SPI_SLAVE`" ] # [ inline ( always ) ] pub fn is_spi_slave ( & self ) -> bool { * self == MODE_A :: SPI_SLAVE } # [ doc = "Checks if the value of the field is `SPI_MASTER`" ] # [ inline ( always ) ] pub fn is_spi_master ( & self ) -> bool { * self == MODE_A :: SPI_MASTER } # [ doc = "Checks if the value of the field is `I2C_SLAVE`" ] # [ inline ( always ) ] pub fn is_i2c_slave ( & self ) -> bool { * self == MODE_A :: I2C_SLAVE } # [ doc = "Checks if the value of the field is `I2C_MASTER`" ] # [ inline ( always ) ] pub fn is_i2c_master ( & self ) -> bool { * self == MODE_A :: I2C_MASTER } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "USART with external clock" ] # [ inline ( always ) ] pub fn usart_ext_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_EXT_CLK ) } # [ doc = "USART with internal clock" ] # [ inline ( always ) ] pub fn usart_int_clk ( self ) -> & 'a mut W { self . variant ( MODE_A :: USART_INT_CLK ) } # [ doc = "SPI in slave operation" ] # [ inline ( always ) ] pub fn spi_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_SLAVE ) } # [ doc = "SPI in master operation" ] # [ inline ( always ) ] pub fn spi_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: SPI_MASTER ) } # [ doc = "I2C slave operation" ] # [ inline ( always ) ] pub fn i2c_slave ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_SLAVE ) } # [ doc = "I2C master operation" ] # [ inline ( always ) ] pub fn i2c_master ( self ) -> & 'a mut W { self . variant ( MODE_A :: I2C_MASTER ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 2 ) ) | ( ( ( value as u32 ) & 0x07 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Reader of field `IBON`" ] pub type IBON_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `IBON`" ] pub struct IBON_W < 'a > { w : & 'a mut W , } impl < 'a > IBON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Possible values of the field `SAMPR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SAMPR_A { # [ doc = "16x over-sampling using arithmetic baudrate generation" ] _16X_ARITHMETIC , # [ doc = "16x over-sampling using fractional baudrate generation" ] _16X_FRACTIONAL , # [ doc = "8x over-sampling using arithmetic baudrate generation" ] _8X_ARITHMETIC , # [ doc = "8x over-sampling using fractional baudrate generation" ] _8X_FRACTIONAL , # [ doc = "3x over-sampling using arithmetic baudrate generation" ] _3X_ARITHMETIC } impl crate :: ToBits < u8 > for SAMPR_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SAMPR_A :: _16X_ARITHMETIC => 0 , SAMPR_A :: _16X_FRACTIONAL => 1 , SAMPR_A :: _8X_ARITHMETIC => 2 , SAMPR_A :: _8X_FRACTIONAL => 3 , SAMPR_A :: _3X_ARITHMETIC => 4 } } } # [ doc = "Reader of field `SAMPR`" ] pub type SAMPR_R = crate :: R < u8 , SAMPR_A > ; impl SAMPR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SAMPR_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SAMPR_A :: _16X_ARITHMETIC ) , 1 => Val ( SAMPR_A :: _16X_FRACTIONAL ) , 2 => Val ( SAMPR_A :: _8X_ARITHMETIC ) , 3 => Val ( SAMPR_A :: _8X_FRACTIONAL ) , 4 => Val ( SAMPR_A :: _3X_ARITHMETIC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_16X_ARITHMETIC`" ] # [ inline ( always ) ] pub fn is_16x_arithmetic ( & self ) -> bool { * self == SAMPR_A :: _16X_ARITHMETIC } # [ doc = "Checks if the value of the field is `_16X_FRACTIONAL`" ] # [ inline ( always ) ] pub fn is_16x_fractional ( & self ) -> bool { * self == SAMPR_A :: _16X_FRACTIONAL } # [ doc = "Checks if the value of the field is `_8X_ARITHMETIC`" ] # [ inline ( always ) ] pub fn is_8x_arithmetic ( & self ) -> bool { * self == SAMPR_A :: _8X_ARITHMETIC } # [ doc = "Checks if the value of the field is `_8X_FRACTIONAL`" ] # [ inline ( always ) ] pub fn is_8x_fractional ( & self ) -> bool { * self == SAMPR_A :: _8X_FRACTIONAL } # [ doc = "Checks if the value of the field is `_3X_ARITHMETIC`" ] # [ inline ( always ) ] pub fn is_3x_arithmetic ( & self ) -> bool { * self == SAMPR_A :: _3X_ARITHMETIC } } # [ doc = "Write proxy for field `SAMPR`" ] pub struct SAMPR_W < 'a > { w : & 'a mut W , } impl < 'a > SAMPR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SAMPR_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "16x over-sampling using arithmetic baudrate generation" ] # [ inline ( always ) ] pub fn _16x_arithmetic ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _16X_ARITHMETIC ) } # [ doc = "16x over-sampling using fractional baudrate generation" ] # [ inline ( always ) ] pub fn _16x_fractional ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _16X_FRACTIONAL ) } # [ doc = "8x over-sampling using arithmetic baudrate generation" ] # [ inline ( always ) ] pub fn _8x_arithmetic ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _8X_ARITHMETIC ) } # [ doc = "8x over-sampling using fractional baudrate generation" ] # [ inline ( always ) ] pub fn _8x_fractional ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _8X_FRACTIONAL ) } # [ doc = "3x over-sampling using arithmetic baudrate generation" ] # [ inline ( always ) ] pub fn _3x_arithmetic ( self ) -> & 'a mut W { self . variant ( SAMPR_A :: _3X_ARITHMETIC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 13 ) ) | ( ( ( value as u32 ) & 0x07 ) << 13 ) ; self . w } } # [ doc = "Possible values of the field `TXPO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TXPO_A { # [ doc = "SERCOM PAD\\[0\\] is used for data transmission" ] PAD0 , # [ doc = "SERCOM PAD\\[2\\] is used for data transmission" ] PAD2 } impl crate :: ToBits < u8 > for TXPO_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { TXPO_A :: PAD0 => 0 , TXPO_A :: PAD2 => 1 } } } # [ doc = "Reader of field `TXPO`" ] pub type TXPO_R = crate :: R < u8 , TXPO_A > ; impl TXPO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , TXPO_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( TXPO_A :: PAD0 ) , 1 => Val ( TXPO_A :: PAD2 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `PAD0`" ] # [ inline ( always ) ] pub fn is_pad0 ( & self ) -> bool { * self == TXPO_A :: PAD0 } # [ doc = "Checks if the value of the field is `PAD2`" ] # [ inline ( always ) ] pub fn is_pad2 ( & self ) -> bool { * self == TXPO_A :: PAD2 } } # [ doc = "Write proxy for field `TXPO`" ] pub struct TXPO_W < 'a > { w : & 'a mut W , } impl < 'a > TXPO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TXPO_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "SERCOM PAD\\[0\\] is used for data transmission" ] # [ inline ( always ) ] pub fn pad0 ( self ) -> & 'a mut W { self . variant ( TXPO_A :: PAD0 ) } # [ doc = "SERCOM PAD\\[2\\] is used for data transmission" ] # [ inline ( always ) ] pub fn pad2 ( self ) -> & 'a mut W { self . variant ( TXPO_A :: PAD2 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 16 ) ) | ( ( ( value as u32 ) & 0x03 ) << 16 ) ; self . w } } # [ doc = "Possible values of the field `RXPO`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RXPO_A { # [ doc = "SERCOM PAD\\[0\\] is used for data reception" ] PAD0 , # [ doc = "SERCOM PAD\\[1\\] is used for data reception" ] PAD1 , # [ doc = "SERCOM PAD\\[2\\] is used for data reception" ] PAD2 , # [ doc = "SERCOM PAD\\[3\\] is used for data reception" ] PAD3 } impl crate :: ToBits < u8 > for RXPO_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { RXPO_A :: PAD0 => 0 , RXPO_A :: PAD1 => 1 , RXPO_A :: PAD2 => 2 , RXPO_A :: PAD3 => 3 } } } # [ doc = "Reader of field `RXPO`" ] pub type RXPO_R = crate :: R < u8 , RXPO_A > ; impl RXPO_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RXPO_A { match self . bits { 0 => RXPO_A :: PAD0 , 1 => RXPO_A :: PAD1 , 2 => RXPO_A :: PAD2 , 3 => RXPO_A :: PAD3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `PAD0`" ] # [ inline ( always ) ] pub fn is_pad0 ( & self ) -> bool { * self == RXPO_A :: PAD0 } # [ doc = "Checks if the value of the field is `PAD1`" ] # [ inline ( always ) ] pub fn is_pad1 ( & self ) -> bool { * self == RXPO_A :: PAD1 } # [ doc = "Checks if the value of the field is `PAD2`" ] # [ inline ( always ) ] pub fn is_pad2 ( & self ) -> bool { * self == RXPO_A :: PAD2 } # [ doc = "Checks if the value of the field is `PAD3`" ] # [ inline ( always ) ] pub fn is_pad3 ( & self ) -> bool { * self == RXPO_A :: PAD3 } } # [ doc = "Write proxy for field `RXPO`" ] pub struct RXPO_W < 'a > { w : & 'a mut W , } impl < 'a > RXPO_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RXPO_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "SERCOM PAD\\[0\\] is used for data reception" ] # [ inline ( always ) ] pub fn pad0 ( self ) -> & 'a mut W { self . variant ( RXPO_A :: PAD0 ) } # [ doc = "SERCOM PAD\\[1\\] is used for data reception" ] # [ inline ( always ) ] pub fn pad1 ( self ) -> & 'a mut W { self . variant ( RXPO_A :: PAD1 ) } # [ doc = "SERCOM PAD\\[2\\] is used for data reception" ] # [ inline ( always ) ] pub fn pad2 ( self ) -> & 'a mut W { self . variant ( RXPO_A :: PAD2 ) } # [ doc = "SERCOM PAD\\[3\\] is used for data reception" ] # [ inline ( always ) ] pub fn pad3 ( self ) -> & 'a mut W { self . variant ( RXPO_A :: PAD3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 20 ) ) | ( ( ( value as u32 ) & 0x03 ) << 20 ) ; self . w } } # [ doc = "Reader of field `SAMPA`" ] pub type SAMPA_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `SAMPA`" ] pub struct SAMPA_W < 'a > { w : & 'a mut W , } impl < 'a > SAMPA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 22 ) ) | ( ( ( value as u32 ) & 0x03 ) << 22 ) ; self . w } } # [ doc = "Possible values of the field `FORM`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum FORM_A { # [ doc = "USART frame" ] USART_FRAME_NO_PARITY , # [ doc = "USART frame with parity" ] USART_FRAME_WITH_PARITY , # [ doc = "LIN Master - Break and sync generation" ] USART_FRAME_LIN_MASTER_MODE , # [ doc = "Auto-baud - break detection and auto-baud" ] USART_FRAME_AUTO_BAUD_NO_PARITY , # [ doc = "Auto-baud - break detection and auto-baud with parity" ] USART_FRAME_AUTO_BAUD_WITH_PARITY } impl crate :: ToBits < u8 > for FORM_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { FORM_A :: USART_FRAME_NO_PARITY => 0 , FORM_A :: USART_FRAME_WITH_PARITY => 1 , FORM_A :: USART_FRAME_LIN_MASTER_MODE => 2 , FORM_A :: USART_FRAME_AUTO_BAUD_NO_PARITY => 4 , FORM_A :: USART_FRAME_AUTO_BAUD_WITH_PARITY => 5 } } } # [ doc = "Reader of field `FORM`" ] pub type FORM_R = crate :: R < u8 , FORM_A > ; impl FORM_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , FORM_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( FORM_A :: USART_FRAME_NO_PARITY ) , 1 => Val ( FORM_A :: USART_FRAME_WITH_PARITY ) , 2 => Val ( FORM_A :: USART_FRAME_LIN_MASTER_MODE ) , 4 => Val ( FORM_A :: USART_FRAME_AUTO_BAUD_NO_PARITY ) , 5 => Val ( FORM_A :: USART_FRAME_AUTO_BAUD_WITH_PARITY ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `USART_FRAME_NO_PARITY`" ] # [ inline ( always ) ] pub fn is_usart_frame_no_parity ( & self ) -> bool { * self == FORM_A :: USART_FRAME_NO_PARITY } # [ doc = "Checks if the value of the field is `USART_FRAME_WITH_PARITY`" ] # [ inline ( always ) ] pub fn is_usart_frame_with_parity ( & self ) -> bool { * self == FORM_A :: USART_FRAME_WITH_PARITY } # [ doc = "Checks if the value of the field is `USART_FRAME_LIN_MASTER_MODE`" ] # [ inline ( always ) ] pub fn is_usart_frame_lin_master_mode ( & self ) -> bool { * self == FORM_A :: USART_FRAME_LIN_MASTER_MODE } # [ doc = "Checks if the value of the field is `USART_FRAME_AUTO_BAUD_NO_PARITY`" ] # [ inline ( always ) ] pub fn is_usart_frame_auto_baud_no_parity ( & self ) -> bool { * self == FORM_A :: USART_FRAME_AUTO_BAUD_NO_PARITY } # [ doc = "Checks if the value of the field is `USART_FRAME_AUTO_BAUD_WITH_PARITY`" ] # [ inline ( always ) ] pub fn is_usart_frame_auto_baud_with_parity ( & self ) -> bool { * self == FORM_A :: USART_FRAME_AUTO_BAUD_WITH_PARITY } } # [ doc = "Write proxy for field `FORM`" ] pub struct FORM_W < 'a > { w : & 'a mut W , } impl < 'a > FORM_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : FORM_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "USART frame" ] # [ inline ( always ) ] pub fn usart_frame_no_parity ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_NO_PARITY ) } # [ doc = "USART frame with parity" ] # [ inline ( always ) ] pub fn usart_frame_with_parity ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_WITH_PARITY ) } # [ doc = "LIN Master - Break and sync generation" ] # [ inline ( always ) ] pub fn usart_frame_lin_master_mode ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_LIN_MASTER_MODE ) } # [ doc = "Auto-baud - break detection and auto-baud" ] # [ inline ( always ) ] pub fn usart_frame_auto_baud_no_parity ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_AUTO_BAUD_NO_PARITY ) } # [ doc = "Auto-baud - break detection and auto-baud with parity" ] # [ inline ( always ) ] pub fn usart_frame_auto_baud_with_parity ( self ) -> & 'a mut W { self . variant ( FORM_A :: USART_FRAME_AUTO_BAUD_WITH_PARITY ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } } # [ doc = "Possible values of the field `CMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMODE_A { # [ doc = "Asynchronous Communication" ] ASYNC , # [ doc = "Synchronous Communication" ] SYNC } impl crate :: ToBits < bool > for CMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CMODE_A :: ASYNC => false , CMODE_A :: SYNC => true } } } # [ doc = "Reader of field `CMODE`" ] pub type CMODE_R = crate :: R < bool , CMODE_A > ; impl CMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CMODE_A { match self . bits { false => CMODE_A :: ASYNC , true => CMODE_A :: SYNC } } # [ doc = "Checks if the value of the field is `ASYNC`" ] # [ inline ( always ) ] pub fn is_async ( & self ) -> bool { * self == CMODE_A :: ASYNC } # [ doc = "Checks if the value of the field is `SYNC`" ] # [ inline ( always ) ] pub fn is_sync ( & self ) -> bool { * self == CMODE_A :: SYNC } } # [ doc = "Write proxy for field `CMODE`" ] pub struct CMODE_W < 'a > { w : & 'a mut W , } impl < 'a > CMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMODE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Asynchronous Communication" ] # [ inline ( always ) ] pub fn async ( self ) -> & 'a mut W { self . variant ( CMODE_A :: ASYNC ) } # [ doc = "Synchronous Communication" ] # [ inline ( always ) ] pub fn sync ( self ) -> & 'a mut W { self . variant ( CMODE_A :: SYNC ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } } # [ doc = "Possible values of the field `CPOL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CPOL_A { # [ doc = "TxD Change:- Rising XCK edge, RxD Sample:- Falling XCK edge" ] IDLE_LOW , # [ doc = "TxD Change:- Falling XCK edge, RxD Sample:- Rising XCK edge" ] IDLE_HIGH } impl crate :: ToBits < bool > for CPOL_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CPOL_A :: IDLE_LOW => false , CPOL_A :: IDLE_HIGH => true } } } # [ doc = "Reader of field `CPOL`" ] pub type CPOL_R = crate :: R < bool , CPOL_A > ; impl CPOL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CPOL_A { match self . bits { false => CPOL_A :: IDLE_LOW , true => CPOL_A :: IDLE_HIGH } } # [ doc = "Checks if the value of the field is `IDLE_LOW`" ] # [ inline ( always ) ] pub fn is_idle_low ( & self ) -> bool { * self == CPOL_A :: IDLE_LOW } # [ doc = "Checks if the value of the field is `IDLE_HIGH`" ] # [ inline ( always ) ] pub fn is_idle_high ( & self ) -> bool { * self == CPOL_A :: IDLE_HIGH } } # [ doc = "Write proxy for field `CPOL`" ] pub struct CPOL_W < 'a > { w : & 'a mut W , } impl < 'a > CPOL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CPOL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "TxD Change:- Rising XCK edge, RxD Sample:- Falling XCK edge" ] # [ inline ( always ) ] pub fn idle_low ( self ) -> & 'a mut W { self . variant ( CPOL_A :: IDLE_LOW ) } # [ doc = "TxD Change:- Falling XCK edge, RxD Sample:- Rising XCK edge" ] # [ inline ( always ) ] pub fn idle_high ( self ) -> & 'a mut W { self . variant ( CPOL_A :: IDLE_HIGH ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 29 ) ) | ( ( ( value as u32 ) & 0x01 ) << 29 ) ; self . w } } # [ doc = "Possible values of the field `DORD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum DORD_A { # [ doc = "MSB is transmitted first" ] MSB , # [ doc = "LSB is transmitted first" ] LSB } impl crate :: ToBits < bool > for DORD_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { DORD_A :: MSB => false , DORD_A :: LSB => true } } } # [ doc = "Reader of field `DORD`" ] pub type DORD_R = crate :: R < bool , DORD_A > ; impl DORD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> DORD_A { match self . bits { false => DORD_A :: MSB , true => DORD_A :: LSB } } # [ doc = "Checks if the value of the field is `MSB`" ] # [ inline ( always ) ] pub fn is_msb ( & self ) -> bool { * self == DORD_A :: MSB } # [ doc = "Checks if the value of the field is `LSB`" ] # [ inline ( always ) ] pub fn is_lsb ( & self ) -> bool { * self == DORD_A :: LSB } } # [ doc = "Write proxy for field `DORD`" ] pub struct DORD_W < 'a > { w : & 'a mut W , } impl < 'a > DORD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : DORD_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "MSB is transmitted first" ] # [ inline ( always ) ] pub fn msb ( self ) -> & 'a mut W { self . variant ( DORD_A :: MSB ) } # [ doc = "LSB is transmitted first" ] # [ inline ( always ) ] pub fn lsb ( self ) -> & 'a mut W { self . variant ( DORD_A :: LSB ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 30 ) ) | ( ( ( value as u32 ) & 0x01 ) << 30 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x07 ) as u8 ) } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Immediate Buffer Overflow Notification" ] # [ inline ( always ) ] pub fn ibon ( & self ) -> IBON_R { IBON_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bits 13:15 - Sample" ] # [ inline ( always ) ] pub fn sampr ( & self ) -> SAMPR_R { SAMPR_R :: new ( ( ( self . bits >> 13 ) & 0x07 ) as u8 ) } # [ doc = "Bits 16:17 - Transmit Data Pinout" ] # [ inline ( always ) ] pub fn txpo ( & self ) -> TXPO_R { TXPO_R :: new ( ( ( self . bits >> 16 ) & 0x03 ) as u8 ) } # [ doc = "Bits 20:21 - Receive Data Pinout" ] # [ inline ( always ) ] pub fn rxpo ( & self ) -> RXPO_R { RXPO_R :: new ( ( ( self . bits >> 20 ) & 0x03 ) as u8 ) } # [ doc = "Bits 22:23 - Sample Adjustment" ] # [ inline ( always ) ] pub fn sampa ( & self ) -> SAMPA_R { SAMPA_R :: new ( ( ( self . bits >> 22 ) & 0x03 ) as u8 ) } # [ doc = "Bits 24:27 - Frame Format" ] # [ inline ( always ) ] pub fn form ( & self ) -> FORM_R { FORM_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) } # [ doc = "Bit 28 - Communication Mode" ] # [ inline ( always ) ] pub fn cmode ( & self ) -> CMODE_R { CMODE_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) } # [ doc = "Bit 29 - Clock Polarity" ] # [ inline ( always ) ] pub fn cpol ( & self ) -> CPOL_R { CPOL_R :: new ( ( ( self . bits >> 29 ) & 0x01 ) != 0 ) } # [ doc = "Bit 30 - Data Order" ] # [ inline ( always ) ] pub fn dord ( & self ) -> DORD_R { DORD_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:4 - Operating Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bit 7 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } } # [ doc = "Bit 8 - Immediate Buffer Overflow Notification" ] # [ inline ( always ) ] pub fn ibon ( & mut self ) -> IBON_W { IBON_W { w : self } } # [ doc = "Bits 13:15 - Sample" ] # [ inline ( always ) ] pub fn sampr ( & mut self ) -> SAMPR_W { SAMPR_W { w : self } } # [ doc = "Bits 16:17 - Transmit Data Pinout" ] # [ inline ( always ) ] pub fn txpo ( & mut self ) -> TXPO_W { TXPO_W { w : self } } # [ doc = "Bits 20:21 - Receive Data Pinout" ] # [ inline ( always ) ] pub fn rxpo ( & mut self ) -> RXPO_W { RXPO_W { w : self } } # [ doc = "Bits 22:23 - Sample Adjustment" ] # [ inline ( always ) ] pub fn sampa ( & mut self ) -> SAMPA_W { SAMPA_W { w : self } } # [ doc = "Bits 24:27 - Frame Format" ] # [ inline ( always ) ] pub fn form ( & mut self ) -> FORM_W { FORM_W { w : self } } # [ doc = "Bit 28 - Communication Mode" ] # [ inline ( always ) ] pub fn cmode ( & mut self ) -> CMODE_W { CMODE_W { w : self } } # [ doc = "Bit 29 - Clock Polarity" ] # [ inline ( always ) ] pub fn cpol ( & mut self ) -> CPOL_W { CPOL_W { w : self } } # [ doc = "Bit 30 - Data Order" ] # [ inline ( always ) ] pub fn dord ( & mut self ) -> DORD_W { DORD_W { w : self } } } } # [ doc = "USART_INT Control B\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u32 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ; # [ doc = "`read()` method returns [ctrlb::R](ctrlb::R) reader structure" ] impl crate :: Readable for CTRLB { } # [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { } # [ doc = "USART_INT Control B" ] pub mod ctrlb { # [ doc = "Reader of register CTRLB" ] pub type R = crate :: R < u32 , super :: CTRLB > ; # [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u32 , super :: CTRLB > ; # [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `CHSIZE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CHSIZE_A { # [ doc = "8 Bits" ] _8_BIT , # [ doc = "9 Bits" ] _9_BIT , # [ doc = "5 Bits" ] _5_BIT , # [ doc = "6 Bits" ] _6_BIT , # [ doc = "7 Bits" ] _7_BIT } impl crate :: ToBits < u8 > for CHSIZE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CHSIZE_A :: _8_BIT => 0 , CHSIZE_A :: _9_BIT => 1 , CHSIZE_A :: _5_BIT => 5 , CHSIZE_A :: _6_BIT => 6 , CHSIZE_A :: _7_BIT => 7 } } } # [ doc = "Reader of field `CHSIZE`" ] pub type CHSIZE_R = crate :: R < u8 , CHSIZE_A > ; impl CHSIZE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CHSIZE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CHSIZE_A :: _8_BIT ) , 1 => Val ( CHSIZE_A :: _9_BIT ) , 5 => Val ( CHSIZE_A :: _5_BIT ) , 6 => Val ( CHSIZE_A :: _6_BIT ) , 7 => Val ( CHSIZE_A :: _7_BIT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_8_BIT`" ] # [ inline ( always ) ] pub fn is_8_bit ( & self ) -> bool { * self == CHSIZE_A :: _8_BIT } # [ doc = "Checks if the value of the field is `_9_BIT`" ] # [ inline ( always ) ] pub fn is_9_bit ( & self ) -> bool { * self == CHSIZE_A :: _9_BIT } # [ doc = "Checks if the value of the field is `_5_BIT`" ] # [ inline ( always ) ] pub fn is_5_bit ( & self ) -> bool { * self == CHSIZE_A :: _5_BIT } # [ doc = "Checks if the value of the field is `_6_BIT`" ] # [ inline ( always ) ] pub fn is_6_bit ( & self ) -> bool { * self == CHSIZE_A :: _6_BIT } # [ doc = "Checks if the value of the field is `_7_BIT`" ] # [ inline ( always ) ] pub fn is_7_bit ( & self ) -> bool { * self == CHSIZE_A :: _7_BIT } } # [ doc = "Write proxy for field `CHSIZE`" ] pub struct CHSIZE_W < 'a > { w : & 'a mut W , } impl < 'a > CHSIZE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CHSIZE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 Bits" ] # [ inline ( always ) ] pub fn _8_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _8_BIT ) } # [ doc = "9 Bits" ] # [ inline ( always ) ] pub fn _9_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _9_BIT ) } # [ doc = "5 Bits" ] # [ inline ( always ) ] pub fn _5_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _5_BIT ) } # [ doc = "6 Bits" ] # [ inline ( always ) ] pub fn _6_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _6_BIT ) } # [ doc = "7 Bits" ] # [ inline ( always ) ] pub fn _7_bit ( self ) -> & 'a mut W { self . variant ( CHSIZE_A :: _7_BIT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } } # [ doc = "Possible values of the field `SBMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SBMODE_A { # [ doc = "One Stop Bit" ] _1_BIT , # [ doc = "Two Stop Bits" ] _2_BIT } impl crate :: ToBits < bool > for SBMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { SBMODE_A :: _1_BIT => false , SBMODE_A :: _2_BIT => true } } } # [ doc = "Reader of field `SBMODE`" ] pub type SBMODE_R = crate :: R < bool , SBMODE_A > ; impl SBMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SBMODE_A { match self . bits { false => SBMODE_A :: _1_BIT , true => SBMODE_A :: _2_BIT } } # [ doc = "Checks if the value of the field is `_1_BIT`" ] # [ inline ( always ) ] pub fn is_1_bit ( & self ) -> bool { * self == SBMODE_A :: _1_BIT } # [ doc = "Checks if the value of the field is `_2_BIT`" ] # [ inline ( always ) ] pub fn is_2_bit ( & self ) -> bool { * self == SBMODE_A :: _2_BIT } } # [ doc = "Write proxy for field `SBMODE`" ] pub struct SBMODE_W < 'a > { w : & 'a mut W , } impl < 'a > SBMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SBMODE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "One Stop Bit" ] # [ inline ( always ) ] pub fn _1_bit ( self ) -> & 'a mut W { self . variant ( SBMODE_A :: _1_BIT ) } # [ doc = "Two Stop Bits" ] # [ inline ( always ) ] pub fn _2_bit ( self ) -> & 'a mut W { self . variant ( SBMODE_A :: _2_BIT ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `COLDEN`" ] pub type COLDEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COLDEN`" ] pub struct COLDEN_W < 'a > { w : & 'a mut W , } impl < 'a > COLDEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `SFDE`" ] pub type SFDE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SFDE`" ] pub struct SFDE_W < 'a > { w : & 'a mut W , } impl < 'a > SFDE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } } # [ doc = "Reader of field `ENC`" ] pub type ENC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENC`" ] pub struct ENC_W < 'a > { w : & 'a mut W , } impl < 'a > ENC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } } # [ doc = "Possible values of the field `PMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PMODE_A { # [ doc = "Even Parity" ] EVEN , # [ doc = "Odd Parity" ] ODD } impl crate :: ToBits < bool > for PMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { PMODE_A :: EVEN => false , PMODE_A :: ODD => true } } } # [ doc = "Reader of field `PMODE`" ] pub type PMODE_R = crate :: R < bool , PMODE_A > ; impl PMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PMODE_A { match self . bits { false => PMODE_A :: EVEN , true => PMODE_A :: ODD } } # [ doc = "Checks if the value of the field is `EVEN`" ] # [ inline ( always ) ] pub fn is_even ( & self ) -> bool { * self == PMODE_A :: EVEN } # [ doc = "Checks if the value of the field is `ODD`" ] # [ inline ( always ) ] pub fn is_odd ( & self ) -> bool { * self == PMODE_A :: ODD } } # [ doc = "Write proxy for field `PMODE`" ] pub struct PMODE_W < 'a > { w : & 'a mut W , } impl < 'a > PMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PMODE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Even Parity" ] # [ inline ( always ) ] pub fn even ( self ) -> & 'a mut W { self . variant ( PMODE_A :: EVEN ) } # [ doc = "Odd Parity" ] # [ inline ( always ) ] pub fn odd ( self ) -> & 'a mut W { self . variant ( PMODE_A :: ODD ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } } # [ doc = "Reader of field `TXEN`" ] pub type TXEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXEN`" ] pub struct TXEN_W < 'a > { w : & 'a mut W , } impl < 'a > TXEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `RXEN`" ] pub type RXEN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXEN`" ] pub struct RXEN_W < 'a > { w : & 'a mut W , } impl < 'a > RXEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Reader of field `LINCMD`" ] pub type LINCMD_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `LINCMD`" ] pub struct LINCMD_W < 'a > { w : & 'a mut W , } impl < 'a > LINCMD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 24 ) ) | ( ( ( value as u32 ) & 0x03 ) << 24 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - Character Size" ] # [ inline ( always ) ] pub fn chsize ( & self ) -> CHSIZE_R { CHSIZE_R :: new ( ( self . bits & 0x07 ) as u8 ) } # [ doc = "Bit 6 - Stop Bit Mode" ] # [ inline ( always ) ] pub fn sbmode ( & self ) -> SBMODE_R { SBMODE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Collision Detection Enable" ] # [ inline ( always ) ] pub fn colden ( & self ) -> COLDEN_R { COLDEN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 9 - Start of Frame Detection Enable" ] # [ inline ( always ) ] pub fn sfde ( & self ) -> SFDE_R { SFDE_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) } # [ doc = "Bit 10 - Encoding Format" ] # [ inline ( always ) ] pub fn enc ( & self ) -> ENC_R { ENC_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - Parity Mode" ] # [ inline ( always ) ] pub fn pmode ( & self ) -> PMODE_R { PMODE_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - Transmitter Enable" ] # [ inline ( always ) ] pub fn txen ( & self ) -> TXEN_R { TXEN_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - Receiver Enable" ] # [ inline ( always ) ] pub fn rxen ( & self ) -> RXEN_R { RXEN_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bits 24:25 - LIN Command" ] # [ inline ( always ) ] pub fn lincmd ( & self ) -> LINCMD_R { LINCMD_R :: new ( ( ( self . bits >> 24 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:2 - Character Size" ] # [ inline ( always ) ] pub fn chsize ( & mut self ) -> CHSIZE_W { CHSIZE_W { w : self } } # [ doc = "Bit 6 - Stop Bit Mode" ] # [ inline ( always ) ] pub fn sbmode ( & mut self ) -> SBMODE_W { SBMODE_W { w : self } } # [ doc = "Bit 8 - Collision Detection Enable" ] # [ inline ( always ) ] pub fn colden ( & mut self ) -> COLDEN_W { COLDEN_W { w : self } } # [ doc = "Bit 9 - Start of Frame Detection Enable" ] # [ inline ( always ) ] pub fn sfde ( & mut self ) -> SFDE_W { SFDE_W { w : self } } # [ doc = "Bit 10 - Encoding Format" ] # [ inline ( always ) ] pub fn enc ( & mut self ) -> ENC_W { ENC_W { w : self } } # [ doc = "Bit 13 - Parity Mode" ] # [ inline ( always ) ] pub fn pmode ( & mut self ) -> PMODE_W { PMODE_W { w : self } } # [ doc = "Bit 16 - Transmitter Enable" ] # [ inline ( always ) ] pub fn txen ( & mut self ) -> TXEN_W { TXEN_W { w : self } } # [ doc = "Bit 17 - Receiver Enable" ] # [ inline ( always ) ] pub fn rxen ( & mut self ) -> RXEN_W { RXEN_W { w : self } } # [ doc = "Bits 24:25 - LIN Command" ] # [ inline ( always ) ] pub fn lincmd ( & mut self ) -> LINCMD_W { LINCMD_W { w : self } } } } # [ doc = "USART_INT Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlc](ctrlc) module" ] pub type CTRLC = crate :: Reg < u32 , _CTRLC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLC ; # [ doc = "`read()` method returns [ctrlc::R](ctrlc::R) reader structure" ] impl crate :: Readable for CTRLC { } # [ doc = "`write(|w| ..)` method takes [ctrlc::W](ctrlc::W) writer structure" ] impl crate :: Writable for CTRLC { } # [ doc = "USART_INT Control C" ] pub mod ctrlc { # [ doc = "Reader of register CTRLC" ] pub type R = crate :: R < u32 , super :: CTRLC > ; # [ doc = "Writer for register CTRLC" ] pub type W = crate :: W < u32 , super :: CTRLC > ; # [ doc = "Register CTRLC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `GTIME`" ] pub type GTIME_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `GTIME`" ] pub struct GTIME_W < 'a > { w : & 'a mut W , } impl < 'a > GTIME_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } } # [ doc = "Reader of field `BRKLEN`" ] pub type BRKLEN_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `BRKLEN`" ] pub struct BRKLEN_W < 'a > { w : & 'a mut W , } impl < 'a > BRKLEN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } } # [ doc = "Reader of field `HDRDLY`" ] pub type HDRDLY_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `HDRDLY`" ] pub struct HDRDLY_W < 'a > { w : & 'a mut W , } impl < 'a > HDRDLY_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u32 ) & 0x03 ) << 10 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - RS485 Guard Time" ] # [ inline ( always ) ] pub fn gtime ( & self ) -> GTIME_R { GTIME_R :: new ( ( self . bits & 0x07 ) as u8 ) } # [ doc = "Bits 8:9 - LIN Master Break Length" ] # [ inline ( always ) ] pub fn brklen ( & self ) -> BRKLEN_R { BRKLEN_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) } # [ doc = "Bits 10:11 - LIN Master Header Delay" ] # [ inline ( always ) ] pub fn hdrdly ( & self ) -> HDRDLY_R { HDRDLY_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:2 - RS485 Guard Time" ] # [ inline ( always ) ] pub fn gtime ( & mut self ) -> GTIME_W { GTIME_W { w : self } } # [ doc = "Bits 8:9 - LIN Master Break Length" ] # [ inline ( always ) ] pub fn brklen ( & mut self ) -> BRKLEN_W { BRKLEN_W { w : self } } # [ doc = "Bits 10:11 - LIN Master Header Delay" ] # [ inline ( always ) ] pub fn hdrdly ( & mut self ) -> HDRDLY_W { HDRDLY_W { w : self } } } } # [ doc = "USART_INT Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud](baud) module" ] pub type BAUD = crate :: Reg < u16 , _BAUD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD ; # [ doc = "`read()` method returns [baud::R](baud::R) reader structure" ] impl crate :: Readable for BAUD { } # [ doc = "`write(|w| ..)` method takes [baud::W](baud::W) writer structure" ] impl crate :: Writable for BAUD { } # [ doc = "USART_INT Baud Rate" ] pub mod baud { # [ doc = "Reader of register BAUD" ] pub type R = crate :: R < u16 , super :: BAUD > ; # [ doc = "Writer for register BAUD" ] pub type W = crate :: W < u16 , super :: BAUD > ; # [ doc = "Register BAUD `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } } } # [ doc = "USART_INT Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud_frac_mode](baud_frac_mode) module" ] pub type BAUD_FRAC_MODE = crate :: Reg < u16 , _BAUD_FRAC_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD_FRAC_MODE ; # [ doc = "`read()` method returns [baud_frac_mode::R](baud_frac_mode::R) reader structure" ] impl crate :: Readable for BAUD_FRAC_MODE { } # [ doc = "`write(|w| ..)` method takes [baud_frac_mode::W](baud_frac_mode::W) writer structure" ] impl crate :: Writable for BAUD_FRAC_MODE { } # [ doc = "USART_INT Baud Rate" ] pub mod baud_frac_mode { # [ doc = "Reader of register BAUD_FRAC_MODE" ] pub type R = crate :: R < u16 , super :: BAUD_FRAC_MODE > ; # [ doc = "Writer for register BAUD_FRAC_MODE" ] pub type W = crate :: W < u16 , super :: BAUD_FRAC_MODE > ; # [ doc = "Register BAUD_FRAC_MODE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD_FRAC_MODE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1fff ) | ( ( value as u16 ) & 0x1fff ) ; self . w } } # [ doc = "Reader of field `FP`" ] pub type FP_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `FP`" ] pub struct FP_W < 'a > { w : & 'a mut W , } impl < 'a > FP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 13 ) ) | ( ( ( value as u16 ) & 0x07 ) << 13 ) ; self . w } } impl R { # [ doc = "Bits 0:12 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0x1fff ) as u16 ) } # [ doc = "Bits 13:15 - Fractional Part" ] # [ inline ( always ) ] pub fn fp ( & self ) -> FP_R { FP_R :: new ( ( ( self . bits >> 13 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bits 0:12 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } # [ doc = "Bits 13:15 - Fractional Part" ] # [ inline ( always ) ] pub fn fp ( & mut self ) -> FP_W { FP_W { w : self } } } } # [ doc = "USART_INT Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud_fracfp_mode](baud_fracfp_mode) module" ] pub type BAUD_FRACFP_MODE = crate :: Reg < u16 , _BAUD_FRACFP_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD_FRACFP_MODE ; # [ doc = "`read()` method returns [baud_fracfp_mode::R](baud_fracfp_mode::R) reader structure" ] impl crate :: Readable for BAUD_FRACFP_MODE { } # [ doc = "`write(|w| ..)` method takes [baud_fracfp_mode::W](baud_fracfp_mode::W) writer structure" ] impl crate :: Writable for BAUD_FRACFP_MODE { } # [ doc = "USART_INT Baud Rate" ] pub mod baud_fracfp_mode { # [ doc = "Reader of register BAUD_FRACFP_MODE" ] pub type R = crate :: R < u16 , super :: BAUD_FRACFP_MODE > ; # [ doc = "Writer for register BAUD_FRACFP_MODE" ] pub type W = crate :: W < u16 , super :: BAUD_FRACFP_MODE > ; # [ doc = "Register BAUD_FRACFP_MODE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD_FRACFP_MODE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1fff ) | ( ( value as u16 ) & 0x1fff ) ; self . w } } # [ doc = "Reader of field `FP`" ] pub type FP_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `FP`" ] pub struct FP_W < 'a > { w : & 'a mut W , } impl < 'a > FP_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 13 ) ) | ( ( ( value as u16 ) & 0x07 ) << 13 ) ; self . w } } impl R { # [ doc = "Bits 0:12 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0x1fff ) as u16 ) } # [ doc = "Bits 13:15 - Fractional Part" ] # [ inline ( always ) ] pub fn fp ( & self ) -> FP_R { FP_R :: new ( ( ( self . bits >> 13 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bits 0:12 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } # [ doc = "Bits 13:15 - Fractional Part" ] # [ inline ( always ) ] pub fn fp ( & mut self ) -> FP_W { FP_W { w : self } } } } # [ doc = "USART_INT Baud Rate\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [baud_usartfp_mode](baud_usartfp_mode) module" ] pub type BAUD_USARTFP_MODE = crate :: Reg < u16 , _BAUD_USARTFP_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BAUD_USARTFP_MODE ; # [ doc = "`read()` method returns [baud_usartfp_mode::R](baud_usartfp_mode::R) reader structure" ] impl crate :: Readable for BAUD_USARTFP_MODE { } # [ doc = "`write(|w| ..)` method takes [baud_usartfp_mode::W](baud_usartfp_mode::W) writer structure" ] impl crate :: Writable for BAUD_USARTFP_MODE { } # [ doc = "USART_INT Baud Rate" ] pub mod baud_usartfp_mode { # [ doc = "Reader of register BAUD_USARTFP_MODE" ] pub type R = crate :: R < u16 , super :: BAUD_USARTFP_MODE > ; # [ doc = "Writer for register BAUD_USARTFP_MODE" ] pub type W = crate :: W < u16 , super :: BAUD_USARTFP_MODE > ; # [ doc = "Register BAUD_USARTFP_MODE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BAUD_USARTFP_MODE { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `BAUD`" ] pub type BAUD_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `BAUD`" ] pub struct BAUD_W < 'a > { w : & 'a mut W , } impl < 'a > BAUD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & self ) -> BAUD_R { BAUD_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Baud Rate Value" ] # [ inline ( always ) ] pub fn baud ( & mut self ) -> BAUD_W { BAUD_W { w : self } } } } # [ doc = "USART_INT Receive Pulse Length\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rxpl](rxpl) module" ] pub type RXPL = crate :: Reg < u8 , _RXPL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RXPL ; # [ doc = "`read()` method returns [rxpl::R](rxpl::R) reader structure" ] impl crate :: Readable for RXPL { } # [ doc = "`write(|w| ..)` method takes [rxpl::W](rxpl::W) writer structure" ] impl crate :: Writable for RXPL { } # [ doc = "USART_INT Receive Pulse Length" ] pub mod rxpl { # [ doc = "Reader of register RXPL" ] pub type R = crate :: R < u8 , super :: RXPL > ; # [ doc = "Writer for register RXPL" ] pub type W = crate :: W < u8 , super :: RXPL > ; # [ doc = "Register RXPL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RXPL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `RXPL`" ] pub type RXPL_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `RXPL`" ] pub struct RXPL_W < 'a > { w : & 'a mut W , } impl < 'a > RXPL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Receive Pulse Length" ] # [ inline ( always ) ] pub fn rxpl ( & self ) -> RXPL_R { RXPL_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Receive Pulse Length" ] # [ inline ( always ) ] pub fn rxpl ( & mut self ) -> RXPL_W { RXPL_W { w : self } } } } # [ doc = "USART_INT Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "USART_INT Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RXS`" ] pub type RXS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXS`" ] pub struct RXS_W < 'a > { w : & 'a mut W , } impl < 'a > RXS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `CTSIC`" ] pub type CTSIC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CTSIC`" ] pub struct CTSIC_W < 'a > { w : & 'a mut W , } impl < 'a > CTSIC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `RXBRK`" ] pub type RXBRK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXBRK`" ] pub struct RXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > RXBRK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt Disable" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Receive Start Interrupt Disable" ] # [ inline ( always ) ] pub fn rxs ( & self ) -> RXS_R { RXS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt Disable" ] # [ inline ( always ) ] pub fn ctsic ( & self ) -> CTSIC_R { CTSIC_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Break Received Interrupt Disable" ] # [ inline ( always ) ] pub fn rxbrk ( & self ) -> RXBRK_R { RXBRK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt Disable" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt Disable" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Receive Start Interrupt Disable" ] # [ inline ( always ) ] pub fn rxs ( & mut self ) -> RXS_W { RXS_W { w : self } } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt Disable" ] # [ inline ( always ) ] pub fn ctsic ( & mut self ) -> CTSIC_W { CTSIC_W { w : self } } # [ doc = "Bit 5 - Break Received Interrupt Disable" ] # [ inline ( always ) ] pub fn rxbrk ( & mut self ) -> RXBRK_W { RXBRK_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Disable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "USART_INT Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "USART_INT Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RXS`" ] pub type RXS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXS`" ] pub struct RXS_W < 'a > { w : & 'a mut W , } impl < 'a > RXS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `CTSIC`" ] pub type CTSIC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CTSIC`" ] pub struct CTSIC_W < 'a > { w : & 'a mut W , } impl < 'a > CTSIC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `RXBRK`" ] pub type RXBRK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXBRK`" ] pub struct RXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > RXBRK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Receive Start Interrupt Enable" ] # [ inline ( always ) ] pub fn rxs ( & self ) -> RXS_R { RXS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt Enable" ] # [ inline ( always ) ] pub fn ctsic ( & self ) -> CTSIC_R { CTSIC_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Break Received Interrupt Enable" ] # [ inline ( always ) ] pub fn rxbrk ( & self ) -> RXBRK_R { RXBRK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt Enable" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt Enable" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Receive Start Interrupt Enable" ] # [ inline ( always ) ] pub fn rxs ( & mut self ) -> RXS_W { RXS_W { w : self } } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt Enable" ] # [ inline ( always ) ] pub fn ctsic ( & mut self ) -> CTSIC_W { CTSIC_W { w : self } } # [ doc = "Bit 5 - Break Received Interrupt Enable" ] # [ inline ( always ) ] pub fn rxbrk ( & mut self ) -> RXBRK_W { RXBRK_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt Enable" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "USART_INT Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "USART_INT Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DRE`" ] pub type DRE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DRE`" ] pub struct DRE_W < 'a > { w : & 'a mut W , } impl < 'a > DRE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `TXC`" ] pub type TXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXC`" ] pub struct TXC_W < 'a > { w : & 'a mut W , } impl < 'a > TXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `RXC`" ] pub type RXC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXC`" ] pub struct RXC_W < 'a > { w : & 'a mut W , } impl < 'a > RXC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `RXS`" ] pub type RXS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXS`" ] pub struct RXS_W < 'a > { w : & 'a mut W , } impl < 'a > RXS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `CTSIC`" ] pub type CTSIC_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CTSIC`" ] pub struct CTSIC_W < 'a > { w : & 'a mut W , } impl < 'a > CTSIC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `RXBRK`" ] pub type RXBRK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RXBRK`" ] pub struct RXBRK_W < 'a > { w : & 'a mut W , } impl < 'a > RXBRK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `ERROR`" ] pub type ERROR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERROR`" ] pub struct ERROR_W < 'a > { w : & 'a mut W , } impl < 'a > ERROR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } } impl R { # [ doc = "Bit 0 - Data Register Empty Interrupt" ] # [ inline ( always ) ] pub fn dre ( & self ) -> DRE_R { DRE_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Transmit Complete Interrupt" ] # [ inline ( always ) ] pub fn txc ( & self ) -> TXC_R { TXC_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Receive Complete Interrupt" ] # [ inline ( always ) ] pub fn rxc ( & self ) -> RXC_R { RXC_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Receive Start Interrupt" ] # [ inline ( always ) ] pub fn rxs ( & self ) -> RXS_R { RXS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt" ] # [ inline ( always ) ] pub fn ctsic ( & self ) -> CTSIC_R { CTSIC_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Break Received Interrupt" ] # [ inline ( always ) ] pub fn rxbrk ( & self ) -> RXBRK_R { RXBRK_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & self ) -> ERROR_R { ERROR_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Data Register Empty Interrupt" ] # [ inline ( always ) ] pub fn dre ( & mut self ) -> DRE_W { DRE_W { w : self } } # [ doc = "Bit 1 - Transmit Complete Interrupt" ] # [ inline ( always ) ] pub fn txc ( & mut self ) -> TXC_W { TXC_W { w : self } } # [ doc = "Bit 2 - Receive Complete Interrupt" ] # [ inline ( always ) ] pub fn rxc ( & mut self ) -> RXC_W { RXC_W { w : self } } # [ doc = "Bit 3 - Receive Start Interrupt" ] # [ inline ( always ) ] pub fn rxs ( & mut self ) -> RXS_W { RXS_W { w : self } } # [ doc = "Bit 4 - Clear To Send Input Change Interrupt" ] # [ inline ( always ) ] pub fn ctsic ( & mut self ) -> CTSIC_W { CTSIC_W { w : self } } # [ doc = "Bit 5 - Break Received Interrupt" ] # [ inline ( always ) ] pub fn rxbrk ( & mut self ) -> RXBRK_W { RXBRK_W { w : self } } # [ doc = "Bit 7 - Combined Error Interrupt" ] # [ inline ( always ) ] pub fn error ( & mut self ) -> ERROR_W { ERROR_W { w : self } } } } # [ doc = "USART_INT Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u16 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { } # [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { } # [ doc = "USART_INT Status" ] pub mod status { # [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u16 , super :: STATUS > ; # [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u16 , super :: STATUS > ; # [ doc = "Register STATUS `reset()`'s with value 0" ] impl crate :: ResetValue for super :: STATUS { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `PERR`" ] pub type PERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PERR`" ] pub struct PERR_W < 'a > { w : & 'a mut W , } impl < 'a > PERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `FERR`" ] pub type FERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `FERR`" ] pub struct FERR_W < 'a > { w : & 'a mut W , } impl < 'a > FERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `BUFOVF`" ] pub type BUFOVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `BUFOVF`" ] pub struct BUFOVF_W < 'a > { w : & 'a mut W , } impl < 'a > BUFOVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Reader of field `CTS`" ] pub type CTS_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CTS`" ] pub struct CTS_W < 'a > { w : & 'a mut W , } impl < 'a > CTS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `ISF`" ] pub type ISF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ISF`" ] pub struct ISF_W < 'a > { w : & 'a mut W , } impl < 'a > ISF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `COLL`" ] pub type COLL_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COLL`" ] pub struct COLL_W < 'a > { w : & 'a mut W , } impl < 'a > COLL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `TXE`" ] pub type TXE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TXE`" ] pub struct TXE_W < 'a > { w : & 'a mut W , } impl < 'a > TXE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } } impl R { # [ doc = "Bit 0 - Parity Error" ] # [ inline ( always ) ] pub fn perr ( & self ) -> PERR_R { PERR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Frame Error" ] # [ inline ( always ) ] pub fn ferr ( & self ) -> FERR_R { FERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - Buffer Overflow" ] # [ inline ( always ) ] pub fn bufovf ( & self ) -> BUFOVF_R { BUFOVF_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Clear To Send" ] # [ inline ( always ) ] pub fn cts ( & self ) -> CTS_R { CTS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Inconsistent Sync Field" ] # [ inline ( always ) ] pub fn isf ( & self ) -> ISF_R { ISF_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Collision Detected" ] # [ inline ( always ) ] pub fn coll ( & self ) -> COLL_R { COLL_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Transmitter Empty" ] # [ inline ( always ) ] pub fn txe ( & self ) -> TXE_R { TXE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Parity Error" ] # [ inline ( always ) ] pub fn perr ( & mut self ) -> PERR_W { PERR_W { w : self } } # [ doc = "Bit 1 - Frame Error" ] # [ inline ( always ) ] pub fn ferr ( & mut self ) -> FERR_W { FERR_W { w : self } } # [ doc = "Bit 2 - Buffer Overflow" ] # [ inline ( always ) ] pub fn bufovf ( & mut self ) -> BUFOVF_W { BUFOVF_W { w : self } } # [ doc = "Bit 3 - Clear To Send" ] # [ inline ( always ) ] pub fn cts ( & mut self ) -> CTS_W { CTS_W { w : self } } # [ doc = "Bit 4 - Inconsistent Sync Field" ] # [ inline ( always ) ] pub fn isf ( & mut self ) -> ISF_W { ISF_W { w : self } } # [ doc = "Bit 5 - Collision Detected" ] # [ inline ( always ) ] pub fn coll ( & mut self ) -> COLL_W { COLL_W { w : self } } # [ doc = "Bit 6 - Transmitter Empty" ] # [ inline ( always ) ] pub fn txe ( & mut self ) -> TXE_W { TXE_W { w : self } } } } # [ doc = "USART_INT Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "USART_INT Synchronization Busy" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CTRLB`" ] pub type CTRLB_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - Software Reset Synchronization Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - SERCOM Enable Synchronization Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - CTRLB Synchronization Busy" ] # [ inline ( always ) ] pub fn ctrlb ( & self ) -> CTRLB_R { CTRLB_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } } } # [ doc = "USART_INT Data\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [data](data) module" ] pub type DATA = crate :: Reg < u16 , _DATA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DATA ; # [ doc = "`read()` method returns [data::R](data::R) reader structure" ] impl crate :: Readable for DATA { } # [ doc = "`write(|w| ..)` method takes [data::W](data::W) writer structure" ] impl crate :: Writable for DATA { } # [ doc = "USART_INT Data" ] pub mod data { # [ doc = "Reader of register DATA" ] pub type R = crate :: R < u16 , super :: DATA > ; # [ doc = "Writer for register DATA" ] pub type W = crate :: W < u16 , super :: DATA > ; # [ doc = "Register DATA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DATA { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DATA`" ] pub type DATA_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `DATA`" ] pub struct DATA_W < 'a > { w : & 'a mut W , } impl < 'a > DATA_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01ff ) | ( ( value as u16 ) & 0x01ff ) ; self . w } } impl R { # [ doc = "Bits 0:8 - Data Value" ] # [ inline ( always ) ] pub fn data ( & self ) -> DATA_R { DATA_R :: new ( ( self . bits & 0x01ff ) as u16 ) } } impl W { # [ doc = "Bits 0:8 - Data Value" ] # [ inline ( always ) ] pub fn data ( & mut self ) -> DATA_W { DATA_W { w : self } } } } # [ doc = "USART_INT Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "USART_INT Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGSTOP`" ] pub type DBGSTOP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGSTOP`" ] pub struct DBGSTOP_W < 'a > { w : & 'a mut W , } impl < 'a > DBGSTOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & self ) -> DBGSTOP_R { DBGSTOP_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Debug Mode" ] # [ inline ( always ) ] pub fn dbgstop ( & mut self ) -> DBGSTOP_W { DBGSTOP_W { w : self } } } } }
}
# [ doc = "Serial Communication Interface" ] pub struct SERCOM1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SERCOM1 { } impl SERCOM1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sercom0 :: RegisterBlock { 0x4200_0800 as * const _ } } impl Deref for SERCOM1 { type Target = sercom0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SERCOM1 :: ptr ( ) } } }
# [ doc = "Serial Communication Interface" ] pub struct SERCOM2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SERCOM2 { } impl SERCOM2 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sercom0 :: RegisterBlock { 0x4200_0c00 as * const _ } } impl Deref for SERCOM2 { type Target = sercom0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SERCOM2 :: ptr ( ) } } }
# [ doc = "Serial Communication Interface" ] pub struct SERCOM3 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SERCOM3 { } impl SERCOM3 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sercom0 :: RegisterBlock { 0x4200_1000 as * const _ } } impl Deref for SERCOM3 { type Target = sercom0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SERCOM3 :: ptr ( ) } } }
# [ doc = "Serial Communication Interface" ] pub struct SERCOM4 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SERCOM4 { } impl SERCOM4 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sercom0 :: RegisterBlock { 0x4200_1400 as * const _ } } impl Deref for SERCOM4 { type Target = sercom0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SERCOM4 :: ptr ( ) } } }
# [ doc = "Serial Communication Interface" ] pub struct SERCOM5 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SERCOM5 { } impl SERCOM5 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sercom0 :: RegisterBlock { 0x4200_1800 as * const _ } } impl Deref for SERCOM5 { type Target = sercom0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SERCOM5 :: ptr ( ) } } }
# [ doc = "Serial Communication Interface" ] pub struct SERCOM6 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SERCOM6 { } impl SERCOM6 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sercom0 :: RegisterBlock { 0x4300_0000 as * const _ } } impl Deref for SERCOM6 { type Target = sercom0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SERCOM6 :: ptr ( ) } } }
# [ doc = "Serial Communication Interface" ] pub struct SERCOM7 { _marker : PhantomData < * const ( ) > } unsafe impl Send for SERCOM7 { } impl SERCOM7 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sercom0 :: RegisterBlock { 0x4300_0400 as * const _ } } impl Deref for SERCOM7 { type Target = sercom0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SERCOM7 :: ptr ( ) } } }
# [ doc = "Supply Controller" ] pub struct SUPC { _marker : PhantomData < * const ( ) > } unsafe impl Send for SUPC { } impl SUPC { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const supc :: RegisterBlock { 0x4000_1800 as * const _ } } impl Deref for SUPC { type Target = supc :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SUPC :: ptr ( ) } } }
# [ doc = "Supply Controller" ] pub mod supc {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x04 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x08 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x0c - Power and Clocks Status" ] pub status : STATUS , # [ doc = "0x10 - BODVDD Control" ] pub bodvdd : BODVDD , _reserved5 : [ u8 ; 4usize ] , # [ doc = "0x18 - VREG Control" ] pub vreg : VREG , # [ doc = "0x1c - VREF Control" ] pub vref : VREF , # [ doc = "0x20 - VREG33 Control" ] pub vreg33 : VREG33 , }
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u32 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u32 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u32 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `BODVDDRDY`" ] pub type BODVDDRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BODVDDRDY`" ] pub struct BODVDDRDY_W < 'a > { w : & 'a mut W , } impl < 'a > BODVDDRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `BODVDDDET`" ] pub type BODVDDDET_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BODVDDDET`" ] pub struct BODVDDDET_W < 'a > { w : & 'a mut W , } impl < 'a > BODVDDDET_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `BVDDSRDY`" ] pub type BVDDSRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BVDDSRDY`" ] pub struct BVDDSRDY_W < 'a > { w : & 'a mut W , } impl < 'a > BVDDSRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `VREG33RDY`" ] pub type VREG33RDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `VREG33RDY`" ] pub struct VREG33RDY_W < 'a > { w : & 'a mut W , } impl < 'a > VREG33RDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - BODVDD Ready" ] # [ inline ( always ) ] pub fn bodvddrdy ( & self ) -> BODVDDRDY_R { BODVDDRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - BODVDD Detection" ] # [ inline ( always ) ] pub fn bodvdddet ( & self ) -> BODVDDDET_R { BODVDDDET_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - BODVDD Synchronization Ready" ] # [ inline ( always ) ] pub fn bvddsrdy ( & self ) -> BVDDSRDY_R { BVDDSRDY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - VREG33 Ready" ] # [ inline ( always ) ] pub fn vreg33rdy ( & self ) -> VREG33RDY_R { VREG33RDY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - BODVDD Ready" ] # [ inline ( always ) ] pub fn bodvddrdy ( & mut self ) -> BODVDDRDY_W { BODVDDRDY_W { w : self } }
# [ doc = "Bit 1 - BODVDD Detection" ] # [ inline ( always ) ] pub fn bodvdddet ( & mut self ) -> BODVDDDET_W { BODVDDDET_W { w : self } }
# [ doc = "Bit 2 - BODVDD Synchronization Ready" ] # [ inline ( always ) ] pub fn bvddsrdy ( & mut self ) -> BVDDSRDY_W { BVDDSRDY_W { w : self } }
# [ doc = "Bit 6 - VREG33 Ready" ] # [ inline ( always ) ] pub fn vreg33rdy ( & mut self ) -> VREG33RDY_W { VREG33RDY_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u32 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u32 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u32 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `BODVDDRDY`" ] pub type BODVDDRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BODVDDRDY`" ] pub struct BODVDDRDY_W < 'a > { w : & 'a mut W , } impl < 'a > BODVDDRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `BODVDDDET`" ] pub type BODVDDDET_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BODVDDDET`" ] pub struct BODVDDDET_W < 'a > { w : & 'a mut W , } impl < 'a > BODVDDDET_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `BVDDSRDY`" ] pub type BVDDSRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BVDDSRDY`" ] pub struct BVDDSRDY_W < 'a > { w : & 'a mut W , } impl < 'a > BVDDSRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `VREG33RDY`" ] pub type VREG33RDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `VREG33RDY`" ] pub struct VREG33RDY_W < 'a > { w : & 'a mut W , } impl < 'a > VREG33RDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - BODVDD Ready" ] # [ inline ( always ) ] pub fn bodvddrdy ( & self ) -> BODVDDRDY_R { BODVDDRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - BODVDD Detection" ] # [ inline ( always ) ] pub fn bodvdddet ( & self ) -> BODVDDDET_R { BODVDDDET_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - BODVDD Synchronization Ready" ] # [ inline ( always ) ] pub fn bvddsrdy ( & self ) -> BVDDSRDY_R { BVDDSRDY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - VREG33 Ready" ] # [ inline ( always ) ] pub fn vreg33rdy ( & self ) -> VREG33RDY_R { VREG33RDY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - BODVDD Ready" ] # [ inline ( always ) ] pub fn bodvddrdy ( & mut self ) -> BODVDDRDY_W { BODVDDRDY_W { w : self } }
# [ doc = "Bit 1 - BODVDD Detection" ] # [ inline ( always ) ] pub fn bodvdddet ( & mut self ) -> BODVDDDET_W { BODVDDDET_W { w : self } }
# [ doc = "Bit 2 - BODVDD Synchronization Ready" ] # [ inline ( always ) ] pub fn bvddsrdy ( & mut self ) -> BVDDSRDY_W { BVDDSRDY_W { w : self } }
# [ doc = "Bit 6 - VREG33 Ready" ] # [ inline ( always ) ] pub fn vreg33rdy ( & mut self ) -> VREG33RDY_W { VREG33RDY_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u32 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u32 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u32 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `BODVDDRDY`" ] pub type BODVDDRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BODVDDRDY`" ] pub struct BODVDDRDY_W < 'a > { w : & 'a mut W , } impl < 'a > BODVDDRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `BODVDDDET`" ] pub type BODVDDDET_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BODVDDDET`" ] pub struct BODVDDDET_W < 'a > { w : & 'a mut W , } impl < 'a > BODVDDDET_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `BVDDSRDY`" ] pub type BVDDSRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BVDDSRDY`" ] pub struct BVDDSRDY_W < 'a > { w : & 'a mut W , } impl < 'a > BVDDSRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `VREG33RDY`" ] pub type VREG33RDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `VREG33RDY`" ] pub struct VREG33RDY_W < 'a > { w : & 'a mut W , } impl < 'a > VREG33RDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - BODVDD Ready" ] # [ inline ( always ) ] pub fn bodvddrdy ( & self ) -> BODVDDRDY_R { BODVDDRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - BODVDD Detection" ] # [ inline ( always ) ] pub fn bodvdddet ( & self ) -> BODVDDDET_R { BODVDDDET_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - BODVDD Synchronization Ready" ] # [ inline ( always ) ] pub fn bvddsrdy ( & self ) -> BVDDSRDY_R { BVDDSRDY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - VREG33 Ready" ] # [ inline ( always ) ] pub fn vreg33rdy ( & self ) -> VREG33RDY_R { VREG33RDY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - BODVDD Ready" ] # [ inline ( always ) ] pub fn bodvddrdy ( & mut self ) -> BODVDDRDY_W { BODVDDRDY_W { w : self } }
# [ doc = "Bit 1 - BODVDD Detection" ] # [ inline ( always ) ] pub fn bodvdddet ( & mut self ) -> BODVDDDET_W { BODVDDDET_W { w : self } }
# [ doc = "Bit 2 - BODVDD Synchronization Ready" ] # [ inline ( always ) ] pub fn bvddsrdy ( & mut self ) -> BVDDSRDY_W { BVDDSRDY_W { w : self } }
# [ doc = "Bit 6 - VREG33 Ready" ] # [ inline ( always ) ] pub fn vreg33rdy ( & mut self ) -> VREG33RDY_W { VREG33RDY_W { w : self } }
}
}
# [ doc = "Power and Clocks Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u32 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ;
# [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { }
# [ doc = "Power and Clocks Status" ] pub mod status {
# [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u32 , super :: STATUS > ;
# [ doc = "Reader of field `BODVDDRDY`" ] pub type BODVDDRDY_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BODVDDDET`" ] pub type BODVDDDET_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `BVDDSRDY`" ] pub type BVDDSRDY_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `VREG33RDY`" ] pub type VREG33RDY_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - BODVDD Ready" ] # [ inline ( always ) ] pub fn bodvddrdy ( & self ) -> BODVDDRDY_R { BODVDDRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - BODVDD Detection" ] # [ inline ( always ) ] pub fn bodvdddet ( & self ) -> BODVDDDET_R { BODVDDDET_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - BODVDD Synchronization Ready" ] # [ inline ( always ) ] pub fn bvddsrdy ( & self ) -> BVDDSRDY_R { BVDDSRDY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - VREG33 Ready" ] # [ inline ( always ) ] pub fn vreg33rdy ( & self ) -> VREG33RDY_R { VREG33RDY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "BODVDD Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [bodvdd](bodvdd) module" ] pub type BODVDD = crate :: Reg < u32 , _BODVDD > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _BODVDD ;
# [ doc = "`read()` method returns [bodvdd::R](bodvdd::R) reader structure" ] impl crate :: Readable for BODVDD { }
# [ doc = "`write(|w| ..)` method takes [bodvdd::W](bodvdd::W) writer structure" ] impl crate :: Writable for BODVDD { }
# [ doc = "BODVDD Control" ] pub mod bodvdd {
# [ doc = "Reader of register BODVDD" ] pub type R = crate :: R < u32 , super :: BODVDD > ;
# [ doc = "Writer for register BODVDD" ] pub type W = crate :: W < u32 , super :: BODVDD > ;
# [ doc = "Register BODVDD `reset()`'s with value 0" ] impl crate :: ResetValue for super :: BODVDD { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `HYST`" ] pub type HYST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HYST`" ] pub struct HYST_W < 'a > { w : & 'a mut W , } impl < 'a > HYST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `ACTION`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ACTION_A { # [ doc = "No action" ] NONE , # [ doc = "The BODVDD generates a reset" ] RESET , # [ doc = "The BODVDD generates an interrupt" ] INT }
impl crate :: ToBits < u8 > for ACTION_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { ACTION_A :: NONE => 0 , ACTION_A :: RESET => 1 , ACTION_A :: INT => 2 } } }
# [ doc = "Reader of field `ACTION`" ] pub type ACTION_R = crate :: R < u8 , ACTION_A > ; impl ACTION_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , ACTION_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( ACTION_A :: NONE ) , 1 => Val ( ACTION_A :: RESET ) , 2 => Val ( ACTION_A :: INT ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == ACTION_A :: NONE } # [ doc = "Checks if the value of the field is `RESET`" ] # [ inline ( always ) ] pub fn is_reset ( & self ) -> bool { * self == ACTION_A :: RESET } # [ doc = "Checks if the value of the field is `INT`" ] # [ inline ( always ) ] pub fn is_int ( & self ) -> bool { * self == ACTION_A :: INT } }
# [ doc = "Write proxy for field `ACTION`" ] pub struct ACTION_W < 'a > { w : & 'a mut W , } impl < 'a > ACTION_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ACTION_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( ACTION_A :: NONE ) } # [ doc = "The BODVDD generates a reset" ] # [ inline ( always ) ] pub fn reset ( self ) -> & 'a mut W { self . variant ( ACTION_A :: RESET ) } # [ doc = "The BODVDD generates an interrupt" ] # [ inline ( always ) ] pub fn int ( self ) -> & 'a mut W { self . variant ( ACTION_A :: INT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 3 ) ) | ( ( ( value as u32 ) & 0x03 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `STDBYCFG`" ] pub type STDBYCFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `STDBYCFG`" ] pub struct STDBYCFG_W < 'a > { w : & 'a mut W , } impl < 'a > STDBYCFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ACTCFG`" ] pub type ACTCFG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ACTCFG`" ] pub struct ACTCFG_W < 'a > { w : & 'a mut W , } impl < 'a > ACTCFG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Possible values of the field `PSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PSEL_A { # [ doc = "Divide clock by 2" ] DIV2 , # [ doc = "Divide clock by 4" ] DIV4 , # [ doc = "Divide clock by 8" ] DIV8 , # [ doc = "Divide clock by 16" ] DIV16 , # [ doc = "Divide clock by 32" ] DIV32 , # [ doc = "Divide clock by 64" ] DIV64 , # [ doc = "Divide clock by 128" ] DIV128 , # [ doc = "Divide clock by 256" ] DIV256 , # [ doc = "Divide clock by 512" ] DIV512 , # [ doc = "Divide clock by 1024" ] DIV1024 , # [ doc = "Divide clock by 2048" ] DIV2048 , # [ doc = "Divide clock by 4096" ] DIV4096 , # [ doc = "Divide clock by 8192" ] DIV8192 , # [ doc = "Divide clock by 16384" ] DIV16384 , # [ doc = "Divide clock by 32768" ] DIV32768 , # [ doc = "Divide clock by 65536" ] DIV65536 }
impl crate :: ToBits < u8 > for PSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PSEL_A :: DIV2 => 0 , PSEL_A :: DIV4 => 1 , PSEL_A :: DIV8 => 2 , PSEL_A :: DIV16 => 3 , PSEL_A :: DIV32 => 4 , PSEL_A :: DIV64 => 5 , PSEL_A :: DIV128 => 6 , PSEL_A :: DIV256 => 7 , PSEL_A :: DIV512 => 8 , PSEL_A :: DIV1024 => 9 , PSEL_A :: DIV2048 => 10 , PSEL_A :: DIV4096 => 11 , PSEL_A :: DIV8192 => 12 , PSEL_A :: DIV16384 => 13 , PSEL_A :: DIV32768 => 14 , PSEL_A :: DIV65536 => 15 } } }
# [ doc = "Reader of field `PSEL`" ] pub type PSEL_R = crate :: R < u8 , PSEL_A > ; impl PSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PSEL_A { match self . bits { 0 => PSEL_A :: DIV2 , 1 => PSEL_A :: DIV4 , 2 => PSEL_A :: DIV8 , 3 => PSEL_A :: DIV16 , 4 => PSEL_A :: DIV32 , 5 => PSEL_A :: DIV64 , 6 => PSEL_A :: DIV128 , 7 => PSEL_A :: DIV256 , 8 => PSEL_A :: DIV512 , 9 => PSEL_A :: DIV1024 , 10 => PSEL_A :: DIV2048 , 11 => PSEL_A :: DIV4096 , 12 => PSEL_A :: DIV8192 , 13 => PSEL_A :: DIV16384 , 14 => PSEL_A :: DIV32768 , 15 => PSEL_A :: DIV65536 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PSEL_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PSEL_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PSEL_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PSEL_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV32`" ] # [ inline ( always ) ] pub fn is_div32 ( & self ) -> bool { * self == PSEL_A :: DIV32 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PSEL_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV128`" ] # [ inline ( always ) ] pub fn is_div128 ( & self ) -> bool { * self == PSEL_A :: DIV128 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PSEL_A :: DIV256 } # [ doc = "Checks if the value of the field is `DIV512`" ] # [ inline ( always ) ] pub fn is_div512 ( & self ) -> bool { * self == PSEL_A :: DIV512 } # [ doc = "Checks if the value of the field is `DIV1024`" ] # [ inline ( always ) ] pub fn is_div1024 ( & self ) -> bool { * self == PSEL_A :: DIV1024 } # [ doc = "Checks if the value of the field is `DIV2048`" ] # [ inline ( always ) ] pub fn is_div2048 ( & self ) -> bool { * self == PSEL_A :: DIV2048 } # [ doc = "Checks if the value of the field is `DIV4096`" ] # [ inline ( always ) ] pub fn is_div4096 ( & self ) -> bool { * self == PSEL_A :: DIV4096 } # [ doc = "Checks if the value of the field is `DIV8192`" ] # [ inline ( always ) ] pub fn is_div8192 ( & self ) -> bool { * self == PSEL_A :: DIV8192 } # [ doc = "Checks if the value of the field is `DIV16384`" ] # [ inline ( always ) ] pub fn is_div16384 ( & self ) -> bool { * self == PSEL_A :: DIV16384 } # [ doc = "Checks if the value of the field is `DIV32768`" ] # [ inline ( always ) ] pub fn is_div32768 ( & self ) -> bool { * self == PSEL_A :: DIV32768 } # [ doc = "Checks if the value of the field is `DIV65536`" ] # [ inline ( always ) ] pub fn is_div65536 ( & self ) -> bool { * self == PSEL_A :: DIV65536 } }
# [ doc = "Write proxy for field `PSEL`" ] pub struct PSEL_W < 'a > { w : & 'a mut W , } impl < 'a > PSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Divide clock by 2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV2 ) } # [ doc = "Divide clock by 4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV4 ) } # [ doc = "Divide clock by 8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV8 ) } # [ doc = "Divide clock by 16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV16 ) } # [ doc = "Divide clock by 32" ] # [ inline ( always ) ] pub fn div32 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV32 ) } # [ doc = "Divide clock by 64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV64 ) } # [ doc = "Divide clock by 128" ] # [ inline ( always ) ] pub fn div128 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV128 ) } # [ doc = "Divide clock by 256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV256 ) } # [ doc = "Divide clock by 512" ] # [ inline ( always ) ] pub fn div512 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV512 ) } # [ doc = "Divide clock by 1024" ] # [ inline ( always ) ] pub fn div1024 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV1024 ) } # [ doc = "Divide clock by 2048" ] # [ inline ( always ) ] pub fn div2048 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV2048 ) } # [ doc = "Divide clock by 4096" ] # [ inline ( always ) ] pub fn div4096 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV4096 ) } # [ doc = "Divide clock by 8192" ] # [ inline ( always ) ] pub fn div8192 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV8192 ) } # [ doc = "Divide clock by 16384" ] # [ inline ( always ) ] pub fn div16384 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV16384 ) } # [ doc = "Divide clock by 32768" ] # [ inline ( always ) ] pub fn div32768 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV32768 ) } # [ doc = "Divide clock by 65536" ] # [ inline ( always ) ] pub fn div65536 ( self ) -> & 'a mut W { self . variant ( PSEL_A :: DIV65536 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 12 ) ) | ( ( ( value as u32 ) & 0x0f ) << 12 ) ; self . w } }
# [ doc = "Reader of field `LEVEL`" ] pub type LEVEL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `LEVEL`" ] pub struct LEVEL_W < 'a > { w : & 'a mut W , } impl < 'a > LEVEL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 16 ) ) | ( ( ( value as u32 ) & 0x3f ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Hysteresis Enable" ] # [ inline ( always ) ] pub fn hyst ( & self ) -> HYST_R { HYST_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 3:4 - Action when Threshold Crossed" ] # [ inline ( always ) ] pub fn action ( & self ) -> ACTION_R { ACTION_R :: new ( ( ( self . bits >> 3 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 5 - Configuration in Standby mode" ] # [ inline ( always ) ] pub fn stdbycfg ( & self ) -> STDBYCFG_R { STDBYCFG_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Configuration in Active mode" ] # [ inline ( always ) ] pub fn actcfg ( & self ) -> ACTCFG_R { ACTCFG_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:15 - Prescaler Select" ] # [ inline ( always ) ] pub fn psel ( & self ) -> PSEL_R { PSEL_R :: new ( ( ( self . bits >> 12 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 16:21 - Threshold Level for VDD" ] # [ inline ( always ) ] pub fn level ( & self ) -> LEVEL_R { LEVEL_R :: new ( ( ( self . bits >> 16 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 2 - Hysteresis Enable" ] # [ inline ( always ) ] pub fn hyst ( & mut self ) -> HYST_W { HYST_W { w : self } }
# [ doc = "Bits 3:4 - Action when Threshold Crossed" ] # [ inline ( always ) ] pub fn action ( & mut self ) -> ACTION_W { ACTION_W { w : self } }
# [ doc = "Bit 5 - Configuration in Standby mode" ] # [ inline ( always ) ] pub fn stdbycfg ( & mut self ) -> STDBYCFG_W { STDBYCFG_W { w : self } }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 8 - Configuration in Active mode" ] # [ inline ( always ) ] pub fn actcfg ( & mut self ) -> ACTCFG_W { ACTCFG_W { w : self } }
# [ doc = "Bits 12:15 - Prescaler Select" ] # [ inline ( always ) ] pub fn psel ( & mut self ) -> PSEL_W { PSEL_W { w : self } }
# [ doc = "Bits 16:21 - Threshold Level for VDD" ] # [ inline ( always ) ] pub fn level ( & mut self ) -> LEVEL_W { LEVEL_W { w : self } }
}
}
# [ doc = "VREG Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [vreg](vreg) module" ] pub type VREG = crate :: Reg < u32 , _VREG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _VREG ;
# [ doc = "`read()` method returns [vreg::R](vreg::R) reader structure" ] impl crate :: Readable for VREG { }
# [ doc = "`write(|w| ..)` method takes [vreg::W](vreg::W) writer structure" ] impl crate :: Writable for VREG { }
# [ doc = "VREG Control" ] pub mod vreg {
# [ doc = "Reader of register VREG" ] pub type R = crate :: R < u32 , super :: VREG > ;
# [ doc = "Writer for register VREG" ] pub type W = crate :: W < u32 , super :: VREG > ;
# [ doc = "Register VREG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: VREG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
}
}
# [ doc = "VREF Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [vref](vref) module" ] pub type VREF = crate :: Reg < u32 , _VREF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _VREF ;
# [ doc = "`read()` method returns [vref::R](vref::R) reader structure" ] impl crate :: Readable for VREF { }
# [ doc = "`write(|w| ..)` method takes [vref::W](vref::W) writer structure" ] impl crate :: Writable for VREF { }
# [ doc = "VREF Control" ] pub mod vref {
# [ doc = "Reader of register VREF" ] pub type R = crate :: R < u32 , super :: VREF > ;
# [ doc = "Writer for register VREF" ] pub type W = crate :: W < u32 , super :: VREF > ;
# [ doc = "Register VREF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: VREF { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `TSEN`" ] pub type TSEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TSEN`" ] pub struct TSEN_W < 'a > { w : & 'a mut W , } impl < 'a > TSEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `VREFOE`" ] pub type VREFOE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `VREFOE`" ] pub struct VREFOE_W < 'a > { w : & 'a mut W , } impl < 'a > VREFOE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `SEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SEL_A { # [ doc = "1.024V voltage reference typical value" ] _1V024 , # [ doc = "2.048V voltage reference typical value" ] _2V048 , # [ doc = "4.096V voltage reference typical value" ] _4V096 }
impl crate :: ToBits < u8 > for SEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SEL_A :: _1V024 => 0 , SEL_A :: _2V048 => 2 , SEL_A :: _4V096 => 3 } } }
# [ doc = "Reader of field `SEL`" ] pub type SEL_R = crate :: R < u8 , SEL_A > ; impl SEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , SEL_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( SEL_A :: _1V024 ) , 2 => Val ( SEL_A :: _2V048 ) , 3 => Val ( SEL_A :: _4V096 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `_1V024`" ] # [ inline ( always ) ] pub fn is_1v024 ( & self ) -> bool { * self == SEL_A :: _1V024 } # [ doc = "Checks if the value of the field is `_2V048`" ] # [ inline ( always ) ] pub fn is_2v048 ( & self ) -> bool { * self == SEL_A :: _2V048 } # [ doc = "Checks if the value of the field is `_4V096`" ] # [ inline ( always ) ] pub fn is_4v096 ( & self ) -> bool { * self == SEL_A :: _4V096 } }
# [ doc = "Write proxy for field `SEL`" ] pub struct SEL_W < 'a > { w : & 'a mut W , } impl < 'a > SEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SEL_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "1.024V voltage reference typical value" ] # [ inline ( always ) ] pub fn _1v024 ( self ) -> & 'a mut W { self . variant ( SEL_A :: _1V024 ) } # [ doc = "2.048V voltage reference typical value" ] # [ inline ( always ) ] pub fn _2v048 ( self ) -> & 'a mut W { self . variant ( SEL_A :: _2V048 ) } # [ doc = "4.096V voltage reference typical value" ] # [ inline ( always ) ] pub fn _4v096 ( self ) -> & 'a mut W { self . variant ( SEL_A :: _4V096 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 16 ) ) | ( ( ( value as u32 ) & 0x0f ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Temperature Sensor Output Enable" ] # [ inline ( always ) ] pub fn tsen ( & self ) -> TSEN_R { TSEN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Voltage Reference Output Enable" ] # [ inline ( always ) ] pub fn vrefoe ( & self ) -> VREFOE_R { VREFOE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:19 - Voltage Reference Selection" ] # [ inline ( always ) ] pub fn sel ( & self ) -> SEL_R { SEL_R :: new ( ( ( self . bits >> 16 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bit 1 - Temperature Sensor Output Enable" ] # [ inline ( always ) ] pub fn tsen ( & mut self ) -> TSEN_W { TSEN_W { w : self } }
# [ doc = "Bit 2 - Voltage Reference Output Enable" ] # [ inline ( always ) ] pub fn vrefoe ( & mut self ) -> VREFOE_W { VREFOE_W { w : self } }
# [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bit 7 - On Demand Control" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } }
# [ doc = "Bits 16:19 - Voltage Reference Selection" ] # [ inline ( always ) ] pub fn sel ( & mut self ) -> SEL_W { SEL_W { w : self } }
}
}
# [ doc = "VREG33 Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [vreg33](vreg33) module" ] pub type VREG33 = crate :: Reg < u32 , _VREG33 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _VREG33 ;
# [ doc = "`read()` method returns [vreg33::R](vreg33::R) reader structure" ] impl crate :: Readable for VREG33 { }
# [ doc = "`write(|w| ..)` method takes [vreg33::W](vreg33::W) writer structure" ] impl crate :: Writable for VREG33 { }
# [ doc = "VREG33 Control" ] pub mod vreg33 {
# [ doc = "Reader of register VREG33" ] pub type R = crate :: R < u32 , super :: VREG33 > ;
# [ doc = "Writer for register VREG33" ] pub type W = crate :: W < u32 , super :: VREG33 > ;
# [ doc = "Register VREG33 `reset()`'s with value 0x10" ] impl crate :: ResetValue for super :: VREG33 { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x10 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `ENRDY`" ] pub type ENRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENRDY`" ] pub struct ENRDY_W < 'a > { w : & 'a mut W , } impl < 'a > ENRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `BYPASS`" ] pub type BYPASS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BYPASS`" ] pub struct BYPASS_W < 'a > { w : & 'a mut W , } impl < 'a > BYPASS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `ISOEN`" ] pub type ISOEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ISOEN`" ] pub struct ISOEN_W < 'a > { w : & 'a mut W , } impl < 'a > ISOEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - VREG33 Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - VREG33 Ready Enable" ] # [ inline ( always ) ] pub fn enrdy ( & self ) -> ENRDY_R { ENRDY_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - VREG33 Bypass" ] # [ inline ( always ) ] pub fn bypass ( & self ) -> BYPASS_R { BYPASS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Isolation Enable" ] # [ inline ( always ) ] pub fn isoen ( & self ) -> ISOEN_R { ISOEN_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - VREG33 Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 2 - VREG33 Ready Enable" ] # [ inline ( always ) ] pub fn enrdy ( & mut self ) -> ENRDY_W { ENRDY_W { w : self } }
# [ doc = "Bit 3 - VREG33 Bypass" ] # [ inline ( always ) ] pub fn bypass ( & mut self ) -> BYPASS_W { BYPASS_W { w : self } }
# [ doc = "Bit 4 - Isolation Enable" ] # [ inline ( always ) ] pub fn isoen ( & mut self ) -> ISOEN_W { ISOEN_W { w : self } }
}
}
}
# [ doc = "Basic Timer Counter" ] pub struct TC0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TC0 { } impl TC0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tc0 :: RegisterBlock { 0x4200_3000 as * const _ } } impl Deref for TC0 { type Target = tc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TC0 :: ptr ( ) } } }
# [ doc = "Basic Timer Counter" ] pub mod tc0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved_0_count8 : [ u8 ; 56usize ] , } impl RegisterBlock { # [ doc = "0x00 - 32-bit Counter Mode" ] # [ inline ( always ) ] pub fn count32 ( & self ) -> & COUNT32 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const COUNT32 ) } } # [ doc = "0x00 - 32-bit Counter Mode" ] # [ inline ( always ) ] pub fn count32_mut ( & self ) -> & mut COUNT32 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut COUNT32 ) } } # [ doc = "0x00 - 16-bit Counter Mode" ] # [ inline ( always ) ] pub fn count16 ( & self ) -> & COUNT16 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const COUNT16 ) } } # [ doc = "0x00 - 16-bit Counter Mode" ] # [ inline ( always ) ] pub fn count16_mut ( & self ) -> & mut COUNT16 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut COUNT16 ) } } # [ doc = "0x00 - 8-bit Counter Mode" ] # [ inline ( always ) ] pub fn count8 ( & self ) -> & COUNT8 { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 0usize ) as * const COUNT8 ) } } # [ doc = "0x00 - 8-bit Counter Mode" ] # [ inline ( always ) ] pub fn count8_mut ( & self ) -> & mut COUNT8 { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 0usize ) as * mut COUNT8 ) } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct COUNT8 { # [ doc = "0x00 - Control A" ] pub ctrla : self::count8::CTRLA , # [ doc = "0x04 - Control B Clear" ] pub ctrlbclr : self::count8::CTRLBCLR , # [ doc = "0x05 - Control B Set" ] pub ctrlbset : self::count8::CTRLBSET , # [ doc = "0x06 - Event Control" ] pub evctrl : self::count8::EVCTRL , # [ doc = "0x08 - Interrupt Enable Clear" ] pub intenclr : self::count8::INTENCLR , # [ doc = "0x09 - Interrupt Enable Set" ] pub intenset : self::count8::INTENSET , # [ doc = "0x0a - Interrupt Flag Status and Clear" ] pub intflag : self::count8::INTFLAG , # [ doc = "0x0b - Status" ] pub status : self::count8::STATUS , # [ doc = "0x0c - Waveform Generation Control" ] pub wave : self::count8::WAVE , # [ doc = "0x0d - Control C" ] pub drvctrl : self::count8::DRVCTRL , _reserved10 : [ u8 ; 1usize ] , # [ doc = "0x0f - Debug Control" ] pub dbgctrl : self::count8::DBGCTRL , # [ doc = "0x10 - Synchronization Status" ] pub syncbusy : self::count8::SYNCBUSY , # [ doc = "0x14 - COUNT8 Count" ] pub count : self::count8::COUNT , _reserved13 : [ u8 ; 6usize ] , # [ doc = "0x1b - COUNT8 Period" ] pub per : self::count8::PER , # [ doc = "0x1c - COUNT8 Compare and Capture" ] pub cc : [ self::count8::CC ; 2 ] , _reserved15 : [ u8 ; 17usize ] , # [ doc = "0x2f - COUNT8 Period Buffer" ] pub perbuf : self::count8::PERBUF , # [ doc = "0x30 - COUNT8 Compare and Capture Buffer" ] pub ccbuf : [ self::count8::CCBUF ; 2 ] , } # [ doc = r"Register block" ] # [ doc = "8-bit Counter Mode" ] pub mod count8 { # [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "Counter in 16-bit mode" ] COUNT16 , # [ doc = "Counter in 8-bit mode" ] COUNT8 , # [ doc = "Counter in 32-bit mode" ] COUNT32 } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: COUNT16 => 0 , MODE_A :: COUNT8 => 1 , MODE_A :: COUNT32 => 2 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: COUNT16 ) , 1 => Val ( MODE_A :: COUNT8 ) , 2 => Val ( MODE_A :: COUNT32 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `COUNT16`" ] # [ inline ( always ) ] pub fn is_count16 ( & self ) -> bool { * self == MODE_A :: COUNT16 } # [ doc = "Checks if the value of the field is `COUNT8`" ] # [ inline ( always ) ] pub fn is_count8 ( & self ) -> bool { * self == MODE_A :: COUNT8 } # [ doc = "Checks if the value of the field is `COUNT32`" ] # [ inline ( always ) ] pub fn is_count32 ( & self ) -> bool { * self == MODE_A :: COUNT32 } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Counter in 16-bit mode" ] # [ inline ( always ) ] pub fn count16 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT16 ) } # [ doc = "Counter in 8-bit mode" ] # [ inline ( always ) ] pub fn count8 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT8 ) } # [ doc = "Counter in 32-bit mode" ] # [ inline ( always ) ] pub fn count32 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT32 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u32 ) & 0x03 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `PRESCSYNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCSYNC_A { # [ doc = "Reload or reset the counter on next generic clock" ] GCLK , # [ doc = "Reload or reset the counter on next prescaler clock" ] PRESC , # [ doc = "Reload or reset the counter on next generic clock and reset the prescaler counter" ] RESYNC } impl crate :: ToBits < u8 > for PRESCSYNC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCSYNC_A :: GCLK => 0 , PRESCSYNC_A :: PRESC => 1 , PRESCSYNC_A :: RESYNC => 2 } } } # [ doc = "Reader of field `PRESCSYNC`" ] pub type PRESCSYNC_R = crate :: R < u8 , PRESCSYNC_A > ; impl PRESCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PRESCSYNC_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PRESCSYNC_A :: GCLK ) , 1 => Val ( PRESCSYNC_A :: PRESC ) , 2 => Val ( PRESCSYNC_A :: RESYNC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK`" ] # [ inline ( always ) ] pub fn is_gclk ( & self ) -> bool { * self == PRESCSYNC_A :: GCLK } # [ doc = "Checks if the value of the field is `PRESC`" ] # [ inline ( always ) ] pub fn is_presc ( & self ) -> bool { * self == PRESCSYNC_A :: PRESC } # [ doc = "Checks if the value of the field is `RESYNC`" ] # [ inline ( always ) ] pub fn is_resync ( & self ) -> bool { * self == PRESCSYNC_A :: RESYNC } } # [ doc = "Write proxy for field `PRESCSYNC`" ] pub struct PRESCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCSYNC_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Reload or reset the counter on next generic clock" ] # [ inline ( always ) ] pub fn gclk ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: GCLK ) } # [ doc = "Reload or reset the counter on next prescaler clock" ] # [ inline ( always ) ] pub fn presc ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: PRESC ) } # [ doc = "Reload or reset the counter on next generic clock and reset the prescaler counter" ] # [ inline ( always ) ] pub fn resync ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: RESYNC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } } # [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Possible values of the field `PRESCALER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER_A { # [ doc = "Prescaler: GCLK_TC" ] DIV1 , # [ doc = "Prescaler: GCLK_TC/2" ] DIV2 , # [ doc = "Prescaler: GCLK_TC/4" ] DIV4 , # [ doc = "Prescaler: GCLK_TC/8" ] DIV8 , # [ doc = "Prescaler: GCLK_TC/16" ] DIV16 , # [ doc = "Prescaler: GCLK_TC/64" ] DIV64 , # [ doc = "Prescaler: GCLK_TC/256" ] DIV256 , # [ doc = "Prescaler: GCLK_TC/1024" ] DIV1024 } impl crate :: ToBits < u8 > for PRESCALER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER_A :: DIV1 => 0 , PRESCALER_A :: DIV2 => 1 , PRESCALER_A :: DIV4 => 2 , PRESCALER_A :: DIV8 => 3 , PRESCALER_A :: DIV16 => 4 , PRESCALER_A :: DIV64 => 5 , PRESCALER_A :: DIV256 => 6 , PRESCALER_A :: DIV1024 => 7 } } } # [ doc = "Reader of field `PRESCALER`" ] pub type PRESCALER_R = crate :: R < u8 , PRESCALER_A > ; impl PRESCALER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV1024 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == PRESCALER_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER_A :: DIV256 } # [ doc = "Checks if the value of the field is `DIV1024`" ] # [ inline ( always ) ] pub fn is_div1024 ( & self ) -> bool { * self == PRESCALER_A :: DIV1024 } } # [ doc = "Write proxy for field `PRESCALER`" ] pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Prescaler: GCLK_TC" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1 ) } # [ doc = "Prescaler: GCLK_TC/2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV2 ) } # [ doc = "Prescaler: GCLK_TC/4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV4 ) } # [ doc = "Prescaler: GCLK_TC/8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV8 ) } # [ doc = "Prescaler: GCLK_TC/16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV16 ) } # [ doc = "Prescaler: GCLK_TC/64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV64 ) } # [ doc = "Prescaler: GCLK_TC/256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV256 ) } # [ doc = "Prescaler: GCLK_TC/1024" ] # [ inline ( always ) ] pub fn div1024 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u32 ) & 0x07 ) << 8 ) ; self . w } } # [ doc = "Reader of field `ALOCK`" ] pub type ALOCK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ALOCK`" ] pub struct ALOCK_W < 'a > { w : & 'a mut W , } impl < 'a > ALOCK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } } # [ doc = "Reader of field `CAPTEN0`" ] pub type CAPTEN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CAPTEN0`" ] pub struct CAPTEN0_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `CAPTEN1`" ] pub type CAPTEN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CAPTEN1`" ] pub struct CAPTEN1_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Reader of field `COPEN0`" ] pub type COPEN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COPEN0`" ] pub struct COPEN0_W < 'a > { w : & 'a mut W , } impl < 'a > COPEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } } # [ doc = "Reader of field `COPEN1`" ] pub type COPEN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COPEN1`" ] pub struct COPEN1_W < 'a > { w : & 'a mut W , } impl < 'a > COPEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } } # [ doc = "Possible values of the field `CAPTMODE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAPTMODE0_A { # [ doc = "Default capture" ] DEFAULT , # [ doc = "Minimum capture" ] CAPTMIN , # [ doc = "Maximum capture" ] CAPTMAX } impl crate :: ToBits < u8 > for CAPTMODE0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CAPTMODE0_A :: DEFAULT => 0 , CAPTMODE0_A :: CAPTMIN => 1 , CAPTMODE0_A :: CAPTMAX => 2 } } } # [ doc = "Reader of field `CAPTMODE0`" ] pub type CAPTMODE0_R = crate :: R < u8 , CAPTMODE0_A > ; impl CAPTMODE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CAPTMODE0_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CAPTMODE0_A :: DEFAULT ) , 1 => Val ( CAPTMODE0_A :: CAPTMIN ) , 2 => Val ( CAPTMODE0_A :: CAPTMAX ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DEFAULT`" ] # [ inline ( always ) ] pub fn is_default ( & self ) -> bool { * self == CAPTMODE0_A :: DEFAULT } # [ doc = "Checks if the value of the field is `CAPTMIN`" ] # [ inline ( always ) ] pub fn is_captmin ( & self ) -> bool { * self == CAPTMODE0_A :: CAPTMIN } # [ doc = "Checks if the value of the field is `CAPTMAX`" ] # [ inline ( always ) ] pub fn is_captmax ( & self ) -> bool { * self == CAPTMODE0_A :: CAPTMAX } } # [ doc = "Write proxy for field `CAPTMODE0`" ] pub struct CAPTMODE0_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTMODE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAPTMODE0_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Default capture" ] # [ inline ( always ) ] pub fn default ( self ) -> & 'a mut W { self . variant ( CAPTMODE0_A :: DEFAULT ) } # [ doc = "Minimum capture" ] # [ inline ( always ) ] pub fn captmin ( self ) -> & 'a mut W { self . variant ( CAPTMODE0_A :: CAPTMIN ) } # [ doc = "Maximum capture" ] # [ inline ( always ) ] pub fn captmax ( self ) -> & 'a mut W { self . variant ( CAPTMODE0_A :: CAPTMAX ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 24 ) ) | ( ( ( value as u32 ) & 0x03 ) << 24 ) ; self . w } } # [ doc = "Possible values of the field `CAPTMODE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAPTMODE1_A { # [ doc = "Default capture" ] DEFAULT , # [ doc = "Minimum capture" ] CAPTMIN , # [ doc = "Maximum capture" ] CAPTMAX } impl crate :: ToBits < u8 > for CAPTMODE1_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CAPTMODE1_A :: DEFAULT => 0 , CAPTMODE1_A :: CAPTMIN => 1 , CAPTMODE1_A :: CAPTMAX => 2 } } } # [ doc = "Reader of field `CAPTMODE1`" ] pub type CAPTMODE1_R = crate :: R < u8 , CAPTMODE1_A > ; impl CAPTMODE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CAPTMODE1_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CAPTMODE1_A :: DEFAULT ) , 1 => Val ( CAPTMODE1_A :: CAPTMIN ) , 2 => Val ( CAPTMODE1_A :: CAPTMAX ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DEFAULT`" ] # [ inline ( always ) ] pub fn is_default ( & self ) -> bool { * self == CAPTMODE1_A :: DEFAULT } # [ doc = "Checks if the value of the field is `CAPTMIN`" ] # [ inline ( always ) ] pub fn is_captmin ( & self ) -> bool { * self == CAPTMODE1_A :: CAPTMIN } # [ doc = "Checks if the value of the field is `CAPTMAX`" ] # [ inline ( always ) ] pub fn is_captmax ( & self ) -> bool { * self == CAPTMODE1_A :: CAPTMAX } } # [ doc = "Write proxy for field `CAPTMODE1`" ] pub struct CAPTMODE1_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTMODE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAPTMODE1_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Default capture" ] # [ inline ( always ) ] pub fn default ( self ) -> & 'a mut W { self . variant ( CAPTMODE1_A :: DEFAULT ) } # [ doc = "Minimum capture" ] # [ inline ( always ) ] pub fn captmin ( self ) -> & 'a mut W { self . variant ( CAPTMODE1_A :: CAPTMIN ) } # [ doc = "Maximum capture" ] # [ inline ( always ) ] pub fn captmax ( self ) -> & 'a mut W { self . variant ( CAPTMODE1_A :: CAPTMAX ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 27 ) ) | ( ( ( value as u32 ) & 0x03 ) << 27 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:3 - Timer Counter Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) } # [ doc = "Bits 4:5 - Prescaler and Counter Synchronization" ] # [ inline ( always ) ] pub fn prescsync ( & self ) -> PRESCSYNC_R { PRESCSYNC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) } # [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Clock On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bits 8:10 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) } # [ doc = "Bit 11 - Auto Lock" ] # [ inline ( always ) ] pub fn alock ( & self ) -> ALOCK_R { ALOCK_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - Capture Channel 0 Enable" ] # [ inline ( always ) ] pub fn capten0 ( & self ) -> CAPTEN0_R { CAPTEN0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - Capture Channel 1 Enable" ] # [ inline ( always ) ] pub fn capten1 ( & self ) -> CAPTEN1_R { CAPTEN1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bit 20 - Capture On Pin 0 Enable" ] # [ inline ( always ) ] pub fn copen0 ( & self ) -> COPEN0_R { COPEN0_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) } # [ doc = "Bit 21 - Capture On Pin 1 Enable" ] # [ inline ( always ) ] pub fn copen1 ( & self ) -> COPEN1_R { COPEN1_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) } # [ doc = "Bits 24:25 - Capture Mode Channel 0" ] # [ inline ( always ) ] pub fn captmode0 ( & self ) -> CAPTMODE0_R { CAPTMODE0_R :: new ( ( ( self . bits >> 24 ) & 0x03 ) as u8 ) } # [ doc = "Bits 27:28 - Capture mode Channel 1" ] # [ inline ( always ) ] pub fn captmode1 ( & self ) -> CAPTMODE1_R { CAPTMODE1_R :: new ( ( ( self . bits >> 27 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:3 - Timer Counter Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bits 4:5 - Prescaler and Counter Synchronization" ] # [ inline ( always ) ] pub fn prescsync ( & mut self ) -> PRESCSYNC_W { PRESCSYNC_W { w : self } } # [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } } # [ doc = "Bit 7 - Clock On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } } # [ doc = "Bits 8:10 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } } # [ doc = "Bit 11 - Auto Lock" ] # [ inline ( always ) ] pub fn alock ( & mut self ) -> ALOCK_W { ALOCK_W { w : self } } # [ doc = "Bit 16 - Capture Channel 0 Enable" ] # [ inline ( always ) ] pub fn capten0 ( & mut self ) -> CAPTEN0_W { CAPTEN0_W { w : self } } # [ doc = "Bit 17 - Capture Channel 1 Enable" ] # [ inline ( always ) ] pub fn capten1 ( & mut self ) -> CAPTEN1_W { CAPTEN1_W { w : self } } # [ doc = "Bit 20 - Capture On Pin 0 Enable" ] # [ inline ( always ) ] pub fn copen0 ( & mut self ) -> COPEN0_W { COPEN0_W { w : self } } # [ doc = "Bit 21 - Capture On Pin 1 Enable" ] # [ inline ( always ) ] pub fn copen1 ( & mut self ) -> COPEN1_W { COPEN1_W { w : self } } # [ doc = "Bits 24:25 - Capture Mode Channel 0" ] # [ inline ( always ) ] pub fn captmode0 ( & mut self ) -> CAPTMODE0_W { CAPTMODE0_W { w : self } } # [ doc = "Bits 27:28 - Capture mode Channel 1" ] # [ inline ( always ) ] pub fn captmode1 ( & mut self ) -> CAPTMODE1_W { CAPTMODE1_W { w : self } } } } # [ doc = "Control B Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlbclr](ctrlbclr) module" ] pub type CTRLBCLR = crate :: Reg < u8 , _CTRLBCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLBCLR ; # [ doc = "`read()` method returns [ctrlbclr::R](ctrlbclr::R) reader structure" ] impl crate :: Readable for CTRLBCLR { } # [ doc = "`write(|w| ..)` method takes [ctrlbclr::W](ctrlbclr::W) writer structure" ] impl crate :: Writable for CTRLBCLR { } # [ doc = "Control B Clear" ] pub mod ctrlbclr { # [ doc = "Reader of register CTRLBCLR" ] pub type R = crate :: R < u8 , super :: CTRLBCLR > ; # [ doc = "Writer for register CTRLBCLR" ] pub type W = crate :: W < u8 , super :: CTRLBCLR > ; # [ doc = "Register CTRLBCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLBCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DIR`" ] pub type DIR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DIR`" ] pub struct DIR_W < 'a > { w : & 'a mut W , } impl < 'a > DIR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LUPD`" ] pub type LUPD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LUPD`" ] pub struct LUPD_W < 'a > { w : & 'a mut W , } impl < 'a > LUPD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ONESHOT`" ] pub type ONESHOT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ONESHOT`" ] pub struct ONESHOT_W < 'a > { w : & 'a mut W , } impl < 'a > ONESHOT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "No action" ] NONE , # [ doc = "Force a start, restart or retrigger" ] RETRIGGER , # [ doc = "Force a stop" ] STOP , # [ doc = "Force update of double-buffered register" ] UPDATE , # [ doc = "Force a read synchronization of COUNT" ] READSYNC , # [ doc = "One-shot DMA trigger" ] DMAOS } impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: NONE => 0 , CMD_A :: RETRIGGER => 1 , CMD_A :: STOP => 2 , CMD_A :: UPDATE => 3 , CMD_A :: READSYNC => 4 , CMD_A :: DMAOS => 5 } } } # [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CMD_A :: NONE ) , 1 => Val ( CMD_A :: RETRIGGER ) , 2 => Val ( CMD_A :: STOP ) , 3 => Val ( CMD_A :: UPDATE ) , 4 => Val ( CMD_A :: READSYNC ) , 5 => Val ( CMD_A :: DMAOS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CMD_A :: NONE } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == CMD_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == CMD_A :: STOP } # [ doc = "Checks if the value of the field is `UPDATE`" ] # [ inline ( always ) ] pub fn is_update ( & self ) -> bool { * self == CMD_A :: UPDATE } # [ doc = "Checks if the value of the field is `READSYNC`" ] # [ inline ( always ) ] pub fn is_readsync ( & self ) -> bool { * self == CMD_A :: READSYNC } # [ doc = "Checks if the value of the field is `DMAOS`" ] # [ inline ( always ) ] pub fn is_dmaos ( & self ) -> bool { * self == CMD_A :: DMAOS } } # [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CMD_A :: NONE ) } # [ doc = "Force a start, restart or retrigger" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( CMD_A :: RETRIGGER ) } # [ doc = "Force a stop" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( CMD_A :: STOP ) } # [ doc = "Force update of double-buffered register" ] # [ inline ( always ) ] pub fn update ( self ) -> & 'a mut W { self . variant ( CMD_A :: UPDATE ) } # [ doc = "Force a read synchronization of COUNT" ] # [ inline ( always ) ] pub fn readsync ( self ) -> & 'a mut W { self . variant ( CMD_A :: READSYNC ) } # [ doc = "One-shot DMA trigger" ] # [ inline ( always ) ] pub fn dmaos ( self ) -> & 'a mut W { self . variant ( CMD_A :: DMAOS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u8 ) & 0x07 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & self ) -> DIR_R { DIR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & self ) -> LUPD_R { LUPD_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & self ) -> ONESHOT_R { ONESHOT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & mut self ) -> DIR_W { DIR_W { w : self } } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & mut self ) -> LUPD_W { LUPD_W { w : self } } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & mut self ) -> ONESHOT_W { ONESHOT_W { w : self } } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } } } } # [ doc = "Control B Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlbset](ctrlbset) module" ] pub type CTRLBSET = crate :: Reg < u8 , _CTRLBSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLBSET ; # [ doc = "`read()` method returns [ctrlbset::R](ctrlbset::R) reader structure" ] impl crate :: Readable for CTRLBSET { } # [ doc = "`write(|w| ..)` method takes [ctrlbset::W](ctrlbset::W) writer structure" ] impl crate :: Writable for CTRLBSET { } # [ doc = "Control B Set" ] pub mod ctrlbset { # [ doc = "Reader of register CTRLBSET" ] pub type R = crate :: R < u8 , super :: CTRLBSET > ; # [ doc = "Writer for register CTRLBSET" ] pub type W = crate :: W < u8 , super :: CTRLBSET > ; # [ doc = "Register CTRLBSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLBSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DIR`" ] pub type DIR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DIR`" ] pub struct DIR_W < 'a > { w : & 'a mut W , } impl < 'a > DIR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LUPD`" ] pub type LUPD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LUPD`" ] pub struct LUPD_W < 'a > { w : & 'a mut W , } impl < 'a > LUPD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ONESHOT`" ] pub type ONESHOT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ONESHOT`" ] pub struct ONESHOT_W < 'a > { w : & 'a mut W , } impl < 'a > ONESHOT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "No action" ] NONE , # [ doc = "Force a start, restart or retrigger" ] RETRIGGER , # [ doc = "Force a stop" ] STOP , # [ doc = "Force update of double-buffered register" ] UPDATE , # [ doc = "Force a read synchronization of COUNT" ] READSYNC , # [ doc = "One-shot DMA trigger" ] DMAOS } impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: NONE => 0 , CMD_A :: RETRIGGER => 1 , CMD_A :: STOP => 2 , CMD_A :: UPDATE => 3 , CMD_A :: READSYNC => 4 , CMD_A :: DMAOS => 5 } } } # [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CMD_A :: NONE ) , 1 => Val ( CMD_A :: RETRIGGER ) , 2 => Val ( CMD_A :: STOP ) , 3 => Val ( CMD_A :: UPDATE ) , 4 => Val ( CMD_A :: READSYNC ) , 5 => Val ( CMD_A :: DMAOS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CMD_A :: NONE } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == CMD_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == CMD_A :: STOP } # [ doc = "Checks if the value of the field is `UPDATE`" ] # [ inline ( always ) ] pub fn is_update ( & self ) -> bool { * self == CMD_A :: UPDATE } # [ doc = "Checks if the value of the field is `READSYNC`" ] # [ inline ( always ) ] pub fn is_readsync ( & self ) -> bool { * self == CMD_A :: READSYNC } # [ doc = "Checks if the value of the field is `DMAOS`" ] # [ inline ( always ) ] pub fn is_dmaos ( & self ) -> bool { * self == CMD_A :: DMAOS } } # [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CMD_A :: NONE ) } # [ doc = "Force a start, restart or retrigger" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( CMD_A :: RETRIGGER ) } # [ doc = "Force a stop" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( CMD_A :: STOP ) } # [ doc = "Force update of double-buffered register" ] # [ inline ( always ) ] pub fn update ( self ) -> & 'a mut W { self . variant ( CMD_A :: UPDATE ) } # [ doc = "Force a read synchronization of COUNT" ] # [ inline ( always ) ] pub fn readsync ( self ) -> & 'a mut W { self . variant ( CMD_A :: READSYNC ) } # [ doc = "One-shot DMA trigger" ] # [ inline ( always ) ] pub fn dmaos ( self ) -> & 'a mut W { self . variant ( CMD_A :: DMAOS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u8 ) & 0x07 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & self ) -> DIR_R { DIR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & self ) -> LUPD_R { LUPD_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & self ) -> ONESHOT_R { ONESHOT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & mut self ) -> DIR_W { DIR_W { w : self } } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & mut self ) -> LUPD_W { LUPD_W { w : self } } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & mut self ) -> ONESHOT_W { ONESHOT_W { w : self } } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } } } } # [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u16 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ; # [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { } # [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { } # [ doc = "Event Control" ] pub mod evctrl { # [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u16 , super :: EVCTRL > ; # [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u16 , super :: EVCTRL > ; # [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `EVACT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EVACT_A { # [ doc = "Event action disabled" ] OFF , # [ doc = "Start, restart or retrigger TC on event" ] RETRIGGER , # [ doc = "Count on event" ] COUNT , # [ doc = "Start TC on event" ] START , # [ doc = "Time stamp capture" ] STAMP , # [ doc = "Period catured in CC0, pulse width in CC1" ] PPW , # [ doc = "Period catured in CC1, pulse width in CC0" ] PWP , # [ doc = "Pulse width capture" ] PW } impl crate :: ToBits < u8 > for EVACT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { EVACT_A :: OFF => 0 , EVACT_A :: RETRIGGER => 1 , EVACT_A :: COUNT => 2 , EVACT_A :: START => 3 , EVACT_A :: STAMP => 4 , EVACT_A :: PPW => 5 , EVACT_A :: PWP => 6 , EVACT_A :: PW => 7 } } } # [ doc = "Reader of field `EVACT`" ] pub type EVACT_R = crate :: R < u8 , EVACT_A > ; impl EVACT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EVACT_A { match self . bits { 0 => EVACT_A :: OFF , 1 => EVACT_A :: RETRIGGER , 2 => EVACT_A :: COUNT , 3 => EVACT_A :: START , 4 => EVACT_A :: STAMP , 5 => EVACT_A :: PPW , 6 => EVACT_A :: PWP , 7 => EVACT_A :: PW , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == EVACT_A :: OFF } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == EVACT_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `COUNT`" ] # [ inline ( always ) ] pub fn is_count ( & self ) -> bool { * self == EVACT_A :: COUNT } # [ doc = "Checks if the value of the field is `START`" ] # [ inline ( always ) ] pub fn is_start ( & self ) -> bool { * self == EVACT_A :: START } # [ doc = "Checks if the value of the field is `STAMP`" ] # [ inline ( always ) ] pub fn is_stamp ( & self ) -> bool { * self == EVACT_A :: STAMP } # [ doc = "Checks if the value of the field is `PPW`" ] # [ inline ( always ) ] pub fn is_ppw ( & self ) -> bool { * self == EVACT_A :: PPW } # [ doc = "Checks if the value of the field is `PWP`" ] # [ inline ( always ) ] pub fn is_pwp ( & self ) -> bool { * self == EVACT_A :: PWP } # [ doc = "Checks if the value of the field is `PW`" ] # [ inline ( always ) ] pub fn is_pw ( & self ) -> bool { * self == EVACT_A :: PW } } # [ doc = "Write proxy for field `EVACT`" ] pub struct EVACT_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EVACT_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Event action disabled" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( EVACT_A :: OFF ) } # [ doc = "Start, restart or retrigger TC on event" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( EVACT_A :: RETRIGGER ) } # [ doc = "Count on event" ] # [ inline ( always ) ] pub fn count ( self ) -> & 'a mut W { self . variant ( EVACT_A :: COUNT ) } # [ doc = "Start TC on event" ] # [ inline ( always ) ] pub fn start ( self ) -> & 'a mut W { self . variant ( EVACT_A :: START ) } # [ doc = "Time stamp capture" ] # [ inline ( always ) ] pub fn stamp ( self ) -> & 'a mut W { self . variant ( EVACT_A :: STAMP ) } # [ doc = "Period catured in CC0, pulse width in CC1" ] # [ inline ( always ) ] pub fn ppw ( self ) -> & 'a mut W { self . variant ( EVACT_A :: PPW ) } # [ doc = "Period catured in CC1, pulse width in CC0" ] # [ inline ( always ) ] pub fn pwp ( self ) -> & 'a mut W { self . variant ( EVACT_A :: PWP ) } # [ doc = "Pulse width capture" ] # [ inline ( always ) ] pub fn pw ( self ) -> & 'a mut W { self . variant ( EVACT_A :: PW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } } # [ doc = "Reader of field `TCINV`" ] pub type TCINV_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TCINV`" ] pub struct TCINV_W < 'a > { w : & 'a mut W , } impl < 'a > TCINV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `TCEI`" ] pub type TCEI_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TCEI`" ] pub struct TCEI_W < 'a > { w : & 'a mut W , } impl < 'a > TCEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `OVFEO`" ] pub type OVFEO_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVFEO`" ] pub struct OVFEO_W < 'a > { w : & 'a mut W , } impl < 'a > OVFEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `MCEO0`" ] pub type MCEO0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MCEO0`" ] pub struct MCEO0_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } } # [ doc = "Reader of field `MCEO1`" ] pub type MCEO1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MCEO1`" ] pub struct MCEO1_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - Event Action" ] # [ inline ( always ) ] pub fn evact ( & self ) -> EVACT_R { EVACT_R :: new ( ( self . bits & 0x07 ) as u8 ) } # [ doc = "Bit 4 - TC Event Input Polarity" ] # [ inline ( always ) ] pub fn tcinv ( & self ) -> TCINV_R { TCINV_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - TC Event Enable" ] # [ inline ( always ) ] pub fn tcei ( & self ) -> TCEI_R { TCEI_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & self ) -> OVFEO_R { OVFEO_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 12 - MC Event Output Enable 0" ] # [ inline ( always ) ] pub fn mceo0 ( & self ) -> MCEO0_R { MCEO0_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - MC Event Output Enable 1" ] # [ inline ( always ) ] pub fn mceo1 ( & self ) -> MCEO1_R { MCEO1_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:2 - Event Action" ] # [ inline ( always ) ] pub fn evact ( & mut self ) -> EVACT_W { EVACT_W { w : self } } # [ doc = "Bit 4 - TC Event Input Polarity" ] # [ inline ( always ) ] pub fn tcinv ( & mut self ) -> TCINV_W { TCINV_W { w : self } } # [ doc = "Bit 5 - TC Event Enable" ] # [ inline ( always ) ] pub fn tcei ( & mut self ) -> TCEI_W { TCEI_W { w : self } } # [ doc = "Bit 8 - Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & mut self ) -> OVFEO_W { OVFEO_W { w : self } } # [ doc = "Bit 12 - MC Event Output Enable 0" ] # [ inline ( always ) ] pub fn mceo0 ( & mut self ) -> MCEO0_W { MCEO0_W { w : self } } # [ doc = "Bit 13 - MC Event Output Enable 1" ] # [ inline ( always ) ] pub fn mceo1 ( & mut self ) -> MCEO1_W { MCEO1_W { w : self } } } } # [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - OVF Interrupt Disable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - ERR Interrupt Disable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - MC Interrupt Disable 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - MC Interrupt Disable 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - OVF Interrupt Disable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } # [ doc = "Bit 1 - ERR Interrupt Disable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } # [ doc = "Bit 4 - MC Interrupt Disable 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } } # [ doc = "Bit 5 - MC Interrupt Disable 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } } } } # [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - OVF Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - ERR Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - MC Interrupt Enable 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - MC Interrupt Enable 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - OVF Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } # [ doc = "Bit 1 - ERR Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } # [ doc = "Bit 4 - MC Interrupt Enable 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } } # [ doc = "Bit 5 - MC Interrupt Enable 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } } } } # [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - OVF Interrupt Flag" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - ERR Interrupt Flag" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - MC Interrupt Flag 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - MC Interrupt Flag 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - OVF Interrupt Flag" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } # [ doc = "Bit 1 - ERR Interrupt Flag" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } # [ doc = "Bit 4 - MC Interrupt Flag 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } } # [ doc = "Bit 5 - MC Interrupt Flag 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } } } } # [ doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u8 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { } # [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { } # [ doc = "Status" ] pub mod status { # [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u8 , super :: STATUS > ; # [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u8 , super :: STATUS > ; # [ doc = "Register STATUS `reset()`'s with value 0x01" ] impl crate :: ResetValue for super :: STATUS { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x01 } } # [ doc = "Reader of field `STOP`" ] pub type STOP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `STOP`" ] pub struct STOP_W < 'a > { w : & 'a mut W , } impl < 'a > STOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `SLAVE`" ] pub type SLAVE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SLAVE`" ] pub struct SLAVE_W < 'a > { w : & 'a mut W , } impl < 'a > SLAVE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PERBUFV`" ] pub type PERBUFV_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PERBUFV`" ] pub struct PERBUFV_W < 'a > { w : & 'a mut W , } impl < 'a > PERBUFV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `CCBUFV0`" ] pub type CCBUFV0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CCBUFV0`" ] pub struct CCBUFV0_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `CCBUFV1`" ] pub type CCBUFV1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CCBUFV1`" ] pub struct CCBUFV1_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Stop Status Flag" ] # [ inline ( always ) ] pub fn stop ( & self ) -> STOP_R { STOP_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Slave Status Flag" ] # [ inline ( always ) ] pub fn slave ( & self ) -> SLAVE_R { SLAVE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Synchronization Busy Status" ] # [ inline ( always ) ] pub fn perbufv ( & self ) -> PERBUFV_R { PERBUFV_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Compare channel buffer 0 valid" ] # [ inline ( always ) ] pub fn ccbufv0 ( & self ) -> CCBUFV0_R { CCBUFV0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Compare channel buffer 1 valid" ] # [ inline ( always ) ] pub fn ccbufv1 ( & self ) -> CCBUFV1_R { CCBUFV1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Stop Status Flag" ] # [ inline ( always ) ] pub fn stop ( & mut self ) -> STOP_W { STOP_W { w : self } } # [ doc = "Bit 1 - Slave Status Flag" ] # [ inline ( always ) ] pub fn slave ( & mut self ) -> SLAVE_W { SLAVE_W { w : self } } # [ doc = "Bit 3 - Synchronization Busy Status" ] # [ inline ( always ) ] pub fn perbufv ( & mut self ) -> PERBUFV_W { PERBUFV_W { w : self } } # [ doc = "Bit 4 - Compare channel buffer 0 valid" ] # [ inline ( always ) ] pub fn ccbufv0 ( & mut self ) -> CCBUFV0_W { CCBUFV0_W { w : self } } # [ doc = "Bit 5 - Compare channel buffer 1 valid" ] # [ inline ( always ) ] pub fn ccbufv1 ( & mut self ) -> CCBUFV1_W { CCBUFV1_W { w : self } } } } # [ doc = "Waveform Generation Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [wave](wave) module" ] pub type WAVE = crate :: Reg < u8 , _WAVE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WAVE ; # [ doc = "`read()` method returns [wave::R](wave::R) reader structure" ] impl crate :: Readable for WAVE { } # [ doc = "`write(|w| ..)` method takes [wave::W](wave::W) writer structure" ] impl crate :: Writable for WAVE { } # [ doc = "Waveform Generation Control" ] pub mod wave { # [ doc = "Reader of register WAVE" ] pub type R = crate :: R < u8 , super :: WAVE > ; # [ doc = "Writer for register WAVE" ] pub type W = crate :: W < u8 , super :: WAVE > ; # [ doc = "Register WAVE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WAVE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `WAVEGEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WAVEGEN_A { # [ doc = "Normal frequency" ] NFRQ , # [ doc = "Match frequency" ] MFRQ , # [ doc = "Normal PWM" ] NPWM , # [ doc = "Match PWM" ] MPWM } impl crate :: ToBits < u8 > for WAVEGEN_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WAVEGEN_A :: NFRQ => 0 , WAVEGEN_A :: MFRQ => 1 , WAVEGEN_A :: NPWM => 2 , WAVEGEN_A :: MPWM => 3 } } } # [ doc = "Reader of field `WAVEGEN`" ] pub type WAVEGEN_R = crate :: R < u8 , WAVEGEN_A > ; impl WAVEGEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WAVEGEN_A { match self . bits { 0 => WAVEGEN_A :: NFRQ , 1 => WAVEGEN_A :: MFRQ , 2 => WAVEGEN_A :: NPWM , 3 => WAVEGEN_A :: MPWM , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NFRQ`" ] # [ inline ( always ) ] pub fn is_nfrq ( & self ) -> bool { * self == WAVEGEN_A :: NFRQ } # [ doc = "Checks if the value of the field is `MFRQ`" ] # [ inline ( always ) ] pub fn is_mfrq ( & self ) -> bool { * self == WAVEGEN_A :: MFRQ } # [ doc = "Checks if the value of the field is `NPWM`" ] # [ inline ( always ) ] pub fn is_npwm ( & self ) -> bool { * self == WAVEGEN_A :: NPWM } # [ doc = "Checks if the value of the field is `MPWM`" ] # [ inline ( always ) ] pub fn is_mpwm ( & self ) -> bool { * self == WAVEGEN_A :: MPWM } } # [ doc = "Write proxy for field `WAVEGEN`" ] pub struct WAVEGEN_W < 'a > { w : & 'a mut W , } impl < 'a > WAVEGEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WAVEGEN_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Normal frequency" ] # [ inline ( always ) ] pub fn nfrq ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: NFRQ ) } # [ doc = "Match frequency" ] # [ inline ( always ) ] pub fn mfrq ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: MFRQ ) } # [ doc = "Normal PWM" ] # [ inline ( always ) ] pub fn npwm ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: NPWM ) } # [ doc = "Match PWM" ] # [ inline ( always ) ] pub fn mpwm ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: MPWM ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u8 ) & 0x03 ) ; self . w } } impl R { # [ doc = "Bits 0:1 - Waveform Generation Mode" ] # [ inline ( always ) ] pub fn wavegen ( & self ) -> WAVEGEN_R { WAVEGEN_R :: new ( ( self . bits & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1 - Waveform Generation Mode" ] # [ inline ( always ) ] pub fn wavegen ( & mut self ) -> WAVEGEN_W { WAVEGEN_W { w : self } } } } # [ doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [drvctrl](drvctrl) module" ] pub type DRVCTRL = crate :: Reg < u8 , _DRVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DRVCTRL ; # [ doc = "`read()` method returns [drvctrl::R](drvctrl::R) reader structure" ] impl crate :: Readable for DRVCTRL { } # [ doc = "`write(|w| ..)` method takes [drvctrl::W](drvctrl::W) writer structure" ] impl crate :: Writable for DRVCTRL { } # [ doc = "Control C" ] pub mod drvctrl { # [ doc = "Reader of register DRVCTRL" ] pub type R = crate :: R < u8 , super :: DRVCTRL > ; # [ doc = "Writer for register DRVCTRL" ] pub type W = crate :: W < u8 , super :: DRVCTRL > ; # [ doc = "Register DRVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DRVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `INVEN0`" ] pub type INVEN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `INVEN0`" ] pub struct INVEN0_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `INVEN1`" ] pub type INVEN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `INVEN1`" ] pub struct INVEN1_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } impl R { # [ doc = "Bit 0 - Output Waveform Invert Enable 0" ] # [ inline ( always ) ] pub fn inven0 ( & self ) -> INVEN0_R { INVEN0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Output Waveform Invert Enable 1" ] # [ inline ( always ) ] pub fn inven1 ( & self ) -> INVEN1_R { INVEN1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Output Waveform Invert Enable 0" ] # [ inline ( always ) ] pub fn inven0 ( & mut self ) -> INVEN0_W { INVEN0_W { w : self } } # [ doc = "Bit 1 - Output Waveform Invert Enable 1" ] # [ inline ( always ) ] pub fn inven1 ( & mut self ) -> INVEN1_W { INVEN1_W { w : self } } } } # [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } } } } # [ doc = "Synchronization Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "Synchronization Status" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CTRLB`" ] pub type CTRLB_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `STATUS`" ] pub type STATUS_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CC0`" ] pub type CC0_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CC1`" ] pub type CC1_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - swrst" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - CTRLB" ] # [ inline ( always ) ] pub fn ctrlb ( & self ) -> CTRLB_R { CTRLB_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - STATUS" ] # [ inline ( always ) ] pub fn status ( & self ) -> STATUS_R { STATUS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Counter" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Period" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Compare Channel 0" ] # [ inline ( always ) ] pub fn cc0 ( & self ) -> CC0_R { CC0_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Compare Channel 1" ] # [ inline ( always ) ] pub fn cc1 ( & self ) -> CC1_R { CC1_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } } # [ doc = "COUNT8 Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [count](count) module" ] pub type COUNT = crate :: Reg < u8 , _COUNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COUNT ; # [ doc = "`read()` method returns [count::R](count::R) reader structure" ] impl crate :: Readable for COUNT { } # [ doc = "`write(|w| ..)` method takes [count::W](count::W) writer structure" ] impl crate :: Writable for COUNT { } # [ doc = "COUNT8 Count" ] pub mod count { # [ doc = "Reader of register COUNT" ] pub type R = crate :: R < u8 , super :: COUNT > ; # [ doc = "Writer for register COUNT" ] pub type W = crate :: W < u8 , super :: COUNT > ; # [ doc = "Register COUNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COUNT { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `COUNT`" ] pub struct COUNT_W < 'a > { w : & 'a mut W , } impl < 'a > COUNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & mut self ) -> COUNT_W { COUNT_W { w : self } } } } # [ doc = "COUNT8 Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [per](per) module" ] pub type PER = crate :: Reg < u8 , _PER > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PER ; # [ doc = "`read()` method returns [per::R](per::R) reader structure" ] impl crate :: Readable for PER { } # [ doc = "`write(|w| ..)` method takes [per::W](per::W) writer structure" ] impl crate :: Writable for PER { } # [ doc = "COUNT8 Period" ] pub mod per { # [ doc = "Reader of register PER" ] pub type R = crate :: R < u8 , super :: PER > ; # [ doc = "Writer for register PER" ] pub type W = crate :: W < u8 , super :: PER > ; # [ doc = "Register PER `reset()`'s with value 0xff" ] impl crate :: ResetValue for super :: PER { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xff } } # [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `PER`" ] pub struct PER_W < 'a > { w : & 'a mut W , } impl < 'a > PER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Period Value" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Period Value" ] # [ inline ( always ) ] pub fn per ( & mut self ) -> PER_W { PER_W { w : self } } } } # [ doc = "COUNT8 Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cc](cc) module" ] pub type CC = crate :: Reg < u8 , _CC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CC ; # [ doc = "`read()` method returns [cc::R](cc::R) reader structure" ] impl crate :: Readable for CC { } # [ doc = "`write(|w| ..)` method takes [cc::W](cc::W) writer structure" ] impl crate :: Writable for CC { } # [ doc = "COUNT8 Compare and Capture" ] pub mod cc { # [ doc = "Reader of register CC[%s]" ] pub type R = crate :: R < u8 , super :: CC > ; # [ doc = "Writer for register CC[%s]" ] pub type W = crate :: W < u8 , super :: CC > ; # [ doc = "Register CC[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `CC`" ] pub type CC_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CC`" ] pub struct CC_W < 'a > { w : & 'a mut W , } impl < 'a > CC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Counter/Compare Value" ] # [ inline ( always ) ] pub fn cc ( & self ) -> CC_R { CC_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Counter/Compare Value" ] # [ inline ( always ) ] pub fn cc ( & mut self ) -> CC_W { CC_W { w : self } } } } # [ doc = "COUNT8 Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [perbuf](perbuf) module" ] pub type PERBUF = crate :: Reg < u8 , _PERBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PERBUF ; # [ doc = "`read()` method returns [perbuf::R](perbuf::R) reader structure" ] impl crate :: Readable for PERBUF { } # [ doc = "`write(|w| ..)` method takes [perbuf::W](perbuf::W) writer structure" ] impl crate :: Writable for PERBUF { } # [ doc = "COUNT8 Period Buffer" ] pub mod perbuf { # [ doc = "Reader of register PERBUF" ] pub type R = crate :: R < u8 , super :: PERBUF > ; # [ doc = "Writer for register PERBUF" ] pub type W = crate :: W < u8 , super :: PERBUF > ; # [ doc = "Register PERBUF `reset()`'s with value 0xff" ] impl crate :: ResetValue for super :: PERBUF { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xff } } # [ doc = "Reader of field `PERBUF`" ] pub type PERBUF_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `PERBUF`" ] pub struct PERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > PERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & self ) -> PERBUF_R { PERBUF_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & mut self ) -> PERBUF_W { PERBUF_W { w : self } } } } # [ doc = "COUNT8 Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ccbuf](ccbuf) module" ] pub type CCBUF = crate :: Reg < u8 , _CCBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CCBUF ; # [ doc = "`read()` method returns [ccbuf::R](ccbuf::R) reader structure" ] impl crate :: Readable for CCBUF { } # [ doc = "`write(|w| ..)` method takes [ccbuf::W](ccbuf::W) writer structure" ] impl crate :: Writable for CCBUF { } # [ doc = "COUNT8 Compare and Capture Buffer" ] pub mod ccbuf { # [ doc = "Reader of register CCBUF[%s]" ] pub type R = crate :: R < u8 , super :: CCBUF > ; # [ doc = "Writer for register CCBUF[%s]" ] pub type W = crate :: W < u8 , super :: CCBUF > ; # [ doc = "Register CCBUF[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CCBUF { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `CCBUF`" ] pub type CCBUF_R = crate :: R < u8 , u8 > ; # [ doc = "Write proxy for field `CCBUF`" ] pub struct CCBUF_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } } impl R { # [ doc = "Bits 0:7 - Counter/Compare Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & self ) -> CCBUF_R { CCBUF_R :: new ( ( self . bits & 0xff ) as u8 ) } } impl W { # [ doc = "Bits 0:7 - Counter/Compare Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & mut self ) -> CCBUF_W { CCBUF_W { w : self } } } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct COUNT16 { # [ doc = "0x00 - Control A" ] pub ctrla : self::count16::CTRLA , # [ doc = "0x04 - Control B Clear" ] pub ctrlbclr : self::count16::CTRLBCLR , # [ doc = "0x05 - Control B Set" ] pub ctrlbset : self::count16::CTRLBSET , # [ doc = "0x06 - Event Control" ] pub evctrl : self::count16::EVCTRL , # [ doc = "0x08 - Interrupt Enable Clear" ] pub intenclr : self::count16::INTENCLR , # [ doc = "0x09 - Interrupt Enable Set" ] pub intenset : self::count16::INTENSET , # [ doc = "0x0a - Interrupt Flag Status and Clear" ] pub intflag : self::count16::INTFLAG , # [ doc = "0x0b - Status" ] pub status : self::count16::STATUS , # [ doc = "0x0c - Waveform Generation Control" ] pub wave : self::count16::WAVE , # [ doc = "0x0d - Control C" ] pub drvctrl : self::count16::DRVCTRL , _reserved10 : [ u8 ; 1usize ] , # [ doc = "0x0f - Debug Control" ] pub dbgctrl : self::count16::DBGCTRL , # [ doc = "0x10 - Synchronization Status" ] pub syncbusy : self::count16::SYNCBUSY , # [ doc = "0x14 - COUNT16 Count" ] pub count : self::count16::COUNT , _reserved13 : [ u8 ; 6usize ] , # [ doc = "0x1c - COUNT16 Compare and Capture" ] pub cc : [ self::count16::CC ; 2 ] , _reserved14 : [ u8 ; 16usize ] , # [ doc = "0x30 - COUNT16 Compare and Capture Buffer" ] pub ccbuf : [ self::count16::CCBUF ; 2 ] , } # [ doc = r"Register block" ] # [ doc = "16-bit Counter Mode" ] pub mod count16 { # [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "Counter in 16-bit mode" ] COUNT16 , # [ doc = "Counter in 8-bit mode" ] COUNT8 , # [ doc = "Counter in 32-bit mode" ] COUNT32 } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: COUNT16 => 0 , MODE_A :: COUNT8 => 1 , MODE_A :: COUNT32 => 2 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: COUNT16 ) , 1 => Val ( MODE_A :: COUNT8 ) , 2 => Val ( MODE_A :: COUNT32 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `COUNT16`" ] # [ inline ( always ) ] pub fn is_count16 ( & self ) -> bool { * self == MODE_A :: COUNT16 } # [ doc = "Checks if the value of the field is `COUNT8`" ] # [ inline ( always ) ] pub fn is_count8 ( & self ) -> bool { * self == MODE_A :: COUNT8 } # [ doc = "Checks if the value of the field is `COUNT32`" ] # [ inline ( always ) ] pub fn is_count32 ( & self ) -> bool { * self == MODE_A :: COUNT32 } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Counter in 16-bit mode" ] # [ inline ( always ) ] pub fn count16 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT16 ) } # [ doc = "Counter in 8-bit mode" ] # [ inline ( always ) ] pub fn count8 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT8 ) } # [ doc = "Counter in 32-bit mode" ] # [ inline ( always ) ] pub fn count32 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT32 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u32 ) & 0x03 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `PRESCSYNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCSYNC_A { # [ doc = "Reload or reset the counter on next generic clock" ] GCLK , # [ doc = "Reload or reset the counter on next prescaler clock" ] PRESC , # [ doc = "Reload or reset the counter on next generic clock and reset the prescaler counter" ] RESYNC } impl crate :: ToBits < u8 > for PRESCSYNC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCSYNC_A :: GCLK => 0 , PRESCSYNC_A :: PRESC => 1 , PRESCSYNC_A :: RESYNC => 2 } } } # [ doc = "Reader of field `PRESCSYNC`" ] pub type PRESCSYNC_R = crate :: R < u8 , PRESCSYNC_A > ; impl PRESCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PRESCSYNC_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PRESCSYNC_A :: GCLK ) , 1 => Val ( PRESCSYNC_A :: PRESC ) , 2 => Val ( PRESCSYNC_A :: RESYNC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK`" ] # [ inline ( always ) ] pub fn is_gclk ( & self ) -> bool { * self == PRESCSYNC_A :: GCLK } # [ doc = "Checks if the value of the field is `PRESC`" ] # [ inline ( always ) ] pub fn is_presc ( & self ) -> bool { * self == PRESCSYNC_A :: PRESC } # [ doc = "Checks if the value of the field is `RESYNC`" ] # [ inline ( always ) ] pub fn is_resync ( & self ) -> bool { * self == PRESCSYNC_A :: RESYNC } } # [ doc = "Write proxy for field `PRESCSYNC`" ] pub struct PRESCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCSYNC_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Reload or reset the counter on next generic clock" ] # [ inline ( always ) ] pub fn gclk ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: GCLK ) } # [ doc = "Reload or reset the counter on next prescaler clock" ] # [ inline ( always ) ] pub fn presc ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: PRESC ) } # [ doc = "Reload or reset the counter on next generic clock and reset the prescaler counter" ] # [ inline ( always ) ] pub fn resync ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: RESYNC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } } # [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Possible values of the field `PRESCALER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER_A { # [ doc = "Prescaler: GCLK_TC" ] DIV1 , # [ doc = "Prescaler: GCLK_TC/2" ] DIV2 , # [ doc = "Prescaler: GCLK_TC/4" ] DIV4 , # [ doc = "Prescaler: GCLK_TC/8" ] DIV8 , # [ doc = "Prescaler: GCLK_TC/16" ] DIV16 , # [ doc = "Prescaler: GCLK_TC/64" ] DIV64 , # [ doc = "Prescaler: GCLK_TC/256" ] DIV256 , # [ doc = "Prescaler: GCLK_TC/1024" ] DIV1024 } impl crate :: ToBits < u8 > for PRESCALER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER_A :: DIV1 => 0 , PRESCALER_A :: DIV2 => 1 , PRESCALER_A :: DIV4 => 2 , PRESCALER_A :: DIV8 => 3 , PRESCALER_A :: DIV16 => 4 , PRESCALER_A :: DIV64 => 5 , PRESCALER_A :: DIV256 => 6 , PRESCALER_A :: DIV1024 => 7 } } } # [ doc = "Reader of field `PRESCALER`" ] pub type PRESCALER_R = crate :: R < u8 , PRESCALER_A > ; impl PRESCALER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV1024 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == PRESCALER_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER_A :: DIV256 } # [ doc = "Checks if the value of the field is `DIV1024`" ] # [ inline ( always ) ] pub fn is_div1024 ( & self ) -> bool { * self == PRESCALER_A :: DIV1024 } } # [ doc = "Write proxy for field `PRESCALER`" ] pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Prescaler: GCLK_TC" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1 ) } # [ doc = "Prescaler: GCLK_TC/2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV2 ) } # [ doc = "Prescaler: GCLK_TC/4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV4 ) } # [ doc = "Prescaler: GCLK_TC/8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV8 ) } # [ doc = "Prescaler: GCLK_TC/16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV16 ) } # [ doc = "Prescaler: GCLK_TC/64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV64 ) } # [ doc = "Prescaler: GCLK_TC/256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV256 ) } # [ doc = "Prescaler: GCLK_TC/1024" ] # [ inline ( always ) ] pub fn div1024 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u32 ) & 0x07 ) << 8 ) ; self . w } } # [ doc = "Reader of field `ALOCK`" ] pub type ALOCK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ALOCK`" ] pub struct ALOCK_W < 'a > { w : & 'a mut W , } impl < 'a > ALOCK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } } # [ doc = "Reader of field `CAPTEN0`" ] pub type CAPTEN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CAPTEN0`" ] pub struct CAPTEN0_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `CAPTEN1`" ] pub type CAPTEN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CAPTEN1`" ] pub struct CAPTEN1_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Reader of field `COPEN0`" ] pub type COPEN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COPEN0`" ] pub struct COPEN0_W < 'a > { w : & 'a mut W , } impl < 'a > COPEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } } # [ doc = "Reader of field `COPEN1`" ] pub type COPEN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COPEN1`" ] pub struct COPEN1_W < 'a > { w : & 'a mut W , } impl < 'a > COPEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } } # [ doc = "Possible values of the field `CAPTMODE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAPTMODE0_A { # [ doc = "Default capture" ] DEFAULT , # [ doc = "Minimum capture" ] CAPTMIN , # [ doc = "Maximum capture" ] CAPTMAX } impl crate :: ToBits < u8 > for CAPTMODE0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CAPTMODE0_A :: DEFAULT => 0 , CAPTMODE0_A :: CAPTMIN => 1 , CAPTMODE0_A :: CAPTMAX => 2 } } } # [ doc = "Reader of field `CAPTMODE0`" ] pub type CAPTMODE0_R = crate :: R < u8 , CAPTMODE0_A > ; impl CAPTMODE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CAPTMODE0_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CAPTMODE0_A :: DEFAULT ) , 1 => Val ( CAPTMODE0_A :: CAPTMIN ) , 2 => Val ( CAPTMODE0_A :: CAPTMAX ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DEFAULT`" ] # [ inline ( always ) ] pub fn is_default ( & self ) -> bool { * self == CAPTMODE0_A :: DEFAULT } # [ doc = "Checks if the value of the field is `CAPTMIN`" ] # [ inline ( always ) ] pub fn is_captmin ( & self ) -> bool { * self == CAPTMODE0_A :: CAPTMIN } # [ doc = "Checks if the value of the field is `CAPTMAX`" ] # [ inline ( always ) ] pub fn is_captmax ( & self ) -> bool { * self == CAPTMODE0_A :: CAPTMAX } } # [ doc = "Write proxy for field `CAPTMODE0`" ] pub struct CAPTMODE0_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTMODE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAPTMODE0_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Default capture" ] # [ inline ( always ) ] pub fn default ( self ) -> & 'a mut W { self . variant ( CAPTMODE0_A :: DEFAULT ) } # [ doc = "Minimum capture" ] # [ inline ( always ) ] pub fn captmin ( self ) -> & 'a mut W { self . variant ( CAPTMODE0_A :: CAPTMIN ) } # [ doc = "Maximum capture" ] # [ inline ( always ) ] pub fn captmax ( self ) -> & 'a mut W { self . variant ( CAPTMODE0_A :: CAPTMAX ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 24 ) ) | ( ( ( value as u32 ) & 0x03 ) << 24 ) ; self . w } } # [ doc = "Possible values of the field `CAPTMODE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAPTMODE1_A { # [ doc = "Default capture" ] DEFAULT , # [ doc = "Minimum capture" ] CAPTMIN , # [ doc = "Maximum capture" ] CAPTMAX } impl crate :: ToBits < u8 > for CAPTMODE1_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CAPTMODE1_A :: DEFAULT => 0 , CAPTMODE1_A :: CAPTMIN => 1 , CAPTMODE1_A :: CAPTMAX => 2 } } } # [ doc = "Reader of field `CAPTMODE1`" ] pub type CAPTMODE1_R = crate :: R < u8 , CAPTMODE1_A > ; impl CAPTMODE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CAPTMODE1_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CAPTMODE1_A :: DEFAULT ) , 1 => Val ( CAPTMODE1_A :: CAPTMIN ) , 2 => Val ( CAPTMODE1_A :: CAPTMAX ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DEFAULT`" ] # [ inline ( always ) ] pub fn is_default ( & self ) -> bool { * self == CAPTMODE1_A :: DEFAULT } # [ doc = "Checks if the value of the field is `CAPTMIN`" ] # [ inline ( always ) ] pub fn is_captmin ( & self ) -> bool { * self == CAPTMODE1_A :: CAPTMIN } # [ doc = "Checks if the value of the field is `CAPTMAX`" ] # [ inline ( always ) ] pub fn is_captmax ( & self ) -> bool { * self == CAPTMODE1_A :: CAPTMAX } } # [ doc = "Write proxy for field `CAPTMODE1`" ] pub struct CAPTMODE1_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTMODE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAPTMODE1_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Default capture" ] # [ inline ( always ) ] pub fn default ( self ) -> & 'a mut W { self . variant ( CAPTMODE1_A :: DEFAULT ) } # [ doc = "Minimum capture" ] # [ inline ( always ) ] pub fn captmin ( self ) -> & 'a mut W { self . variant ( CAPTMODE1_A :: CAPTMIN ) } # [ doc = "Maximum capture" ] # [ inline ( always ) ] pub fn captmax ( self ) -> & 'a mut W { self . variant ( CAPTMODE1_A :: CAPTMAX ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 27 ) ) | ( ( ( value as u32 ) & 0x03 ) << 27 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:3 - Timer Counter Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) } # [ doc = "Bits 4:5 - Prescaler and Counter Synchronization" ] # [ inline ( always ) ] pub fn prescsync ( & self ) -> PRESCSYNC_R { PRESCSYNC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) } # [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Clock On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bits 8:10 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) } # [ doc = "Bit 11 - Auto Lock" ] # [ inline ( always ) ] pub fn alock ( & self ) -> ALOCK_R { ALOCK_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - Capture Channel 0 Enable" ] # [ inline ( always ) ] pub fn capten0 ( & self ) -> CAPTEN0_R { CAPTEN0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - Capture Channel 1 Enable" ] # [ inline ( always ) ] pub fn capten1 ( & self ) -> CAPTEN1_R { CAPTEN1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bit 20 - Capture On Pin 0 Enable" ] # [ inline ( always ) ] pub fn copen0 ( & self ) -> COPEN0_R { COPEN0_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) } # [ doc = "Bit 21 - Capture On Pin 1 Enable" ] # [ inline ( always ) ] pub fn copen1 ( & self ) -> COPEN1_R { COPEN1_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) } # [ doc = "Bits 24:25 - Capture Mode Channel 0" ] # [ inline ( always ) ] pub fn captmode0 ( & self ) -> CAPTMODE0_R { CAPTMODE0_R :: new ( ( ( self . bits >> 24 ) & 0x03 ) as u8 ) } # [ doc = "Bits 27:28 - Capture mode Channel 1" ] # [ inline ( always ) ] pub fn captmode1 ( & self ) -> CAPTMODE1_R { CAPTMODE1_R :: new ( ( ( self . bits >> 27 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:3 - Timer Counter Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bits 4:5 - Prescaler and Counter Synchronization" ] # [ inline ( always ) ] pub fn prescsync ( & mut self ) -> PRESCSYNC_W { PRESCSYNC_W { w : self } } # [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } } # [ doc = "Bit 7 - Clock On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } } # [ doc = "Bits 8:10 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } } # [ doc = "Bit 11 - Auto Lock" ] # [ inline ( always ) ] pub fn alock ( & mut self ) -> ALOCK_W { ALOCK_W { w : self } } # [ doc = "Bit 16 - Capture Channel 0 Enable" ] # [ inline ( always ) ] pub fn capten0 ( & mut self ) -> CAPTEN0_W { CAPTEN0_W { w : self } } # [ doc = "Bit 17 - Capture Channel 1 Enable" ] # [ inline ( always ) ] pub fn capten1 ( & mut self ) -> CAPTEN1_W { CAPTEN1_W { w : self } } # [ doc = "Bit 20 - Capture On Pin 0 Enable" ] # [ inline ( always ) ] pub fn copen0 ( & mut self ) -> COPEN0_W { COPEN0_W { w : self } } # [ doc = "Bit 21 - Capture On Pin 1 Enable" ] # [ inline ( always ) ] pub fn copen1 ( & mut self ) -> COPEN1_W { COPEN1_W { w : self } } # [ doc = "Bits 24:25 - Capture Mode Channel 0" ] # [ inline ( always ) ] pub fn captmode0 ( & mut self ) -> CAPTMODE0_W { CAPTMODE0_W { w : self } } # [ doc = "Bits 27:28 - Capture mode Channel 1" ] # [ inline ( always ) ] pub fn captmode1 ( & mut self ) -> CAPTMODE1_W { CAPTMODE1_W { w : self } } } } # [ doc = "Control B Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlbclr](ctrlbclr) module" ] pub type CTRLBCLR = crate :: Reg < u8 , _CTRLBCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLBCLR ; # [ doc = "`read()` method returns [ctrlbclr::R](ctrlbclr::R) reader structure" ] impl crate :: Readable for CTRLBCLR { } # [ doc = "`write(|w| ..)` method takes [ctrlbclr::W](ctrlbclr::W) writer structure" ] impl crate :: Writable for CTRLBCLR { } # [ doc = "Control B Clear" ] pub mod ctrlbclr { # [ doc = "Reader of register CTRLBCLR" ] pub type R = crate :: R < u8 , super :: CTRLBCLR > ; # [ doc = "Writer for register CTRLBCLR" ] pub type W = crate :: W < u8 , super :: CTRLBCLR > ; # [ doc = "Register CTRLBCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLBCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DIR`" ] pub type DIR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DIR`" ] pub struct DIR_W < 'a > { w : & 'a mut W , } impl < 'a > DIR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LUPD`" ] pub type LUPD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LUPD`" ] pub struct LUPD_W < 'a > { w : & 'a mut W , } impl < 'a > LUPD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ONESHOT`" ] pub type ONESHOT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ONESHOT`" ] pub struct ONESHOT_W < 'a > { w : & 'a mut W , } impl < 'a > ONESHOT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "No action" ] NONE , # [ doc = "Force a start, restart or retrigger" ] RETRIGGER , # [ doc = "Force a stop" ] STOP , # [ doc = "Force update of double-buffered register" ] UPDATE , # [ doc = "Force a read synchronization of COUNT" ] READSYNC , # [ doc = "One-shot DMA trigger" ] DMAOS } impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: NONE => 0 , CMD_A :: RETRIGGER => 1 , CMD_A :: STOP => 2 , CMD_A :: UPDATE => 3 , CMD_A :: READSYNC => 4 , CMD_A :: DMAOS => 5 } } } # [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CMD_A :: NONE ) , 1 => Val ( CMD_A :: RETRIGGER ) , 2 => Val ( CMD_A :: STOP ) , 3 => Val ( CMD_A :: UPDATE ) , 4 => Val ( CMD_A :: READSYNC ) , 5 => Val ( CMD_A :: DMAOS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CMD_A :: NONE } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == CMD_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == CMD_A :: STOP } # [ doc = "Checks if the value of the field is `UPDATE`" ] # [ inline ( always ) ] pub fn is_update ( & self ) -> bool { * self == CMD_A :: UPDATE } # [ doc = "Checks if the value of the field is `READSYNC`" ] # [ inline ( always ) ] pub fn is_readsync ( & self ) -> bool { * self == CMD_A :: READSYNC } # [ doc = "Checks if the value of the field is `DMAOS`" ] # [ inline ( always ) ] pub fn is_dmaos ( & self ) -> bool { * self == CMD_A :: DMAOS } } # [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CMD_A :: NONE ) } # [ doc = "Force a start, restart or retrigger" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( CMD_A :: RETRIGGER ) } # [ doc = "Force a stop" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( CMD_A :: STOP ) } # [ doc = "Force update of double-buffered register" ] # [ inline ( always ) ] pub fn update ( self ) -> & 'a mut W { self . variant ( CMD_A :: UPDATE ) } # [ doc = "Force a read synchronization of COUNT" ] # [ inline ( always ) ] pub fn readsync ( self ) -> & 'a mut W { self . variant ( CMD_A :: READSYNC ) } # [ doc = "One-shot DMA trigger" ] # [ inline ( always ) ] pub fn dmaos ( self ) -> & 'a mut W { self . variant ( CMD_A :: DMAOS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u8 ) & 0x07 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & self ) -> DIR_R { DIR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & self ) -> LUPD_R { LUPD_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & self ) -> ONESHOT_R { ONESHOT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & mut self ) -> DIR_W { DIR_W { w : self } } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & mut self ) -> LUPD_W { LUPD_W { w : self } } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & mut self ) -> ONESHOT_W { ONESHOT_W { w : self } } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } } } } # [ doc = "Control B Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlbset](ctrlbset) module" ] pub type CTRLBSET = crate :: Reg < u8 , _CTRLBSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLBSET ; # [ doc = "`read()` method returns [ctrlbset::R](ctrlbset::R) reader structure" ] impl crate :: Readable for CTRLBSET { } # [ doc = "`write(|w| ..)` method takes [ctrlbset::W](ctrlbset::W) writer structure" ] impl crate :: Writable for CTRLBSET { } # [ doc = "Control B Set" ] pub mod ctrlbset { # [ doc = "Reader of register CTRLBSET" ] pub type R = crate :: R < u8 , super :: CTRLBSET > ; # [ doc = "Writer for register CTRLBSET" ] pub type W = crate :: W < u8 , super :: CTRLBSET > ; # [ doc = "Register CTRLBSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLBSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DIR`" ] pub type DIR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DIR`" ] pub struct DIR_W < 'a > { w : & 'a mut W , } impl < 'a > DIR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LUPD`" ] pub type LUPD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LUPD`" ] pub struct LUPD_W < 'a > { w : & 'a mut W , } impl < 'a > LUPD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ONESHOT`" ] pub type ONESHOT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ONESHOT`" ] pub struct ONESHOT_W < 'a > { w : & 'a mut W , } impl < 'a > ONESHOT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "No action" ] NONE , # [ doc = "Force a start, restart or retrigger" ] RETRIGGER , # [ doc = "Force a stop" ] STOP , # [ doc = "Force update of double-buffered register" ] UPDATE , # [ doc = "Force a read synchronization of COUNT" ] READSYNC , # [ doc = "One-shot DMA trigger" ] DMAOS } impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: NONE => 0 , CMD_A :: RETRIGGER => 1 , CMD_A :: STOP => 2 , CMD_A :: UPDATE => 3 , CMD_A :: READSYNC => 4 , CMD_A :: DMAOS => 5 } } } # [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CMD_A :: NONE ) , 1 => Val ( CMD_A :: RETRIGGER ) , 2 => Val ( CMD_A :: STOP ) , 3 => Val ( CMD_A :: UPDATE ) , 4 => Val ( CMD_A :: READSYNC ) , 5 => Val ( CMD_A :: DMAOS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CMD_A :: NONE } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == CMD_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == CMD_A :: STOP } # [ doc = "Checks if the value of the field is `UPDATE`" ] # [ inline ( always ) ] pub fn is_update ( & self ) -> bool { * self == CMD_A :: UPDATE } # [ doc = "Checks if the value of the field is `READSYNC`" ] # [ inline ( always ) ] pub fn is_readsync ( & self ) -> bool { * self == CMD_A :: READSYNC } # [ doc = "Checks if the value of the field is `DMAOS`" ] # [ inline ( always ) ] pub fn is_dmaos ( & self ) -> bool { * self == CMD_A :: DMAOS } } # [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CMD_A :: NONE ) } # [ doc = "Force a start, restart or retrigger" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( CMD_A :: RETRIGGER ) } # [ doc = "Force a stop" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( CMD_A :: STOP ) } # [ doc = "Force update of double-buffered register" ] # [ inline ( always ) ] pub fn update ( self ) -> & 'a mut W { self . variant ( CMD_A :: UPDATE ) } # [ doc = "Force a read synchronization of COUNT" ] # [ inline ( always ) ] pub fn readsync ( self ) -> & 'a mut W { self . variant ( CMD_A :: READSYNC ) } # [ doc = "One-shot DMA trigger" ] # [ inline ( always ) ] pub fn dmaos ( self ) -> & 'a mut W { self . variant ( CMD_A :: DMAOS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u8 ) & 0x07 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & self ) -> DIR_R { DIR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & self ) -> LUPD_R { LUPD_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & self ) -> ONESHOT_R { ONESHOT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & mut self ) -> DIR_W { DIR_W { w : self } } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & mut self ) -> LUPD_W { LUPD_W { w : self } } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & mut self ) -> ONESHOT_W { ONESHOT_W { w : self } } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } } } } # [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u16 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ; # [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { } # [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { } # [ doc = "Event Control" ] pub mod evctrl { # [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u16 , super :: EVCTRL > ; # [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u16 , super :: EVCTRL > ; # [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `EVACT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EVACT_A { # [ doc = "Event action disabled" ] OFF , # [ doc = "Start, restart or retrigger TC on event" ] RETRIGGER , # [ doc = "Count on event" ] COUNT , # [ doc = "Start TC on event" ] START , # [ doc = "Time stamp capture" ] STAMP , # [ doc = "Period catured in CC0, pulse width in CC1" ] PPW , # [ doc = "Period catured in CC1, pulse width in CC0" ] PWP , # [ doc = "Pulse width capture" ] PW } impl crate :: ToBits < u8 > for EVACT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { EVACT_A :: OFF => 0 , EVACT_A :: RETRIGGER => 1 , EVACT_A :: COUNT => 2 , EVACT_A :: START => 3 , EVACT_A :: STAMP => 4 , EVACT_A :: PPW => 5 , EVACT_A :: PWP => 6 , EVACT_A :: PW => 7 } } } # [ doc = "Reader of field `EVACT`" ] pub type EVACT_R = crate :: R < u8 , EVACT_A > ; impl EVACT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EVACT_A { match self . bits { 0 => EVACT_A :: OFF , 1 => EVACT_A :: RETRIGGER , 2 => EVACT_A :: COUNT , 3 => EVACT_A :: START , 4 => EVACT_A :: STAMP , 5 => EVACT_A :: PPW , 6 => EVACT_A :: PWP , 7 => EVACT_A :: PW , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == EVACT_A :: OFF } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == EVACT_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `COUNT`" ] # [ inline ( always ) ] pub fn is_count ( & self ) -> bool { * self == EVACT_A :: COUNT } # [ doc = "Checks if the value of the field is `START`" ] # [ inline ( always ) ] pub fn is_start ( & self ) -> bool { * self == EVACT_A :: START } # [ doc = "Checks if the value of the field is `STAMP`" ] # [ inline ( always ) ] pub fn is_stamp ( & self ) -> bool { * self == EVACT_A :: STAMP } # [ doc = "Checks if the value of the field is `PPW`" ] # [ inline ( always ) ] pub fn is_ppw ( & self ) -> bool { * self == EVACT_A :: PPW } # [ doc = "Checks if the value of the field is `PWP`" ] # [ inline ( always ) ] pub fn is_pwp ( & self ) -> bool { * self == EVACT_A :: PWP } # [ doc = "Checks if the value of the field is `PW`" ] # [ inline ( always ) ] pub fn is_pw ( & self ) -> bool { * self == EVACT_A :: PW } } # [ doc = "Write proxy for field `EVACT`" ] pub struct EVACT_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EVACT_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Event action disabled" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( EVACT_A :: OFF ) } # [ doc = "Start, restart or retrigger TC on event" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( EVACT_A :: RETRIGGER ) } # [ doc = "Count on event" ] # [ inline ( always ) ] pub fn count ( self ) -> & 'a mut W { self . variant ( EVACT_A :: COUNT ) } # [ doc = "Start TC on event" ] # [ inline ( always ) ] pub fn start ( self ) -> & 'a mut W { self . variant ( EVACT_A :: START ) } # [ doc = "Time stamp capture" ] # [ inline ( always ) ] pub fn stamp ( self ) -> & 'a mut W { self . variant ( EVACT_A :: STAMP ) } # [ doc = "Period catured in CC0, pulse width in CC1" ] # [ inline ( always ) ] pub fn ppw ( self ) -> & 'a mut W { self . variant ( EVACT_A :: PPW ) } # [ doc = "Period catured in CC1, pulse width in CC0" ] # [ inline ( always ) ] pub fn pwp ( self ) -> & 'a mut W { self . variant ( EVACT_A :: PWP ) } # [ doc = "Pulse width capture" ] # [ inline ( always ) ] pub fn pw ( self ) -> & 'a mut W { self . variant ( EVACT_A :: PW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } } # [ doc = "Reader of field `TCINV`" ] pub type TCINV_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TCINV`" ] pub struct TCINV_W < 'a > { w : & 'a mut W , } impl < 'a > TCINV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `TCEI`" ] pub type TCEI_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TCEI`" ] pub struct TCEI_W < 'a > { w : & 'a mut W , } impl < 'a > TCEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `OVFEO`" ] pub type OVFEO_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVFEO`" ] pub struct OVFEO_W < 'a > { w : & 'a mut W , } impl < 'a > OVFEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `MCEO0`" ] pub type MCEO0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MCEO0`" ] pub struct MCEO0_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } } # [ doc = "Reader of field `MCEO1`" ] pub type MCEO1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MCEO1`" ] pub struct MCEO1_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - Event Action" ] # [ inline ( always ) ] pub fn evact ( & self ) -> EVACT_R { EVACT_R :: new ( ( self . bits & 0x07 ) as u8 ) } # [ doc = "Bit 4 - TC Event Input Polarity" ] # [ inline ( always ) ] pub fn tcinv ( & self ) -> TCINV_R { TCINV_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - TC Event Enable" ] # [ inline ( always ) ] pub fn tcei ( & self ) -> TCEI_R { TCEI_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & self ) -> OVFEO_R { OVFEO_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 12 - MC Event Output Enable 0" ] # [ inline ( always ) ] pub fn mceo0 ( & self ) -> MCEO0_R { MCEO0_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - MC Event Output Enable 1" ] # [ inline ( always ) ] pub fn mceo1 ( & self ) -> MCEO1_R { MCEO1_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:2 - Event Action" ] # [ inline ( always ) ] pub fn evact ( & mut self ) -> EVACT_W { EVACT_W { w : self } } # [ doc = "Bit 4 - TC Event Input Polarity" ] # [ inline ( always ) ] pub fn tcinv ( & mut self ) -> TCINV_W { TCINV_W { w : self } } # [ doc = "Bit 5 - TC Event Enable" ] # [ inline ( always ) ] pub fn tcei ( & mut self ) -> TCEI_W { TCEI_W { w : self } } # [ doc = "Bit 8 - Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & mut self ) -> OVFEO_W { OVFEO_W { w : self } } # [ doc = "Bit 12 - MC Event Output Enable 0" ] # [ inline ( always ) ] pub fn mceo0 ( & mut self ) -> MCEO0_W { MCEO0_W { w : self } } # [ doc = "Bit 13 - MC Event Output Enable 1" ] # [ inline ( always ) ] pub fn mceo1 ( & mut self ) -> MCEO1_W { MCEO1_W { w : self } } } } # [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - OVF Interrupt Disable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - ERR Interrupt Disable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - MC Interrupt Disable 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - MC Interrupt Disable 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - OVF Interrupt Disable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } # [ doc = "Bit 1 - ERR Interrupt Disable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } # [ doc = "Bit 4 - MC Interrupt Disable 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } } # [ doc = "Bit 5 - MC Interrupt Disable 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } } } } # [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - OVF Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - ERR Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - MC Interrupt Enable 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - MC Interrupt Enable 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - OVF Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } # [ doc = "Bit 1 - ERR Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } # [ doc = "Bit 4 - MC Interrupt Enable 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } } # [ doc = "Bit 5 - MC Interrupt Enable 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } } } } # [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - OVF Interrupt Flag" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - ERR Interrupt Flag" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - MC Interrupt Flag 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - MC Interrupt Flag 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - OVF Interrupt Flag" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } # [ doc = "Bit 1 - ERR Interrupt Flag" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } # [ doc = "Bit 4 - MC Interrupt Flag 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } } # [ doc = "Bit 5 - MC Interrupt Flag 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } } } } # [ doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u8 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { } # [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { } # [ doc = "Status" ] pub mod status { # [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u8 , super :: STATUS > ; # [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u8 , super :: STATUS > ; # [ doc = "Register STATUS `reset()`'s with value 0x01" ] impl crate :: ResetValue for super :: STATUS { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x01 } } # [ doc = "Reader of field `STOP`" ] pub type STOP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `STOP`" ] pub struct STOP_W < 'a > { w : & 'a mut W , } impl < 'a > STOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `SLAVE`" ] pub type SLAVE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SLAVE`" ] pub struct SLAVE_W < 'a > { w : & 'a mut W , } impl < 'a > SLAVE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PERBUFV`" ] pub type PERBUFV_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PERBUFV`" ] pub struct PERBUFV_W < 'a > { w : & 'a mut W , } impl < 'a > PERBUFV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `CCBUFV0`" ] pub type CCBUFV0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CCBUFV0`" ] pub struct CCBUFV0_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `CCBUFV1`" ] pub type CCBUFV1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CCBUFV1`" ] pub struct CCBUFV1_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Stop Status Flag" ] # [ inline ( always ) ] pub fn stop ( & self ) -> STOP_R { STOP_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Slave Status Flag" ] # [ inline ( always ) ] pub fn slave ( & self ) -> SLAVE_R { SLAVE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Synchronization Busy Status" ] # [ inline ( always ) ] pub fn perbufv ( & self ) -> PERBUFV_R { PERBUFV_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Compare channel buffer 0 valid" ] # [ inline ( always ) ] pub fn ccbufv0 ( & self ) -> CCBUFV0_R { CCBUFV0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Compare channel buffer 1 valid" ] # [ inline ( always ) ] pub fn ccbufv1 ( & self ) -> CCBUFV1_R { CCBUFV1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Stop Status Flag" ] # [ inline ( always ) ] pub fn stop ( & mut self ) -> STOP_W { STOP_W { w : self } } # [ doc = "Bit 1 - Slave Status Flag" ] # [ inline ( always ) ] pub fn slave ( & mut self ) -> SLAVE_W { SLAVE_W { w : self } } # [ doc = "Bit 3 - Synchronization Busy Status" ] # [ inline ( always ) ] pub fn perbufv ( & mut self ) -> PERBUFV_W { PERBUFV_W { w : self } } # [ doc = "Bit 4 - Compare channel buffer 0 valid" ] # [ inline ( always ) ] pub fn ccbufv0 ( & mut self ) -> CCBUFV0_W { CCBUFV0_W { w : self } } # [ doc = "Bit 5 - Compare channel buffer 1 valid" ] # [ inline ( always ) ] pub fn ccbufv1 ( & mut self ) -> CCBUFV1_W { CCBUFV1_W { w : self } } } } # [ doc = "Waveform Generation Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [wave](wave) module" ] pub type WAVE = crate :: Reg < u8 , _WAVE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WAVE ; # [ doc = "`read()` method returns [wave::R](wave::R) reader structure" ] impl crate :: Readable for WAVE { } # [ doc = "`write(|w| ..)` method takes [wave::W](wave::W) writer structure" ] impl crate :: Writable for WAVE { } # [ doc = "Waveform Generation Control" ] pub mod wave { # [ doc = "Reader of register WAVE" ] pub type R = crate :: R < u8 , super :: WAVE > ; # [ doc = "Writer for register WAVE" ] pub type W = crate :: W < u8 , super :: WAVE > ; # [ doc = "Register WAVE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WAVE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `WAVEGEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WAVEGEN_A { # [ doc = "Normal frequency" ] NFRQ , # [ doc = "Match frequency" ] MFRQ , # [ doc = "Normal PWM" ] NPWM , # [ doc = "Match PWM" ] MPWM } impl crate :: ToBits < u8 > for WAVEGEN_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WAVEGEN_A :: NFRQ => 0 , WAVEGEN_A :: MFRQ => 1 , WAVEGEN_A :: NPWM => 2 , WAVEGEN_A :: MPWM => 3 } } } # [ doc = "Reader of field `WAVEGEN`" ] pub type WAVEGEN_R = crate :: R < u8 , WAVEGEN_A > ; impl WAVEGEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WAVEGEN_A { match self . bits { 0 => WAVEGEN_A :: NFRQ , 1 => WAVEGEN_A :: MFRQ , 2 => WAVEGEN_A :: NPWM , 3 => WAVEGEN_A :: MPWM , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NFRQ`" ] # [ inline ( always ) ] pub fn is_nfrq ( & self ) -> bool { * self == WAVEGEN_A :: NFRQ } # [ doc = "Checks if the value of the field is `MFRQ`" ] # [ inline ( always ) ] pub fn is_mfrq ( & self ) -> bool { * self == WAVEGEN_A :: MFRQ } # [ doc = "Checks if the value of the field is `NPWM`" ] # [ inline ( always ) ] pub fn is_npwm ( & self ) -> bool { * self == WAVEGEN_A :: NPWM } # [ doc = "Checks if the value of the field is `MPWM`" ] # [ inline ( always ) ] pub fn is_mpwm ( & self ) -> bool { * self == WAVEGEN_A :: MPWM } } # [ doc = "Write proxy for field `WAVEGEN`" ] pub struct WAVEGEN_W < 'a > { w : & 'a mut W , } impl < 'a > WAVEGEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WAVEGEN_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Normal frequency" ] # [ inline ( always ) ] pub fn nfrq ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: NFRQ ) } # [ doc = "Match frequency" ] # [ inline ( always ) ] pub fn mfrq ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: MFRQ ) } # [ doc = "Normal PWM" ] # [ inline ( always ) ] pub fn npwm ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: NPWM ) } # [ doc = "Match PWM" ] # [ inline ( always ) ] pub fn mpwm ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: MPWM ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u8 ) & 0x03 ) ; self . w } } impl R { # [ doc = "Bits 0:1 - Waveform Generation Mode" ] # [ inline ( always ) ] pub fn wavegen ( & self ) -> WAVEGEN_R { WAVEGEN_R :: new ( ( self . bits & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1 - Waveform Generation Mode" ] # [ inline ( always ) ] pub fn wavegen ( & mut self ) -> WAVEGEN_W { WAVEGEN_W { w : self } } } } # [ doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [drvctrl](drvctrl) module" ] pub type DRVCTRL = crate :: Reg < u8 , _DRVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DRVCTRL ; # [ doc = "`read()` method returns [drvctrl::R](drvctrl::R) reader structure" ] impl crate :: Readable for DRVCTRL { } # [ doc = "`write(|w| ..)` method takes [drvctrl::W](drvctrl::W) writer structure" ] impl crate :: Writable for DRVCTRL { } # [ doc = "Control C" ] pub mod drvctrl { # [ doc = "Reader of register DRVCTRL" ] pub type R = crate :: R < u8 , super :: DRVCTRL > ; # [ doc = "Writer for register DRVCTRL" ] pub type W = crate :: W < u8 , super :: DRVCTRL > ; # [ doc = "Register DRVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DRVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `INVEN0`" ] pub type INVEN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `INVEN0`" ] pub struct INVEN0_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `INVEN1`" ] pub type INVEN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `INVEN1`" ] pub struct INVEN1_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } impl R { # [ doc = "Bit 0 - Output Waveform Invert Enable 0" ] # [ inline ( always ) ] pub fn inven0 ( & self ) -> INVEN0_R { INVEN0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Output Waveform Invert Enable 1" ] # [ inline ( always ) ] pub fn inven1 ( & self ) -> INVEN1_R { INVEN1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Output Waveform Invert Enable 0" ] # [ inline ( always ) ] pub fn inven0 ( & mut self ) -> INVEN0_W { INVEN0_W { w : self } } # [ doc = "Bit 1 - Output Waveform Invert Enable 1" ] # [ inline ( always ) ] pub fn inven1 ( & mut self ) -> INVEN1_W { INVEN1_W { w : self } } } } # [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } } } } # [ doc = "Synchronization Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "Synchronization Status" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CTRLB`" ] pub type CTRLB_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `STATUS`" ] pub type STATUS_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CC0`" ] pub type CC0_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CC1`" ] pub type CC1_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - swrst" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - CTRLB" ] # [ inline ( always ) ] pub fn ctrlb ( & self ) -> CTRLB_R { CTRLB_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - STATUS" ] # [ inline ( always ) ] pub fn status ( & self ) -> STATUS_R { STATUS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Counter" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Period" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Compare Channel 0" ] # [ inline ( always ) ] pub fn cc0 ( & self ) -> CC0_R { CC0_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Compare Channel 1" ] # [ inline ( always ) ] pub fn cc1 ( & self ) -> CC1_R { CC1_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } } # [ doc = "COUNT16 Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [count](count) module" ] pub type COUNT = crate :: Reg < u16 , _COUNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COUNT ; # [ doc = "`read()` method returns [count::R](count::R) reader structure" ] impl crate :: Readable for COUNT { } # [ doc = "`write(|w| ..)` method takes [count::W](count::W) writer structure" ] impl crate :: Writable for COUNT { } # [ doc = "COUNT16 Count" ] pub mod count { # [ doc = "Reader of register COUNT" ] pub type R = crate :: R < u16 , super :: COUNT > ; # [ doc = "Writer for register COUNT" ] pub type W = crate :: W < u16 , super :: COUNT > ; # [ doc = "Register COUNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COUNT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `COUNT`" ] pub struct COUNT_W < 'a > { w : & 'a mut W , } impl < 'a > COUNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & mut self ) -> COUNT_W { COUNT_W { w : self } } } } # [ doc = "COUNT16 Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cc](cc) module" ] pub type CC = crate :: Reg < u16 , _CC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CC ; # [ doc = "`read()` method returns [cc::R](cc::R) reader structure" ] impl crate :: Readable for CC { } # [ doc = "`write(|w| ..)` method takes [cc::W](cc::W) writer structure" ] impl crate :: Writable for CC { } # [ doc = "COUNT16 Compare and Capture" ] pub mod cc { # [ doc = "Reader of register CC[%s]" ] pub type R = crate :: R < u16 , super :: CC > ; # [ doc = "Writer for register CC[%s]" ] pub type W = crate :: W < u16 , super :: CC > ; # [ doc = "Register CC[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CC { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `CC`" ] pub type CC_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `CC`" ] pub struct CC_W < 'a > { w : & 'a mut W , } impl < 'a > CC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Counter/Compare Value" ] # [ inline ( always ) ] pub fn cc ( & self ) -> CC_R { CC_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Counter/Compare Value" ] # [ inline ( always ) ] pub fn cc ( & mut self ) -> CC_W { CC_W { w : self } } } } # [ doc = "COUNT16 Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ccbuf](ccbuf) module" ] pub type CCBUF = crate :: Reg < u16 , _CCBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CCBUF ; # [ doc = "`read()` method returns [ccbuf::R](ccbuf::R) reader structure" ] impl crate :: Readable for CCBUF { } # [ doc = "`write(|w| ..)` method takes [ccbuf::W](ccbuf::W) writer structure" ] impl crate :: Writable for CCBUF { } # [ doc = "COUNT16 Compare and Capture Buffer" ] pub mod ccbuf { # [ doc = "Reader of register CCBUF[%s]" ] pub type R = crate :: R < u16 , super :: CCBUF > ; # [ doc = "Writer for register CCBUF[%s]" ] pub type W = crate :: W < u16 , super :: CCBUF > ; # [ doc = "Register CCBUF[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CCBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `CCBUF`" ] pub type CCBUF_R = crate :: R < u16 , u16 > ; # [ doc = "Write proxy for field `CCBUF`" ] pub struct CCBUF_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff ) | ( ( value as u16 ) & 0xffff ) ; self . w } } impl R { # [ doc = "Bits 0:15 - Counter/Compare Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & self ) -> CCBUF_R { CCBUF_R :: new ( ( self . bits & 0xffff ) as u16 ) } } impl W { # [ doc = "Bits 0:15 - Counter/Compare Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & mut self ) -> CCBUF_W { CCBUF_W { w : self } } } } }
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct COUNT32 { # [ doc = "0x00 - Control A" ] pub ctrla : self::count32::CTRLA , # [ doc = "0x04 - Control B Clear" ] pub ctrlbclr : self::count32::CTRLBCLR , # [ doc = "0x05 - Control B Set" ] pub ctrlbset : self::count32::CTRLBSET , # [ doc = "0x06 - Event Control" ] pub evctrl : self::count32::EVCTRL , # [ doc = "0x08 - Interrupt Enable Clear" ] pub intenclr : self::count32::INTENCLR , # [ doc = "0x09 - Interrupt Enable Set" ] pub intenset : self::count32::INTENSET , # [ doc = "0x0a - Interrupt Flag Status and Clear" ] pub intflag : self::count32::INTFLAG , # [ doc = "0x0b - Status" ] pub status : self::count32::STATUS , # [ doc = "0x0c - Waveform Generation Control" ] pub wave : self::count32::WAVE , # [ doc = "0x0d - Control C" ] pub drvctrl : self::count32::DRVCTRL , _reserved10 : [ u8 ; 1usize ] , # [ doc = "0x0f - Debug Control" ] pub dbgctrl : self::count32::DBGCTRL , # [ doc = "0x10 - Synchronization Status" ] pub syncbusy : self::count32::SYNCBUSY , # [ doc = "0x14 - COUNT32 Count" ] pub count : self::count32::COUNT , _reserved13 : [ u8 ; 4usize ] , # [ doc = "0x1c - COUNT32 Compare and Capture" ] pub cc : [ self::count32::CC ; 2 ] , _reserved14 : [ u8 ; 12usize ] , # [ doc = "0x30 - COUNT32 Compare and Capture Buffer" ] pub ccbuf : [ self::count32::CCBUF ; 2 ] , } # [ doc = r"Register block" ] # [ doc = "32-bit Counter Mode" ] pub mod count32 { # [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ; # [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { } # [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { } # [ doc = "Control A" ] pub mod ctrla { # [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ; # [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ; # [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Possible values of the field `MODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum MODE_A { # [ doc = "Counter in 16-bit mode" ] COUNT16 , # [ doc = "Counter in 8-bit mode" ] COUNT8 , # [ doc = "Counter in 32-bit mode" ] COUNT32 } impl crate :: ToBits < u8 > for MODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { MODE_A :: COUNT16 => 0 , MODE_A :: COUNT8 => 1 , MODE_A :: COUNT32 => 2 } } } # [ doc = "Reader of field `MODE`" ] pub type MODE_R = crate :: R < u8 , MODE_A > ; impl MODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , MODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( MODE_A :: COUNT16 ) , 1 => Val ( MODE_A :: COUNT8 ) , 2 => Val ( MODE_A :: COUNT32 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `COUNT16`" ] # [ inline ( always ) ] pub fn is_count16 ( & self ) -> bool { * self == MODE_A :: COUNT16 } # [ doc = "Checks if the value of the field is `COUNT8`" ] # [ inline ( always ) ] pub fn is_count8 ( & self ) -> bool { * self == MODE_A :: COUNT8 } # [ doc = "Checks if the value of the field is `COUNT32`" ] # [ inline ( always ) ] pub fn is_count32 ( & self ) -> bool { * self == MODE_A :: COUNT32 } } # [ doc = "Write proxy for field `MODE`" ] pub struct MODE_W < 'a > { w : & 'a mut W , } impl < 'a > MODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : MODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Counter in 16-bit mode" ] # [ inline ( always ) ] pub fn count16 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT16 ) } # [ doc = "Counter in 8-bit mode" ] # [ inline ( always ) ] pub fn count8 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT8 ) } # [ doc = "Counter in 32-bit mode" ] # [ inline ( always ) ] pub fn count32 ( self ) -> & 'a mut W { self . variant ( MODE_A :: COUNT32 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 2 ) ) | ( ( ( value as u32 ) & 0x03 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `PRESCSYNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCSYNC_A { # [ doc = "Reload or reset the counter on next generic clock" ] GCLK , # [ doc = "Reload or reset the counter on next prescaler clock" ] PRESC , # [ doc = "Reload or reset the counter on next generic clock and reset the prescaler counter" ] RESYNC } impl crate :: ToBits < u8 > for PRESCSYNC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCSYNC_A :: GCLK => 0 , PRESCSYNC_A :: PRESC => 1 , PRESCSYNC_A :: RESYNC => 2 } } } # [ doc = "Reader of field `PRESCSYNC`" ] pub type PRESCSYNC_R = crate :: R < u8 , PRESCSYNC_A > ; impl PRESCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PRESCSYNC_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PRESCSYNC_A :: GCLK ) , 1 => Val ( PRESCSYNC_A :: PRESC ) , 2 => Val ( PRESCSYNC_A :: RESYNC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK`" ] # [ inline ( always ) ] pub fn is_gclk ( & self ) -> bool { * self == PRESCSYNC_A :: GCLK } # [ doc = "Checks if the value of the field is `PRESC`" ] # [ inline ( always ) ] pub fn is_presc ( & self ) -> bool { * self == PRESCSYNC_A :: PRESC } # [ doc = "Checks if the value of the field is `RESYNC`" ] # [ inline ( always ) ] pub fn is_resync ( & self ) -> bool { * self == PRESCSYNC_A :: RESYNC } } # [ doc = "Write proxy for field `PRESCSYNC`" ] pub struct PRESCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCSYNC_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Reload or reset the counter on next generic clock" ] # [ inline ( always ) ] pub fn gclk ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: GCLK ) } # [ doc = "Reload or reset the counter on next prescaler clock" ] # [ inline ( always ) ] pub fn presc ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: PRESC ) } # [ doc = "Reload or reset the counter on next generic clock and reset the prescaler counter" ] # [ inline ( always ) ] pub fn resync ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: RESYNC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } } # [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } } # [ doc = "Reader of field `ONDEMAND`" ] pub type ONDEMAND_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ONDEMAND`" ] pub struct ONDEMAND_W < 'a > { w : & 'a mut W , } impl < 'a > ONDEMAND_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } } # [ doc = "Possible values of the field `PRESCALER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER_A { # [ doc = "Prescaler: GCLK_TC" ] DIV1 , # [ doc = "Prescaler: GCLK_TC/2" ] DIV2 , # [ doc = "Prescaler: GCLK_TC/4" ] DIV4 , # [ doc = "Prescaler: GCLK_TC/8" ] DIV8 , # [ doc = "Prescaler: GCLK_TC/16" ] DIV16 , # [ doc = "Prescaler: GCLK_TC/64" ] DIV64 , # [ doc = "Prescaler: GCLK_TC/256" ] DIV256 , # [ doc = "Prescaler: GCLK_TC/1024" ] DIV1024 } impl crate :: ToBits < u8 > for PRESCALER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER_A :: DIV1 => 0 , PRESCALER_A :: DIV2 => 1 , PRESCALER_A :: DIV4 => 2 , PRESCALER_A :: DIV8 => 3 , PRESCALER_A :: DIV16 => 4 , PRESCALER_A :: DIV64 => 5 , PRESCALER_A :: DIV256 => 6 , PRESCALER_A :: DIV1024 => 7 } } } # [ doc = "Reader of field `PRESCALER`" ] pub type PRESCALER_R = crate :: R < u8 , PRESCALER_A > ; impl PRESCALER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV1024 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == PRESCALER_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER_A :: DIV256 } # [ doc = "Checks if the value of the field is `DIV1024`" ] # [ inline ( always ) ] pub fn is_div1024 ( & self ) -> bool { * self == PRESCALER_A :: DIV1024 } } # [ doc = "Write proxy for field `PRESCALER`" ] pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Prescaler: GCLK_TC" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1 ) } # [ doc = "Prescaler: GCLK_TC/2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV2 ) } # [ doc = "Prescaler: GCLK_TC/4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV4 ) } # [ doc = "Prescaler: GCLK_TC/8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV8 ) } # [ doc = "Prescaler: GCLK_TC/16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV16 ) } # [ doc = "Prescaler: GCLK_TC/64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV64 ) } # [ doc = "Prescaler: GCLK_TC/256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV256 ) } # [ doc = "Prescaler: GCLK_TC/1024" ] # [ inline ( always ) ] pub fn div1024 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u32 ) & 0x07 ) << 8 ) ; self . w } } # [ doc = "Reader of field `ALOCK`" ] pub type ALOCK_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ALOCK`" ] pub struct ALOCK_W < 'a > { w : & 'a mut W , } impl < 'a > ALOCK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } } # [ doc = "Reader of field `CAPTEN0`" ] pub type CAPTEN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CAPTEN0`" ] pub struct CAPTEN0_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } } # [ doc = "Reader of field `CAPTEN1`" ] pub type CAPTEN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CAPTEN1`" ] pub struct CAPTEN1_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } } # [ doc = "Reader of field `COPEN0`" ] pub type COPEN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COPEN0`" ] pub struct COPEN0_W < 'a > { w : & 'a mut W , } impl < 'a > COPEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } } # [ doc = "Reader of field `COPEN1`" ] pub type COPEN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `COPEN1`" ] pub struct COPEN1_W < 'a > { w : & 'a mut W , } impl < 'a > COPEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } } # [ doc = "Possible values of the field `CAPTMODE0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAPTMODE0_A { # [ doc = "Default capture" ] DEFAULT , # [ doc = "Minimum capture" ] CAPTMIN , # [ doc = "Maximum capture" ] CAPTMAX } impl crate :: ToBits < u8 > for CAPTMODE0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CAPTMODE0_A :: DEFAULT => 0 , CAPTMODE0_A :: CAPTMIN => 1 , CAPTMODE0_A :: CAPTMAX => 2 } } } # [ doc = "Reader of field `CAPTMODE0`" ] pub type CAPTMODE0_R = crate :: R < u8 , CAPTMODE0_A > ; impl CAPTMODE0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CAPTMODE0_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CAPTMODE0_A :: DEFAULT ) , 1 => Val ( CAPTMODE0_A :: CAPTMIN ) , 2 => Val ( CAPTMODE0_A :: CAPTMAX ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DEFAULT`" ] # [ inline ( always ) ] pub fn is_default ( & self ) -> bool { * self == CAPTMODE0_A :: DEFAULT } # [ doc = "Checks if the value of the field is `CAPTMIN`" ] # [ inline ( always ) ] pub fn is_captmin ( & self ) -> bool { * self == CAPTMODE0_A :: CAPTMIN } # [ doc = "Checks if the value of the field is `CAPTMAX`" ] # [ inline ( always ) ] pub fn is_captmax ( & self ) -> bool { * self == CAPTMODE0_A :: CAPTMAX } } # [ doc = "Write proxy for field `CAPTMODE0`" ] pub struct CAPTMODE0_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTMODE0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAPTMODE0_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Default capture" ] # [ inline ( always ) ] pub fn default ( self ) -> & 'a mut W { self . variant ( CAPTMODE0_A :: DEFAULT ) } # [ doc = "Minimum capture" ] # [ inline ( always ) ] pub fn captmin ( self ) -> & 'a mut W { self . variant ( CAPTMODE0_A :: CAPTMIN ) } # [ doc = "Maximum capture" ] # [ inline ( always ) ] pub fn captmax ( self ) -> & 'a mut W { self . variant ( CAPTMODE0_A :: CAPTMAX ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 24 ) ) | ( ( ( value as u32 ) & 0x03 ) << 24 ) ; self . w } } # [ doc = "Possible values of the field `CAPTMODE1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAPTMODE1_A { # [ doc = "Default capture" ] DEFAULT , # [ doc = "Minimum capture" ] CAPTMIN , # [ doc = "Maximum capture" ] CAPTMAX } impl crate :: ToBits < u8 > for CAPTMODE1_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CAPTMODE1_A :: DEFAULT => 0 , CAPTMODE1_A :: CAPTMIN => 1 , CAPTMODE1_A :: CAPTMAX => 2 } } } # [ doc = "Reader of field `CAPTMODE1`" ] pub type CAPTMODE1_R = crate :: R < u8 , CAPTMODE1_A > ; impl CAPTMODE1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CAPTMODE1_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CAPTMODE1_A :: DEFAULT ) , 1 => Val ( CAPTMODE1_A :: CAPTMIN ) , 2 => Val ( CAPTMODE1_A :: CAPTMAX ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DEFAULT`" ] # [ inline ( always ) ] pub fn is_default ( & self ) -> bool { * self == CAPTMODE1_A :: DEFAULT } # [ doc = "Checks if the value of the field is `CAPTMIN`" ] # [ inline ( always ) ] pub fn is_captmin ( & self ) -> bool { * self == CAPTMODE1_A :: CAPTMIN } # [ doc = "Checks if the value of the field is `CAPTMAX`" ] # [ inline ( always ) ] pub fn is_captmax ( & self ) -> bool { * self == CAPTMODE1_A :: CAPTMAX } } # [ doc = "Write proxy for field `CAPTMODE1`" ] pub struct CAPTMODE1_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTMODE1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAPTMODE1_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Default capture" ] # [ inline ( always ) ] pub fn default ( self ) -> & 'a mut W { self . variant ( CAPTMODE1_A :: DEFAULT ) } # [ doc = "Minimum capture" ] # [ inline ( always ) ] pub fn captmin ( self ) -> & 'a mut W { self . variant ( CAPTMODE1_A :: CAPTMIN ) } # [ doc = "Maximum capture" ] # [ inline ( always ) ] pub fn captmax ( self ) -> & 'a mut W { self . variant ( CAPTMODE1_A :: CAPTMAX ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 27 ) ) | ( ( ( value as u32 ) & 0x03 ) << 27 ) ; self . w } } impl R { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bits 2:3 - Timer Counter Mode" ] # [ inline ( always ) ] pub fn mode ( & self ) -> MODE_R { MODE_R :: new ( ( ( self . bits >> 2 ) & 0x03 ) as u8 ) } # [ doc = "Bits 4:5 - Prescaler and Counter Synchronization" ] # [ inline ( always ) ] pub fn prescsync ( & self ) -> PRESCSYNC_R { PRESCSYNC_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) } # [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Clock On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & self ) -> ONDEMAND_R { ONDEMAND_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } # [ doc = "Bits 8:10 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) } # [ doc = "Bit 11 - Auto Lock" ] # [ inline ( always ) ] pub fn alock ( & self ) -> ALOCK_R { ALOCK_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) } # [ doc = "Bit 16 - Capture Channel 0 Enable" ] # [ inline ( always ) ] pub fn capten0 ( & self ) -> CAPTEN0_R { CAPTEN0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) } # [ doc = "Bit 17 - Capture Channel 1 Enable" ] # [ inline ( always ) ] pub fn capten1 ( & self ) -> CAPTEN1_R { CAPTEN1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) } # [ doc = "Bit 20 - Capture On Pin 0 Enable" ] # [ inline ( always ) ] pub fn copen0 ( & self ) -> COPEN0_R { COPEN0_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) } # [ doc = "Bit 21 - Capture On Pin 1 Enable" ] # [ inline ( always ) ] pub fn copen1 ( & self ) -> COPEN1_R { COPEN1_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) } # [ doc = "Bits 24:25 - Capture Mode Channel 0" ] # [ inline ( always ) ] pub fn captmode0 ( & self ) -> CAPTMODE0_R { CAPTMODE0_R :: new ( ( ( self . bits >> 24 ) & 0x03 ) as u8 ) } # [ doc = "Bits 27:28 - Capture mode Channel 1" ] # [ inline ( always ) ] pub fn captmode1 ( & self ) -> CAPTMODE1_R { CAPTMODE1_R :: new ( ( ( self . bits >> 27 ) & 0x03 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } } # [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } } # [ doc = "Bits 2:3 - Timer Counter Mode" ] # [ inline ( always ) ] pub fn mode ( & mut self ) -> MODE_W { MODE_W { w : self } } # [ doc = "Bits 4:5 - Prescaler and Counter Synchronization" ] # [ inline ( always ) ] pub fn prescsync ( & mut self ) -> PRESCSYNC_W { PRESCSYNC_W { w : self } } # [ doc = "Bit 6 - Run during Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } } # [ doc = "Bit 7 - Clock On Demand" ] # [ inline ( always ) ] pub fn ondemand ( & mut self ) -> ONDEMAND_W { ONDEMAND_W { w : self } } # [ doc = "Bits 8:10 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } } # [ doc = "Bit 11 - Auto Lock" ] # [ inline ( always ) ] pub fn alock ( & mut self ) -> ALOCK_W { ALOCK_W { w : self } } # [ doc = "Bit 16 - Capture Channel 0 Enable" ] # [ inline ( always ) ] pub fn capten0 ( & mut self ) -> CAPTEN0_W { CAPTEN0_W { w : self } } # [ doc = "Bit 17 - Capture Channel 1 Enable" ] # [ inline ( always ) ] pub fn capten1 ( & mut self ) -> CAPTEN1_W { CAPTEN1_W { w : self } } # [ doc = "Bit 20 - Capture On Pin 0 Enable" ] # [ inline ( always ) ] pub fn copen0 ( & mut self ) -> COPEN0_W { COPEN0_W { w : self } } # [ doc = "Bit 21 - Capture On Pin 1 Enable" ] # [ inline ( always ) ] pub fn copen1 ( & mut self ) -> COPEN1_W { COPEN1_W { w : self } } # [ doc = "Bits 24:25 - Capture Mode Channel 0" ] # [ inline ( always ) ] pub fn captmode0 ( & mut self ) -> CAPTMODE0_W { CAPTMODE0_W { w : self } } # [ doc = "Bits 27:28 - Capture mode Channel 1" ] # [ inline ( always ) ] pub fn captmode1 ( & mut self ) -> CAPTMODE1_W { CAPTMODE1_W { w : self } } } } # [ doc = "Control B Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlbclr](ctrlbclr) module" ] pub type CTRLBCLR = crate :: Reg < u8 , _CTRLBCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLBCLR ; # [ doc = "`read()` method returns [ctrlbclr::R](ctrlbclr::R) reader structure" ] impl crate :: Readable for CTRLBCLR { } # [ doc = "`write(|w| ..)` method takes [ctrlbclr::W](ctrlbclr::W) writer structure" ] impl crate :: Writable for CTRLBCLR { } # [ doc = "Control B Clear" ] pub mod ctrlbclr { # [ doc = "Reader of register CTRLBCLR" ] pub type R = crate :: R < u8 , super :: CTRLBCLR > ; # [ doc = "Writer for register CTRLBCLR" ] pub type W = crate :: W < u8 , super :: CTRLBCLR > ; # [ doc = "Register CTRLBCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLBCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DIR`" ] pub type DIR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DIR`" ] pub struct DIR_W < 'a > { w : & 'a mut W , } impl < 'a > DIR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LUPD`" ] pub type LUPD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LUPD`" ] pub struct LUPD_W < 'a > { w : & 'a mut W , } impl < 'a > LUPD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ONESHOT`" ] pub type ONESHOT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ONESHOT`" ] pub struct ONESHOT_W < 'a > { w : & 'a mut W , } impl < 'a > ONESHOT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "No action" ] NONE , # [ doc = "Force a start, restart or retrigger" ] RETRIGGER , # [ doc = "Force a stop" ] STOP , # [ doc = "Force update of double-buffered register" ] UPDATE , # [ doc = "Force a read synchronization of COUNT" ] READSYNC , # [ doc = "One-shot DMA trigger" ] DMAOS } impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: NONE => 0 , CMD_A :: RETRIGGER => 1 , CMD_A :: STOP => 2 , CMD_A :: UPDATE => 3 , CMD_A :: READSYNC => 4 , CMD_A :: DMAOS => 5 } } } # [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CMD_A :: NONE ) , 1 => Val ( CMD_A :: RETRIGGER ) , 2 => Val ( CMD_A :: STOP ) , 3 => Val ( CMD_A :: UPDATE ) , 4 => Val ( CMD_A :: READSYNC ) , 5 => Val ( CMD_A :: DMAOS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CMD_A :: NONE } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == CMD_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == CMD_A :: STOP } # [ doc = "Checks if the value of the field is `UPDATE`" ] # [ inline ( always ) ] pub fn is_update ( & self ) -> bool { * self == CMD_A :: UPDATE } # [ doc = "Checks if the value of the field is `READSYNC`" ] # [ inline ( always ) ] pub fn is_readsync ( & self ) -> bool { * self == CMD_A :: READSYNC } # [ doc = "Checks if the value of the field is `DMAOS`" ] # [ inline ( always ) ] pub fn is_dmaos ( & self ) -> bool { * self == CMD_A :: DMAOS } } # [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CMD_A :: NONE ) } # [ doc = "Force a start, restart or retrigger" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( CMD_A :: RETRIGGER ) } # [ doc = "Force a stop" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( CMD_A :: STOP ) } # [ doc = "Force update of double-buffered register" ] # [ inline ( always ) ] pub fn update ( self ) -> & 'a mut W { self . variant ( CMD_A :: UPDATE ) } # [ doc = "Force a read synchronization of COUNT" ] # [ inline ( always ) ] pub fn readsync ( self ) -> & 'a mut W { self . variant ( CMD_A :: READSYNC ) } # [ doc = "One-shot DMA trigger" ] # [ inline ( always ) ] pub fn dmaos ( self ) -> & 'a mut W { self . variant ( CMD_A :: DMAOS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u8 ) & 0x07 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & self ) -> DIR_R { DIR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & self ) -> LUPD_R { LUPD_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & self ) -> ONESHOT_R { ONESHOT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & mut self ) -> DIR_W { DIR_W { w : self } } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & mut self ) -> LUPD_W { LUPD_W { w : self } } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & mut self ) -> ONESHOT_W { ONESHOT_W { w : self } } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } } } } # [ doc = "Control B Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlbset](ctrlbset) module" ] pub type CTRLBSET = crate :: Reg < u8 , _CTRLBSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLBSET ; # [ doc = "`read()` method returns [ctrlbset::R](ctrlbset::R) reader structure" ] impl crate :: Readable for CTRLBSET { } # [ doc = "`write(|w| ..)` method takes [ctrlbset::W](ctrlbset::W) writer structure" ] impl crate :: Writable for CTRLBSET { } # [ doc = "Control B Set" ] pub mod ctrlbset { # [ doc = "Reader of register CTRLBSET" ] pub type R = crate :: R < u8 , super :: CTRLBSET > ; # [ doc = "Writer for register CTRLBSET" ] pub type W = crate :: W < u8 , super :: CTRLBSET > ; # [ doc = "Register CTRLBSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLBSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DIR`" ] pub type DIR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DIR`" ] pub struct DIR_W < 'a > { w : & 'a mut W , } impl < 'a > DIR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `LUPD`" ] pub type LUPD_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `LUPD`" ] pub struct LUPD_W < 'a > { w : & 'a mut W , } impl < 'a > LUPD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `ONESHOT`" ] pub type ONESHOT_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ONESHOT`" ] pub struct ONESHOT_W < 'a > { w : & 'a mut W , } impl < 'a > ONESHOT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } } # [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "No action" ] NONE , # [ doc = "Force a start, restart or retrigger" ] RETRIGGER , # [ doc = "Force a stop" ] STOP , # [ doc = "Force update of double-buffered register" ] UPDATE , # [ doc = "Force a read synchronization of COUNT" ] READSYNC , # [ doc = "One-shot DMA trigger" ] DMAOS } impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: NONE => 0 , CMD_A :: RETRIGGER => 1 , CMD_A :: STOP => 2 , CMD_A :: UPDATE => 3 , CMD_A :: READSYNC => 4 , CMD_A :: DMAOS => 5 } } } # [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CMD_A :: NONE ) , 1 => Val ( CMD_A :: RETRIGGER ) , 2 => Val ( CMD_A :: STOP ) , 3 => Val ( CMD_A :: UPDATE ) , 4 => Val ( CMD_A :: READSYNC ) , 5 => Val ( CMD_A :: DMAOS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CMD_A :: NONE } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == CMD_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == CMD_A :: STOP } # [ doc = "Checks if the value of the field is `UPDATE`" ] # [ inline ( always ) ] pub fn is_update ( & self ) -> bool { * self == CMD_A :: UPDATE } # [ doc = "Checks if the value of the field is `READSYNC`" ] # [ inline ( always ) ] pub fn is_readsync ( & self ) -> bool { * self == CMD_A :: READSYNC } # [ doc = "Checks if the value of the field is `DMAOS`" ] # [ inline ( always ) ] pub fn is_dmaos ( & self ) -> bool { * self == CMD_A :: DMAOS } } # [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CMD_A :: NONE ) } # [ doc = "Force a start, restart or retrigger" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( CMD_A :: RETRIGGER ) } # [ doc = "Force a stop" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( CMD_A :: STOP ) } # [ doc = "Force update of double-buffered register" ] # [ inline ( always ) ] pub fn update ( self ) -> & 'a mut W { self . variant ( CMD_A :: UPDATE ) } # [ doc = "Force a read synchronization of COUNT" ] # [ inline ( always ) ] pub fn readsync ( self ) -> & 'a mut W { self . variant ( CMD_A :: READSYNC ) } # [ doc = "One-shot DMA trigger" ] # [ inline ( always ) ] pub fn dmaos ( self ) -> & 'a mut W { self . variant ( CMD_A :: DMAOS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u8 ) & 0x07 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & self ) -> DIR_R { DIR_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & self ) -> LUPD_R { LUPD_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & self ) -> ONESHOT_R { ONESHOT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) } } impl W { # [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & mut self ) -> DIR_W { DIR_W { w : self } } # [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & mut self ) -> LUPD_W { LUPD_W { w : self } } # [ doc = "Bit 2 - One-Shot on Counter" ] # [ inline ( always ) ] pub fn oneshot ( & mut self ) -> ONESHOT_W { ONESHOT_W { w : self } } # [ doc = "Bits 5:7 - Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } } } } # [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u16 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ; # [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { } # [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { } # [ doc = "Event Control" ] pub mod evctrl { # [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u16 , super :: EVCTRL > ; # [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u16 , super :: EVCTRL > ; # [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `EVACT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EVACT_A { # [ doc = "Event action disabled" ] OFF , # [ doc = "Start, restart or retrigger TC on event" ] RETRIGGER , # [ doc = "Count on event" ] COUNT , # [ doc = "Start TC on event" ] START , # [ doc = "Time stamp capture" ] STAMP , # [ doc = "Period catured in CC0, pulse width in CC1" ] PPW , # [ doc = "Period catured in CC1, pulse width in CC0" ] PWP , # [ doc = "Pulse width capture" ] PW } impl crate :: ToBits < u8 > for EVACT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { EVACT_A :: OFF => 0 , EVACT_A :: RETRIGGER => 1 , EVACT_A :: COUNT => 2 , EVACT_A :: START => 3 , EVACT_A :: STAMP => 4 , EVACT_A :: PPW => 5 , EVACT_A :: PWP => 6 , EVACT_A :: PW => 7 } } } # [ doc = "Reader of field `EVACT`" ] pub type EVACT_R = crate :: R < u8 , EVACT_A > ; impl EVACT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EVACT_A { match self . bits { 0 => EVACT_A :: OFF , 1 => EVACT_A :: RETRIGGER , 2 => EVACT_A :: COUNT , 3 => EVACT_A :: START , 4 => EVACT_A :: STAMP , 5 => EVACT_A :: PPW , 6 => EVACT_A :: PWP , 7 => EVACT_A :: PW , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == EVACT_A :: OFF } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == EVACT_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `COUNT`" ] # [ inline ( always ) ] pub fn is_count ( & self ) -> bool { * self == EVACT_A :: COUNT } # [ doc = "Checks if the value of the field is `START`" ] # [ inline ( always ) ] pub fn is_start ( & self ) -> bool { * self == EVACT_A :: START } # [ doc = "Checks if the value of the field is `STAMP`" ] # [ inline ( always ) ] pub fn is_stamp ( & self ) -> bool { * self == EVACT_A :: STAMP } # [ doc = "Checks if the value of the field is `PPW`" ] # [ inline ( always ) ] pub fn is_ppw ( & self ) -> bool { * self == EVACT_A :: PPW } # [ doc = "Checks if the value of the field is `PWP`" ] # [ inline ( always ) ] pub fn is_pwp ( & self ) -> bool { * self == EVACT_A :: PWP } # [ doc = "Checks if the value of the field is `PW`" ] # [ inline ( always ) ] pub fn is_pw ( & self ) -> bool { * self == EVACT_A :: PW } } # [ doc = "Write proxy for field `EVACT`" ] pub struct EVACT_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EVACT_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Event action disabled" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( EVACT_A :: OFF ) } # [ doc = "Start, restart or retrigger TC on event" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( EVACT_A :: RETRIGGER ) } # [ doc = "Count on event" ] # [ inline ( always ) ] pub fn count ( self ) -> & 'a mut W { self . variant ( EVACT_A :: COUNT ) } # [ doc = "Start TC on event" ] # [ inline ( always ) ] pub fn start ( self ) -> & 'a mut W { self . variant ( EVACT_A :: START ) } # [ doc = "Time stamp capture" ] # [ inline ( always ) ] pub fn stamp ( self ) -> & 'a mut W { self . variant ( EVACT_A :: STAMP ) } # [ doc = "Period catured in CC0, pulse width in CC1" ] # [ inline ( always ) ] pub fn ppw ( self ) -> & 'a mut W { self . variant ( EVACT_A :: PPW ) } # [ doc = "Period catured in CC1, pulse width in CC0" ] # [ inline ( always ) ] pub fn pwp ( self ) -> & 'a mut W { self . variant ( EVACT_A :: PWP ) } # [ doc = "Pulse width capture" ] # [ inline ( always ) ] pub fn pw ( self ) -> & 'a mut W { self . variant ( EVACT_A :: PW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u16 ) & 0x07 ) ; self . w } } # [ doc = "Reader of field `TCINV`" ] pub type TCINV_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TCINV`" ] pub struct TCINV_W < 'a > { w : & 'a mut W , } impl < 'a > TCINV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `TCEI`" ] pub type TCEI_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `TCEI`" ] pub struct TCEI_W < 'a > { w : & 'a mut W , } impl < 'a > TCEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } } # [ doc = "Reader of field `OVFEO`" ] pub type OVFEO_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVFEO`" ] pub struct OVFEO_W < 'a > { w : & 'a mut W , } impl < 'a > OVFEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } } # [ doc = "Reader of field `MCEO0`" ] pub type MCEO0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MCEO0`" ] pub struct MCEO0_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } } # [ doc = "Reader of field `MCEO1`" ] pub type MCEO1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MCEO1`" ] pub struct MCEO1_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } } impl R { # [ doc = "Bits 0:2 - Event Action" ] # [ inline ( always ) ] pub fn evact ( & self ) -> EVACT_R { EVACT_R :: new ( ( self . bits & 0x07 ) as u8 ) } # [ doc = "Bit 4 - TC Event Input Polarity" ] # [ inline ( always ) ] pub fn tcinv ( & self ) -> TCINV_R { TCINV_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - TC Event Enable" ] # [ inline ( always ) ] pub fn tcei ( & self ) -> TCEI_R { TCEI_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 8 - Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & self ) -> OVFEO_R { OVFEO_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) } # [ doc = "Bit 12 - MC Event Output Enable 0" ] # [ inline ( always ) ] pub fn mceo0 ( & self ) -> MCEO0_R { MCEO0_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) } # [ doc = "Bit 13 - MC Event Output Enable 1" ] # [ inline ( always ) ] pub fn mceo1 ( & self ) -> MCEO1_R { MCEO1_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bits 0:2 - Event Action" ] # [ inline ( always ) ] pub fn evact ( & mut self ) -> EVACT_W { EVACT_W { w : self } } # [ doc = "Bit 4 - TC Event Input Polarity" ] # [ inline ( always ) ] pub fn tcinv ( & mut self ) -> TCINV_W { TCINV_W { w : self } } # [ doc = "Bit 5 - TC Event Enable" ] # [ inline ( always ) ] pub fn tcei ( & mut self ) -> TCEI_W { TCEI_W { w : self } } # [ doc = "Bit 8 - Event Output Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & mut self ) -> OVFEO_W { OVFEO_W { w : self } } # [ doc = "Bit 12 - MC Event Output Enable 0" ] # [ inline ( always ) ] pub fn mceo0 ( & mut self ) -> MCEO0_W { MCEO0_W { w : self } } # [ doc = "Bit 13 - MC Event Output Enable 1" ] # [ inline ( always ) ] pub fn mceo1 ( & mut self ) -> MCEO1_W { MCEO1_W { w : self } } } } # [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ; # [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { } # [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { } # [ doc = "Interrupt Enable Clear" ] pub mod intenclr { # [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ; # [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ; # [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - OVF Interrupt Disable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - ERR Interrupt Disable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - MC Interrupt Disable 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - MC Interrupt Disable 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - OVF Interrupt Disable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } # [ doc = "Bit 1 - ERR Interrupt Disable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } # [ doc = "Bit 4 - MC Interrupt Disable 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } } # [ doc = "Bit 5 - MC Interrupt Disable 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } } } } # [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ; # [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { } # [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { } # [ doc = "Interrupt Enable Set" ] pub mod intenset { # [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ; # [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ; # [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - OVF Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - ERR Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - MC Interrupt Enable 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - MC Interrupt Enable 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - OVF Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } # [ doc = "Bit 1 - ERR Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } # [ doc = "Bit 4 - MC Interrupt Enable 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } } # [ doc = "Bit 5 - MC Interrupt Enable 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } } } } # [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ; # [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { } # [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { } # [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag { # [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ; # [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ; # [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - OVF Interrupt Flag" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - ERR Interrupt Flag" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - MC Interrupt Flag 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - MC Interrupt Flag 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - OVF Interrupt Flag" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } } # [ doc = "Bit 1 - ERR Interrupt Flag" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } } # [ doc = "Bit 4 - MC Interrupt Flag 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } } # [ doc = "Bit 5 - MC Interrupt Flag 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } } } } # [ doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u8 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ; # [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { } # [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { } # [ doc = "Status" ] pub mod status { # [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u8 , super :: STATUS > ; # [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u8 , super :: STATUS > ; # [ doc = "Register STATUS `reset()`'s with value 0x01" ] impl crate :: ResetValue for super :: STATUS { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x01 } } # [ doc = "Reader of field `STOP`" ] pub type STOP_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `STOP`" ] pub struct STOP_W < 'a > { w : & 'a mut W , } impl < 'a > STOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `SLAVE`" ] pub type SLAVE_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `SLAVE`" ] pub struct SLAVE_W < 'a > { w : & 'a mut W , } impl < 'a > SLAVE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } # [ doc = "Reader of field `PERBUFV`" ] pub type PERBUFV_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `PERBUFV`" ] pub struct PERBUFV_W < 'a > { w : & 'a mut W , } impl < 'a > PERBUFV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } } # [ doc = "Reader of field `CCBUFV0`" ] pub type CCBUFV0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CCBUFV0`" ] pub struct CCBUFV0_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } } # [ doc = "Reader of field `CCBUFV1`" ] pub type CCBUFV1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `CCBUFV1`" ] pub struct CCBUFV1_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u8 ) & 0x01 ) << 5 ) ; self . w } } impl R { # [ doc = "Bit 0 - Stop Status Flag" ] # [ inline ( always ) ] pub fn stop ( & self ) -> STOP_R { STOP_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Slave Status Flag" ] # [ inline ( always ) ] pub fn slave ( & self ) -> SLAVE_R { SLAVE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - Synchronization Busy Status" ] # [ inline ( always ) ] pub fn perbufv ( & self ) -> PERBUFV_R { PERBUFV_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Compare channel buffer 0 valid" ] # [ inline ( always ) ] pub fn ccbufv0 ( & self ) -> CCBUFV0_R { CCBUFV0_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Compare channel buffer 1 valid" ] # [ inline ( always ) ] pub fn ccbufv1 ( & self ) -> CCBUFV1_R { CCBUFV1_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Stop Status Flag" ] # [ inline ( always ) ] pub fn stop ( & mut self ) -> STOP_W { STOP_W { w : self } } # [ doc = "Bit 1 - Slave Status Flag" ] # [ inline ( always ) ] pub fn slave ( & mut self ) -> SLAVE_W { SLAVE_W { w : self } } # [ doc = "Bit 3 - Synchronization Busy Status" ] # [ inline ( always ) ] pub fn perbufv ( & mut self ) -> PERBUFV_W { PERBUFV_W { w : self } } # [ doc = "Bit 4 - Compare channel buffer 0 valid" ] # [ inline ( always ) ] pub fn ccbufv0 ( & mut self ) -> CCBUFV0_W { CCBUFV0_W { w : self } } # [ doc = "Bit 5 - Compare channel buffer 1 valid" ] # [ inline ( always ) ] pub fn ccbufv1 ( & mut self ) -> CCBUFV1_W { CCBUFV1_W { w : self } } } } # [ doc = "Waveform Generation Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [wave](wave) module" ] pub type WAVE = crate :: Reg < u8 , _WAVE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WAVE ; # [ doc = "`read()` method returns [wave::R](wave::R) reader structure" ] impl crate :: Readable for WAVE { } # [ doc = "`write(|w| ..)` method takes [wave::W](wave::W) writer structure" ] impl crate :: Writable for WAVE { } # [ doc = "Waveform Generation Control" ] pub mod wave { # [ doc = "Reader of register WAVE" ] pub type R = crate :: R < u8 , super :: WAVE > ; # [ doc = "Writer for register WAVE" ] pub type W = crate :: W < u8 , super :: WAVE > ; # [ doc = "Register WAVE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WAVE { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Possible values of the field `WAVEGEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WAVEGEN_A { # [ doc = "Normal frequency" ] NFRQ , # [ doc = "Match frequency" ] MFRQ , # [ doc = "Normal PWM" ] NPWM , # [ doc = "Match PWM" ] MPWM } impl crate :: ToBits < u8 > for WAVEGEN_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WAVEGEN_A :: NFRQ => 0 , WAVEGEN_A :: MFRQ => 1 , WAVEGEN_A :: NPWM => 2 , WAVEGEN_A :: MPWM => 3 } } } # [ doc = "Reader of field `WAVEGEN`" ] pub type WAVEGEN_R = crate :: R < u8 , WAVEGEN_A > ; impl WAVEGEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> WAVEGEN_A { match self . bits { 0 => WAVEGEN_A :: NFRQ , 1 => WAVEGEN_A :: MFRQ , 2 => WAVEGEN_A :: NPWM , 3 => WAVEGEN_A :: MPWM , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NFRQ`" ] # [ inline ( always ) ] pub fn is_nfrq ( & self ) -> bool { * self == WAVEGEN_A :: NFRQ } # [ doc = "Checks if the value of the field is `MFRQ`" ] # [ inline ( always ) ] pub fn is_mfrq ( & self ) -> bool { * self == WAVEGEN_A :: MFRQ } # [ doc = "Checks if the value of the field is `NPWM`" ] # [ inline ( always ) ] pub fn is_npwm ( & self ) -> bool { * self == WAVEGEN_A :: NPWM } # [ doc = "Checks if the value of the field is `MPWM`" ] # [ inline ( always ) ] pub fn is_mpwm ( & self ) -> bool { * self == WAVEGEN_A :: MPWM } } # [ doc = "Write proxy for field `WAVEGEN`" ] pub struct WAVEGEN_W < 'a > { w : & 'a mut W , } impl < 'a > WAVEGEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WAVEGEN_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Normal frequency" ] # [ inline ( always ) ] pub fn nfrq ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: NFRQ ) } # [ doc = "Match frequency" ] # [ inline ( always ) ] pub fn mfrq ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: MFRQ ) } # [ doc = "Normal PWM" ] # [ inline ( always ) ] pub fn npwm ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: NPWM ) } # [ doc = "Match PWM" ] # [ inline ( always ) ] pub fn mpwm ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: MPWM ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u8 ) & 0x03 ) ; self . w } } impl R { # [ doc = "Bits 0:1 - Waveform Generation Mode" ] # [ inline ( always ) ] pub fn wavegen ( & self ) -> WAVEGEN_R { WAVEGEN_R :: new ( ( self . bits & 0x03 ) as u8 ) } } impl W { # [ doc = "Bits 0:1 - Waveform Generation Mode" ] # [ inline ( always ) ] pub fn wavegen ( & mut self ) -> WAVEGEN_W { WAVEGEN_W { w : self } } } } # [ doc = "Control C\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [drvctrl](drvctrl) module" ] pub type DRVCTRL = crate :: Reg < u8 , _DRVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DRVCTRL ; # [ doc = "`read()` method returns [drvctrl::R](drvctrl::R) reader structure" ] impl crate :: Readable for DRVCTRL { } # [ doc = "`write(|w| ..)` method takes [drvctrl::W](drvctrl::W) writer structure" ] impl crate :: Writable for DRVCTRL { } # [ doc = "Control C" ] pub mod drvctrl { # [ doc = "Reader of register DRVCTRL" ] pub type R = crate :: R < u8 , super :: DRVCTRL > ; # [ doc = "Writer for register DRVCTRL" ] pub type W = crate :: W < u8 , super :: DRVCTRL > ; # [ doc = "Register DRVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DRVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `INVEN0`" ] pub type INVEN0_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `INVEN0`" ] pub struct INVEN0_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } # [ doc = "Reader of field `INVEN1`" ] pub type INVEN1_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `INVEN1`" ] pub struct INVEN1_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } } impl R { # [ doc = "Bit 0 - Output Waveform Invert Enable 0" ] # [ inline ( always ) ] pub fn inven0 ( & self ) -> INVEN0_R { INVEN0_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - Output Waveform Invert Enable 1" ] # [ inline ( always ) ] pub fn inven1 ( & self ) -> INVEN1_R { INVEN1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Output Waveform Invert Enable 0" ] # [ inline ( always ) ] pub fn inven0 ( & mut self ) -> INVEN0_W { INVEN0_W { w : self } } # [ doc = "Bit 1 - Output Waveform Invert Enable 1" ] # [ inline ( always ) ] pub fn inven1 ( & mut self ) -> INVEN1_W { INVEN1_W { w : self } } } } # [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ; # [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { } # [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { } # [ doc = "Debug Control" ] pub mod dbgctrl { # [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ; # [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ; # [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ; # [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } } impl R { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) } } impl W { # [ doc = "Bit 0 - Run During Debug" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } } } } # [ doc = "Synchronization Status\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ; # [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { } # [ doc = "Synchronization Status" ] pub mod syncbusy { # [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ; # [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CTRLB`" ] pub type CTRLB_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `STATUS`" ] pub type STATUS_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CC0`" ] pub type CC0_R = crate :: R < bool , bool > ; # [ doc = "Reader of field `CC1`" ] pub type CC1_R = crate :: R < bool , bool > ; impl R { # [ doc = "Bit 0 - swrst" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) } # [ doc = "Bit 1 - enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) } # [ doc = "Bit 2 - CTRLB" ] # [ inline ( always ) ] pub fn ctrlb ( & self ) -> CTRLB_R { CTRLB_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) } # [ doc = "Bit 3 - STATUS" ] # [ inline ( always ) ] pub fn status ( & self ) -> STATUS_R { STATUS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) } # [ doc = "Bit 4 - Counter" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) } # [ doc = "Bit 5 - Period" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) } # [ doc = "Bit 6 - Compare Channel 0" ] # [ inline ( always ) ] pub fn cc0 ( & self ) -> CC0_R { CC0_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) } # [ doc = "Bit 7 - Compare Channel 1" ] # [ inline ( always ) ] pub fn cc1 ( & self ) -> CC1_R { CC1_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) } } } # [ doc = "COUNT32 Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [count](count) module" ] pub type COUNT = crate :: Reg < u32 , _COUNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COUNT ; # [ doc = "`read()` method returns [count::R](count::R) reader structure" ] impl crate :: Readable for COUNT { } # [ doc = "`write(|w| ..)` method takes [count::W](count::W) writer structure" ] impl crate :: Writable for COUNT { } # [ doc = "COUNT32 Count" ] pub mod count { # [ doc = "Reader of register COUNT" ] pub type R = crate :: R < u32 , super :: COUNT > ; # [ doc = "Writer for register COUNT" ] pub type W = crate :: W < u32 , super :: COUNT > ; # [ doc = "Register COUNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COUNT { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `COUNT`" ] pub struct COUNT_W < 'a > { w : & 'a mut W , } impl < 'a > COUNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & mut self ) -> COUNT_W { COUNT_W { w : self } } } } # [ doc = "COUNT32 Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cc](cc) module" ] pub type CC = crate :: Reg < u32 , _CC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CC ; # [ doc = "`read()` method returns [cc::R](cc::R) reader structure" ] impl crate :: Readable for CC { } # [ doc = "`write(|w| ..)` method takes [cc::W](cc::W) writer structure" ] impl crate :: Writable for CC { } # [ doc = "COUNT32 Compare and Capture" ] pub mod cc { # [ doc = "Reader of register CC[%s]" ] pub type R = crate :: R < u32 , super :: CC > ; # [ doc = "Writer for register CC[%s]" ] pub type W = crate :: W < u32 , super :: CC > ; # [ doc = "Register CC[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `CC`" ] pub type CC_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `CC`" ] pub struct CC_W < 'a > { w : & 'a mut W , } impl < 'a > CC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Counter/Compare Value" ] # [ inline ( always ) ] pub fn cc ( & self ) -> CC_R { CC_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Counter/Compare Value" ] # [ inline ( always ) ] pub fn cc ( & mut self ) -> CC_W { CC_W { w : self } } } } # [ doc = "COUNT32 Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ccbuf](ccbuf) module" ] pub type CCBUF = crate :: Reg < u32 , _CCBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CCBUF ; # [ doc = "`read()` method returns [ccbuf::R](ccbuf::R) reader structure" ] impl crate :: Readable for CCBUF { } # [ doc = "`write(|w| ..)` method takes [ccbuf::W](ccbuf::W) writer structure" ] impl crate :: Writable for CCBUF { } # [ doc = "COUNT32 Compare and Capture Buffer" ] pub mod ccbuf { # [ doc = "Reader of register CCBUF[%s]" ] pub type R = crate :: R < u32 , super :: CCBUF > ; # [ doc = "Writer for register CCBUF[%s]" ] pub type W = crate :: W < u32 , super :: CCBUF > ; # [ doc = "Register CCBUF[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CCBUF { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } } # [ doc = "Reader of field `CCBUF`" ] pub type CCBUF_R = crate :: R < u32 , u32 > ; # [ doc = "Write proxy for field `CCBUF`" ] pub struct CCBUF_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xffff_ffff ) | ( ( value as u32 ) & 0xffff_ffff ) ; self . w } } impl R { # [ doc = "Bits 0:31 - Counter/Compare Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & self ) -> CCBUF_R { CCBUF_R :: new ( ( self . bits & 0xffff_ffff ) as u32 ) } } impl W { # [ doc = "Bits 0:31 - Counter/Compare Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & mut self ) -> CCBUF_W { CCBUF_W { w : self } } } } }
}
# [ doc = "Basic Timer Counter" ] pub struct TC1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TC1 { } impl TC1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tc0 :: RegisterBlock { 0x4200_3400 as * const _ } } impl Deref for TC1 { type Target = tc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TC1 :: ptr ( ) } } }
# [ doc = "Basic Timer Counter" ] pub struct TC2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TC2 { } impl TC2 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tc0 :: RegisterBlock { 0x4200_3800 as * const _ } } impl Deref for TC2 { type Target = tc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TC2 :: ptr ( ) } } }
# [ doc = "Basic Timer Counter" ] pub struct TC3 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TC3 { } impl TC3 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tc0 :: RegisterBlock { 0x4200_3c00 as * const _ } } impl Deref for TC3 { type Target = tc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TC3 :: ptr ( ) } } }
# [ doc = "Basic Timer Counter" ] pub struct TC4 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TC4 { } impl TC4 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tc0 :: RegisterBlock { 0x4200_4000 as * const _ } } impl Deref for TC4 { type Target = tc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TC4 :: ptr ( ) } } }
# [ doc = "Basic Timer Counter" ] pub struct TC5 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TC5 { } impl TC5 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tc0 :: RegisterBlock { 0x4300_0800 as * const _ } } impl Deref for TC5 { type Target = tc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TC5 :: ptr ( ) } } }
# [ doc = "Basic Timer Counter" ] pub struct TC6 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TC6 { } impl TC6 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tc0 :: RegisterBlock { 0x4300_0c00 as * const _ } } impl Deref for TC6 { type Target = tc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TC6 :: ptr ( ) } } }
# [ doc = "Basic Timer Counter" ] pub struct TC7 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TC7 { } impl TC7 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tc0 :: RegisterBlock { 0x4300_1000 as * const _ } } impl Deref for TC7 { type Target = tc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TC7 :: ptr ( ) } } }
# [ doc = "Timer Counter Control" ] pub struct TCC0 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TCC0 { } impl TCC0 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tcc0 :: RegisterBlock { 0x4200_2400 as * const _ } } impl Deref for TCC0 { type Target = tcc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TCC0 :: ptr ( ) } } }
# [ doc = "Timer Counter Control" ] pub mod tcc0 {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control A" ] pub ctrla : CTRLA , # [ doc = "0x04 - Control B Clear" ] pub ctrlbclr : CTRLBCLR , # [ doc = "0x05 - Control B Set" ] pub ctrlbset : CTRLBSET , _reserved3 : [ u8 ; 2usize ] , # [ doc = "0x08 - Synchronization Busy" ] pub syncbusy : SYNCBUSY , # [ doc = "0x0c - Recoverable Fault A Configuration" ] pub fctrla : FCTRLA , # [ doc = "0x10 - Recoverable Fault B Configuration" ] pub fctrlb : FCTRLB , # [ doc = "0x14 - Waveform Extension Configuration" ] pub wexctrl : WEXCTRL , # [ doc = "0x18 - Driver Control" ] pub drvctrl : DRVCTRL , _reserved8 : [ u8 ; 2usize ] , # [ doc = "0x1e - Debug Control" ] pub dbgctrl : DBGCTRL , _reserved9 : [ u8 ; 1usize ] , # [ doc = "0x20 - Event Control" ] pub evctrl : EVCTRL , # [ doc = "0x24 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x28 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x2c - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , # [ doc = "0x30 - Status" ] pub status : STATUS , _reserved_14_count : [ u8 ; 4usize ] , # [ doc = "0x38 - Pattern" ] pub patt : PATT , _reserved16 : [ u8 ; 2usize ] , # [ doc = "0x3c - Waveform Control" ] pub wave : WAVE , _reserved_17_per : [ u8 ; 4usize ] , _reserved_18_cc : [ u8 ; 16usize ] , _reserved19 : [ u8 ; 16usize ] , # [ doc = "0x64 - Pattern Buffer" ] pub pattbuf : PATTBUF , _reserved20 : [ u8 ; 6usize ] , _reserved_20_perbuf : [ u8 ; 4usize ] , _reserved_21_ccbuf : [ u8 ; 16usize ] , } impl RegisterBlock { # [ doc = "0x34 - Count" ] # [ inline ( always ) ] pub fn count_dith6_mode ( & self ) -> & COUNT_DITH6_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 52usize ) as * const COUNT_DITH6_MODE ) } } # [ doc = "0x34 - Count" ] # [ inline ( always ) ] pub fn count_dith6_mode_mut ( & self ) -> & mut COUNT_DITH6_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 52usize ) as * mut COUNT_DITH6_MODE ) } } # [ doc = "0x34 - Count" ] # [ inline ( always ) ] pub fn count_dith5_mode ( & self ) -> & COUNT_DITH5_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 52usize ) as * const COUNT_DITH5_MODE ) } } # [ doc = "0x34 - Count" ] # [ inline ( always ) ] pub fn count_dith5_mode_mut ( & self ) -> & mut COUNT_DITH5_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 52usize ) as * mut COUNT_DITH5_MODE ) } } # [ doc = "0x34 - Count" ] # [ inline ( always ) ] pub fn count_dith4_mode ( & self ) -> & COUNT_DITH4_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 52usize ) as * const COUNT_DITH4_MODE ) } } # [ doc = "0x34 - Count" ] # [ inline ( always ) ] pub fn count_dith4_mode_mut ( & self ) -> & mut COUNT_DITH4_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 52usize ) as * mut COUNT_DITH4_MODE ) } } # [ doc = "0x34 - Count" ] # [ inline ( always ) ] pub fn count ( & self ) -> & COUNT { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 52usize ) as * const COUNT ) } } # [ doc = "0x34 - Count" ] # [ inline ( always ) ] pub fn count_mut ( & self ) -> & mut COUNT { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 52usize ) as * mut COUNT ) } } # [ doc = "0x40 - Period" ] # [ inline ( always ) ] pub fn per_dith6_mode ( & self ) -> & PER_DITH6_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 64usize ) as * const PER_DITH6_MODE ) } } # [ doc = "0x40 - Period" ] # [ inline ( always ) ] pub fn per_dith6_mode_mut ( & self ) -> & mut PER_DITH6_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 64usize ) as * mut PER_DITH6_MODE ) } } # [ doc = "0x40 - Period" ] # [ inline ( always ) ] pub fn per_dith5_mode ( & self ) -> & PER_DITH5_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 64usize ) as * const PER_DITH5_MODE ) } } # [ doc = "0x40 - Period" ] # [ inline ( always ) ] pub fn per_dith5_mode_mut ( & self ) -> & mut PER_DITH5_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 64usize ) as * mut PER_DITH5_MODE ) } } # [ doc = "0x40 - Period" ] # [ inline ( always ) ] pub fn per_dith4_mode ( & self ) -> & PER_DITH4_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 64usize ) as * const PER_DITH4_MODE ) } } # [ doc = "0x40 - Period" ] # [ inline ( always ) ] pub fn per_dith4_mode_mut ( & self ) -> & mut PER_DITH4_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 64usize ) as * mut PER_DITH4_MODE ) } } # [ doc = "0x40 - Period" ] # [ inline ( always ) ] pub fn per ( & self ) -> & PER { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 64usize ) as * const PER ) } } # [ doc = "0x40 - Period" ] # [ inline ( always ) ] pub fn per_mut ( & self ) -> & mut PER { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 64usize ) as * mut PER ) } } # [ doc = "0x44 - Compare and Capture" ] # [ inline ( always ) ] pub fn cc_dith6_mode ( & self ) -> & [ CC_DITH6_MODE ; 4 ] { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 68usize ) as * const [ CC_DITH6_MODE ; 4 ] ) } } # [ doc = "0x44 - Compare and Capture" ] # [ inline ( always ) ] pub fn cc_dith6_mode_mut ( & self ) -> & mut [ CC_DITH6_MODE ; 4 ] { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 68usize ) as * mut [ CC_DITH6_MODE ; 4 ] ) } } # [ doc = "0x44 - Compare and Capture" ] # [ inline ( always ) ] pub fn cc_dith5_mode ( & self ) -> & [ CC_DITH5_MODE ; 4 ] { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 68usize ) as * const [ CC_DITH5_MODE ; 4 ] ) } } # [ doc = "0x44 - Compare and Capture" ] # [ inline ( always ) ] pub fn cc_dith5_mode_mut ( & self ) -> & mut [ CC_DITH5_MODE ; 4 ] { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 68usize ) as * mut [ CC_DITH5_MODE ; 4 ] ) } } # [ doc = "0x44 - Compare and Capture" ] # [ inline ( always ) ] pub fn cc_dith4_mode ( & self ) -> & [ CC_DITH4_MODE ; 4 ] { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 68usize ) as * const [ CC_DITH4_MODE ; 4 ] ) } } # [ doc = "0x44 - Compare and Capture" ] # [ inline ( always ) ] pub fn cc_dith4_mode_mut ( & self ) -> & mut [ CC_DITH4_MODE ; 4 ] { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 68usize ) as * mut [ CC_DITH4_MODE ; 4 ] ) } } # [ doc = "0x44 - Compare and Capture" ] # [ inline ( always ) ] pub fn cc ( & self ) -> & [ CC ; 4 ] { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 68usize ) as * const [ CC ; 4 ] ) } } # [ doc = "0x44 - Compare and Capture" ] # [ inline ( always ) ] pub fn cc_mut ( & self ) -> & mut [ CC ; 4 ] { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 68usize ) as * mut [ CC ; 4 ] ) } } # [ doc = "0x6c - Period Buffer" ] # [ inline ( always ) ] pub fn perbuf_dith6_mode ( & self ) -> & PERBUF_DITH6_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 108usize ) as * const PERBUF_DITH6_MODE ) } } # [ doc = "0x6c - Period Buffer" ] # [ inline ( always ) ] pub fn perbuf_dith6_mode_mut ( & self ) -> & mut PERBUF_DITH6_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 108usize ) as * mut PERBUF_DITH6_MODE ) } } # [ doc = "0x6c - Period Buffer" ] # [ inline ( always ) ] pub fn perbuf_dith5_mode ( & self ) -> & PERBUF_DITH5_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 108usize ) as * const PERBUF_DITH5_MODE ) } } # [ doc = "0x6c - Period Buffer" ] # [ inline ( always ) ] pub fn perbuf_dith5_mode_mut ( & self ) -> & mut PERBUF_DITH5_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 108usize ) as * mut PERBUF_DITH5_MODE ) } } # [ doc = "0x6c - Period Buffer" ] # [ inline ( always ) ] pub fn perbuf_dith4_mode ( & self ) -> & PERBUF_DITH4_MODE { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 108usize ) as * const PERBUF_DITH4_MODE ) } } # [ doc = "0x6c - Period Buffer" ] # [ inline ( always ) ] pub fn perbuf_dith4_mode_mut ( & self ) -> & mut PERBUF_DITH4_MODE { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 108usize ) as * mut PERBUF_DITH4_MODE ) } } # [ doc = "0x6c - Period Buffer" ] # [ inline ( always ) ] pub fn perbuf ( & self ) -> & PERBUF { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 108usize ) as * const PERBUF ) } } # [ doc = "0x6c - Period Buffer" ] # [ inline ( always ) ] pub fn perbuf_mut ( & self ) -> & mut PERBUF { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 108usize ) as * mut PERBUF ) } } # [ doc = "0x70 - Compare and Capture Buffer" ] # [ inline ( always ) ] pub fn ccbuf_dith6_mode ( & self ) -> & [ CCBUF_DITH6_MODE ; 4 ] { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 112usize ) as * const [ CCBUF_DITH6_MODE ; 4 ] ) } } # [ doc = "0x70 - Compare and Capture Buffer" ] # [ inline ( always ) ] pub fn ccbuf_dith6_mode_mut ( & self ) -> & mut [ CCBUF_DITH6_MODE ; 4 ] { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 112usize ) as * mut [ CCBUF_DITH6_MODE ; 4 ] ) } } # [ doc = "0x70 - Compare and Capture Buffer" ] # [ inline ( always ) ] pub fn ccbuf_dith5_mode ( & self ) -> & [ CCBUF_DITH5_MODE ; 4 ] { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 112usize ) as * const [ CCBUF_DITH5_MODE ; 4 ] ) } } # [ doc = "0x70 - Compare and Capture Buffer" ] # [ inline ( always ) ] pub fn ccbuf_dith5_mode_mut ( & self ) -> & mut [ CCBUF_DITH5_MODE ; 4 ] { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 112usize ) as * mut [ CCBUF_DITH5_MODE ; 4 ] ) } } # [ doc = "0x70 - Compare and Capture Buffer" ] # [ inline ( always ) ] pub fn ccbuf_dith4_mode ( & self ) -> & [ CCBUF_DITH4_MODE ; 4 ] { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 112usize ) as * const [ CCBUF_DITH4_MODE ; 4 ] ) } } # [ doc = "0x70 - Compare and Capture Buffer" ] # [ inline ( always ) ] pub fn ccbuf_dith4_mode_mut ( & self ) -> & mut [ CCBUF_DITH4_MODE ; 4 ] { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 112usize ) as * mut [ CCBUF_DITH4_MODE ; 4 ] ) } } # [ doc = "0x70 - Compare and Capture Buffer" ] # [ inline ( always ) ] pub fn ccbuf ( & self ) -> & [ CCBUF ; 4 ] { unsafe { & * ( ( ( self as * const Self ) as * const u8 ) . add ( 112usize ) as * const [ CCBUF ; 4 ] ) } } # [ doc = "0x70 - Compare and Capture Buffer" ] # [ inline ( always ) ] pub fn ccbuf_mut ( & self ) -> & mut [ CCBUF ; 4 ] { unsafe { & mut * ( ( ( self as * const Self ) as * mut u8 ) . add ( 112usize ) as * mut [ CCBUF ; 4 ] ) } } }
# [ doc = "Control A\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u32 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control A" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u32 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u32 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Possible values of the field `RESOLUTION`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RESOLUTION_A { # [ doc = "Dithering is disabled" ] NONE , # [ doc = "Dithering is done every 16 PWM frames" ] DITH4 , # [ doc = "Dithering is done every 32 PWM frames" ] DITH5 , # [ doc = "Dithering is done every 64 PWM frames" ] DITH6 }
impl crate :: ToBits < u8 > for RESOLUTION_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { RESOLUTION_A :: NONE => 0 , RESOLUTION_A :: DITH4 => 1 , RESOLUTION_A :: DITH5 => 2 , RESOLUTION_A :: DITH6 => 3 } } }
# [ doc = "Reader of field `RESOLUTION`" ] pub type RESOLUTION_R = crate :: R < u8 , RESOLUTION_A > ; impl RESOLUTION_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RESOLUTION_A { match self . bits { 0 => RESOLUTION_A :: NONE , 1 => RESOLUTION_A :: DITH4 , 2 => RESOLUTION_A :: DITH5 , 3 => RESOLUTION_A :: DITH6 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == RESOLUTION_A :: NONE } # [ doc = "Checks if the value of the field is `DITH4`" ] # [ inline ( always ) ] pub fn is_dith4 ( & self ) -> bool { * self == RESOLUTION_A :: DITH4 } # [ doc = "Checks if the value of the field is `DITH5`" ] # [ inline ( always ) ] pub fn is_dith5 ( & self ) -> bool { * self == RESOLUTION_A :: DITH5 } # [ doc = "Checks if the value of the field is `DITH6`" ] # [ inline ( always ) ] pub fn is_dith6 ( & self ) -> bool { * self == RESOLUTION_A :: DITH6 } }
# [ doc = "Write proxy for field `RESOLUTION`" ] pub struct RESOLUTION_W < 'a > { w : & 'a mut W , } impl < 'a > RESOLUTION_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RESOLUTION_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Dithering is disabled" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( RESOLUTION_A :: NONE ) } # [ doc = "Dithering is done every 16 PWM frames" ] # [ inline ( always ) ] pub fn dith4 ( self ) -> & 'a mut W { self . variant ( RESOLUTION_A :: DITH4 ) } # [ doc = "Dithering is done every 32 PWM frames" ] # [ inline ( always ) ] pub fn dith5 ( self ) -> & 'a mut W { self . variant ( RESOLUTION_A :: DITH5 ) } # [ doc = "Dithering is done every 64 PWM frames" ] # [ inline ( always ) ] pub fn dith6 ( self ) -> & 'a mut W { self . variant ( RESOLUTION_A :: DITH6 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 5 ) ) | ( ( ( value as u32 ) & 0x03 ) << 5 ) ; self . w } }
# [ doc = "Possible values of the field `PRESCALER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCALER_A { # [ doc = "No division" ] DIV1 , # [ doc = "Divide by 2" ] DIV2 , # [ doc = "Divide by 4" ] DIV4 , # [ doc = "Divide by 8" ] DIV8 , # [ doc = "Divide by 16" ] DIV16 , # [ doc = "Divide by 64" ] DIV64 , # [ doc = "Divide by 256" ] DIV256 , # [ doc = "Divide by 1024" ] DIV1024 }
impl crate :: ToBits < u8 > for PRESCALER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCALER_A :: DIV1 => 0 , PRESCALER_A :: DIV2 => 1 , PRESCALER_A :: DIV4 => 2 , PRESCALER_A :: DIV8 => 3 , PRESCALER_A :: DIV16 => 4 , PRESCALER_A :: DIV64 => 5 , PRESCALER_A :: DIV256 => 6 , PRESCALER_A :: DIV1024 => 7 } } }
# [ doc = "Reader of field `PRESCALER`" ] pub type PRESCALER_R = crate :: R < u8 , PRESCALER_A > ; impl PRESCALER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PRESCALER_A { match self . bits { 0 => PRESCALER_A :: DIV1 , 1 => PRESCALER_A :: DIV2 , 2 => PRESCALER_A :: DIV4 , 3 => PRESCALER_A :: DIV8 , 4 => PRESCALER_A :: DIV16 , 5 => PRESCALER_A :: DIV64 , 6 => PRESCALER_A :: DIV256 , 7 => PRESCALER_A :: DIV1024 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DIV1`" ] # [ inline ( always ) ] pub fn is_div1 ( & self ) -> bool { * self == PRESCALER_A :: DIV1 } # [ doc = "Checks if the value of the field is `DIV2`" ] # [ inline ( always ) ] pub fn is_div2 ( & self ) -> bool { * self == PRESCALER_A :: DIV2 } # [ doc = "Checks if the value of the field is `DIV4`" ] # [ inline ( always ) ] pub fn is_div4 ( & self ) -> bool { * self == PRESCALER_A :: DIV4 } # [ doc = "Checks if the value of the field is `DIV8`" ] # [ inline ( always ) ] pub fn is_div8 ( & self ) -> bool { * self == PRESCALER_A :: DIV8 } # [ doc = "Checks if the value of the field is `DIV16`" ] # [ inline ( always ) ] pub fn is_div16 ( & self ) -> bool { * self == PRESCALER_A :: DIV16 } # [ doc = "Checks if the value of the field is `DIV64`" ] # [ inline ( always ) ] pub fn is_div64 ( & self ) -> bool { * self == PRESCALER_A :: DIV64 } # [ doc = "Checks if the value of the field is `DIV256`" ] # [ inline ( always ) ] pub fn is_div256 ( & self ) -> bool { * self == PRESCALER_A :: DIV256 } # [ doc = "Checks if the value of the field is `DIV1024`" ] # [ inline ( always ) ] pub fn is_div1024 ( & self ) -> bool { * self == PRESCALER_A :: DIV1024 } }
# [ doc = "Write proxy for field `PRESCALER`" ] pub struct PRESCALER_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCALER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCALER_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "No division" ] # [ inline ( always ) ] pub fn div1 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1 ) } # [ doc = "Divide by 2" ] # [ inline ( always ) ] pub fn div2 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV2 ) } # [ doc = "Divide by 4" ] # [ inline ( always ) ] pub fn div4 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV4 ) } # [ doc = "Divide by 8" ] # [ inline ( always ) ] pub fn div8 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV8 ) } # [ doc = "Divide by 16" ] # [ inline ( always ) ] pub fn div16 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV16 ) } # [ doc = "Divide by 64" ] # [ inline ( always ) ] pub fn div64 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV64 ) } # [ doc = "Divide by 256" ] # [ inline ( always ) ] pub fn div256 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV256 ) } # [ doc = "Divide by 1024" ] # [ inline ( always ) ] pub fn div1024 ( self ) -> & 'a mut W { self . variant ( PRESCALER_A :: DIV1024 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 8 ) ) | ( ( ( value as u32 ) & 0x07 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Possible values of the field `PRESCSYNC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PRESCSYNC_A { # [ doc = "Reload or reset counter on next GCLK" ] GCLK , # [ doc = "Reload or reset counter on next prescaler clock" ] PRESC , # [ doc = "Reload or reset counter on next GCLK and reset prescaler counter" ] RESYNC }
impl crate :: ToBits < u8 > for PRESCSYNC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PRESCSYNC_A :: GCLK => 0 , PRESCSYNC_A :: PRESC => 1 , PRESCSYNC_A :: RESYNC => 2 } } }
# [ doc = "Reader of field `PRESCSYNC`" ] pub type PRESCSYNC_R = crate :: R < u8 , PRESCSYNC_A > ; impl PRESCSYNC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PRESCSYNC_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PRESCSYNC_A :: GCLK ) , 1 => Val ( PRESCSYNC_A :: PRESC ) , 2 => Val ( PRESCSYNC_A :: RESYNC ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `GCLK`" ] # [ inline ( always ) ] pub fn is_gclk ( & self ) -> bool { * self == PRESCSYNC_A :: GCLK } # [ doc = "Checks if the value of the field is `PRESC`" ] # [ inline ( always ) ] pub fn is_presc ( & self ) -> bool { * self == PRESCSYNC_A :: PRESC } # [ doc = "Checks if the value of the field is `RESYNC`" ] # [ inline ( always ) ] pub fn is_resync ( & self ) -> bool { * self == PRESCSYNC_A :: RESYNC } }
# [ doc = "Write proxy for field `PRESCSYNC`" ] pub struct PRESCSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > PRESCSYNC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PRESCSYNC_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Reload or reset counter on next GCLK" ] # [ inline ( always ) ] pub fn gclk ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: GCLK ) } # [ doc = "Reload or reset counter on next prescaler clock" ] # [ inline ( always ) ] pub fn presc ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: PRESC ) } # [ doc = "Reload or reset counter on next GCLK and reset prescaler counter" ] # [ inline ( always ) ] pub fn resync ( self ) -> & 'a mut W { self . variant ( PRESCSYNC_A :: RESYNC ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 12 ) ) | ( ( ( value as u32 ) & 0x03 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ALOCK`" ] pub type ALOCK_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ALOCK`" ] pub struct ALOCK_W < 'a > { w : & 'a mut W , } impl < 'a > ALOCK_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `MSYNC`" ] pub type MSYNC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MSYNC`" ] pub struct MSYNC_W < 'a > { w : & 'a mut W , } impl < 'a > MSYNC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `DMAOS`" ] pub type DMAOS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DMAOS`" ] pub struct DMAOS_W < 'a > { w : & 'a mut W , } impl < 'a > DMAOS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `CPTEN0`" ] pub type CPTEN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CPTEN0`" ] pub struct CPTEN0_W < 'a > { w : & 'a mut W , } impl < 'a > CPTEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `CPTEN1`" ] pub type CPTEN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CPTEN1`" ] pub struct CPTEN1_W < 'a > { w : & 'a mut W , } impl < 'a > CPTEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `CPTEN2`" ] pub type CPTEN2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CPTEN2`" ] pub struct CPTEN2_W < 'a > { w : & 'a mut W , } impl < 'a > CPTEN2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `CPTEN3`" ] pub type CPTEN3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CPTEN3`" ] pub struct CPTEN3_W < 'a > { w : & 'a mut W , } impl < 'a > CPTEN3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:6 - Enhanced Resolution" ] # [ inline ( always ) ] pub fn resolution ( & self ) -> RESOLUTION_R { RESOLUTION_R :: new ( ( ( self . bits >> 5 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 8:10 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & self ) -> PRESCALER_R { PRESCALER_R :: new ( ( ( self . bits >> 8 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 11 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 12:13 - Prescaler and Counter Synchronization Selection" ] # [ inline ( always ) ] pub fn prescsync ( & self ) -> PRESCSYNC_R { PRESCSYNC_R :: new ( ( ( self . bits >> 12 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 14 - Auto Lock" ] # [ inline ( always ) ] pub fn alock ( & self ) -> ALOCK_R { ALOCK_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Master Synchronization (only for TCC Slave Instance)" ] # [ inline ( always ) ] pub fn msync ( & self ) -> MSYNC_R { MSYNC_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - DMA One-shot Trigger Mode" ] # [ inline ( always ) ] pub fn dmaos ( & self ) -> DMAOS_R { DMAOS_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Capture Channel 0 Enable" ] # [ inline ( always ) ] pub fn cpten0 ( & self ) -> CPTEN0_R { CPTEN0_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Capture Channel 1 Enable" ] # [ inline ( always ) ] pub fn cpten1 ( & self ) -> CPTEN1_R { CPTEN1_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Capture Channel 2 Enable" ] # [ inline ( always ) ] pub fn cpten2 ( & self ) -> CPTEN2_R { CPTEN2_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Capture Channel 3 Enable" ] # [ inline ( always ) ] pub fn cpten3 ( & self ) -> CPTEN3_R { CPTEN3_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bits 5:6 - Enhanced Resolution" ] # [ inline ( always ) ] pub fn resolution ( & mut self ) -> RESOLUTION_W { RESOLUTION_W { w : self } }
# [ doc = "Bits 8:10 - Prescaler" ] # [ inline ( always ) ] pub fn prescaler ( & mut self ) -> PRESCALER_W { PRESCALER_W { w : self } }
# [ doc = "Bit 11 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
# [ doc = "Bits 12:13 - Prescaler and Counter Synchronization Selection" ] # [ inline ( always ) ] pub fn prescsync ( & mut self ) -> PRESCSYNC_W { PRESCSYNC_W { w : self } }
# [ doc = "Bit 14 - Auto Lock" ] # [ inline ( always ) ] pub fn alock ( & mut self ) -> ALOCK_W { ALOCK_W { w : self } }
# [ doc = "Bit 15 - Master Synchronization (only for TCC Slave Instance)" ] # [ inline ( always ) ] pub fn msync ( & mut self ) -> MSYNC_W { MSYNC_W { w : self } }
# [ doc = "Bit 23 - DMA One-shot Trigger Mode" ] # [ inline ( always ) ] pub fn dmaos ( & mut self ) -> DMAOS_W { DMAOS_W { w : self } }
# [ doc = "Bit 24 - Capture Channel 0 Enable" ] # [ inline ( always ) ] pub fn cpten0 ( & mut self ) -> CPTEN0_W { CPTEN0_W { w : self } }
# [ doc = "Bit 25 - Capture Channel 1 Enable" ] # [ inline ( always ) ] pub fn cpten1 ( & mut self ) -> CPTEN1_W { CPTEN1_W { w : self } }
# [ doc = "Bit 26 - Capture Channel 2 Enable" ] # [ inline ( always ) ] pub fn cpten2 ( & mut self ) -> CPTEN2_W { CPTEN2_W { w : self } }
# [ doc = "Bit 27 - Capture Channel 3 Enable" ] # [ inline ( always ) ] pub fn cpten3 ( & mut self ) -> CPTEN3_W { CPTEN3_W { w : self } }
}
}
# [ doc = "Control B Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlbclr](ctrlbclr) module" ] pub type CTRLBCLR = crate :: Reg < u8 , _CTRLBCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLBCLR ;
# [ doc = "`read()` method returns [ctrlbclr::R](ctrlbclr::R) reader structure" ] impl crate :: Readable for CTRLBCLR { }
# [ doc = "`write(|w| ..)` method takes [ctrlbclr::W](ctrlbclr::W) writer structure" ] impl crate :: Writable for CTRLBCLR { }
# [ doc = "Control B Clear" ] pub mod ctrlbclr {
# [ doc = "Reader of register CTRLBCLR" ] pub type R = crate :: R < u8 , super :: CTRLBCLR > ;
# [ doc = "Writer for register CTRLBCLR" ] pub type W = crate :: W < u8 , super :: CTRLBCLR > ;
# [ doc = "Register CTRLBCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLBCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DIR`" ] pub type DIR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DIR`" ] pub struct DIR_W < 'a > { w : & 'a mut W , } impl < 'a > DIR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `LUPD`" ] pub type LUPD_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LUPD`" ] pub struct LUPD_W < 'a > { w : & 'a mut W , } impl < 'a > LUPD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `ONESHOT`" ] pub type ONESHOT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONESHOT`" ] pub struct ONESHOT_W < 'a > { w : & 'a mut W , } impl < 'a > ONESHOT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `IDXCMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IDXCMD_A { # [ doc = "Command disabled: Index toggles between cycles A and B" ] DISABLE , # [ doc = "Set index: cycle B will be forced in the next cycle" ] SET , # [ doc = "Clear index: cycle A will be forced in the next cycle" ] CLEAR , # [ doc = "Hold index: the next cycle will be the same as the current cycle" ] HOLD }
impl crate :: ToBits < u8 > for IDXCMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { IDXCMD_A :: DISABLE => 0 , IDXCMD_A :: SET => 1 , IDXCMD_A :: CLEAR => 2 , IDXCMD_A :: HOLD => 3 } } }
# [ doc = "Reader of field `IDXCMD`" ] pub type IDXCMD_R = crate :: R < u8 , IDXCMD_A > ; impl IDXCMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> IDXCMD_A { match self . bits { 0 => IDXCMD_A :: DISABLE , 1 => IDXCMD_A :: SET , 2 => IDXCMD_A :: CLEAR , 3 => IDXCMD_A :: HOLD , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == IDXCMD_A :: DISABLE } # [ doc = "Checks if the value of the field is `SET`" ] # [ inline ( always ) ] pub fn is_set ( & self ) -> bool { * self == IDXCMD_A :: SET } # [ doc = "Checks if the value of the field is `CLEAR`" ] # [ inline ( always ) ] pub fn is_clear ( & self ) -> bool { * self == IDXCMD_A :: CLEAR } # [ doc = "Checks if the value of the field is `HOLD`" ] # [ inline ( always ) ] pub fn is_hold ( & self ) -> bool { * self == IDXCMD_A :: HOLD } }
# [ doc = "Write proxy for field `IDXCMD`" ] pub struct IDXCMD_W < 'a > { w : & 'a mut W , } impl < 'a > IDXCMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : IDXCMD_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Command disabled: Index toggles between cycles A and B" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( IDXCMD_A :: DISABLE ) } # [ doc = "Set index: cycle B will be forced in the next cycle" ] # [ inline ( always ) ] pub fn set ( self ) -> & 'a mut W { self . variant ( IDXCMD_A :: SET ) } # [ doc = "Clear index: cycle A will be forced in the next cycle" ] # [ inline ( always ) ] pub fn clear ( self ) -> & 'a mut W { self . variant ( IDXCMD_A :: CLEAR ) } # [ doc = "Hold index: the next cycle will be the same as the current cycle" ] # [ inline ( always ) ] pub fn hold ( self ) -> & 'a mut W { self . variant ( IDXCMD_A :: HOLD ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 3 ) ) | ( ( ( value as u8 ) & 0x03 ) << 3 ) ; self . w } }
# [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "No action" ] NONE , # [ doc = "Clear start, restart or retrigger" ] RETRIGGER , # [ doc = "Force stop" ] STOP , # [ doc = "Force update or double buffered registers" ] UPDATE , # [ doc = "Force COUNT read synchronization" ] READSYNC , # [ doc = "One-shot DMA trigger" ] DMAOS }
impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: NONE => 0 , CMD_A :: RETRIGGER => 1 , CMD_A :: STOP => 2 , CMD_A :: UPDATE => 3 , CMD_A :: READSYNC => 4 , CMD_A :: DMAOS => 5 } } }
# [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CMD_A :: NONE ) , 1 => Val ( CMD_A :: RETRIGGER ) , 2 => Val ( CMD_A :: STOP ) , 3 => Val ( CMD_A :: UPDATE ) , 4 => Val ( CMD_A :: READSYNC ) , 5 => Val ( CMD_A :: DMAOS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CMD_A :: NONE } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == CMD_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == CMD_A :: STOP } # [ doc = "Checks if the value of the field is `UPDATE`" ] # [ inline ( always ) ] pub fn is_update ( & self ) -> bool { * self == CMD_A :: UPDATE } # [ doc = "Checks if the value of the field is `READSYNC`" ] # [ inline ( always ) ] pub fn is_readsync ( & self ) -> bool { * self == CMD_A :: READSYNC } # [ doc = "Checks if the value of the field is `DMAOS`" ] # [ inline ( always ) ] pub fn is_dmaos ( & self ) -> bool { * self == CMD_A :: DMAOS } }
# [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CMD_A :: NONE ) } # [ doc = "Clear start, restart or retrigger" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( CMD_A :: RETRIGGER ) } # [ doc = "Force stop" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( CMD_A :: STOP ) } # [ doc = "Force update or double buffered registers" ] # [ inline ( always ) ] pub fn update ( self ) -> & 'a mut W { self . variant ( CMD_A :: UPDATE ) } # [ doc = "Force COUNT read synchronization" ] # [ inline ( always ) ] pub fn readsync ( self ) -> & 'a mut W { self . variant ( CMD_A :: READSYNC ) } # [ doc = "One-shot DMA trigger" ] # [ inline ( always ) ] pub fn dmaos ( self ) -> & 'a mut W { self . variant ( CMD_A :: DMAOS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u8 ) & 0x07 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & self ) -> DIR_R { DIR_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & self ) -> LUPD_R { LUPD_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - One-Shot" ] # [ inline ( always ) ] pub fn oneshot ( & self ) -> ONESHOT_R { ONESHOT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 3:4 - Ramp Index Command" ] # [ inline ( always ) ] pub fn idxcmd ( & self ) -> IDXCMD_R { IDXCMD_R :: new ( ( ( self . bits >> 3 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 5:7 - TCC Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & mut self ) -> DIR_W { DIR_W { w : self } }
# [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & mut self ) -> LUPD_W { LUPD_W { w : self } }
# [ doc = "Bit 2 - One-Shot" ] # [ inline ( always ) ] pub fn oneshot ( & mut self ) -> ONESHOT_W { ONESHOT_W { w : self } }
# [ doc = "Bits 3:4 - Ramp Index Command" ] # [ inline ( always ) ] pub fn idxcmd ( & mut self ) -> IDXCMD_W { IDXCMD_W { w : self } }
# [ doc = "Bits 5:7 - TCC Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } }
}
}
# [ doc = "Control B Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlbset](ctrlbset) module" ] pub type CTRLBSET = crate :: Reg < u8 , _CTRLBSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLBSET ;
# [ doc = "`read()` method returns [ctrlbset::R](ctrlbset::R) reader structure" ] impl crate :: Readable for CTRLBSET { }
# [ doc = "`write(|w| ..)` method takes [ctrlbset::W](ctrlbset::W) writer structure" ] impl crate :: Writable for CTRLBSET { }
# [ doc = "Control B Set" ] pub mod ctrlbset {
# [ doc = "Reader of register CTRLBSET" ] pub type R = crate :: R < u8 , super :: CTRLBSET > ;
# [ doc = "Writer for register CTRLBSET" ] pub type W = crate :: W < u8 , super :: CTRLBSET > ;
# [ doc = "Register CTRLBSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLBSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DIR`" ] pub type DIR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DIR`" ] pub struct DIR_W < 'a > { w : & 'a mut W , } impl < 'a > DIR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `LUPD`" ] pub type LUPD_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `LUPD`" ] pub struct LUPD_W < 'a > { w : & 'a mut W , } impl < 'a > LUPD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `ONESHOT`" ] pub type ONESHOT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ONESHOT`" ] pub struct ONESHOT_W < 'a > { w : & 'a mut W , } impl < 'a > ONESHOT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `IDXCMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum IDXCMD_A { # [ doc = "Command disabled: Index toggles between cycles A and B" ] DISABLE , # [ doc = "Set index: cycle B will be forced in the next cycle" ] SET , # [ doc = "Clear index: cycle A will be forced in the next cycle" ] CLEAR , # [ doc = "Hold index: the next cycle will be the same as the current cycle" ] HOLD }
impl crate :: ToBits < u8 > for IDXCMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { IDXCMD_A :: DISABLE => 0 , IDXCMD_A :: SET => 1 , IDXCMD_A :: CLEAR => 2 , IDXCMD_A :: HOLD => 3 } } }
# [ doc = "Reader of field `IDXCMD`" ] pub type IDXCMD_R = crate :: R < u8 , IDXCMD_A > ; impl IDXCMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> IDXCMD_A { match self . bits { 0 => IDXCMD_A :: DISABLE , 1 => IDXCMD_A :: SET , 2 => IDXCMD_A :: CLEAR , 3 => IDXCMD_A :: HOLD , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == IDXCMD_A :: DISABLE } # [ doc = "Checks if the value of the field is `SET`" ] # [ inline ( always ) ] pub fn is_set ( & self ) -> bool { * self == IDXCMD_A :: SET } # [ doc = "Checks if the value of the field is `CLEAR`" ] # [ inline ( always ) ] pub fn is_clear ( & self ) -> bool { * self == IDXCMD_A :: CLEAR } # [ doc = "Checks if the value of the field is `HOLD`" ] # [ inline ( always ) ] pub fn is_hold ( & self ) -> bool { * self == IDXCMD_A :: HOLD } }
# [ doc = "Write proxy for field `IDXCMD`" ] pub struct IDXCMD_W < 'a > { w : & 'a mut W , } impl < 'a > IDXCMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : IDXCMD_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Command disabled: Index toggles between cycles A and B" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( IDXCMD_A :: DISABLE ) } # [ doc = "Set index: cycle B will be forced in the next cycle" ] # [ inline ( always ) ] pub fn set ( self ) -> & 'a mut W { self . variant ( IDXCMD_A :: SET ) } # [ doc = "Clear index: cycle A will be forced in the next cycle" ] # [ inline ( always ) ] pub fn clear ( self ) -> & 'a mut W { self . variant ( IDXCMD_A :: CLEAR ) } # [ doc = "Hold index: the next cycle will be the same as the current cycle" ] # [ inline ( always ) ] pub fn hold ( self ) -> & 'a mut W { self . variant ( IDXCMD_A :: HOLD ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 3 ) ) | ( ( ( value as u8 ) & 0x03 ) << 3 ) ; self . w } }
# [ doc = "Possible values of the field `CMD`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CMD_A { # [ doc = "No action" ] NONE , # [ doc = "Clear start, restart or retrigger" ] RETRIGGER , # [ doc = "Force stop" ] STOP , # [ doc = "Force update or double buffered registers" ] UPDATE , # [ doc = "Force COUNT read synchronization" ] READSYNC , # [ doc = "One-shot DMA trigger" ] DMAOS }
impl crate :: ToBits < u8 > for CMD_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CMD_A :: NONE => 0 , CMD_A :: RETRIGGER => 1 , CMD_A :: STOP => 2 , CMD_A :: UPDATE => 3 , CMD_A :: READSYNC => 4 , CMD_A :: DMAOS => 5 } } }
# [ doc = "Reader of field `CMD`" ] pub type CMD_R = crate :: R < u8 , CMD_A > ; impl CMD_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , CMD_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( CMD_A :: NONE ) , 1 => Val ( CMD_A :: RETRIGGER ) , 2 => Val ( CMD_A :: STOP ) , 3 => Val ( CMD_A :: UPDATE ) , 4 => Val ( CMD_A :: READSYNC ) , 5 => Val ( CMD_A :: DMAOS ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NONE`" ] # [ inline ( always ) ] pub fn is_none ( & self ) -> bool { * self == CMD_A :: NONE } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == CMD_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == CMD_A :: STOP } # [ doc = "Checks if the value of the field is `UPDATE`" ] # [ inline ( always ) ] pub fn is_update ( & self ) -> bool { * self == CMD_A :: UPDATE } # [ doc = "Checks if the value of the field is `READSYNC`" ] # [ inline ( always ) ] pub fn is_readsync ( & self ) -> bool { * self == CMD_A :: READSYNC } # [ doc = "Checks if the value of the field is `DMAOS`" ] # [ inline ( always ) ] pub fn is_dmaos ( & self ) -> bool { * self == CMD_A :: DMAOS } }
# [ doc = "Write proxy for field `CMD`" ] pub struct CMD_W < 'a > { w : & 'a mut W , } impl < 'a > CMD_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CMD_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No action" ] # [ inline ( always ) ] pub fn none ( self ) -> & 'a mut W { self . variant ( CMD_A :: NONE ) } # [ doc = "Clear start, restart or retrigger" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( CMD_A :: RETRIGGER ) } # [ doc = "Force stop" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( CMD_A :: STOP ) } # [ doc = "Force update or double buffered registers" ] # [ inline ( always ) ] pub fn update ( self ) -> & 'a mut W { self . variant ( CMD_A :: UPDATE ) } # [ doc = "Force COUNT read synchronization" ] # [ inline ( always ) ] pub fn readsync ( self ) -> & 'a mut W { self . variant ( CMD_A :: READSYNC ) } # [ doc = "One-shot DMA trigger" ] # [ inline ( always ) ] pub fn dmaos ( self ) -> & 'a mut W { self . variant ( CMD_A :: DMAOS ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 5 ) ) | ( ( ( value as u8 ) & 0x07 ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & self ) -> DIR_R { DIR_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & self ) -> LUPD_R { LUPD_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - One-Shot" ] # [ inline ( always ) ] pub fn oneshot ( & self ) -> ONESHOT_R { ONESHOT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 3:4 - Ramp Index Command" ] # [ inline ( always ) ] pub fn idxcmd ( & self ) -> IDXCMD_R { IDXCMD_R :: new ( ( ( self . bits >> 3 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 5:7 - TCC Command" ] # [ inline ( always ) ] pub fn cmd ( & self ) -> CMD_R { CMD_R :: new ( ( ( self . bits >> 5 ) & 0x07 ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Counter Direction" ] # [ inline ( always ) ] pub fn dir ( & mut self ) -> DIR_W { DIR_W { w : self } }
# [ doc = "Bit 1 - Lock Update" ] # [ inline ( always ) ] pub fn lupd ( & mut self ) -> LUPD_W { LUPD_W { w : self } }
# [ doc = "Bit 2 - One-Shot" ] # [ inline ( always ) ] pub fn oneshot ( & mut self ) -> ONESHOT_W { ONESHOT_W { w : self } }
# [ doc = "Bits 3:4 - Ramp Index Command" ] # [ inline ( always ) ] pub fn idxcmd ( & mut self ) -> IDXCMD_W { IDXCMD_W { w : self } }
# [ doc = "Bits 5:7 - TCC Command" ] # [ inline ( always ) ] pub fn cmd ( & mut self ) -> CMD_W { CMD_W { w : self } }
}
}
# [ doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CTRLB`" ] pub type CTRLB_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `STATUS`" ] pub type STATUS_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PATT`" ] pub type PATT_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WAVE`" ] pub type WAVE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CC0`" ] pub type CC0_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CC1`" ] pub type CC1_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CC2`" ] pub type CC2_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CC3`" ] pub type CC3_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Swrst Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Ctrlb Busy" ] # [ inline ( always ) ] pub fn ctrlb ( & self ) -> CTRLB_R { CTRLB_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Status Busy" ] # [ inline ( always ) ] pub fn status ( & self ) -> STATUS_R { STATUS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Count Busy" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Pattern Busy" ] # [ inline ( always ) ] pub fn patt ( & self ) -> PATT_R { PATT_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Wave Busy" ] # [ inline ( always ) ] pub fn wave ( & self ) -> WAVE_R { WAVE_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Period Busy" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Compare Channel 0 Busy" ] # [ inline ( always ) ] pub fn cc0 ( & self ) -> CC0_R { CC0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Compare Channel 1 Busy" ] # [ inline ( always ) ] pub fn cc1 ( & self ) -> CC1_R { CC1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Compare Channel 2 Busy" ] # [ inline ( always ) ] pub fn cc2 ( & self ) -> CC2_R { CC2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Compare Channel 3 Busy" ] # [ inline ( always ) ] pub fn cc3 ( & self ) -> CC3_R { CC3_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Recoverable Fault A Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [fctrla](fctrla) module" ] pub type FCTRLA = crate :: Reg < u32 , _FCTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _FCTRLA ;
# [ doc = "`read()` method returns [fctrla::R](fctrla::R) reader structure" ] impl crate :: Readable for FCTRLA { }
# [ doc = "`write(|w| ..)` method takes [fctrla::W](fctrla::W) writer structure" ] impl crate :: Writable for FCTRLA { }
# [ doc = "Recoverable Fault A Configuration" ] pub mod fctrla {
# [ doc = "Reader of register FCTRLA" ] pub type R = crate :: R < u32 , super :: FCTRLA > ;
# [ doc = "Writer for register FCTRLA" ] pub type W = crate :: W < u32 , super :: FCTRLA > ;
# [ doc = "Register FCTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: FCTRLA { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `SRC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SRC_A { # [ doc = "Fault input disabled" ] DISABLE , # [ doc = "MCEx (x=0,1) event input" ] ENABLE , # [ doc = "Inverted MCEx (x=0,1) event input" ] INVERT , # [ doc = "Alternate fault (A or B) state at the end of the previous period" ] ALTFAULT }
impl crate :: ToBits < u8 > for SRC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SRC_A :: DISABLE => 0 , SRC_A :: ENABLE => 1 , SRC_A :: INVERT => 2 , SRC_A :: ALTFAULT => 3 } } }
# [ doc = "Reader of field `SRC`" ] pub type SRC_R = crate :: R < u8 , SRC_A > ; impl SRC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SRC_A { match self . bits { 0 => SRC_A :: DISABLE , 1 => SRC_A :: ENABLE , 2 => SRC_A :: INVERT , 3 => SRC_A :: ALTFAULT , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == SRC_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == SRC_A :: ENABLE } # [ doc = "Checks if the value of the field is `INVERT`" ] # [ inline ( always ) ] pub fn is_invert ( & self ) -> bool { * self == SRC_A :: INVERT } # [ doc = "Checks if the value of the field is `ALTFAULT`" ] # [ inline ( always ) ] pub fn is_altfault ( & self ) -> bool { * self == SRC_A :: ALTFAULT } }
# [ doc = "Write proxy for field `SRC`" ] pub struct SRC_W < 'a > { w : & 'a mut W , } impl < 'a > SRC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SRC_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Fault input disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( SRC_A :: DISABLE ) } # [ doc = "MCEx (x=0,1) event input" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( SRC_A :: ENABLE ) } # [ doc = "Inverted MCEx (x=0,1) event input" ] # [ inline ( always ) ] pub fn invert ( self ) -> & 'a mut W { self . variant ( SRC_A :: INVERT ) } # [ doc = "Alternate fault (A or B) state at the end of the previous period" ] # [ inline ( always ) ] pub fn altfault ( self ) -> & 'a mut W { self . variant ( SRC_A :: ALTFAULT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `KEEP`" ] pub type KEEP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `KEEP`" ] pub struct KEEP_W < 'a > { w : & 'a mut W , } impl < 'a > KEEP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `QUAL`" ] pub type QUAL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `QUAL`" ] pub struct QUAL_W < 'a > { w : & 'a mut W , } impl < 'a > QUAL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Possible values of the field `BLANK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BLANK_A { # [ doc = "Blanking applied from start of the ramp" ] START , # [ doc = "Blanking applied from rising edge of the output waveform" ] RISE , # [ doc = "Blanking applied from falling edge of the output waveform" ] FALL , # [ doc = "Blanking applied from each toggle of the output waveform" ] BOTH }
impl crate :: ToBits < u8 > for BLANK_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { BLANK_A :: START => 0 , BLANK_A :: RISE => 1 , BLANK_A :: FALL => 2 , BLANK_A :: BOTH => 3 } } }
# [ doc = "Reader of field `BLANK`" ] pub type BLANK_R = crate :: R < u8 , BLANK_A > ; impl BLANK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> BLANK_A { match self . bits { 0 => BLANK_A :: START , 1 => BLANK_A :: RISE , 2 => BLANK_A :: FALL , 3 => BLANK_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `START`" ] # [ inline ( always ) ] pub fn is_start ( & self ) -> bool { * self == BLANK_A :: START } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == BLANK_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == BLANK_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == BLANK_A :: BOTH } }
# [ doc = "Write proxy for field `BLANK`" ] pub struct BLANK_W < 'a > { w : & 'a mut W , } impl < 'a > BLANK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : BLANK_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Blanking applied from start of the ramp" ] # [ inline ( always ) ] pub fn start ( self ) -> & 'a mut W { self . variant ( BLANK_A :: START ) } # [ doc = "Blanking applied from rising edge of the output waveform" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( BLANK_A :: RISE ) } # [ doc = "Blanking applied from falling edge of the output waveform" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( BLANK_A :: FALL ) } # [ doc = "Blanking applied from each toggle of the output waveform" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( BLANK_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 5 ) ) | ( ( ( value as u32 ) & 0x03 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `RESTART`" ] pub type RESTART_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESTART`" ] pub struct RESTART_W < 'a > { w : & 'a mut W , } impl < 'a > RESTART_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `HALT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HALT_A { # [ doc = "Halt action disabled" ] DISABLE , # [ doc = "Hardware halt action" ] HW , # [ doc = "Software halt action" ] SW , # [ doc = "Non-recoverable fault" ] NR }
impl crate :: ToBits < u8 > for HALT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { HALT_A :: DISABLE => 0 , HALT_A :: HW => 1 , HALT_A :: SW => 2 , HALT_A :: NR => 3 } } }
# [ doc = "Reader of field `HALT`" ] pub type HALT_R = crate :: R < u8 , HALT_A > ; impl HALT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> HALT_A { match self . bits { 0 => HALT_A :: DISABLE , 1 => HALT_A :: HW , 2 => HALT_A :: SW , 3 => HALT_A :: NR , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == HALT_A :: DISABLE } # [ doc = "Checks if the value of the field is `HW`" ] # [ inline ( always ) ] pub fn is_hw ( & self ) -> bool { * self == HALT_A :: HW } # [ doc = "Checks if the value of the field is `SW`" ] # [ inline ( always ) ] pub fn is_sw ( & self ) -> bool { * self == HALT_A :: SW } # [ doc = "Checks if the value of the field is `NR`" ] # [ inline ( always ) ] pub fn is_nr ( & self ) -> bool { * self == HALT_A :: NR } }
# [ doc = "Write proxy for field `HALT`" ] pub struct HALT_W < 'a > { w : & 'a mut W , } impl < 'a > HALT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : HALT_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Halt action disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( HALT_A :: DISABLE ) } # [ doc = "Hardware halt action" ] # [ inline ( always ) ] pub fn hw ( self ) -> & 'a mut W { self . variant ( HALT_A :: HW ) } # [ doc = "Software halt action" ] # [ inline ( always ) ] pub fn sw ( self ) -> & 'a mut W { self . variant ( HALT_A :: SW ) } # [ doc = "Non-recoverable fault" ] # [ inline ( always ) ] pub fn nr ( self ) -> & 'a mut W { self . variant ( HALT_A :: NR ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Possible values of the field `CHSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CHSEL_A { # [ doc = "Capture value stored in channel 0" ] CC0 , # [ doc = "Capture value stored in channel 1" ] CC1 , # [ doc = "Capture value stored in channel 2" ] CC2 , # [ doc = "Capture value stored in channel 3" ] CC3 }
impl crate :: ToBits < u8 > for CHSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CHSEL_A :: CC0 => 0 , CHSEL_A :: CC1 => 1 , CHSEL_A :: CC2 => 2 , CHSEL_A :: CC3 => 3 } } }
# [ doc = "Reader of field `CHSEL`" ] pub type CHSEL_R = crate :: R < u8 , CHSEL_A > ; impl CHSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CHSEL_A { match self . bits { 0 => CHSEL_A :: CC0 , 1 => CHSEL_A :: CC1 , 2 => CHSEL_A :: CC2 , 3 => CHSEL_A :: CC3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CC0`" ] # [ inline ( always ) ] pub fn is_cc0 ( & self ) -> bool { * self == CHSEL_A :: CC0 } # [ doc = "Checks if the value of the field is `CC1`" ] # [ inline ( always ) ] pub fn is_cc1 ( & self ) -> bool { * self == CHSEL_A :: CC1 } # [ doc = "Checks if the value of the field is `CC2`" ] # [ inline ( always ) ] pub fn is_cc2 ( & self ) -> bool { * self == CHSEL_A :: CC2 } # [ doc = "Checks if the value of the field is `CC3`" ] # [ inline ( always ) ] pub fn is_cc3 ( & self ) -> bool { * self == CHSEL_A :: CC3 } }
# [ doc = "Write proxy for field `CHSEL`" ] pub struct CHSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CHSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CHSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Capture value stored in channel 0" ] # [ inline ( always ) ] pub fn cc0 ( self ) -> & 'a mut W { self . variant ( CHSEL_A :: CC0 ) } # [ doc = "Capture value stored in channel 1" ] # [ inline ( always ) ] pub fn cc1 ( self ) -> & 'a mut W { self . variant ( CHSEL_A :: CC1 ) } # [ doc = "Capture value stored in channel 2" ] # [ inline ( always ) ] pub fn cc2 ( self ) -> & 'a mut W { self . variant ( CHSEL_A :: CC2 ) } # [ doc = "Capture value stored in channel 3" ] # [ inline ( always ) ] pub fn cc3 ( self ) -> & 'a mut W { self . variant ( CHSEL_A :: CC3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u32 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Possible values of the field `CAPTURE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAPTURE_A { # [ doc = "No capture" ] DISABLE , # [ doc = "Capture on fault" ] CAPT , # [ doc = "Minimum capture" ] CAPTMIN , # [ doc = "Maximum capture" ] CAPTMAX , # [ doc = "Minimum local detection" ] LOCMIN , # [ doc = "Maximum local detection" ] LOCMAX , # [ doc = "Minimum and maximum local detection" ] DERIV0 , # [ doc = "Capture with ramp index as MSB value" ] CAPTMARK }
impl crate :: ToBits < u8 > for CAPTURE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CAPTURE_A :: DISABLE => 0 , CAPTURE_A :: CAPT => 1 , CAPTURE_A :: CAPTMIN => 2 , CAPTURE_A :: CAPTMAX => 3 , CAPTURE_A :: LOCMIN => 4 , CAPTURE_A :: LOCMAX => 5 , CAPTURE_A :: DERIV0 => 6 , CAPTURE_A :: CAPTMARK => 7 } } }
# [ doc = "Reader of field `CAPTURE`" ] pub type CAPTURE_R = crate :: R < u8 , CAPTURE_A > ; impl CAPTURE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAPTURE_A { match self . bits { 0 => CAPTURE_A :: DISABLE , 1 => CAPTURE_A :: CAPT , 2 => CAPTURE_A :: CAPTMIN , 3 => CAPTURE_A :: CAPTMAX , 4 => CAPTURE_A :: LOCMIN , 5 => CAPTURE_A :: LOCMAX , 6 => CAPTURE_A :: DERIV0 , 7 => CAPTURE_A :: CAPTMARK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == CAPTURE_A :: DISABLE } # [ doc = "Checks if the value of the field is `CAPT`" ] # [ inline ( always ) ] pub fn is_capt ( & self ) -> bool { * self == CAPTURE_A :: CAPT } # [ doc = "Checks if the value of the field is `CAPTMIN`" ] # [ inline ( always ) ] pub fn is_captmin ( & self ) -> bool { * self == CAPTURE_A :: CAPTMIN } # [ doc = "Checks if the value of the field is `CAPTMAX`" ] # [ inline ( always ) ] pub fn is_captmax ( & self ) -> bool { * self == CAPTURE_A :: CAPTMAX } # [ doc = "Checks if the value of the field is `LOCMIN`" ] # [ inline ( always ) ] pub fn is_locmin ( & self ) -> bool { * self == CAPTURE_A :: LOCMIN } # [ doc = "Checks if the value of the field is `LOCMAX`" ] # [ inline ( always ) ] pub fn is_locmax ( & self ) -> bool { * self == CAPTURE_A :: LOCMAX } # [ doc = "Checks if the value of the field is `DERIV0`" ] # [ inline ( always ) ] pub fn is_deriv0 ( & self ) -> bool { * self == CAPTURE_A :: DERIV0 } # [ doc = "Checks if the value of the field is `CAPTMARK`" ] # [ inline ( always ) ] pub fn is_captmark ( & self ) -> bool { * self == CAPTURE_A :: CAPTMARK } }
# [ doc = "Write proxy for field `CAPTURE`" ] pub struct CAPTURE_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTURE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAPTURE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: DISABLE ) } # [ doc = "Capture on fault" ] # [ inline ( always ) ] pub fn capt ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: CAPT ) } # [ doc = "Minimum capture" ] # [ inline ( always ) ] pub fn captmin ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: CAPTMIN ) } # [ doc = "Maximum capture" ] # [ inline ( always ) ] pub fn captmax ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: CAPTMAX ) } # [ doc = "Minimum local detection" ] # [ inline ( always ) ] pub fn locmin ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: LOCMIN ) } # [ doc = "Maximum local detection" ] # [ inline ( always ) ] pub fn locmax ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: LOCMAX ) } # [ doc = "Minimum and maximum local detection" ] # [ inline ( always ) ] pub fn deriv0 ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: DERIV0 ) } # [ doc = "Capture with ramp index as MSB value" ] # [ inline ( always ) ] pub fn captmark ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: CAPTMARK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 12 ) ) | ( ( ( value as u32 ) & 0x07 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `BLANKPRESC`" ] pub type BLANKPRESC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BLANKPRESC`" ] pub struct BLANKPRESC_W < 'a > { w : & 'a mut W , } impl < 'a > BLANKPRESC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `BLANKVAL`" ] pub type BLANKVAL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `BLANKVAL`" ] pub struct BLANKVAL_W < 'a > { w : & 'a mut W , } impl < 'a > BLANKVAL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } }
# [ doc = "Reader of field `FILTERVAL`" ] pub type FILTERVAL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FILTERVAL`" ] pub struct FILTERVAL_W < 'a > { w : & 'a mut W , } impl < 'a > FILTERVAL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Fault A Source" ] # [ inline ( always ) ] pub fn src ( & self ) -> SRC_R { SRC_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - Fault A Keeper" ] # [ inline ( always ) ] pub fn keep ( & self ) -> KEEP_R { KEEP_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Fault A Qualification" ] # [ inline ( always ) ] pub fn qual ( & self ) -> QUAL_R { QUAL_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:6 - Fault A Blanking Mode" ] # [ inline ( always ) ] pub fn blank ( & self ) -> BLANK_R { BLANK_R :: new ( ( ( self . bits >> 5 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - Fault A Restart" ] # [ inline ( always ) ] pub fn restart ( & self ) -> RESTART_R { RESTART_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - Fault A Halt Mode" ] # [ inline ( always ) ] pub fn halt ( & self ) -> HALT_R { HALT_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Fault A Capture Channel" ] # [ inline ( always ) ] pub fn chsel ( & self ) -> CHSEL_R { CHSEL_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:14 - Fault A Capture Action" ] # [ inline ( always ) ] pub fn capture ( & self ) -> CAPTURE_R { CAPTURE_R :: new ( ( ( self . bits >> 12 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 15 - Fault A Blanking Prescaler" ] # [ inline ( always ) ] pub fn blankpresc ( & self ) -> BLANKPRESC_R { BLANKPRESC_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:23 - Fault A Blanking Time" ] # [ inline ( always ) ] pub fn blankval ( & self ) -> BLANKVAL_R { BLANKVAL_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) }
# [ doc = "Bits 24:27 - Fault A Filter Value" ] # [ inline ( always ) ] pub fn filterval ( & self ) -> FILTERVAL_R { FILTERVAL_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Fault A Source" ] # [ inline ( always ) ] pub fn src ( & mut self ) -> SRC_W { SRC_W { w : self } }
# [ doc = "Bit 3 - Fault A Keeper" ] # [ inline ( always ) ] pub fn keep ( & mut self ) -> KEEP_W { KEEP_W { w : self } }
# [ doc = "Bit 4 - Fault A Qualification" ] # [ inline ( always ) ] pub fn qual ( & mut self ) -> QUAL_W { QUAL_W { w : self } }
# [ doc = "Bits 5:6 - Fault A Blanking Mode" ] # [ inline ( always ) ] pub fn blank ( & mut self ) -> BLANK_W { BLANK_W { w : self } }
# [ doc = "Bit 7 - Fault A Restart" ] # [ inline ( always ) ] pub fn restart ( & mut self ) -> RESTART_W { RESTART_W { w : self } }
# [ doc = "Bits 8:9 - Fault A Halt Mode" ] # [ inline ( always ) ] pub fn halt ( & mut self ) -> HALT_W { HALT_W { w : self } }
# [ doc = "Bits 10:11 - Fault A Capture Channel" ] # [ inline ( always ) ] pub fn chsel ( & mut self ) -> CHSEL_W { CHSEL_W { w : self } }
# [ doc = "Bits 12:14 - Fault A Capture Action" ] # [ inline ( always ) ] pub fn capture ( & mut self ) -> CAPTURE_W { CAPTURE_W { w : self } }
# [ doc = "Bit 15 - Fault A Blanking Prescaler" ] # [ inline ( always ) ] pub fn blankpresc ( & mut self ) -> BLANKPRESC_W { BLANKPRESC_W { w : self } }
# [ doc = "Bits 16:23 - Fault A Blanking Time" ] # [ inline ( always ) ] pub fn blankval ( & mut self ) -> BLANKVAL_W { BLANKVAL_W { w : self } }
# [ doc = "Bits 24:27 - Fault A Filter Value" ] # [ inline ( always ) ] pub fn filterval ( & mut self ) -> FILTERVAL_W { FILTERVAL_W { w : self } }
}
}
# [ doc = "Recoverable Fault B Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [fctrlb](fctrlb) module" ] pub type FCTRLB = crate :: Reg < u32 , _FCTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _FCTRLB ;
# [ doc = "`read()` method returns [fctrlb::R](fctrlb::R) reader structure" ] impl crate :: Readable for FCTRLB { }
# [ doc = "`write(|w| ..)` method takes [fctrlb::W](fctrlb::W) writer structure" ] impl crate :: Writable for FCTRLB { }
# [ doc = "Recoverable Fault B Configuration" ] pub mod fctrlb {
# [ doc = "Reader of register FCTRLB" ] pub type R = crate :: R < u32 , super :: FCTRLB > ;
# [ doc = "Writer for register FCTRLB" ] pub type W = crate :: W < u32 , super :: FCTRLB > ;
# [ doc = "Register FCTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: FCTRLB { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `SRC`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SRC_A { # [ doc = "Fault input disabled" ] DISABLE , # [ doc = "MCEx (x=0,1) event input" ] ENABLE , # [ doc = "Inverted MCEx (x=0,1) event input" ] INVERT , # [ doc = "Alternate fault (A or B) state at the end of the previous period" ] ALTFAULT }
impl crate :: ToBits < u8 > for SRC_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { SRC_A :: DISABLE => 0 , SRC_A :: ENABLE => 1 , SRC_A :: INVERT => 2 , SRC_A :: ALTFAULT => 3 } } }
# [ doc = "Reader of field `SRC`" ] pub type SRC_R = crate :: R < u8 , SRC_A > ; impl SRC_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SRC_A { match self . bits { 0 => SRC_A :: DISABLE , 1 => SRC_A :: ENABLE , 2 => SRC_A :: INVERT , 3 => SRC_A :: ALTFAULT , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == SRC_A :: DISABLE } # [ doc = "Checks if the value of the field is `ENABLE`" ] # [ inline ( always ) ] pub fn is_enable ( & self ) -> bool { * self == SRC_A :: ENABLE } # [ doc = "Checks if the value of the field is `INVERT`" ] # [ inline ( always ) ] pub fn is_invert ( & self ) -> bool { * self == SRC_A :: INVERT } # [ doc = "Checks if the value of the field is `ALTFAULT`" ] # [ inline ( always ) ] pub fn is_altfault ( & self ) -> bool { * self == SRC_A :: ALTFAULT } }
# [ doc = "Write proxy for field `SRC`" ] pub struct SRC_W < 'a > { w : & 'a mut W , } impl < 'a > SRC_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SRC_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Fault input disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( SRC_A :: DISABLE ) } # [ doc = "MCEx (x=0,1) event input" ] # [ inline ( always ) ] pub fn enable ( self ) -> & 'a mut W { self . variant ( SRC_A :: ENABLE ) } # [ doc = "Inverted MCEx (x=0,1) event input" ] # [ inline ( always ) ] pub fn invert ( self ) -> & 'a mut W { self . variant ( SRC_A :: INVERT ) } # [ doc = "Alternate fault (A or B) state at the end of the previous period" ] # [ inline ( always ) ] pub fn altfault ( self ) -> & 'a mut W { self . variant ( SRC_A :: ALTFAULT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `KEEP`" ] pub type KEEP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `KEEP`" ] pub struct KEEP_W < 'a > { w : & 'a mut W , } impl < 'a > KEEP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `QUAL`" ] pub type QUAL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `QUAL`" ] pub struct QUAL_W < 'a > { w : & 'a mut W , } impl < 'a > QUAL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Possible values of the field `BLANK`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum BLANK_A { # [ doc = "Blanking applied from start of the ramp" ] START , # [ doc = "Blanking applied from rising edge of the output waveform" ] RISE , # [ doc = "Blanking applied from falling edge of the output waveform" ] FALL , # [ doc = "Blanking applied from each toggle of the output waveform" ] BOTH }
impl crate :: ToBits < u8 > for BLANK_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { BLANK_A :: START => 0 , BLANK_A :: RISE => 1 , BLANK_A :: FALL => 2 , BLANK_A :: BOTH => 3 } } }
# [ doc = "Reader of field `BLANK`" ] pub type BLANK_R = crate :: R < u8 , BLANK_A > ; impl BLANK_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> BLANK_A { match self . bits { 0 => BLANK_A :: START , 1 => BLANK_A :: RISE , 2 => BLANK_A :: FALL , 3 => BLANK_A :: BOTH , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `START`" ] # [ inline ( always ) ] pub fn is_start ( & self ) -> bool { * self == BLANK_A :: START } # [ doc = "Checks if the value of the field is `RISE`" ] # [ inline ( always ) ] pub fn is_rise ( & self ) -> bool { * self == BLANK_A :: RISE } # [ doc = "Checks if the value of the field is `FALL`" ] # [ inline ( always ) ] pub fn is_fall ( & self ) -> bool { * self == BLANK_A :: FALL } # [ doc = "Checks if the value of the field is `BOTH`" ] # [ inline ( always ) ] pub fn is_both ( & self ) -> bool { * self == BLANK_A :: BOTH } }
# [ doc = "Write proxy for field `BLANK`" ] pub struct BLANK_W < 'a > { w : & 'a mut W , } impl < 'a > BLANK_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : BLANK_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Blanking applied from start of the ramp" ] # [ inline ( always ) ] pub fn start ( self ) -> & 'a mut W { self . variant ( BLANK_A :: START ) } # [ doc = "Blanking applied from rising edge of the output waveform" ] # [ inline ( always ) ] pub fn rise ( self ) -> & 'a mut W { self . variant ( BLANK_A :: RISE ) } # [ doc = "Blanking applied from falling edge of the output waveform" ] # [ inline ( always ) ] pub fn fall ( self ) -> & 'a mut W { self . variant ( BLANK_A :: FALL ) } # [ doc = "Blanking applied from each toggle of the output waveform" ] # [ inline ( always ) ] pub fn both ( self ) -> & 'a mut W { self . variant ( BLANK_A :: BOTH ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 5 ) ) | ( ( ( value as u32 ) & 0x03 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `RESTART`" ] pub type RESTART_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESTART`" ] pub struct RESTART_W < 'a > { w : & 'a mut W , } impl < 'a > RESTART_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Possible values of the field `HALT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum HALT_A { # [ doc = "Halt action disabled" ] DISABLE , # [ doc = "Hardware halt action" ] HW , # [ doc = "Software halt action" ] SW , # [ doc = "Non-recoverable fault" ] NR }
impl crate :: ToBits < u8 > for HALT_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { HALT_A :: DISABLE => 0 , HALT_A :: HW => 1 , HALT_A :: SW => 2 , HALT_A :: NR => 3 } } }
# [ doc = "Reader of field `HALT`" ] pub type HALT_R = crate :: R < u8 , HALT_A > ; impl HALT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> HALT_A { match self . bits { 0 => HALT_A :: DISABLE , 1 => HALT_A :: HW , 2 => HALT_A :: SW , 3 => HALT_A :: NR , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == HALT_A :: DISABLE } # [ doc = "Checks if the value of the field is `HW`" ] # [ inline ( always ) ] pub fn is_hw ( & self ) -> bool { * self == HALT_A :: HW } # [ doc = "Checks if the value of the field is `SW`" ] # [ inline ( always ) ] pub fn is_sw ( & self ) -> bool { * self == HALT_A :: SW } # [ doc = "Checks if the value of the field is `NR`" ] # [ inline ( always ) ] pub fn is_nr ( & self ) -> bool { * self == HALT_A :: NR } }
# [ doc = "Write proxy for field `HALT`" ] pub struct HALT_W < 'a > { w : & 'a mut W , } impl < 'a > HALT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : HALT_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Halt action disabled" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( HALT_A :: DISABLE ) } # [ doc = "Hardware halt action" ] # [ inline ( always ) ] pub fn hw ( self ) -> & 'a mut W { self . variant ( HALT_A :: HW ) } # [ doc = "Software halt action" ] # [ inline ( always ) ] pub fn sw ( self ) -> & 'a mut W { self . variant ( HALT_A :: SW ) } # [ doc = "Non-recoverable fault" ] # [ inline ( always ) ] pub fn nr ( self ) -> & 'a mut W { self . variant ( HALT_A :: NR ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 8 ) ) | ( ( ( value as u32 ) & 0x03 ) << 8 ) ; self . w } }
# [ doc = "Possible values of the field `CHSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CHSEL_A { # [ doc = "Capture value stored in channel 0" ] CC0 , # [ doc = "Capture value stored in channel 1" ] CC1 , # [ doc = "Capture value stored in channel 2" ] CC2 , # [ doc = "Capture value stored in channel 3" ] CC3 }
impl crate :: ToBits < u8 > for CHSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CHSEL_A :: CC0 => 0 , CHSEL_A :: CC1 => 1 , CHSEL_A :: CC2 => 2 , CHSEL_A :: CC3 => 3 } } }
# [ doc = "Reader of field `CHSEL`" ] pub type CHSEL_R = crate :: R < u8 , CHSEL_A > ; impl CHSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CHSEL_A { match self . bits { 0 => CHSEL_A :: CC0 , 1 => CHSEL_A :: CC1 , 2 => CHSEL_A :: CC2 , 3 => CHSEL_A :: CC3 , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `CC0`" ] # [ inline ( always ) ] pub fn is_cc0 ( & self ) -> bool { * self == CHSEL_A :: CC0 } # [ doc = "Checks if the value of the field is `CC1`" ] # [ inline ( always ) ] pub fn is_cc1 ( & self ) -> bool { * self == CHSEL_A :: CC1 } # [ doc = "Checks if the value of the field is `CC2`" ] # [ inline ( always ) ] pub fn is_cc2 ( & self ) -> bool { * self == CHSEL_A :: CC2 } # [ doc = "Checks if the value of the field is `CC3`" ] # [ inline ( always ) ] pub fn is_cc3 ( & self ) -> bool { * self == CHSEL_A :: CC3 } }
# [ doc = "Write proxy for field `CHSEL`" ] pub struct CHSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CHSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CHSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Capture value stored in channel 0" ] # [ inline ( always ) ] pub fn cc0 ( self ) -> & 'a mut W { self . variant ( CHSEL_A :: CC0 ) } # [ doc = "Capture value stored in channel 1" ] # [ inline ( always ) ] pub fn cc1 ( self ) -> & 'a mut W { self . variant ( CHSEL_A :: CC1 ) } # [ doc = "Capture value stored in channel 2" ] # [ inline ( always ) ] pub fn cc2 ( self ) -> & 'a mut W { self . variant ( CHSEL_A :: CC2 ) } # [ doc = "Capture value stored in channel 3" ] # [ inline ( always ) ] pub fn cc3 ( self ) -> & 'a mut W { self . variant ( CHSEL_A :: CC3 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 10 ) ) | ( ( ( value as u32 ) & 0x03 ) << 10 ) ; self . w } }
# [ doc = "Possible values of the field `CAPTURE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CAPTURE_A { # [ doc = "No capture" ] DISABLE , # [ doc = "Capture on fault" ] CAPT , # [ doc = "Minimum capture" ] CAPTMIN , # [ doc = "Maximum capture" ] CAPTMAX , # [ doc = "Minimum local detection" ] LOCMIN , # [ doc = "Maximum local detection" ] LOCMAX , # [ doc = "Minimum and maximum local detection" ] DERIV0 , # [ doc = "Capture with ramp index as MSB value" ] CAPTMARK }
impl crate :: ToBits < u8 > for CAPTURE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CAPTURE_A :: DISABLE => 0 , CAPTURE_A :: CAPT => 1 , CAPTURE_A :: CAPTMIN => 2 , CAPTURE_A :: CAPTMAX => 3 , CAPTURE_A :: LOCMIN => 4 , CAPTURE_A :: LOCMAX => 5 , CAPTURE_A :: DERIV0 => 6 , CAPTURE_A :: CAPTMARK => 7 } } }
# [ doc = "Reader of field `CAPTURE`" ] pub type CAPTURE_R = crate :: R < u8 , CAPTURE_A > ; impl CAPTURE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CAPTURE_A { match self . bits { 0 => CAPTURE_A :: DISABLE , 1 => CAPTURE_A :: CAPT , 2 => CAPTURE_A :: CAPTMIN , 3 => CAPTURE_A :: CAPTMAX , 4 => CAPTURE_A :: LOCMIN , 5 => CAPTURE_A :: LOCMAX , 6 => CAPTURE_A :: DERIV0 , 7 => CAPTURE_A :: CAPTMARK , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == CAPTURE_A :: DISABLE } # [ doc = "Checks if the value of the field is `CAPT`" ] # [ inline ( always ) ] pub fn is_capt ( & self ) -> bool { * self == CAPTURE_A :: CAPT } # [ doc = "Checks if the value of the field is `CAPTMIN`" ] # [ inline ( always ) ] pub fn is_captmin ( & self ) -> bool { * self == CAPTURE_A :: CAPTMIN } # [ doc = "Checks if the value of the field is `CAPTMAX`" ] # [ inline ( always ) ] pub fn is_captmax ( & self ) -> bool { * self == CAPTURE_A :: CAPTMAX } # [ doc = "Checks if the value of the field is `LOCMIN`" ] # [ inline ( always ) ] pub fn is_locmin ( & self ) -> bool { * self == CAPTURE_A :: LOCMIN } # [ doc = "Checks if the value of the field is `LOCMAX`" ] # [ inline ( always ) ] pub fn is_locmax ( & self ) -> bool { * self == CAPTURE_A :: LOCMAX } # [ doc = "Checks if the value of the field is `DERIV0`" ] # [ inline ( always ) ] pub fn is_deriv0 ( & self ) -> bool { * self == CAPTURE_A :: DERIV0 } # [ doc = "Checks if the value of the field is `CAPTMARK`" ] # [ inline ( always ) ] pub fn is_captmark ( & self ) -> bool { * self == CAPTURE_A :: CAPTMARK } }
# [ doc = "Write proxy for field `CAPTURE`" ] pub struct CAPTURE_W < 'a > { w : & 'a mut W , } impl < 'a > CAPTURE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CAPTURE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "No capture" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: DISABLE ) } # [ doc = "Capture on fault" ] # [ inline ( always ) ] pub fn capt ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: CAPT ) } # [ doc = "Minimum capture" ] # [ inline ( always ) ] pub fn captmin ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: CAPTMIN ) } # [ doc = "Maximum capture" ] # [ inline ( always ) ] pub fn captmax ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: CAPTMAX ) } # [ doc = "Minimum local detection" ] # [ inline ( always ) ] pub fn locmin ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: LOCMIN ) } # [ doc = "Maximum local detection" ] # [ inline ( always ) ] pub fn locmax ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: LOCMAX ) } # [ doc = "Minimum and maximum local detection" ] # [ inline ( always ) ] pub fn deriv0 ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: DERIV0 ) } # [ doc = "Capture with ramp index as MSB value" ] # [ inline ( always ) ] pub fn captmark ( self ) -> & 'a mut W { self . variant ( CAPTURE_A :: CAPTMARK ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 12 ) ) | ( ( ( value as u32 ) & 0x07 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `BLANKPRESC`" ] pub type BLANKPRESC_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BLANKPRESC`" ] pub struct BLANKPRESC_W < 'a > { w : & 'a mut W , } impl < 'a > BLANKPRESC_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `BLANKVAL`" ] pub type BLANKVAL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `BLANKVAL`" ] pub struct BLANKVAL_W < 'a > { w : & 'a mut W , } impl < 'a > BLANKVAL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } }
# [ doc = "Reader of field `FILTERVAL`" ] pub type FILTERVAL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FILTERVAL`" ] pub struct FILTERVAL_W < 'a > { w : & 'a mut W , } impl < 'a > FILTERVAL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Fault B Source" ] # [ inline ( always ) ] pub fn src ( & self ) -> SRC_R { SRC_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 3 - Fault B Keeper" ] # [ inline ( always ) ] pub fn keep ( & self ) -> KEEP_R { KEEP_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Fault B Qualification" ] # [ inline ( always ) ] pub fn qual ( & self ) -> QUAL_R { QUAL_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 5:6 - Fault B Blanking Mode" ] # [ inline ( always ) ] pub fn blank ( & self ) -> BLANK_R { BLANK_R :: new ( ( ( self . bits >> 5 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - Fault B Restart" ] # [ inline ( always ) ] pub fn restart ( & self ) -> RESTART_R { RESTART_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 8:9 - Fault B Halt Mode" ] # [ inline ( always ) ] pub fn halt ( & self ) -> HALT_R { HALT_R :: new ( ( ( self . bits >> 8 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 10:11 - Fault B Capture Channel" ] # [ inline ( always ) ] pub fn chsel ( & self ) -> CHSEL_R { CHSEL_R :: new ( ( ( self . bits >> 10 ) & 0x03 ) as u8 ) }
# [ doc = "Bits 12:14 - Fault B Capture Action" ] # [ inline ( always ) ] pub fn capture ( & self ) -> CAPTURE_R { CAPTURE_R :: new ( ( ( self . bits >> 12 ) & 0x07 ) as u8 ) }
# [ doc = "Bit 15 - Fault B Blanking Prescaler" ] # [ inline ( always ) ] pub fn blankpresc ( & self ) -> BLANKPRESC_R { BLANKPRESC_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:23 - Fault B Blanking Time" ] # [ inline ( always ) ] pub fn blankval ( & self ) -> BLANKVAL_R { BLANKVAL_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) }
# [ doc = "Bits 24:27 - Fault B Filter Value" ] # [ inline ( always ) ] pub fn filterval ( & self ) -> FILTERVAL_R { FILTERVAL_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Fault B Source" ] # [ inline ( always ) ] pub fn src ( & mut self ) -> SRC_W { SRC_W { w : self } }
# [ doc = "Bit 3 - Fault B Keeper" ] # [ inline ( always ) ] pub fn keep ( & mut self ) -> KEEP_W { KEEP_W { w : self } }
# [ doc = "Bit 4 - Fault B Qualification" ] # [ inline ( always ) ] pub fn qual ( & mut self ) -> QUAL_W { QUAL_W { w : self } }
# [ doc = "Bits 5:6 - Fault B Blanking Mode" ] # [ inline ( always ) ] pub fn blank ( & mut self ) -> BLANK_W { BLANK_W { w : self } }
# [ doc = "Bit 7 - Fault B Restart" ] # [ inline ( always ) ] pub fn restart ( & mut self ) -> RESTART_W { RESTART_W { w : self } }
# [ doc = "Bits 8:9 - Fault B Halt Mode" ] # [ inline ( always ) ] pub fn halt ( & mut self ) -> HALT_W { HALT_W { w : self } }
# [ doc = "Bits 10:11 - Fault B Capture Channel" ] # [ inline ( always ) ] pub fn chsel ( & mut self ) -> CHSEL_W { CHSEL_W { w : self } }
# [ doc = "Bits 12:14 - Fault B Capture Action" ] # [ inline ( always ) ] pub fn capture ( & mut self ) -> CAPTURE_W { CAPTURE_W { w : self } }
# [ doc = "Bit 15 - Fault B Blanking Prescaler" ] # [ inline ( always ) ] pub fn blankpresc ( & mut self ) -> BLANKPRESC_W { BLANKPRESC_W { w : self } }
# [ doc = "Bits 16:23 - Fault B Blanking Time" ] # [ inline ( always ) ] pub fn blankval ( & mut self ) -> BLANKVAL_W { BLANKVAL_W { w : self } }
# [ doc = "Bits 24:27 - Fault B Filter Value" ] # [ inline ( always ) ] pub fn filterval ( & mut self ) -> FILTERVAL_W { FILTERVAL_W { w : self } }
}
}
# [ doc = "Waveform Extension Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [wexctrl](wexctrl) module" ] pub type WEXCTRL = crate :: Reg < u32 , _WEXCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WEXCTRL ;
# [ doc = "`read()` method returns [wexctrl::R](wexctrl::R) reader structure" ] impl crate :: Readable for WEXCTRL { }
# [ doc = "`write(|w| ..)` method takes [wexctrl::W](wexctrl::W) writer structure" ] impl crate :: Writable for WEXCTRL { }
# [ doc = "Waveform Extension Configuration" ] pub mod wexctrl {
# [ doc = "Reader of register WEXCTRL" ] pub type R = crate :: R < u32 , super :: WEXCTRL > ;
# [ doc = "Writer for register WEXCTRL" ] pub type W = crate :: W < u32 , super :: WEXCTRL > ;
# [ doc = "Register WEXCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WEXCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OTMX`" ] pub type OTMX_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `OTMX`" ] pub struct OTMX_W < 'a > { w : & 'a mut W , } impl < 'a > OTMX_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x03 ) | ( ( value as u32 ) & 0x03 ) ; self . w } }
# [ doc = "Reader of field `DTIEN0`" ] pub type DTIEN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DTIEN0`" ] pub struct DTIEN0_W < 'a > { w : & 'a mut W , } impl < 'a > DTIEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `DTIEN1`" ] pub type DTIEN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DTIEN1`" ] pub struct DTIEN1_W < 'a > { w : & 'a mut W , } impl < 'a > DTIEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `DTIEN2`" ] pub type DTIEN2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DTIEN2`" ] pub struct DTIEN2_W < 'a > { w : & 'a mut W , } impl < 'a > DTIEN2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `DTIEN3`" ] pub type DTIEN3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DTIEN3`" ] pub struct DTIEN3_W < 'a > { w : & 'a mut W , } impl < 'a > DTIEN3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `DTLS`" ] pub type DTLS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DTLS`" ] pub struct DTLS_W < 'a > { w : & 'a mut W , } impl < 'a > DTLS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } }
# [ doc = "Reader of field `DTHS`" ] pub type DTHS_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DTHS`" ] pub struct DTHS_W < 'a > { w : & 'a mut W , } impl < 'a > DTHS_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 24 ) ) | ( ( ( value as u32 ) & 0xff ) << 24 ) ; self . w } }
impl R {
# [ doc = "Bits 0:1 - Output Matrix" ] # [ inline ( always ) ] pub fn otmx ( & self ) -> OTMX_R { OTMX_R :: new ( ( self . bits & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Dead-time Insertion Generator 0 Enable" ] # [ inline ( always ) ] pub fn dtien0 ( & self ) -> DTIEN0_R { DTIEN0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Dead-time Insertion Generator 1 Enable" ] # [ inline ( always ) ] pub fn dtien1 ( & self ) -> DTIEN1_R { DTIEN1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Dead-time Insertion Generator 2 Enable" ] # [ inline ( always ) ] pub fn dtien2 ( & self ) -> DTIEN2_R { DTIEN2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Dead-time Insertion Generator 3 Enable" ] # [ inline ( always ) ] pub fn dtien3 ( & self ) -> DTIEN3_R { DTIEN3_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:23 - Dead-time Low Side Outputs Value" ] # [ inline ( always ) ] pub fn dtls ( & self ) -> DTLS_R { DTLS_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) }
# [ doc = "Bits 24:31 - Dead-time High Side Outputs Value" ] # [ inline ( always ) ] pub fn dths ( & self ) -> DTHS_R { DTHS_R :: new ( ( ( self . bits >> 24 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:1 - Output Matrix" ] # [ inline ( always ) ] pub fn otmx ( & mut self ) -> OTMX_W { OTMX_W { w : self } }
# [ doc = "Bit 8 - Dead-time Insertion Generator 0 Enable" ] # [ inline ( always ) ] pub fn dtien0 ( & mut self ) -> DTIEN0_W { DTIEN0_W { w : self } }
# [ doc = "Bit 9 - Dead-time Insertion Generator 1 Enable" ] # [ inline ( always ) ] pub fn dtien1 ( & mut self ) -> DTIEN1_W { DTIEN1_W { w : self } }
# [ doc = "Bit 10 - Dead-time Insertion Generator 2 Enable" ] # [ inline ( always ) ] pub fn dtien2 ( & mut self ) -> DTIEN2_W { DTIEN2_W { w : self } }
# [ doc = "Bit 11 - Dead-time Insertion Generator 3 Enable" ] # [ inline ( always ) ] pub fn dtien3 ( & mut self ) -> DTIEN3_W { DTIEN3_W { w : self } }
# [ doc = "Bits 16:23 - Dead-time Low Side Outputs Value" ] # [ inline ( always ) ] pub fn dtls ( & mut self ) -> DTLS_W { DTLS_W { w : self } }
# [ doc = "Bits 24:31 - Dead-time High Side Outputs Value" ] # [ inline ( always ) ] pub fn dths ( & mut self ) -> DTHS_W { DTHS_W { w : self } }
}
}
# [ doc = "Driver Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [drvctrl](drvctrl) module" ] pub type DRVCTRL = crate :: Reg < u32 , _DRVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DRVCTRL ;
# [ doc = "`read()` method returns [drvctrl::R](drvctrl::R) reader structure" ] impl crate :: Readable for DRVCTRL { }
# [ doc = "`write(|w| ..)` method takes [drvctrl::W](drvctrl::W) writer structure" ] impl crate :: Writable for DRVCTRL { }
# [ doc = "Driver Control" ] pub mod drvctrl {
# [ doc = "Reader of register DRVCTRL" ] pub type R = crate :: R < u32 , super :: DRVCTRL > ;
# [ doc = "Writer for register DRVCTRL" ] pub type W = crate :: W < u32 , super :: DRVCTRL > ;
# [ doc = "Register DRVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DRVCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `NRE0`" ] pub type NRE0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRE0`" ] pub struct NRE0_W < 'a > { w : & 'a mut W , } impl < 'a > NRE0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `NRE1`" ] pub type NRE1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRE1`" ] pub struct NRE1_W < 'a > { w : & 'a mut W , } impl < 'a > NRE1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `NRE2`" ] pub type NRE2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRE2`" ] pub struct NRE2_W < 'a > { w : & 'a mut W , } impl < 'a > NRE2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `NRE3`" ] pub type NRE3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRE3`" ] pub struct NRE3_W < 'a > { w : & 'a mut W , } impl < 'a > NRE3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `NRE4`" ] pub type NRE4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRE4`" ] pub struct NRE4_W < 'a > { w : & 'a mut W , } impl < 'a > NRE4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `NRE5`" ] pub type NRE5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRE5`" ] pub struct NRE5_W < 'a > { w : & 'a mut W , } impl < 'a > NRE5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `NRE6`" ] pub type NRE6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRE6`" ] pub struct NRE6_W < 'a > { w : & 'a mut W , } impl < 'a > NRE6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u32 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `NRE7`" ] pub type NRE7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRE7`" ] pub struct NRE7_W < 'a > { w : & 'a mut W , } impl < 'a > NRE7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `NRV0`" ] pub type NRV0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRV0`" ] pub struct NRV0_W < 'a > { w : & 'a mut W , } impl < 'a > NRV0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `NRV1`" ] pub type NRV1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRV1`" ] pub struct NRV1_W < 'a > { w : & 'a mut W , } impl < 'a > NRV1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `NRV2`" ] pub type NRV2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRV2`" ] pub struct NRV2_W < 'a > { w : & 'a mut W , } impl < 'a > NRV2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `NRV3`" ] pub type NRV3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRV3`" ] pub struct NRV3_W < 'a > { w : & 'a mut W , } impl < 'a > NRV3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `NRV4`" ] pub type NRV4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRV4`" ] pub struct NRV4_W < 'a > { w : & 'a mut W , } impl < 'a > NRV4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `NRV5`" ] pub type NRV5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRV5`" ] pub struct NRV5_W < 'a > { w : & 'a mut W , } impl < 'a > NRV5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `NRV6`" ] pub type NRV6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRV6`" ] pub struct NRV6_W < 'a > { w : & 'a mut W , } impl < 'a > NRV6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `NRV7`" ] pub type NRV7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `NRV7`" ] pub struct NRV7_W < 'a > { w : & 'a mut W , } impl < 'a > NRV7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `INVEN0`" ] pub type INVEN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEN0`" ] pub struct INVEN0_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `INVEN1`" ] pub type INVEN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEN1`" ] pub struct INVEN1_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `INVEN2`" ] pub type INVEN2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEN2`" ] pub struct INVEN2_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `INVEN3`" ] pub type INVEN3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEN3`" ] pub struct INVEN3_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `INVEN4`" ] pub type INVEN4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEN4`" ] pub struct INVEN4_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 20 ) ) | ( ( ( value as u32 ) & 0x01 ) << 20 ) ; self . w } }
# [ doc = "Reader of field `INVEN5`" ] pub type INVEN5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEN5`" ] pub struct INVEN5_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 21 ) ) | ( ( ( value as u32 ) & 0x01 ) << 21 ) ; self . w } }
# [ doc = "Reader of field `INVEN6`" ] pub type INVEN6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEN6`" ] pub struct INVEN6_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `INVEN7`" ] pub type INVEN7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `INVEN7`" ] pub struct INVEN7_W < 'a > { w : & 'a mut W , } impl < 'a > INVEN7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Reader of field `FILTERVAL0`" ] pub type FILTERVAL0_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FILTERVAL0`" ] pub struct FILTERVAL0_W < 'a > { w : & 'a mut W , } impl < 'a > FILTERVAL0_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 24 ) ) | ( ( ( value as u32 ) & 0x0f ) << 24 ) ; self . w } }
# [ doc = "Reader of field `FILTERVAL1`" ] pub type FILTERVAL1_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FILTERVAL1`" ] pub struct FILTERVAL1_W < 'a > { w : & 'a mut W , } impl < 'a > FILTERVAL1_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 28 ) ) | ( ( ( value as u32 ) & 0x0f ) << 28 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Non-Recoverable State 0 Output Enable" ] # [ inline ( always ) ] pub fn nre0 ( & self ) -> NRE0_R { NRE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Non-Recoverable State 1 Output Enable" ] # [ inline ( always ) ] pub fn nre1 ( & self ) -> NRE1_R { NRE1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Non-Recoverable State 2 Output Enable" ] # [ inline ( always ) ] pub fn nre2 ( & self ) -> NRE2_R { NRE2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Non-Recoverable State 3 Output Enable" ] # [ inline ( always ) ] pub fn nre3 ( & self ) -> NRE3_R { NRE3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Non-Recoverable State 4 Output Enable" ] # [ inline ( always ) ] pub fn nre4 ( & self ) -> NRE4_R { NRE4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Non-Recoverable State 5 Output Enable" ] # [ inline ( always ) ] pub fn nre5 ( & self ) -> NRE5_R { NRE5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Non-Recoverable State 6 Output Enable" ] # [ inline ( always ) ] pub fn nre6 ( & self ) -> NRE6_R { NRE6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Non-Recoverable State 7 Output Enable" ] # [ inline ( always ) ] pub fn nre7 ( & self ) -> NRE7_R { NRE7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Non-Recoverable State 0 Output Value" ] # [ inline ( always ) ] pub fn nrv0 ( & self ) -> NRV0_R { NRV0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Non-Recoverable State 1 Output Value" ] # [ inline ( always ) ] pub fn nrv1 ( & self ) -> NRV1_R { NRV1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Non-Recoverable State 2 Output Value" ] # [ inline ( always ) ] pub fn nrv2 ( & self ) -> NRV2_R { NRV2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Non-Recoverable State 3 Output Value" ] # [ inline ( always ) ] pub fn nrv3 ( & self ) -> NRV3_R { NRV3_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Non-Recoverable State 4 Output Value" ] # [ inline ( always ) ] pub fn nrv4 ( & self ) -> NRV4_R { NRV4_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Non-Recoverable State 5 Output Value" ] # [ inline ( always ) ] pub fn nrv5 ( & self ) -> NRV5_R { NRV5_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Non-Recoverable State 6 Output Value" ] # [ inline ( always ) ] pub fn nrv6 ( & self ) -> NRV6_R { NRV6_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Non-Recoverable State 7 Output Value" ] # [ inline ( always ) ] pub fn nrv7 ( & self ) -> NRV7_R { NRV7_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Output Waveform 0 Inversion" ] # [ inline ( always ) ] pub fn inven0 ( & self ) -> INVEN0_R { INVEN0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Output Waveform 1 Inversion" ] # [ inline ( always ) ] pub fn inven1 ( & self ) -> INVEN1_R { INVEN1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Output Waveform 2 Inversion" ] # [ inline ( always ) ] pub fn inven2 ( & self ) -> INVEN2_R { INVEN2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Output Waveform 3 Inversion" ] # [ inline ( always ) ] pub fn inven3 ( & self ) -> INVEN3_R { INVEN3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 20 - Output Waveform 4 Inversion" ] # [ inline ( always ) ] pub fn inven4 ( & self ) -> INVEN4_R { INVEN4_R :: new ( ( ( self . bits >> 20 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 21 - Output Waveform 5 Inversion" ] # [ inline ( always ) ] pub fn inven5 ( & self ) -> INVEN5_R { INVEN5_R :: new ( ( ( self . bits >> 21 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 22 - Output Waveform 6 Inversion" ] # [ inline ( always ) ] pub fn inven6 ( & self ) -> INVEN6_R { INVEN6_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Output Waveform 7 Inversion" ] # [ inline ( always ) ] pub fn inven7 ( & self ) -> INVEN7_R { INVEN7_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 24:27 - Non-Recoverable Fault Input 0 Filter Value" ] # [ inline ( always ) ] pub fn filterval0 ( & self ) -> FILTERVAL0_R { FILTERVAL0_R :: new ( ( ( self . bits >> 24 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 28:31 - Non-Recoverable Fault Input 1 Filter Value" ] # [ inline ( always ) ] pub fn filterval1 ( & self ) -> FILTERVAL1_R { FILTERVAL1_R :: new ( ( ( self . bits >> 28 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bit 0 - Non-Recoverable State 0 Output Enable" ] # [ inline ( always ) ] pub fn nre0 ( & mut self ) -> NRE0_W { NRE0_W { w : self } }
# [ doc = "Bit 1 - Non-Recoverable State 1 Output Enable" ] # [ inline ( always ) ] pub fn nre1 ( & mut self ) -> NRE1_W { NRE1_W { w : self } }
# [ doc = "Bit 2 - Non-Recoverable State 2 Output Enable" ] # [ inline ( always ) ] pub fn nre2 ( & mut self ) -> NRE2_W { NRE2_W { w : self } }
# [ doc = "Bit 3 - Non-Recoverable State 3 Output Enable" ] # [ inline ( always ) ] pub fn nre3 ( & mut self ) -> NRE3_W { NRE3_W { w : self } }
# [ doc = "Bit 4 - Non-Recoverable State 4 Output Enable" ] # [ inline ( always ) ] pub fn nre4 ( & mut self ) -> NRE4_W { NRE4_W { w : self } }
# [ doc = "Bit 5 - Non-Recoverable State 5 Output Enable" ] # [ inline ( always ) ] pub fn nre5 ( & mut self ) -> NRE5_W { NRE5_W { w : self } }
# [ doc = "Bit 6 - Non-Recoverable State 6 Output Enable" ] # [ inline ( always ) ] pub fn nre6 ( & mut self ) -> NRE6_W { NRE6_W { w : self } }
# [ doc = "Bit 7 - Non-Recoverable State 7 Output Enable" ] # [ inline ( always ) ] pub fn nre7 ( & mut self ) -> NRE7_W { NRE7_W { w : self } }
# [ doc = "Bit 8 - Non-Recoverable State 0 Output Value" ] # [ inline ( always ) ] pub fn nrv0 ( & mut self ) -> NRV0_W { NRV0_W { w : self } }
# [ doc = "Bit 9 - Non-Recoverable State 1 Output Value" ] # [ inline ( always ) ] pub fn nrv1 ( & mut self ) -> NRV1_W { NRV1_W { w : self } }
# [ doc = "Bit 10 - Non-Recoverable State 2 Output Value" ] # [ inline ( always ) ] pub fn nrv2 ( & mut self ) -> NRV2_W { NRV2_W { w : self } }
# [ doc = "Bit 11 - Non-Recoverable State 3 Output Value" ] # [ inline ( always ) ] pub fn nrv3 ( & mut self ) -> NRV3_W { NRV3_W { w : self } }
# [ doc = "Bit 12 - Non-Recoverable State 4 Output Value" ] # [ inline ( always ) ] pub fn nrv4 ( & mut self ) -> NRV4_W { NRV4_W { w : self } }
# [ doc = "Bit 13 - Non-Recoverable State 5 Output Value" ] # [ inline ( always ) ] pub fn nrv5 ( & mut self ) -> NRV5_W { NRV5_W { w : self } }
# [ doc = "Bit 14 - Non-Recoverable State 6 Output Value" ] # [ inline ( always ) ] pub fn nrv6 ( & mut self ) -> NRV6_W { NRV6_W { w : self } }
# [ doc = "Bit 15 - Non-Recoverable State 7 Output Value" ] # [ inline ( always ) ] pub fn nrv7 ( & mut self ) -> NRV7_W { NRV7_W { w : self } }
# [ doc = "Bit 16 - Output Waveform 0 Inversion" ] # [ inline ( always ) ] pub fn inven0 ( & mut self ) -> INVEN0_W { INVEN0_W { w : self } }
# [ doc = "Bit 17 - Output Waveform 1 Inversion" ] # [ inline ( always ) ] pub fn inven1 ( & mut self ) -> INVEN1_W { INVEN1_W { w : self } }
# [ doc = "Bit 18 - Output Waveform 2 Inversion" ] # [ inline ( always ) ] pub fn inven2 ( & mut self ) -> INVEN2_W { INVEN2_W { w : self } }
# [ doc = "Bit 19 - Output Waveform 3 Inversion" ] # [ inline ( always ) ] pub fn inven3 ( & mut self ) -> INVEN3_W { INVEN3_W { w : self } }
# [ doc = "Bit 20 - Output Waveform 4 Inversion" ] # [ inline ( always ) ] pub fn inven4 ( & mut self ) -> INVEN4_W { INVEN4_W { w : self } }
# [ doc = "Bit 21 - Output Waveform 5 Inversion" ] # [ inline ( always ) ] pub fn inven5 ( & mut self ) -> INVEN5_W { INVEN5_W { w : self } }
# [ doc = "Bit 22 - Output Waveform 6 Inversion" ] # [ inline ( always ) ] pub fn inven6 ( & mut self ) -> INVEN6_W { INVEN6_W { w : self } }
# [ doc = "Bit 23 - Output Waveform 7 Inversion" ] # [ inline ( always ) ] pub fn inven7 ( & mut self ) -> INVEN7_W { INVEN7_W { w : self } }
# [ doc = "Bits 24:27 - Non-Recoverable Fault Input 0 Filter Value" ] # [ inline ( always ) ] pub fn filterval0 ( & mut self ) -> FILTERVAL0_W { FILTERVAL0_W { w : self } }
# [ doc = "Bits 28:31 - Non-Recoverable Fault Input 1 Filter Value" ] # [ inline ( always ) ] pub fn filterval1 ( & mut self ) -> FILTERVAL1_W { FILTERVAL1_W { w : self } }
}
}
# [ doc = "Debug Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ;
# [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { }
# [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { }
# [ doc = "Debug Control" ] pub mod dbgctrl {
# [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ;
# [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ;
# [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `FDDBD`" ] pub type FDDBD_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FDDBD`" ] pub struct FDDBD_W < 'a > { w : & 'a mut W , } impl < 'a > FDDBD_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Debug Running Mode" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Fault Detection on Debug Break Detection" ] # [ inline ( always ) ] pub fn fddbd ( & self ) -> FDDBD_R { FDDBD_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Debug Running Mode" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } }
# [ doc = "Bit 2 - Fault Detection on Debug Break Detection" ] # [ inline ( always ) ] pub fn fddbd ( & mut self ) -> FDDBD_W { FDDBD_W { w : self } }
}
}
# [ doc = "Event Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u32 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event Control" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u32 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u32 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `EVACT0`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EVACT0_A { # [ doc = "Event action disabled" ] OFF , # [ doc = "Start, restart or re-trigger counter on event" ] RETRIGGER , # [ doc = "Count on event" ] COUNTEV , # [ doc = "Start counter on event" ] START , # [ doc = "Increment counter on event" ] INC , # [ doc = "Count on active state of asynchronous event" ] COUNT , # [ doc = "Stamp capture" ] STAMP , # [ doc = "Non-recoverable fault" ] FAULT }
impl crate :: ToBits < u8 > for EVACT0_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { EVACT0_A :: OFF => 0 , EVACT0_A :: RETRIGGER => 1 , EVACT0_A :: COUNTEV => 2 , EVACT0_A :: START => 3 , EVACT0_A :: INC => 4 , EVACT0_A :: COUNT => 5 , EVACT0_A :: STAMP => 6 , EVACT0_A :: FAULT => 7 } } }
# [ doc = "Reader of field `EVACT0`" ] pub type EVACT0_R = crate :: R < u8 , EVACT0_A > ; impl EVACT0_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EVACT0_A { match self . bits { 0 => EVACT0_A :: OFF , 1 => EVACT0_A :: RETRIGGER , 2 => EVACT0_A :: COUNTEV , 3 => EVACT0_A :: START , 4 => EVACT0_A :: INC , 5 => EVACT0_A :: COUNT , 6 => EVACT0_A :: STAMP , 7 => EVACT0_A :: FAULT , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == EVACT0_A :: OFF } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == EVACT0_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `COUNTEV`" ] # [ inline ( always ) ] pub fn is_countev ( & self ) -> bool { * self == EVACT0_A :: COUNTEV } # [ doc = "Checks if the value of the field is `START`" ] # [ inline ( always ) ] pub fn is_start ( & self ) -> bool { * self == EVACT0_A :: START } # [ doc = "Checks if the value of the field is `INC`" ] # [ inline ( always ) ] pub fn is_inc ( & self ) -> bool { * self == EVACT0_A :: INC } # [ doc = "Checks if the value of the field is `COUNT`" ] # [ inline ( always ) ] pub fn is_count ( & self ) -> bool { * self == EVACT0_A :: COUNT } # [ doc = "Checks if the value of the field is `STAMP`" ] # [ inline ( always ) ] pub fn is_stamp ( & self ) -> bool { * self == EVACT0_A :: STAMP } # [ doc = "Checks if the value of the field is `FAULT`" ] # [ inline ( always ) ] pub fn is_fault ( & self ) -> bool { * self == EVACT0_A :: FAULT } }
# [ doc = "Write proxy for field `EVACT0`" ] pub struct EVACT0_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT0_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EVACT0_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Event action disabled" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: OFF ) } # [ doc = "Start, restart or re-trigger counter on event" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: RETRIGGER ) } # [ doc = "Count on event" ] # [ inline ( always ) ] pub fn countev ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: COUNTEV ) } # [ doc = "Start counter on event" ] # [ inline ( always ) ] pub fn start ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: START ) } # [ doc = "Increment counter on event" ] # [ inline ( always ) ] pub fn inc ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: INC ) } # [ doc = "Count on active state of asynchronous event" ] # [ inline ( always ) ] pub fn count ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: COUNT ) } # [ doc = "Stamp capture" ] # [ inline ( always ) ] pub fn stamp ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: STAMP ) } # [ doc = "Non-recoverable fault" ] # [ inline ( always ) ] pub fn fault ( self ) -> & 'a mut W { self . variant ( EVACT0_A :: FAULT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
# [ doc = "Possible values of the field `EVACT1`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EVACT1_A { # [ doc = "Event action disabled" ] OFF , # [ doc = "Re-trigger counter on event" ] RETRIGGER , # [ doc = "Direction control" ] DIR , # [ doc = "Stop counter on event" ] STOP , # [ doc = "Decrement counter on event" ] DEC , # [ doc = "Period capture value in CC0 register, pulse width capture value in CC1 register" ] PPW , # [ doc = "Period capture value in CC1 register, pulse width capture value in CC0 register" ] PWP , # [ doc = "Non-recoverable fault" ] FAULT }
impl crate :: ToBits < u8 > for EVACT1_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { EVACT1_A :: OFF => 0 , EVACT1_A :: RETRIGGER => 1 , EVACT1_A :: DIR => 2 , EVACT1_A :: STOP => 3 , EVACT1_A :: DEC => 4 , EVACT1_A :: PPW => 5 , EVACT1_A :: PWP => 6 , EVACT1_A :: FAULT => 7 } } }
# [ doc = "Reader of field `EVACT1`" ] pub type EVACT1_R = crate :: R < u8 , EVACT1_A > ; impl EVACT1_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> EVACT1_A { match self . bits { 0 => EVACT1_A :: OFF , 1 => EVACT1_A :: RETRIGGER , 2 => EVACT1_A :: DIR , 3 => EVACT1_A :: STOP , 4 => EVACT1_A :: DEC , 5 => EVACT1_A :: PPW , 6 => EVACT1_A :: PWP , 7 => EVACT1_A :: FAULT , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `OFF`" ] # [ inline ( always ) ] pub fn is_off ( & self ) -> bool { * self == EVACT1_A :: OFF } # [ doc = "Checks if the value of the field is `RETRIGGER`" ] # [ inline ( always ) ] pub fn is_retrigger ( & self ) -> bool { * self == EVACT1_A :: RETRIGGER } # [ doc = "Checks if the value of the field is `DIR`" ] # [ inline ( always ) ] pub fn is_dir ( & self ) -> bool { * self == EVACT1_A :: DIR } # [ doc = "Checks if the value of the field is `STOP`" ] # [ inline ( always ) ] pub fn is_stop ( & self ) -> bool { * self == EVACT1_A :: STOP } # [ doc = "Checks if the value of the field is `DEC`" ] # [ inline ( always ) ] pub fn is_dec ( & self ) -> bool { * self == EVACT1_A :: DEC } # [ doc = "Checks if the value of the field is `PPW`" ] # [ inline ( always ) ] pub fn is_ppw ( & self ) -> bool { * self == EVACT1_A :: PPW } # [ doc = "Checks if the value of the field is `PWP`" ] # [ inline ( always ) ] pub fn is_pwp ( & self ) -> bool { * self == EVACT1_A :: PWP } # [ doc = "Checks if the value of the field is `FAULT`" ] # [ inline ( always ) ] pub fn is_fault ( & self ) -> bool { * self == EVACT1_A :: FAULT } }
# [ doc = "Write proxy for field `EVACT1`" ] pub struct EVACT1_W < 'a > { w : & 'a mut W , } impl < 'a > EVACT1_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EVACT1_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "Event action disabled" ] # [ inline ( always ) ] pub fn off ( self ) -> & 'a mut W { self . variant ( EVACT1_A :: OFF ) } # [ doc = "Re-trigger counter on event" ] # [ inline ( always ) ] pub fn retrigger ( self ) -> & 'a mut W { self . variant ( EVACT1_A :: RETRIGGER ) } # [ doc = "Direction control" ] # [ inline ( always ) ] pub fn dir ( self ) -> & 'a mut W { self . variant ( EVACT1_A :: DIR ) } # [ doc = "Stop counter on event" ] # [ inline ( always ) ] pub fn stop ( self ) -> & 'a mut W { self . variant ( EVACT1_A :: STOP ) } # [ doc = "Decrement counter on event" ] # [ inline ( always ) ] pub fn dec ( self ) -> & 'a mut W { self . variant ( EVACT1_A :: DEC ) } # [ doc = "Period capture value in CC0 register, pulse width capture value in CC1 register" ] # [ inline ( always ) ] pub fn ppw ( self ) -> & 'a mut W { self . variant ( EVACT1_A :: PPW ) } # [ doc = "Period capture value in CC1 register, pulse width capture value in CC0 register" ] # [ inline ( always ) ] pub fn pwp ( self ) -> & 'a mut W { self . variant ( EVACT1_A :: PWP ) } # [ doc = "Non-recoverable fault" ] # [ inline ( always ) ] pub fn fault ( self ) -> & 'a mut W { self . variant ( EVACT1_A :: FAULT ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x07 << 3 ) ) | ( ( ( value as u32 ) & 0x07 ) << 3 ) ; self . w } }
# [ doc = "Possible values of the field `CNTSEL`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CNTSEL_A { # [ doc = "An interrupt/event is generated when a new counter cycle starts" ] START , # [ doc = "An interrupt/event is generated when a counter cycle ends" ] END , # [ doc = "An interrupt/event is generated when a counter cycle ends, except for the first and last cycles" ] BETWEEN , # [ doc = "An interrupt/event is generated when a new counter cycle starts or a counter cycle ends" ] BOUNDARY }
impl crate :: ToBits < u8 > for CNTSEL_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CNTSEL_A :: START => 0 , CNTSEL_A :: END => 1 , CNTSEL_A :: BETWEEN => 2 , CNTSEL_A :: BOUNDARY => 3 } } }
# [ doc = "Reader of field `CNTSEL`" ] pub type CNTSEL_R = crate :: R < u8 , CNTSEL_A > ; impl CNTSEL_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CNTSEL_A { match self . bits { 0 => CNTSEL_A :: START , 1 => CNTSEL_A :: END , 2 => CNTSEL_A :: BETWEEN , 3 => CNTSEL_A :: BOUNDARY , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `START`" ] # [ inline ( always ) ] pub fn is_start ( & self ) -> bool { * self == CNTSEL_A :: START } # [ doc = "Checks if the value of the field is `END`" ] # [ inline ( always ) ] pub fn is_end ( & self ) -> bool { * self == CNTSEL_A :: END } # [ doc = "Checks if the value of the field is `BETWEEN`" ] # [ inline ( always ) ] pub fn is_between ( & self ) -> bool { * self == CNTSEL_A :: BETWEEN } # [ doc = "Checks if the value of the field is `BOUNDARY`" ] # [ inline ( always ) ] pub fn is_boundary ( & self ) -> bool { * self == CNTSEL_A :: BOUNDARY } }
# [ doc = "Write proxy for field `CNTSEL`" ] pub struct CNTSEL_W < 'a > { w : & 'a mut W , } impl < 'a > CNTSEL_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CNTSEL_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "An interrupt/event is generated when a new counter cycle starts" ] # [ inline ( always ) ] pub fn start ( self ) -> & 'a mut W { self . variant ( CNTSEL_A :: START ) } # [ doc = "An interrupt/event is generated when a counter cycle ends" ] # [ inline ( always ) ] pub fn end ( self ) -> & 'a mut W { self . variant ( CNTSEL_A :: END ) } # [ doc = "An interrupt/event is generated when a counter cycle ends, except for the first and last cycles" ] # [ inline ( always ) ] pub fn between ( self ) -> & 'a mut W { self . variant ( CNTSEL_A :: BETWEEN ) } # [ doc = "An interrupt/event is generated when a new counter cycle starts or a counter cycle ends" ] # [ inline ( always ) ] pub fn boundary ( self ) -> & 'a mut W { self . variant ( CNTSEL_A :: BOUNDARY ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 6 ) ) | ( ( ( value as u32 ) & 0x03 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `OVFEO`" ] pub type OVFEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVFEO`" ] pub struct OVFEO_W < 'a > { w : & 'a mut W , } impl < 'a > OVFEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `TRGEO`" ] pub type TRGEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TRGEO`" ] pub struct TRGEO_W < 'a > { w : & 'a mut W , } impl < 'a > TRGEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `CNTEO`" ] pub type CNTEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CNTEO`" ] pub struct CNTEO_W < 'a > { w : & 'a mut W , } impl < 'a > CNTEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `TCINV0`" ] pub type TCINV0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCINV0`" ] pub struct TCINV0_W < 'a > { w : & 'a mut W , } impl < 'a > TCINV0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `TCINV1`" ] pub type TCINV1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCINV1`" ] pub struct TCINV1_W < 'a > { w : & 'a mut W , } impl < 'a > TCINV1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `TCEI0`" ] pub type TCEI0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCEI0`" ] pub struct TCEI0_W < 'a > { w : & 'a mut W , } impl < 'a > TCEI0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `TCEI1`" ] pub type TCEI1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TCEI1`" ] pub struct TCEI1_W < 'a > { w : & 'a mut W , } impl < 'a > TCEI1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `MCEI0`" ] pub type MCEI0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCEI0`" ] pub struct MCEI0_W < 'a > { w : & 'a mut W , } impl < 'a > MCEI0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `MCEI1`" ] pub type MCEI1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCEI1`" ] pub struct MCEI1_W < 'a > { w : & 'a mut W , } impl < 'a > MCEI1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `MCEI2`" ] pub type MCEI2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCEI2`" ] pub struct MCEI2_W < 'a > { w : & 'a mut W , } impl < 'a > MCEI2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `MCEI3`" ] pub type MCEI3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCEI3`" ] pub struct MCEI3_W < 'a > { w : & 'a mut W , } impl < 'a > MCEI3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `MCEO0`" ] pub type MCEO0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCEO0`" ] pub struct MCEO0_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `MCEO1`" ] pub type MCEO1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCEO1`" ] pub struct MCEO1_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `MCEO2`" ] pub type MCEO2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCEO2`" ] pub struct MCEO2_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `MCEO3`" ] pub type MCEO3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MCEO3`" ] pub struct MCEO3_W < 'a > { w : & 'a mut W , } impl < 'a > MCEO3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Timer/counter Input Event0 Action" ] # [ inline ( always ) ] pub fn evact0 ( & self ) -> EVACT0_R { EVACT0_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bits 3:5 - Timer/counter Input Event1 Action" ] # [ inline ( always ) ] pub fn evact1 ( & self ) -> EVACT1_R { EVACT1_R :: new ( ( ( self . bits >> 3 ) & 0x07 ) as u8 ) }
# [ doc = "Bits 6:7 - Timer/counter Output Event Mode" ] # [ inline ( always ) ] pub fn cntsel ( & self ) -> CNTSEL_R { CNTSEL_R :: new ( ( ( self . bits >> 6 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 8 - Overflow/Underflow Output Event Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & self ) -> OVFEO_R { OVFEO_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Retrigger Output Event Enable" ] # [ inline ( always ) ] pub fn trgeo ( & self ) -> TRGEO_R { TRGEO_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Timer/counter Output Event Enable" ] # [ inline ( always ) ] pub fn cnteo ( & self ) -> CNTEO_R { CNTEO_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Inverted Event 0 Input Enable" ] # [ inline ( always ) ] pub fn tcinv0 ( & self ) -> TCINV0_R { TCINV0_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Inverted Event 1 Input Enable" ] # [ inline ( always ) ] pub fn tcinv1 ( & self ) -> TCINV1_R { TCINV1_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Timer/counter Event 0 Input Enable" ] # [ inline ( always ) ] pub fn tcei0 ( & self ) -> TCEI0_R { TCEI0_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Timer/counter Event 1 Input Enable" ] # [ inline ( always ) ] pub fn tcei1 ( & self ) -> TCEI1_R { TCEI1_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Match or Capture Channel 0 Event Input Enable" ] # [ inline ( always ) ] pub fn mcei0 ( & self ) -> MCEI0_R { MCEI0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Match or Capture Channel 1 Event Input Enable" ] # [ inline ( always ) ] pub fn mcei1 ( & self ) -> MCEI1_R { MCEI1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Match or Capture Channel 2 Event Input Enable" ] # [ inline ( always ) ] pub fn mcei2 ( & self ) -> MCEI2_R { MCEI2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Match or Capture Channel 3 Event Input Enable" ] # [ inline ( always ) ] pub fn mcei3 ( & self ) -> MCEI3_R { MCEI3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Match or Capture Channel 0 Event Output Enable" ] # [ inline ( always ) ] pub fn mceo0 ( & self ) -> MCEO0_R { MCEO0_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Match or Capture Channel 1 Event Output Enable" ] # [ inline ( always ) ] pub fn mceo1 ( & self ) -> MCEO1_R { MCEO1_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Match or Capture Channel 2 Event Output Enable" ] # [ inline ( always ) ] pub fn mceo2 ( & self ) -> MCEO2_R { MCEO2_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Match or Capture Channel 3 Event Output Enable" ] # [ inline ( always ) ] pub fn mceo3 ( & self ) -> MCEO3_R { MCEO3_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:2 - Timer/counter Input Event0 Action" ] # [ inline ( always ) ] pub fn evact0 ( & mut self ) -> EVACT0_W { EVACT0_W { w : self } }
# [ doc = "Bits 3:5 - Timer/counter Input Event1 Action" ] # [ inline ( always ) ] pub fn evact1 ( & mut self ) -> EVACT1_W { EVACT1_W { w : self } }
# [ doc = "Bits 6:7 - Timer/counter Output Event Mode" ] # [ inline ( always ) ] pub fn cntsel ( & mut self ) -> CNTSEL_W { CNTSEL_W { w : self } }
# [ doc = "Bit 8 - Overflow/Underflow Output Event Enable" ] # [ inline ( always ) ] pub fn ovfeo ( & mut self ) -> OVFEO_W { OVFEO_W { w : self } }
# [ doc = "Bit 9 - Retrigger Output Event Enable" ] # [ inline ( always ) ] pub fn trgeo ( & mut self ) -> TRGEO_W { TRGEO_W { w : self } }
# [ doc = "Bit 10 - Timer/counter Output Event Enable" ] # [ inline ( always ) ] pub fn cnteo ( & mut self ) -> CNTEO_W { CNTEO_W { w : self } }
# [ doc = "Bit 12 - Inverted Event 0 Input Enable" ] # [ inline ( always ) ] pub fn tcinv0 ( & mut self ) -> TCINV0_W { TCINV0_W { w : self } }
# [ doc = "Bit 13 - Inverted Event 1 Input Enable" ] # [ inline ( always ) ] pub fn tcinv1 ( & mut self ) -> TCINV1_W { TCINV1_W { w : self } }
# [ doc = "Bit 14 - Timer/counter Event 0 Input Enable" ] # [ inline ( always ) ] pub fn tcei0 ( & mut self ) -> TCEI0_W { TCEI0_W { w : self } }
# [ doc = "Bit 15 - Timer/counter Event 1 Input Enable" ] # [ inline ( always ) ] pub fn tcei1 ( & mut self ) -> TCEI1_W { TCEI1_W { w : self } }
# [ doc = "Bit 16 - Match or Capture Channel 0 Event Input Enable" ] # [ inline ( always ) ] pub fn mcei0 ( & mut self ) -> MCEI0_W { MCEI0_W { w : self } }
# [ doc = "Bit 17 - Match or Capture Channel 1 Event Input Enable" ] # [ inline ( always ) ] pub fn mcei1 ( & mut self ) -> MCEI1_W { MCEI1_W { w : self } }
# [ doc = "Bit 18 - Match or Capture Channel 2 Event Input Enable" ] # [ inline ( always ) ] pub fn mcei2 ( & mut self ) -> MCEI2_W { MCEI2_W { w : self } }
# [ doc = "Bit 19 - Match or Capture Channel 3 Event Input Enable" ] # [ inline ( always ) ] pub fn mcei3 ( & mut self ) -> MCEI3_W { MCEI3_W { w : self } }
# [ doc = "Bit 24 - Match or Capture Channel 0 Event Output Enable" ] # [ inline ( always ) ] pub fn mceo0 ( & mut self ) -> MCEO0_W { MCEO0_W { w : self } }
# [ doc = "Bit 25 - Match or Capture Channel 1 Event Output Enable" ] # [ inline ( always ) ] pub fn mceo1 ( & mut self ) -> MCEO1_W { MCEO1_W { w : self } }
# [ doc = "Bit 26 - Match or Capture Channel 2 Event Output Enable" ] # [ inline ( always ) ] pub fn mceo2 ( & mut self ) -> MCEO2_W { MCEO2_W { w : self } }
# [ doc = "Bit 27 - Match or Capture Channel 3 Event Output Enable" ] # [ inline ( always ) ] pub fn mceo3 ( & mut self ) -> MCEO3_W { MCEO3_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u32 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u32 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u32 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `TRG`" ] pub type TRG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TRG`" ] pub struct TRG_W < 'a > { w : & 'a mut W , } impl < 'a > TRG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CNT`" ] pub type CNT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CNT`" ] pub struct CNT_W < 'a > { w : & 'a mut W , } impl < 'a > CNT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `UFS`" ] pub type UFS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `UFS`" ] pub struct UFS_W < 'a > { w : & 'a mut W , } impl < 'a > UFS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `DFS`" ] pub type DFS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DFS`" ] pub struct DFS_W < 'a > { w : & 'a mut W , } impl < 'a > DFS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `FAULTA`" ] pub type FAULTA_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTA`" ] pub struct FAULTA_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTA_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `FAULTB`" ] pub type FAULTB_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTB`" ] pub struct FAULTB_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `FAULT0`" ] pub type FAULT0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT0`" ] pub struct FAULT0_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `FAULT1`" ] pub type FAULT1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT1`" ] pub struct FAULT1_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `MC2`" ] pub type MC2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC2`" ] pub struct MC2_W < 'a > { w : & 'a mut W , } impl < 'a > MC2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `MC3`" ] pub type MC3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC3`" ] pub struct MC3_W < 'a > { w : & 'a mut W , } impl < 'a > MC3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Retrigger Interrupt Enable" ] # [ inline ( always ) ] pub fn trg ( & self ) -> TRG_R { TRG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Counter Interrupt Enable" ] # [ inline ( always ) ] pub fn cnt ( & self ) -> CNT_R { CNT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Error Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Non-Recoverable Update Fault Interrupt Enable" ] # [ inline ( always ) ] pub fn ufs ( & self ) -> UFS_R { UFS_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable" ] # [ inline ( always ) ] pub fn dfs ( & self ) -> DFS_R { DFS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Recoverable Fault A Interrupt Enable" ] # [ inline ( always ) ] pub fn faulta ( & self ) -> FAULTA_R { FAULTA_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Recoverable Fault B Interrupt Enable" ] # [ inline ( always ) ] pub fn faultb ( & self ) -> FAULTB_R { FAULTB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn fault0 ( & self ) -> FAULT0_R { FAULT0_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn fault1 ( & self ) -> FAULT1_R { FAULT1_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc2 ( & self ) -> MC2_R { MC2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc3 ( & self ) -> MC3_R { MC3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } }
# [ doc = "Bit 1 - Retrigger Interrupt Enable" ] # [ inline ( always ) ] pub fn trg ( & mut self ) -> TRG_W { TRG_W { w : self } }
# [ doc = "Bit 2 - Counter Interrupt Enable" ] # [ inline ( always ) ] pub fn cnt ( & mut self ) -> CNT_W { CNT_W { w : self } }
# [ doc = "Bit 3 - Error Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } }
# [ doc = "Bit 10 - Non-Recoverable Update Fault Interrupt Enable" ] # [ inline ( always ) ] pub fn ufs ( & mut self ) -> UFS_W { UFS_W { w : self } }
# [ doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable" ] # [ inline ( always ) ] pub fn dfs ( & mut self ) -> DFS_W { DFS_W { w : self } }
# [ doc = "Bit 12 - Recoverable Fault A Interrupt Enable" ] # [ inline ( always ) ] pub fn faulta ( & mut self ) -> FAULTA_W { FAULTA_W { w : self } }
# [ doc = "Bit 13 - Recoverable Fault B Interrupt Enable" ] # [ inline ( always ) ] pub fn faultb ( & mut self ) -> FAULTB_W { FAULTB_W { w : self } }
# [ doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn fault0 ( & mut self ) -> FAULT0_W { FAULT0_W { w : self } }
# [ doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn fault1 ( & mut self ) -> FAULT1_W { FAULT1_W { w : self } }
# [ doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } }
# [ doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } }
# [ doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc2 ( & mut self ) -> MC2_W { MC2_W { w : self } }
# [ doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc3 ( & mut self ) -> MC3_W { MC3_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u32 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u32 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u32 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `TRG`" ] pub type TRG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TRG`" ] pub struct TRG_W < 'a > { w : & 'a mut W , } impl < 'a > TRG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CNT`" ] pub type CNT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CNT`" ] pub struct CNT_W < 'a > { w : & 'a mut W , } impl < 'a > CNT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `UFS`" ] pub type UFS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `UFS`" ] pub struct UFS_W < 'a > { w : & 'a mut W , } impl < 'a > UFS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `DFS`" ] pub type DFS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DFS`" ] pub struct DFS_W < 'a > { w : & 'a mut W , } impl < 'a > DFS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `FAULTA`" ] pub type FAULTA_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTA`" ] pub struct FAULTA_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTA_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `FAULTB`" ] pub type FAULTB_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTB`" ] pub struct FAULTB_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `FAULT0`" ] pub type FAULT0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT0`" ] pub struct FAULT0_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `FAULT1`" ] pub type FAULT1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT1`" ] pub struct FAULT1_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `MC2`" ] pub type MC2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC2`" ] pub struct MC2_W < 'a > { w : & 'a mut W , } impl < 'a > MC2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `MC3`" ] pub type MC3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC3`" ] pub struct MC3_W < 'a > { w : & 'a mut W , } impl < 'a > MC3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Retrigger Interrupt Enable" ] # [ inline ( always ) ] pub fn trg ( & self ) -> TRG_R { TRG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Counter Interrupt Enable" ] # [ inline ( always ) ] pub fn cnt ( & self ) -> CNT_R { CNT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Error Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Non-Recoverable Update Fault Interrupt Enable" ] # [ inline ( always ) ] pub fn ufs ( & self ) -> UFS_R { UFS_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable" ] # [ inline ( always ) ] pub fn dfs ( & self ) -> DFS_R { DFS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Recoverable Fault A Interrupt Enable" ] # [ inline ( always ) ] pub fn faulta ( & self ) -> FAULTA_R { FAULTA_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Recoverable Fault B Interrupt Enable" ] # [ inline ( always ) ] pub fn faultb ( & self ) -> FAULTB_R { FAULTB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn fault0 ( & self ) -> FAULT0_R { FAULT0_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn fault1 ( & self ) -> FAULT1_R { FAULT1_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc2 ( & self ) -> MC2_R { MC2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc3 ( & self ) -> MC3_R { MC3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } }
# [ doc = "Bit 1 - Retrigger Interrupt Enable" ] # [ inline ( always ) ] pub fn trg ( & mut self ) -> TRG_W { TRG_W { w : self } }
# [ doc = "Bit 2 - Counter Interrupt Enable" ] # [ inline ( always ) ] pub fn cnt ( & mut self ) -> CNT_W { CNT_W { w : self } }
# [ doc = "Bit 3 - Error Interrupt Enable" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } }
# [ doc = "Bit 10 - Non-Recoverable Update Fault Interrupt Enable" ] # [ inline ( always ) ] pub fn ufs ( & mut self ) -> UFS_W { UFS_W { w : self } }
# [ doc = "Bit 11 - Non-Recoverable Debug Fault Interrupt Enable" ] # [ inline ( always ) ] pub fn dfs ( & mut self ) -> DFS_W { DFS_W { w : self } }
# [ doc = "Bit 12 - Recoverable Fault A Interrupt Enable" ] # [ inline ( always ) ] pub fn faulta ( & mut self ) -> FAULTA_W { FAULTA_W { w : self } }
# [ doc = "Bit 13 - Recoverable Fault B Interrupt Enable" ] # [ inline ( always ) ] pub fn faultb ( & mut self ) -> FAULTB_W { FAULTB_W { w : self } }
# [ doc = "Bit 14 - Non-Recoverable Fault 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn fault0 ( & mut self ) -> FAULT0_W { FAULT0_W { w : self } }
# [ doc = "Bit 15 - Non-Recoverable Fault 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn fault1 ( & mut self ) -> FAULT1_W { FAULT1_W { w : self } }
# [ doc = "Bit 16 - Match or Capture Channel 0 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } }
# [ doc = "Bit 17 - Match or Capture Channel 1 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } }
# [ doc = "Bit 18 - Match or Capture Channel 2 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc2 ( & mut self ) -> MC2_W { MC2_W { w : self } }
# [ doc = "Bit 19 - Match or Capture Channel 3 Interrupt Enable" ] # [ inline ( always ) ] pub fn mc3 ( & mut self ) -> MC3_W { MC3_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u32 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u32 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u32 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `TRG`" ] pub type TRG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `TRG`" ] pub struct TRG_W < 'a > { w : & 'a mut W , } impl < 'a > TRG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `CNT`" ] pub type CNT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CNT`" ] pub struct CNT_W < 'a > { w : & 'a mut W , } impl < 'a > CNT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ERR`" ] pub type ERR_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ERR`" ] pub struct ERR_W < 'a > { w : & 'a mut W , } impl < 'a > ERR_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `UFS`" ] pub type UFS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `UFS`" ] pub struct UFS_W < 'a > { w : & 'a mut W , } impl < 'a > UFS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `DFS`" ] pub type DFS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DFS`" ] pub struct DFS_W < 'a > { w : & 'a mut W , } impl < 'a > DFS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `FAULTA`" ] pub type FAULTA_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTA`" ] pub struct FAULTA_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTA_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `FAULTB`" ] pub type FAULTB_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTB`" ] pub struct FAULTB_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `FAULT0`" ] pub type FAULT0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT0`" ] pub struct FAULT0_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `FAULT1`" ] pub type FAULT1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT1`" ] pub struct FAULT1_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `MC0`" ] pub type MC0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC0`" ] pub struct MC0_W < 'a > { w : & 'a mut W , } impl < 'a > MC0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `MC1`" ] pub type MC1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC1`" ] pub struct MC1_W < 'a > { w : & 'a mut W , } impl < 'a > MC1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `MC2`" ] pub type MC2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC2`" ] pub struct MC2_W < 'a > { w : & 'a mut W , } impl < 'a > MC2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `MC3`" ] pub type MC3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `MC3`" ] pub struct MC3_W < 'a > { w : & 'a mut W , } impl < 'a > MC3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Retrigger" ] # [ inline ( always ) ] pub fn trg ( & self ) -> TRG_R { TRG_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Counter" ] # [ inline ( always ) ] pub fn cnt ( & self ) -> CNT_R { CNT_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Error" ] # [ inline ( always ) ] pub fn err ( & self ) -> ERR_R { ERR_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Non-Recoverable Update Fault" ] # [ inline ( always ) ] pub fn ufs ( & self ) -> UFS_R { UFS_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Non-Recoverable Debug Fault" ] # [ inline ( always ) ] pub fn dfs ( & self ) -> DFS_R { DFS_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Recoverable Fault A" ] # [ inline ( always ) ] pub fn faulta ( & self ) -> FAULTA_R { FAULTA_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Recoverable Fault B" ] # [ inline ( always ) ] pub fn faultb ( & self ) -> FAULTB_R { FAULTB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Non-Recoverable Fault 0" ] # [ inline ( always ) ] pub fn fault0 ( & self ) -> FAULT0_R { FAULT0_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Non-Recoverable Fault 1" ] # [ inline ( always ) ] pub fn fault1 ( & self ) -> FAULT1_R { FAULT1_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Match or Capture 0" ] # [ inline ( always ) ] pub fn mc0 ( & self ) -> MC0_R { MC0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Match or Capture 1" ] # [ inline ( always ) ] pub fn mc1 ( & self ) -> MC1_R { MC1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Match or Capture 2" ] # [ inline ( always ) ] pub fn mc2 ( & self ) -> MC2_R { MC2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Match or Capture 3" ] # [ inline ( always ) ] pub fn mc3 ( & self ) -> MC3_R { MC3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } }
# [ doc = "Bit 1 - Retrigger" ] # [ inline ( always ) ] pub fn trg ( & mut self ) -> TRG_W { TRG_W { w : self } }
# [ doc = "Bit 2 - Counter" ] # [ inline ( always ) ] pub fn cnt ( & mut self ) -> CNT_W { CNT_W { w : self } }
# [ doc = "Bit 3 - Error" ] # [ inline ( always ) ] pub fn err ( & mut self ) -> ERR_W { ERR_W { w : self } }
# [ doc = "Bit 10 - Non-Recoverable Update Fault" ] # [ inline ( always ) ] pub fn ufs ( & mut self ) -> UFS_W { UFS_W { w : self } }
# [ doc = "Bit 11 - Non-Recoverable Debug Fault" ] # [ inline ( always ) ] pub fn dfs ( & mut self ) -> DFS_W { DFS_W { w : self } }
# [ doc = "Bit 12 - Recoverable Fault A" ] # [ inline ( always ) ] pub fn faulta ( & mut self ) -> FAULTA_W { FAULTA_W { w : self } }
# [ doc = "Bit 13 - Recoverable Fault B" ] # [ inline ( always ) ] pub fn faultb ( & mut self ) -> FAULTB_W { FAULTB_W { w : self } }
# [ doc = "Bit 14 - Non-Recoverable Fault 0" ] # [ inline ( always ) ] pub fn fault0 ( & mut self ) -> FAULT0_W { FAULT0_W { w : self } }
# [ doc = "Bit 15 - Non-Recoverable Fault 1" ] # [ inline ( always ) ] pub fn fault1 ( & mut self ) -> FAULT1_W { FAULT1_W { w : self } }
# [ doc = "Bit 16 - Match or Capture 0" ] # [ inline ( always ) ] pub fn mc0 ( & mut self ) -> MC0_W { MC0_W { w : self } }
# [ doc = "Bit 17 - Match or Capture 1" ] # [ inline ( always ) ] pub fn mc1 ( & mut self ) -> MC1_W { MC1_W { w : self } }
# [ doc = "Bit 18 - Match or Capture 2" ] # [ inline ( always ) ] pub fn mc2 ( & mut self ) -> MC2_W { MC2_W { w : self } }
# [ doc = "Bit 19 - Match or Capture 3" ] # [ inline ( always ) ] pub fn mc3 ( & mut self ) -> MC3_W { MC3_W { w : self } }
}
}
# [ doc = "Status\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u32 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ;
# [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { }
# [ doc = "`write(|w| ..)` method takes [status::W](status::W) writer structure" ] impl crate :: Writable for STATUS { }
# [ doc = "Status" ] pub mod status {
# [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u32 , super :: STATUS > ;
# [ doc = "Writer for register STATUS" ] pub type W = crate :: W < u32 , super :: STATUS > ;
# [ doc = "Register STATUS `reset()`'s with value 0x01" ] impl crate :: ResetValue for super :: STATUS { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x01 } }
# [ doc = "Reader of field `STOP`" ] pub type STOP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `STOP`" ] pub struct STOP_W < 'a > { w : & 'a mut W , } impl < 'a > STOP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `IDX`" ] pub type IDX_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `IDX`" ] pub struct IDX_W < 'a > { w : & 'a mut W , } impl < 'a > IDX_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `UFS`" ] pub type UFS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `UFS`" ] pub struct UFS_W < 'a > { w : & 'a mut W , } impl < 'a > UFS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `DFS`" ] pub type DFS_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DFS`" ] pub struct DFS_W < 'a > { w : & 'a mut W , } impl < 'a > DFS_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `SLAVE`" ] pub type SLAVE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SLAVE`" ] pub struct SLAVE_W < 'a > { w : & 'a mut W , } impl < 'a > SLAVE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `PATTBUFV`" ] pub type PATTBUFV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PATTBUFV`" ] pub struct PATTBUFV_W < 'a > { w : & 'a mut W , } impl < 'a > PATTBUFV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u32 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `PERBUFV`" ] pub type PERBUFV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PERBUFV`" ] pub struct PERBUFV_W < 'a > { w : & 'a mut W , } impl < 'a > PERBUFV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `FAULTAIN`" ] pub type FAULTAIN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTAIN`" ] pub struct FAULTAIN_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTAIN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `FAULTBIN`" ] pub type FAULTBIN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTBIN`" ] pub struct FAULTBIN_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTBIN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `FAULT0IN`" ] pub type FAULT0IN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT0IN`" ] pub struct FAULT0IN_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT0IN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `FAULT1IN`" ] pub type FAULT1IN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT1IN`" ] pub struct FAULT1IN_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT1IN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `FAULTA`" ] pub type FAULTA_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTA`" ] pub struct FAULTA_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTA_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u32 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `FAULTB`" ] pub type FAULTB_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULTB`" ] pub struct FAULTB_W < 'a > { w : & 'a mut W , } impl < 'a > FAULTB_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u32 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `FAULT0`" ] pub type FAULT0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT0`" ] pub struct FAULT0_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u32 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `FAULT1`" ] pub type FAULT1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FAULT1`" ] pub struct FAULT1_W < 'a > { w : & 'a mut W , } impl < 'a > FAULT1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `CCBUFV0`" ] pub type CCBUFV0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CCBUFV0`" ] pub struct CCBUFV0_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `CCBUFV1`" ] pub type CCBUFV1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CCBUFV1`" ] pub struct CCBUFV1_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `CCBUFV2`" ] pub type CCBUFV2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CCBUFV2`" ] pub struct CCBUFV2_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `CCBUFV3`" ] pub type CCBUFV3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CCBUFV3`" ] pub struct CCBUFV3_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUFV3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `CMP0`" ] pub type CMP0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CMP0`" ] pub struct CMP0_W < 'a > { w : & 'a mut W , } impl < 'a > CMP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `CMP1`" ] pub type CMP1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CMP1`" ] pub struct CMP1_W < 'a > { w : & 'a mut W , } impl < 'a > CMP1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `CMP2`" ] pub type CMP2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CMP2`" ] pub struct CMP2_W < 'a > { w : & 'a mut W , } impl < 'a > CMP2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `CMP3`" ] pub type CMP3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CMP3`" ] pub struct CMP3_W < 'a > { w : & 'a mut W , } impl < 'a > CMP3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Stop" ] # [ inline ( always ) ] pub fn stop ( & self ) -> STOP_R { STOP_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Ramp" ] # [ inline ( always ) ] pub fn idx ( & self ) -> IDX_R { IDX_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Non-recoverable Update Fault State" ] # [ inline ( always ) ] pub fn ufs ( & self ) -> UFS_R { UFS_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Non-Recoverable Debug Fault State" ] # [ inline ( always ) ] pub fn dfs ( & self ) -> DFS_R { DFS_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Slave" ] # [ inline ( always ) ] pub fn slave ( & self ) -> SLAVE_R { SLAVE_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Pattern Buffer Valid" ] # [ inline ( always ) ] pub fn pattbufv ( & self ) -> PATTBUFV_R { PATTBUFV_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Period Buffer Valid" ] # [ inline ( always ) ] pub fn perbufv ( & self ) -> PERBUFV_R { PERBUFV_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Recoverable Fault A Input" ] # [ inline ( always ) ] pub fn faultain ( & self ) -> FAULTAIN_R { FAULTAIN_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Recoverable Fault B Input" ] # [ inline ( always ) ] pub fn faultbin ( & self ) -> FAULTBIN_R { FAULTBIN_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Non-Recoverable Fault0 Input" ] # [ inline ( always ) ] pub fn fault0in ( & self ) -> FAULT0IN_R { FAULT0IN_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Non-Recoverable Fault1 Input" ] # [ inline ( always ) ] pub fn fault1in ( & self ) -> FAULT1IN_R { FAULT1IN_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Recoverable Fault A State" ] # [ inline ( always ) ] pub fn faulta ( & self ) -> FAULTA_R { FAULTA_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Recoverable Fault B State" ] # [ inline ( always ) ] pub fn faultb ( & self ) -> FAULTB_R { FAULTB_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Non-Recoverable Fault 0 State" ] # [ inline ( always ) ] pub fn fault0 ( & self ) -> FAULT0_R { FAULT0_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Non-Recoverable Fault 1 State" ] # [ inline ( always ) ] pub fn fault1 ( & self ) -> FAULT1_R { FAULT1_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Compare Channel 0 Buffer Valid" ] # [ inline ( always ) ] pub fn ccbufv0 ( & self ) -> CCBUFV0_R { CCBUFV0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Compare Channel 1 Buffer Valid" ] # [ inline ( always ) ] pub fn ccbufv1 ( & self ) -> CCBUFV1_R { CCBUFV1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Compare Channel 2 Buffer Valid" ] # [ inline ( always ) ] pub fn ccbufv2 ( & self ) -> CCBUFV2_R { CCBUFV2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Compare Channel 3 Buffer Valid" ] # [ inline ( always ) ] pub fn ccbufv3 ( & self ) -> CCBUFV3_R { CCBUFV3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Compare Channel 0 Value" ] # [ inline ( always ) ] pub fn cmp0 ( & self ) -> CMP0_R { CMP0_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Compare Channel 1 Value" ] # [ inline ( always ) ] pub fn cmp1 ( & self ) -> CMP1_R { CMP1_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Compare Channel 2 Value" ] # [ inline ( always ) ] pub fn cmp2 ( & self ) -> CMP2_R { CMP2_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Compare Channel 3 Value" ] # [ inline ( always ) ] pub fn cmp3 ( & self ) -> CMP3_R { CMP3_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Stop" ] # [ inline ( always ) ] pub fn stop ( & mut self ) -> STOP_W { STOP_W { w : self } }
# [ doc = "Bit 1 - Ramp" ] # [ inline ( always ) ] pub fn idx ( & mut self ) -> IDX_W { IDX_W { w : self } }
# [ doc = "Bit 2 - Non-recoverable Update Fault State" ] # [ inline ( always ) ] pub fn ufs ( & mut self ) -> UFS_W { UFS_W { w : self } }
# [ doc = "Bit 3 - Non-Recoverable Debug Fault State" ] # [ inline ( always ) ] pub fn dfs ( & mut self ) -> DFS_W { DFS_W { w : self } }
# [ doc = "Bit 4 - Slave" ] # [ inline ( always ) ] pub fn slave ( & mut self ) -> SLAVE_W { SLAVE_W { w : self } }
# [ doc = "Bit 5 - Pattern Buffer Valid" ] # [ inline ( always ) ] pub fn pattbufv ( & mut self ) -> PATTBUFV_W { PATTBUFV_W { w : self } }
# [ doc = "Bit 7 - Period Buffer Valid" ] # [ inline ( always ) ] pub fn perbufv ( & mut self ) -> PERBUFV_W { PERBUFV_W { w : self } }
# [ doc = "Bit 8 - Recoverable Fault A Input" ] # [ inline ( always ) ] pub fn faultain ( & mut self ) -> FAULTAIN_W { FAULTAIN_W { w : self } }
# [ doc = "Bit 9 - Recoverable Fault B Input" ] # [ inline ( always ) ] pub fn faultbin ( & mut self ) -> FAULTBIN_W { FAULTBIN_W { w : self } }
# [ doc = "Bit 10 - Non-Recoverable Fault0 Input" ] # [ inline ( always ) ] pub fn fault0in ( & mut self ) -> FAULT0IN_W { FAULT0IN_W { w : self } }
# [ doc = "Bit 11 - Non-Recoverable Fault1 Input" ] # [ inline ( always ) ] pub fn fault1in ( & mut self ) -> FAULT1IN_W { FAULT1IN_W { w : self } }
# [ doc = "Bit 12 - Recoverable Fault A State" ] # [ inline ( always ) ] pub fn faulta ( & mut self ) -> FAULTA_W { FAULTA_W { w : self } }
# [ doc = "Bit 13 - Recoverable Fault B State" ] # [ inline ( always ) ] pub fn faultb ( & mut self ) -> FAULTB_W { FAULTB_W { w : self } }
# [ doc = "Bit 14 - Non-Recoverable Fault 0 State" ] # [ inline ( always ) ] pub fn fault0 ( & mut self ) -> FAULT0_W { FAULT0_W { w : self } }
# [ doc = "Bit 15 - Non-Recoverable Fault 1 State" ] # [ inline ( always ) ] pub fn fault1 ( & mut self ) -> FAULT1_W { FAULT1_W { w : self } }
# [ doc = "Bit 16 - Compare Channel 0 Buffer Valid" ] # [ inline ( always ) ] pub fn ccbufv0 ( & mut self ) -> CCBUFV0_W { CCBUFV0_W { w : self } }
# [ doc = "Bit 17 - Compare Channel 1 Buffer Valid" ] # [ inline ( always ) ] pub fn ccbufv1 ( & mut self ) -> CCBUFV1_W { CCBUFV1_W { w : self } }
# [ doc = "Bit 18 - Compare Channel 2 Buffer Valid" ] # [ inline ( always ) ] pub fn ccbufv2 ( & mut self ) -> CCBUFV2_W { CCBUFV2_W { w : self } }
# [ doc = "Bit 19 - Compare Channel 3 Buffer Valid" ] # [ inline ( always ) ] pub fn ccbufv3 ( & mut self ) -> CCBUFV3_W { CCBUFV3_W { w : self } }
# [ doc = "Bit 24 - Compare Channel 0 Value" ] # [ inline ( always ) ] pub fn cmp0 ( & mut self ) -> CMP0_W { CMP0_W { w : self } }
# [ doc = "Bit 25 - Compare Channel 1 Value" ] # [ inline ( always ) ] pub fn cmp1 ( & mut self ) -> CMP1_W { CMP1_W { w : self } }
# [ doc = "Bit 26 - Compare Channel 2 Value" ] # [ inline ( always ) ] pub fn cmp2 ( & mut self ) -> CMP2_W { CMP2_W { w : self } }
# [ doc = "Bit 27 - Compare Channel 3 Value" ] # [ inline ( always ) ] pub fn cmp3 ( & mut self ) -> CMP3_W { CMP3_W { w : self } }
}
}
# [ doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [count](count) module" ] pub type COUNT = crate :: Reg < u32 , _COUNT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COUNT ;
# [ doc = "`read()` method returns [count::R](count::R) reader structure" ] impl crate :: Readable for COUNT { }
# [ doc = "`write(|w| ..)` method takes [count::W](count::W) writer structure" ] impl crate :: Writable for COUNT { }
# [ doc = "Count" ] pub mod count {
# [ doc = "Reader of register COUNT" ] pub type R = crate :: R < u32 , super :: COUNT > ;
# [ doc = "Writer for register COUNT" ] pub type W = crate :: W < u32 , super :: COUNT > ;
# [ doc = "Register COUNT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COUNT { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `COUNT`" ] pub struct COUNT_W < 'a > { w : & 'a mut W , } impl < 'a > COUNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & mut self ) -> COUNT_W { COUNT_W { w : self } }
}
}
# [ doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [count_dith4_mode](count_dith4_mode) module" ] pub type COUNT_DITH4_MODE = crate :: Reg < u32 , _COUNT_DITH4_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COUNT_DITH4_MODE ;
# [ doc = "`read()` method returns [count_dith4_mode::R](count_dith4_mode::R) reader structure" ] impl crate :: Readable for COUNT_DITH4_MODE { }
# [ doc = "`write(|w| ..)` method takes [count_dith4_mode::W](count_dith4_mode::W) writer structure" ] impl crate :: Writable for COUNT_DITH4_MODE { }
# [ doc = "Count" ] pub mod count_dith4_mode {
# [ doc = "Reader of register COUNT_DITH4_MODE" ] pub type R = crate :: R < u32 , super :: COUNT_DITH4_MODE > ;
# [ doc = "Writer for register COUNT_DITH4_MODE" ] pub type W = crate :: W < u32 , super :: COUNT_DITH4_MODE > ;
# [ doc = "Register COUNT_DITH4_MODE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COUNT_DITH4_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `COUNT`" ] pub struct COUNT_W < 'a > { w : & 'a mut W , } impl < 'a > COUNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x000f_ffff << 4 ) ) | ( ( ( value as u32 ) & 0x000f_ffff ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 4:23 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( ( self . bits >> 4 ) & 0x000f_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 4:23 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & mut self ) -> COUNT_W { COUNT_W { w : self } }
}
}
# [ doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [count_dith5_mode](count_dith5_mode) module" ] pub type COUNT_DITH5_MODE = crate :: Reg < u32 , _COUNT_DITH5_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COUNT_DITH5_MODE ;
# [ doc = "`read()` method returns [count_dith5_mode::R](count_dith5_mode::R) reader structure" ] impl crate :: Readable for COUNT_DITH5_MODE { }
# [ doc = "`write(|w| ..)` method takes [count_dith5_mode::W](count_dith5_mode::W) writer structure" ] impl crate :: Writable for COUNT_DITH5_MODE { }
# [ doc = "Count" ] pub mod count_dith5_mode {
# [ doc = "Reader of register COUNT_DITH5_MODE" ] pub type R = crate :: R < u32 , super :: COUNT_DITH5_MODE > ;
# [ doc = "Writer for register COUNT_DITH5_MODE" ] pub type W = crate :: W < u32 , super :: COUNT_DITH5_MODE > ;
# [ doc = "Register COUNT_DITH5_MODE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COUNT_DITH5_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `COUNT`" ] pub struct COUNT_W < 'a > { w : & 'a mut W , } impl < 'a > COUNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0007_ffff << 5 ) ) | ( ( ( value as u32 ) & 0x0007_ffff ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bits 5:23 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( ( self . bits >> 5 ) & 0x0007_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 5:23 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & mut self ) -> COUNT_W { COUNT_W { w : self } }
}
}
# [ doc = "Count\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [count_dith6_mode](count_dith6_mode) module" ] pub type COUNT_DITH6_MODE = crate :: Reg < u32 , _COUNT_DITH6_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _COUNT_DITH6_MODE ;
# [ doc = "`read()` method returns [count_dith6_mode::R](count_dith6_mode::R) reader structure" ] impl crate :: Readable for COUNT_DITH6_MODE { }
# [ doc = "`write(|w| ..)` method takes [count_dith6_mode::W](count_dith6_mode::W) writer structure" ] impl crate :: Writable for COUNT_DITH6_MODE { }
# [ doc = "Count" ] pub mod count_dith6_mode {
# [ doc = "Reader of register COUNT_DITH6_MODE" ] pub type R = crate :: R < u32 , super :: COUNT_DITH6_MODE > ;
# [ doc = "Writer for register COUNT_DITH6_MODE" ] pub type W = crate :: W < u32 , super :: COUNT_DITH6_MODE > ;
# [ doc = "Register COUNT_DITH6_MODE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: COUNT_DITH6_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `COUNT`" ] pub type COUNT_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `COUNT`" ] pub struct COUNT_W < 'a > { w : & 'a mut W , } impl < 'a > COUNT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0003_ffff << 6 ) ) | ( ( ( value as u32 ) & 0x0003_ffff ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bits 6:23 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & self ) -> COUNT_R { COUNT_R :: new ( ( ( self . bits >> 6 ) & 0x0003_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 6:23 - Counter Value" ] # [ inline ( always ) ] pub fn count ( & mut self ) -> COUNT_W { COUNT_W { w : self } }
}
}
# [ doc = "Pattern\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [patt](patt) module" ] pub type PATT = crate :: Reg < u16 , _PATT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PATT ;
# [ doc = "`read()` method returns [patt::R](patt::R) reader structure" ] impl crate :: Readable for PATT { }
# [ doc = "`write(|w| ..)` method takes [patt::W](patt::W) writer structure" ] impl crate :: Writable for PATT { }
# [ doc = "Pattern" ] pub mod patt {
# [ doc = "Reader of register PATT" ] pub type R = crate :: R < u16 , super :: PATT > ;
# [ doc = "Writer for register PATT" ] pub type W = crate :: W < u16 , super :: PATT > ;
# [ doc = "Register PATT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PATT { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `PGE0`" ] pub type PGE0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGE0`" ] pub struct PGE0_W < 'a > { w : & 'a mut W , } impl < 'a > PGE0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `PGE1`" ] pub type PGE1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGE1`" ] pub struct PGE1_W < 'a > { w : & 'a mut W , } impl < 'a > PGE1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `PGE2`" ] pub type PGE2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGE2`" ] pub struct PGE2_W < 'a > { w : & 'a mut W , } impl < 'a > PGE2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `PGE3`" ] pub type PGE3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGE3`" ] pub struct PGE3_W < 'a > { w : & 'a mut W , } impl < 'a > PGE3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `PGE4`" ] pub type PGE4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGE4`" ] pub struct PGE4_W < 'a > { w : & 'a mut W , } impl < 'a > PGE4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `PGE5`" ] pub type PGE5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGE5`" ] pub struct PGE5_W < 'a > { w : & 'a mut W , } impl < 'a > PGE5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `PGE6`" ] pub type PGE6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGE6`" ] pub struct PGE6_W < 'a > { w : & 'a mut W , } impl < 'a > PGE6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `PGE7`" ] pub type PGE7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGE7`" ] pub struct PGE7_W < 'a > { w : & 'a mut W , } impl < 'a > PGE7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `PGV0`" ] pub type PGV0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGV0`" ] pub struct PGV0_W < 'a > { w : & 'a mut W , } impl < 'a > PGV0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `PGV1`" ] pub type PGV1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGV1`" ] pub struct PGV1_W < 'a > { w : & 'a mut W , } impl < 'a > PGV1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `PGV2`" ] pub type PGV2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGV2`" ] pub struct PGV2_W < 'a > { w : & 'a mut W , } impl < 'a > PGV2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `PGV3`" ] pub type PGV3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGV3`" ] pub struct PGV3_W < 'a > { w : & 'a mut W , } impl < 'a > PGV3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `PGV4`" ] pub type PGV4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGV4`" ] pub struct PGV4_W < 'a > { w : & 'a mut W , } impl < 'a > PGV4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `PGV5`" ] pub type PGV5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGV5`" ] pub struct PGV5_W < 'a > { w : & 'a mut W , } impl < 'a > PGV5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `PGV6`" ] pub type PGV6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGV6`" ] pub struct PGV6_W < 'a > { w : & 'a mut W , } impl < 'a > PGV6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `PGV7`" ] pub type PGV7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGV7`" ] pub struct PGV7_W < 'a > { w : & 'a mut W , } impl < 'a > PGV7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Pattern Generator 0 Output Enable" ] # [ inline ( always ) ] pub fn pge0 ( & self ) -> PGE0_R { PGE0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Pattern Generator 1 Output Enable" ] # [ inline ( always ) ] pub fn pge1 ( & self ) -> PGE1_R { PGE1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Pattern Generator 2 Output Enable" ] # [ inline ( always ) ] pub fn pge2 ( & self ) -> PGE2_R { PGE2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Pattern Generator 3 Output Enable" ] # [ inline ( always ) ] pub fn pge3 ( & self ) -> PGE3_R { PGE3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Pattern Generator 4 Output Enable" ] # [ inline ( always ) ] pub fn pge4 ( & self ) -> PGE4_R { PGE4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Pattern Generator 5 Output Enable" ] # [ inline ( always ) ] pub fn pge5 ( & self ) -> PGE5_R { PGE5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Pattern Generator 6 Output Enable" ] # [ inline ( always ) ] pub fn pge6 ( & self ) -> PGE6_R { PGE6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Pattern Generator 7 Output Enable" ] # [ inline ( always ) ] pub fn pge7 ( & self ) -> PGE7_R { PGE7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Pattern Generator 0 Output Value" ] # [ inline ( always ) ] pub fn pgv0 ( & self ) -> PGV0_R { PGV0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Pattern Generator 1 Output Value" ] # [ inline ( always ) ] pub fn pgv1 ( & self ) -> PGV1_R { PGV1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Pattern Generator 2 Output Value" ] # [ inline ( always ) ] pub fn pgv2 ( & self ) -> PGV2_R { PGV2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Pattern Generator 3 Output Value" ] # [ inline ( always ) ] pub fn pgv3 ( & self ) -> PGV3_R { PGV3_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Pattern Generator 4 Output Value" ] # [ inline ( always ) ] pub fn pgv4 ( & self ) -> PGV4_R { PGV4_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Pattern Generator 5 Output Value" ] # [ inline ( always ) ] pub fn pgv5 ( & self ) -> PGV5_R { PGV5_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Pattern Generator 6 Output Value" ] # [ inline ( always ) ] pub fn pgv6 ( & self ) -> PGV6_R { PGV6_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Pattern Generator 7 Output Value" ] # [ inline ( always ) ] pub fn pgv7 ( & self ) -> PGV7_R { PGV7_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Pattern Generator 0 Output Enable" ] # [ inline ( always ) ] pub fn pge0 ( & mut self ) -> PGE0_W { PGE0_W { w : self } }
# [ doc = "Bit 1 - Pattern Generator 1 Output Enable" ] # [ inline ( always ) ] pub fn pge1 ( & mut self ) -> PGE1_W { PGE1_W { w : self } }
# [ doc = "Bit 2 - Pattern Generator 2 Output Enable" ] # [ inline ( always ) ] pub fn pge2 ( & mut self ) -> PGE2_W { PGE2_W { w : self } }
# [ doc = "Bit 3 - Pattern Generator 3 Output Enable" ] # [ inline ( always ) ] pub fn pge3 ( & mut self ) -> PGE3_W { PGE3_W { w : self } }
# [ doc = "Bit 4 - Pattern Generator 4 Output Enable" ] # [ inline ( always ) ] pub fn pge4 ( & mut self ) -> PGE4_W { PGE4_W { w : self } }
# [ doc = "Bit 5 - Pattern Generator 5 Output Enable" ] # [ inline ( always ) ] pub fn pge5 ( & mut self ) -> PGE5_W { PGE5_W { w : self } }
# [ doc = "Bit 6 - Pattern Generator 6 Output Enable" ] # [ inline ( always ) ] pub fn pge6 ( & mut self ) -> PGE6_W { PGE6_W { w : self } }
# [ doc = "Bit 7 - Pattern Generator 7 Output Enable" ] # [ inline ( always ) ] pub fn pge7 ( & mut self ) -> PGE7_W { PGE7_W { w : self } }
# [ doc = "Bit 8 - Pattern Generator 0 Output Value" ] # [ inline ( always ) ] pub fn pgv0 ( & mut self ) -> PGV0_W { PGV0_W { w : self } }
# [ doc = "Bit 9 - Pattern Generator 1 Output Value" ] # [ inline ( always ) ] pub fn pgv1 ( & mut self ) -> PGV1_W { PGV1_W { w : self } }
# [ doc = "Bit 10 - Pattern Generator 2 Output Value" ] # [ inline ( always ) ] pub fn pgv2 ( & mut self ) -> PGV2_W { PGV2_W { w : self } }
# [ doc = "Bit 11 - Pattern Generator 3 Output Value" ] # [ inline ( always ) ] pub fn pgv3 ( & mut self ) -> PGV3_W { PGV3_W { w : self } }
# [ doc = "Bit 12 - Pattern Generator 4 Output Value" ] # [ inline ( always ) ] pub fn pgv4 ( & mut self ) -> PGV4_W { PGV4_W { w : self } }
# [ doc = "Bit 13 - Pattern Generator 5 Output Value" ] # [ inline ( always ) ] pub fn pgv5 ( & mut self ) -> PGV5_W { PGV5_W { w : self } }
# [ doc = "Bit 14 - Pattern Generator 6 Output Value" ] # [ inline ( always ) ] pub fn pgv6 ( & mut self ) -> PGV6_W { PGV6_W { w : self } }
# [ doc = "Bit 15 - Pattern Generator 7 Output Value" ] # [ inline ( always ) ] pub fn pgv7 ( & mut self ) -> PGV7_W { PGV7_W { w : self } }
}
}
# [ doc = "Waveform Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [wave](wave) module" ] pub type WAVE = crate :: Reg < u32 , _WAVE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WAVE ;
# [ doc = "`read()` method returns [wave::R](wave::R) reader structure" ] impl crate :: Readable for WAVE { }
# [ doc = "`write(|w| ..)` method takes [wave::W](wave::W) writer structure" ] impl crate :: Writable for WAVE { }
# [ doc = "Waveform Control" ] pub mod wave {
# [ doc = "Reader of register WAVE" ] pub type R = crate :: R < u32 , super :: WAVE > ;
# [ doc = "Writer for register WAVE" ] pub type W = crate :: W < u32 , super :: WAVE > ;
# [ doc = "Register WAVE `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WAVE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `WAVEGEN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WAVEGEN_A { # [ doc = "Normal frequency" ] NFRQ , # [ doc = "Match frequency" ] MFRQ , # [ doc = "Normal PWM" ] NPWM , # [ doc = "Dual-slope critical" ] DSCRITICAL , # [ doc = "Dual-slope with interrupt/event condition when COUNT reaches ZERO" ] DSBOTTOM , # [ doc = "Dual-slope with interrupt/event condition when COUNT reaches ZERO or TOP" ] DSBOTH , # [ doc = "Dual-slope with interrupt/event condition when COUNT reaches TOP" ] DSTOP }
impl crate :: ToBits < u8 > for WAVEGEN_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WAVEGEN_A :: NFRQ => 0 , WAVEGEN_A :: MFRQ => 1 , WAVEGEN_A :: NPWM => 2 , WAVEGEN_A :: DSCRITICAL => 4 , WAVEGEN_A :: DSBOTTOM => 5 , WAVEGEN_A :: DSBOTH => 6 , WAVEGEN_A :: DSTOP => 7 } } }
# [ doc = "Reader of field `WAVEGEN`" ] pub type WAVEGEN_R = crate :: R < u8 , WAVEGEN_A > ; impl WAVEGEN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , WAVEGEN_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( WAVEGEN_A :: NFRQ ) , 1 => Val ( WAVEGEN_A :: MFRQ ) , 2 => Val ( WAVEGEN_A :: NPWM ) , 4 => Val ( WAVEGEN_A :: DSCRITICAL ) , 5 => Val ( WAVEGEN_A :: DSBOTTOM ) , 6 => Val ( WAVEGEN_A :: DSBOTH ) , 7 => Val ( WAVEGEN_A :: DSTOP ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `NFRQ`" ] # [ inline ( always ) ] pub fn is_nfrq ( & self ) -> bool { * self == WAVEGEN_A :: NFRQ } # [ doc = "Checks if the value of the field is `MFRQ`" ] # [ inline ( always ) ] pub fn is_mfrq ( & self ) -> bool { * self == WAVEGEN_A :: MFRQ } # [ doc = "Checks if the value of the field is `NPWM`" ] # [ inline ( always ) ] pub fn is_npwm ( & self ) -> bool { * self == WAVEGEN_A :: NPWM } # [ doc = "Checks if the value of the field is `DSCRITICAL`" ] # [ inline ( always ) ] pub fn is_dscritical ( & self ) -> bool { * self == WAVEGEN_A :: DSCRITICAL } # [ doc = "Checks if the value of the field is `DSBOTTOM`" ] # [ inline ( always ) ] pub fn is_dsbottom ( & self ) -> bool { * self == WAVEGEN_A :: DSBOTTOM } # [ doc = "Checks if the value of the field is `DSBOTH`" ] # [ inline ( always ) ] pub fn is_dsboth ( & self ) -> bool { * self == WAVEGEN_A :: DSBOTH } # [ doc = "Checks if the value of the field is `DSTOP`" ] # [ inline ( always ) ] pub fn is_dstop ( & self ) -> bool { * self == WAVEGEN_A :: DSTOP } }
# [ doc = "Write proxy for field `WAVEGEN`" ] pub struct WAVEGEN_W < 'a > { w : & 'a mut W , } impl < 'a > WAVEGEN_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WAVEGEN_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Normal frequency" ] # [ inline ( always ) ] pub fn nfrq ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: NFRQ ) } # [ doc = "Match frequency" ] # [ inline ( always ) ] pub fn mfrq ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: MFRQ ) } # [ doc = "Normal PWM" ] # [ inline ( always ) ] pub fn npwm ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: NPWM ) } # [ doc = "Dual-slope critical" ] # [ inline ( always ) ] pub fn dscritical ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: DSCRITICAL ) } # [ doc = "Dual-slope with interrupt/event condition when COUNT reaches ZERO" ] # [ inline ( always ) ] pub fn dsbottom ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: DSBOTTOM ) } # [ doc = "Dual-slope with interrupt/event condition when COUNT reaches ZERO or TOP" ] # [ inline ( always ) ] pub fn dsboth ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: DSBOTH ) } # [ doc = "Dual-slope with interrupt/event condition when COUNT reaches TOP" ] # [ inline ( always ) ] pub fn dstop ( self ) -> & 'a mut W { self . variant ( WAVEGEN_A :: DSTOP ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u32 ) & 0x07 ) ; self . w } }
# [ doc = "Possible values of the field `RAMP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum RAMP_A { # [ doc = "RAMP1 operation" ] RAMP1 , # [ doc = "Alternative RAMP2 operation" ] RAMP2A , # [ doc = "RAMP2 operation" ] RAMP2 , # [ doc = "Critical RAMP2 operation" ] RAMP2C }
impl crate :: ToBits < u8 > for RAMP_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { RAMP_A :: RAMP1 => 0 , RAMP_A :: RAMP2A => 1 , RAMP_A :: RAMP2 => 2 , RAMP_A :: RAMP2C => 3 } } }
# [ doc = "Reader of field `RAMP`" ] pub type RAMP_R = crate :: R < u8 , RAMP_A > ; impl RAMP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> RAMP_A { match self . bits { 0 => RAMP_A :: RAMP1 , 1 => RAMP_A :: RAMP2A , 2 => RAMP_A :: RAMP2 , 3 => RAMP_A :: RAMP2C , _ => unreachable ! ( ) } } # [ doc = "Checks if the value of the field is `RAMP1`" ] # [ inline ( always ) ] pub fn is_ramp1 ( & self ) -> bool { * self == RAMP_A :: RAMP1 } # [ doc = "Checks if the value of the field is `RAMP2A`" ] # [ inline ( always ) ] pub fn is_ramp2a ( & self ) -> bool { * self == RAMP_A :: RAMP2A } # [ doc = "Checks if the value of the field is `RAMP2`" ] # [ inline ( always ) ] pub fn is_ramp2 ( & self ) -> bool { * self == RAMP_A :: RAMP2 } # [ doc = "Checks if the value of the field is `RAMP2C`" ] # [ inline ( always ) ] pub fn is_ramp2c ( & self ) -> bool { * self == RAMP_A :: RAMP2C } }
# [ doc = "Write proxy for field `RAMP`" ] pub struct RAMP_W < 'a > { w : & 'a mut W , } impl < 'a > RAMP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : RAMP_A ) -> & 'a mut W { use crate :: ToBits ; { self . bits ( variant . _bits ( ) ) } } # [ doc = "RAMP1 operation" ] # [ inline ( always ) ] pub fn ramp1 ( self ) -> & 'a mut W { self . variant ( RAMP_A :: RAMP1 ) } # [ doc = "Alternative RAMP2 operation" ] # [ inline ( always ) ] pub fn ramp2a ( self ) -> & 'a mut W { self . variant ( RAMP_A :: RAMP2A ) } # [ doc = "RAMP2 operation" ] # [ inline ( always ) ] pub fn ramp2 ( self ) -> & 'a mut W { self . variant ( RAMP_A :: RAMP2 ) } # [ doc = "Critical RAMP2 operation" ] # [ inline ( always ) ] pub fn ramp2c ( self ) -> & 'a mut W { self . variant ( RAMP_A :: RAMP2C ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x03 << 4 ) ) | ( ( ( value as u32 ) & 0x03 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `CIPEREN`" ] pub type CIPEREN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CIPEREN`" ] pub struct CIPEREN_W < 'a > { w : & 'a mut W , } impl < 'a > CIPEREN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u32 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `CICCEN0`" ] pub type CICCEN0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CICCEN0`" ] pub struct CICCEN0_W < 'a > { w : & 'a mut W , } impl < 'a > CICCEN0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u32 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `CICCEN1`" ] pub type CICCEN1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CICCEN1`" ] pub struct CICCEN1_W < 'a > { w : & 'a mut W , } impl < 'a > CICCEN1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u32 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `CICCEN2`" ] pub type CICCEN2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CICCEN2`" ] pub struct CICCEN2_W < 'a > { w : & 'a mut W , } impl < 'a > CICCEN2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u32 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `CICCEN3`" ] pub type CICCEN3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `CICCEN3`" ] pub struct CICCEN3_W < 'a > { w : & 'a mut W , } impl < 'a > CICCEN3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u32 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `POL0`" ] pub type POL0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `POL0`" ] pub struct POL0_W < 'a > { w : & 'a mut W , } impl < 'a > POL0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
# [ doc = "Reader of field `POL1`" ] pub type POL1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `POL1`" ] pub struct POL1_W < 'a > { w : & 'a mut W , } impl < 'a > POL1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 17 ) ) | ( ( ( value as u32 ) & 0x01 ) << 17 ) ; self . w } }
# [ doc = "Reader of field `POL2`" ] pub type POL2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `POL2`" ] pub struct POL2_W < 'a > { w : & 'a mut W , } impl < 'a > POL2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 18 ) ) | ( ( ( value as u32 ) & 0x01 ) << 18 ) ; self . w } }
# [ doc = "Reader of field `POL3`" ] pub type POL3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `POL3`" ] pub struct POL3_W < 'a > { w : & 'a mut W , } impl < 'a > POL3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 19 ) ) | ( ( ( value as u32 ) & 0x01 ) << 19 ) ; self . w } }
# [ doc = "Reader of field `SWAP0`" ] pub type SWAP0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWAP0`" ] pub struct SWAP0_W < 'a > { w : & 'a mut W , } impl < 'a > SWAP0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 24 ) ) | ( ( ( value as u32 ) & 0x01 ) << 24 ) ; self . w } }
# [ doc = "Reader of field `SWAP1`" ] pub type SWAP1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWAP1`" ] pub struct SWAP1_W < 'a > { w : & 'a mut W , } impl < 'a > SWAP1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Reader of field `SWAP2`" ] pub type SWAP2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWAP2`" ] pub struct SWAP2_W < 'a > { w : & 'a mut W , } impl < 'a > SWAP2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Reader of field `SWAP3`" ] pub type SWAP3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWAP3`" ] pub struct SWAP3_W < 'a > { w : & 'a mut W , } impl < 'a > SWAP3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Waveform Generation" ] # [ inline ( always ) ] pub fn wavegen ( & self ) -> WAVEGEN_R { WAVEGEN_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bits 4:5 - Ramp Mode" ] # [ inline ( always ) ] pub fn ramp ( & self ) -> RAMP_R { RAMP_R :: new ( ( ( self . bits >> 4 ) & 0x03 ) as u8 ) }
# [ doc = "Bit 7 - Circular period Enable" ] # [ inline ( always ) ] pub fn ciperen ( & self ) -> CIPEREN_R { CIPEREN_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Circular Channel 0 Enable" ] # [ inline ( always ) ] pub fn ciccen0 ( & self ) -> CICCEN0_R { CICCEN0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Circular Channel 1 Enable" ] # [ inline ( always ) ] pub fn ciccen1 ( & self ) -> CICCEN1_R { CICCEN1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Circular Channel 2 Enable" ] # [ inline ( always ) ] pub fn ciccen2 ( & self ) -> CICCEN2_R { CICCEN2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Circular Channel 3 Enable" ] # [ inline ( always ) ] pub fn ciccen3 ( & self ) -> CICCEN3_R { CICCEN3_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Channel 0 Polarity" ] # [ inline ( always ) ] pub fn pol0 ( & self ) -> POL0_R { POL0_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 17 - Channel 1 Polarity" ] # [ inline ( always ) ] pub fn pol1 ( & self ) -> POL1_R { POL1_R :: new ( ( ( self . bits >> 17 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 18 - Channel 2 Polarity" ] # [ inline ( always ) ] pub fn pol2 ( & self ) -> POL2_R { POL2_R :: new ( ( ( self . bits >> 18 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 19 - Channel 3 Polarity" ] # [ inline ( always ) ] pub fn pol3 ( & self ) -> POL3_R { POL3_R :: new ( ( ( self . bits >> 19 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 24 - Swap DTI Output Pair 0" ] # [ inline ( always ) ] pub fn swap0 ( & self ) -> SWAP0_R { SWAP0_R :: new ( ( ( self . bits >> 24 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - Swap DTI Output Pair 1" ] # [ inline ( always ) ] pub fn swap1 ( & self ) -> SWAP1_R { SWAP1_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - Swap DTI Output Pair 2" ] # [ inline ( always ) ] pub fn swap2 ( & self ) -> SWAP2_R { SWAP2_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - Swap DTI Output Pair 3" ] # [ inline ( always ) ] pub fn swap3 ( & self ) -> SWAP3_R { SWAP3_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:2 - Waveform Generation" ] # [ inline ( always ) ] pub fn wavegen ( & mut self ) -> WAVEGEN_W { WAVEGEN_W { w : self } }
# [ doc = "Bits 4:5 - Ramp Mode" ] # [ inline ( always ) ] pub fn ramp ( & mut self ) -> RAMP_W { RAMP_W { w : self } }
# [ doc = "Bit 7 - Circular period Enable" ] # [ inline ( always ) ] pub fn ciperen ( & mut self ) -> CIPEREN_W { CIPEREN_W { w : self } }
# [ doc = "Bit 8 - Circular Channel 0 Enable" ] # [ inline ( always ) ] pub fn ciccen0 ( & mut self ) -> CICCEN0_W { CICCEN0_W { w : self } }
# [ doc = "Bit 9 - Circular Channel 1 Enable" ] # [ inline ( always ) ] pub fn ciccen1 ( & mut self ) -> CICCEN1_W { CICCEN1_W { w : self } }
# [ doc = "Bit 10 - Circular Channel 2 Enable" ] # [ inline ( always ) ] pub fn ciccen2 ( & mut self ) -> CICCEN2_W { CICCEN2_W { w : self } }
# [ doc = "Bit 11 - Circular Channel 3 Enable" ] # [ inline ( always ) ] pub fn ciccen3 ( & mut self ) -> CICCEN3_W { CICCEN3_W { w : self } }
# [ doc = "Bit 16 - Channel 0 Polarity" ] # [ inline ( always ) ] pub fn pol0 ( & mut self ) -> POL0_W { POL0_W { w : self } }
# [ doc = "Bit 17 - Channel 1 Polarity" ] # [ inline ( always ) ] pub fn pol1 ( & mut self ) -> POL1_W { POL1_W { w : self } }
# [ doc = "Bit 18 - Channel 2 Polarity" ] # [ inline ( always ) ] pub fn pol2 ( & mut self ) -> POL2_W { POL2_W { w : self } }
# [ doc = "Bit 19 - Channel 3 Polarity" ] # [ inline ( always ) ] pub fn pol3 ( & mut self ) -> POL3_W { POL3_W { w : self } }
# [ doc = "Bit 24 - Swap DTI Output Pair 0" ] # [ inline ( always ) ] pub fn swap0 ( & mut self ) -> SWAP0_W { SWAP0_W { w : self } }
# [ doc = "Bit 25 - Swap DTI Output Pair 1" ] # [ inline ( always ) ] pub fn swap1 ( & mut self ) -> SWAP1_W { SWAP1_W { w : self } }
# [ doc = "Bit 26 - Swap DTI Output Pair 2" ] # [ inline ( always ) ] pub fn swap2 ( & mut self ) -> SWAP2_W { SWAP2_W { w : self } }
# [ doc = "Bit 27 - Swap DTI Output Pair 3" ] # [ inline ( always ) ] pub fn swap3 ( & mut self ) -> SWAP3_W { SWAP3_W { w : self } }
}
}
# [ doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [per](per) module" ] pub type PER = crate :: Reg < u32 , _PER > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PER ;
# [ doc = "`read()` method returns [per::R](per::R) reader structure" ] impl crate :: Readable for PER { }
# [ doc = "`write(|w| ..)` method takes [per::W](per::W) writer structure" ] impl crate :: Writable for PER { }
# [ doc = "Period" ] pub mod per {
# [ doc = "Reader of register PER" ] pub type R = crate :: R < u32 , super :: PER > ;
# [ doc = "Writer for register PER" ] pub type W = crate :: W < u32 , super :: PER > ;
# [ doc = "Register PER `reset()`'s with value 0xffff_ffff" ] impl crate :: ResetValue for super :: PER { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff_ffff } }
# [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `PER`" ] pub struct PER_W < 'a > { w : & 'a mut W , } impl < 'a > PER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Period Value" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Period Value" ] # [ inline ( always ) ] pub fn per ( & mut self ) -> PER_W { PER_W { w : self } }
}
}
# [ doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [per_dith4_mode](per_dith4_mode) module" ] pub type PER_DITH4_MODE = crate :: Reg < u32 , _PER_DITH4_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PER_DITH4_MODE ;
# [ doc = "`read()` method returns [per_dith4_mode::R](per_dith4_mode::R) reader structure" ] impl crate :: Readable for PER_DITH4_MODE { }
# [ doc = "`write(|w| ..)` method takes [per_dith4_mode::W](per_dith4_mode::W) writer structure" ] impl crate :: Writable for PER_DITH4_MODE { }
# [ doc = "Period" ] pub mod per_dith4_mode {
# [ doc = "Reader of register PER_DITH4_MODE" ] pub type R = crate :: R < u32 , super :: PER_DITH4_MODE > ;
# [ doc = "Writer for register PER_DITH4_MODE" ] pub type W = crate :: W < u32 , super :: PER_DITH4_MODE > ;
# [ doc = "Register PER_DITH4_MODE `reset()`'s with value 0xffff_ffff" ] impl crate :: ResetValue for super :: PER_DITH4_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff_ffff } }
# [ doc = "Reader of field `DITHER`" ] pub type DITHER_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHER`" ] pub struct DITHER_W < 'a > { w : & 'a mut W , } impl < 'a > DITHER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u32 ) & 0x0f ) ; self . w } }
# [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `PER`" ] pub struct PER_W < 'a > { w : & 'a mut W , } impl < 'a > PER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x000f_ffff << 4 ) ) | ( ( ( value as u32 ) & 0x000f_ffff ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & self ) -> DITHER_R { DITHER_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:23 - Period Value" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( ( self . bits >> 4 ) & 0x000f_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:3 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & mut self ) -> DITHER_W { DITHER_W { w : self } }
# [ doc = "Bits 4:23 - Period Value" ] # [ inline ( always ) ] pub fn per ( & mut self ) -> PER_W { PER_W { w : self } }
}
}
# [ doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [per_dith5_mode](per_dith5_mode) module" ] pub type PER_DITH5_MODE = crate :: Reg < u32 , _PER_DITH5_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PER_DITH5_MODE ;
# [ doc = "`read()` method returns [per_dith5_mode::R](per_dith5_mode::R) reader structure" ] impl crate :: Readable for PER_DITH5_MODE { }
# [ doc = "`write(|w| ..)` method takes [per_dith5_mode::W](per_dith5_mode::W) writer structure" ] impl crate :: Writable for PER_DITH5_MODE { }
# [ doc = "Period" ] pub mod per_dith5_mode {
# [ doc = "Reader of register PER_DITH5_MODE" ] pub type R = crate :: R < u32 , super :: PER_DITH5_MODE > ;
# [ doc = "Writer for register PER_DITH5_MODE" ] pub type W = crate :: W < u32 , super :: PER_DITH5_MODE > ;
# [ doc = "Register PER_DITH5_MODE `reset()`'s with value 0xffff_ffff" ] impl crate :: ResetValue for super :: PER_DITH5_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff_ffff } }
# [ doc = "Reader of field `DITHER`" ] pub type DITHER_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHER`" ] pub struct DITHER_W < 'a > { w : & 'a mut W , } impl < 'a > DITHER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u32 ) & 0x1f ) ; self . w } }
# [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `PER`" ] pub struct PER_W < 'a > { w : & 'a mut W , } impl < 'a > PER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0007_ffff << 5 ) ) | ( ( ( value as u32 ) & 0x0007_ffff ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bits 0:4 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & self ) -> DITHER_R { DITHER_R :: new ( ( self . bits & 0x1f ) as u8 ) }
# [ doc = "Bits 5:23 - Period Value" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( ( self . bits >> 5 ) & 0x0007_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:4 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & mut self ) -> DITHER_W { DITHER_W { w : self } }
# [ doc = "Bits 5:23 - Period Value" ] # [ inline ( always ) ] pub fn per ( & mut self ) -> PER_W { PER_W { w : self } }
}
}
# [ doc = "Period\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [per_dith6_mode](per_dith6_mode) module" ] pub type PER_DITH6_MODE = crate :: Reg < u32 , _PER_DITH6_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PER_DITH6_MODE ;
# [ doc = "`read()` method returns [per_dith6_mode::R](per_dith6_mode::R) reader structure" ] impl crate :: Readable for PER_DITH6_MODE { }
# [ doc = "`write(|w| ..)` method takes [per_dith6_mode::W](per_dith6_mode::W) writer structure" ] impl crate :: Writable for PER_DITH6_MODE { }
# [ doc = "Period" ] pub mod per_dith6_mode {
# [ doc = "Reader of register PER_DITH6_MODE" ] pub type R = crate :: R < u32 , super :: PER_DITH6_MODE > ;
# [ doc = "Writer for register PER_DITH6_MODE" ] pub type W = crate :: W < u32 , super :: PER_DITH6_MODE > ;
# [ doc = "Register PER_DITH6_MODE `reset()`'s with value 0xffff_ffff" ] impl crate :: ResetValue for super :: PER_DITH6_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff_ffff } }
# [ doc = "Reader of field `DITHER`" ] pub type DITHER_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHER`" ] pub struct DITHER_W < 'a > { w : & 'a mut W , } impl < 'a > DITHER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } }
# [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `PER`" ] pub struct PER_W < 'a > { w : & 'a mut W , } impl < 'a > PER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0003_ffff << 6 ) ) | ( ( ( value as u32 ) & 0x0003_ffff ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & self ) -> DITHER_R { DITHER_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 6:23 - Period Value" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( ( self . bits >> 6 ) & 0x0003_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:5 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & mut self ) -> DITHER_W { DITHER_W { w : self } }
# [ doc = "Bits 6:23 - Period Value" ] # [ inline ( always ) ] pub fn per ( & mut self ) -> PER_W { PER_W { w : self } }
}
}
# [ doc = "Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cc](cc) module" ] pub type CC = crate :: Reg < u32 , _CC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CC ;
# [ doc = "`read()` method returns [cc::R](cc::R) reader structure" ] impl crate :: Readable for CC { }
# [ doc = "`write(|w| ..)` method takes [cc::W](cc::W) writer structure" ] impl crate :: Writable for CC { }
# [ doc = "Compare and Capture" ] pub mod cc {
# [ doc = "Reader of register CC[%s]" ] pub type R = crate :: R < u32 , super :: CC > ;
# [ doc = "Writer for register CC[%s]" ] pub type W = crate :: W < u32 , super :: CC > ;
# [ doc = "Register CC[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CC { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CC`" ] pub type CC_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CC`" ] pub struct CC_W < 'a > { w : & 'a mut W , } impl < 'a > CC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Channel Compare/Capture Value" ] # [ inline ( always ) ] pub fn cc ( & self ) -> CC_R { CC_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Channel Compare/Capture Value" ] # [ inline ( always ) ] pub fn cc ( & mut self ) -> CC_W { CC_W { w : self } }
}
}
# [ doc = "Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cc_dith4_mode](cc_dith4_mode) module" ] pub type CC_DITH4_MODE = crate :: Reg < u32 , _CC_DITH4_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CC_DITH4_MODE ;
# [ doc = "`read()` method returns [cc_dith4_mode::R](cc_dith4_mode::R) reader structure" ] impl crate :: Readable for CC_DITH4_MODE { }
# [ doc = "`write(|w| ..)` method takes [cc_dith4_mode::W](cc_dith4_mode::W) writer structure" ] impl crate :: Writable for CC_DITH4_MODE { }
# [ doc = "Compare and Capture" ] pub mod cc_dith4_mode {
# [ doc = "Reader of register CC_DITH4_MODE[%s]" ] pub type R = crate :: R < u32 , super :: CC_DITH4_MODE > ;
# [ doc = "Writer for register CC_DITH4_MODE[%s]" ] pub type W = crate :: W < u32 , super :: CC_DITH4_MODE > ;
# [ doc = "Register CC_DITH4_MODE[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CC_DITH4_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DITHER`" ] pub type DITHER_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHER`" ] pub struct DITHER_W < 'a > { w : & 'a mut W , } impl < 'a > DITHER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u32 ) & 0x0f ) ; self . w } }
# [ doc = "Reader of field `CC`" ] pub type CC_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CC`" ] pub struct CC_W < 'a > { w : & 'a mut W , } impl < 'a > CC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x000f_ffff << 4 ) ) | ( ( ( value as u32 ) & 0x000f_ffff ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & self ) -> DITHER_R { DITHER_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:23 - Channel Compare/Capture Value" ] # [ inline ( always ) ] pub fn cc ( & self ) -> CC_R { CC_R :: new ( ( ( self . bits >> 4 ) & 0x000f_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:3 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & mut self ) -> DITHER_W { DITHER_W { w : self } }
# [ doc = "Bits 4:23 - Channel Compare/Capture Value" ] # [ inline ( always ) ] pub fn cc ( & mut self ) -> CC_W { CC_W { w : self } }
}
}
# [ doc = "Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cc_dith5_mode](cc_dith5_mode) module" ] pub type CC_DITH5_MODE = crate :: Reg < u32 , _CC_DITH5_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CC_DITH5_MODE ;
# [ doc = "`read()` method returns [cc_dith5_mode::R](cc_dith5_mode::R) reader structure" ] impl crate :: Readable for CC_DITH5_MODE { }
# [ doc = "`write(|w| ..)` method takes [cc_dith5_mode::W](cc_dith5_mode::W) writer structure" ] impl crate :: Writable for CC_DITH5_MODE { }
# [ doc = "Compare and Capture" ] pub mod cc_dith5_mode {
# [ doc = "Reader of register CC_DITH5_MODE[%s]" ] pub type R = crate :: R < u32 , super :: CC_DITH5_MODE > ;
# [ doc = "Writer for register CC_DITH5_MODE[%s]" ] pub type W = crate :: W < u32 , super :: CC_DITH5_MODE > ;
# [ doc = "Register CC_DITH5_MODE[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CC_DITH5_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DITHER`" ] pub type DITHER_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHER`" ] pub struct DITHER_W < 'a > { w : & 'a mut W , } impl < 'a > DITHER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u32 ) & 0x1f ) ; self . w } }
# [ doc = "Reader of field `CC`" ] pub type CC_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CC`" ] pub struct CC_W < 'a > { w : & 'a mut W , } impl < 'a > CC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0007_ffff << 5 ) ) | ( ( ( value as u32 ) & 0x0007_ffff ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bits 0:4 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & self ) -> DITHER_R { DITHER_R :: new ( ( self . bits & 0x1f ) as u8 ) }
# [ doc = "Bits 5:23 - Channel Compare/Capture Value" ] # [ inline ( always ) ] pub fn cc ( & self ) -> CC_R { CC_R :: new ( ( ( self . bits >> 5 ) & 0x0007_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:4 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & mut self ) -> DITHER_W { DITHER_W { w : self } }
# [ doc = "Bits 5:23 - Channel Compare/Capture Value" ] # [ inline ( always ) ] pub fn cc ( & mut self ) -> CC_W { CC_W { w : self } }
}
}
# [ doc = "Compare and Capture\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cc_dith6_mode](cc_dith6_mode) module" ] pub type CC_DITH6_MODE = crate :: Reg < u32 , _CC_DITH6_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CC_DITH6_MODE ;
# [ doc = "`read()` method returns [cc_dith6_mode::R](cc_dith6_mode::R) reader structure" ] impl crate :: Readable for CC_DITH6_MODE { }
# [ doc = "`write(|w| ..)` method takes [cc_dith6_mode::W](cc_dith6_mode::W) writer structure" ] impl crate :: Writable for CC_DITH6_MODE { }
# [ doc = "Compare and Capture" ] pub mod cc_dith6_mode {
# [ doc = "Reader of register CC_DITH6_MODE[%s]" ] pub type R = crate :: R < u32 , super :: CC_DITH6_MODE > ;
# [ doc = "Writer for register CC_DITH6_MODE[%s]" ] pub type W = crate :: W < u32 , super :: CC_DITH6_MODE > ;
# [ doc = "Register CC_DITH6_MODE[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CC_DITH6_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DITHER`" ] pub type DITHER_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHER`" ] pub struct DITHER_W < 'a > { w : & 'a mut W , } impl < 'a > DITHER_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } }
# [ doc = "Reader of field `CC`" ] pub type CC_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CC`" ] pub struct CC_W < 'a > { w : & 'a mut W , } impl < 'a > CC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0003_ffff << 6 ) ) | ( ( ( value as u32 ) & 0x0003_ffff ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & self ) -> DITHER_R { DITHER_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 6:23 - Channel Compare/Capture Value" ] # [ inline ( always ) ] pub fn cc ( & self ) -> CC_R { CC_R :: new ( ( ( self . bits >> 6 ) & 0x0003_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:5 - Dithering Cycle Number" ] # [ inline ( always ) ] pub fn dither ( & mut self ) -> DITHER_W { DITHER_W { w : self } }
# [ doc = "Bits 6:23 - Channel Compare/Capture Value" ] # [ inline ( always ) ] pub fn cc ( & mut self ) -> CC_W { CC_W { w : self } }
}
}
# [ doc = "Pattern Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [pattbuf](pattbuf) module" ] pub type PATTBUF = crate :: Reg < u16 , _PATTBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PATTBUF ;
# [ doc = "`read()` method returns [pattbuf::R](pattbuf::R) reader structure" ] impl crate :: Readable for PATTBUF { }
# [ doc = "`write(|w| ..)` method takes [pattbuf::W](pattbuf::W) writer structure" ] impl crate :: Writable for PATTBUF { }
# [ doc = "Pattern Buffer" ] pub mod pattbuf {
# [ doc = "Reader of register PATTBUF" ] pub type R = crate :: R < u16 , super :: PATTBUF > ;
# [ doc = "Writer for register PATTBUF" ] pub type W = crate :: W < u16 , super :: PATTBUF > ;
# [ doc = "Register PATTBUF `reset()`'s with value 0" ] impl crate :: ResetValue for super :: PATTBUF { type Type = u16 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `PGEB0`" ] pub type PGEB0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGEB0`" ] pub struct PGEB0_W < 'a > { w : & 'a mut W , } impl < 'a > PGEB0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u16 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `PGEB1`" ] pub type PGEB1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGEB1`" ] pub struct PGEB1_W < 'a > { w : & 'a mut W , } impl < 'a > PGEB1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u16 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `PGEB2`" ] pub type PGEB2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGEB2`" ] pub struct PGEB2_W < 'a > { w : & 'a mut W , } impl < 'a > PGEB2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u16 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `PGEB3`" ] pub type PGEB3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGEB3`" ] pub struct PGEB3_W < 'a > { w : & 'a mut W , } impl < 'a > PGEB3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u16 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `PGEB4`" ] pub type PGEB4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGEB4`" ] pub struct PGEB4_W < 'a > { w : & 'a mut W , } impl < 'a > PGEB4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u16 ) & 0x01 ) << 4 ) ; self . w } }
# [ doc = "Reader of field `PGEB5`" ] pub type PGEB5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGEB5`" ] pub struct PGEB5_W < 'a > { w : & 'a mut W , } impl < 'a > PGEB5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 5 ) ) | ( ( ( value as u16 ) & 0x01 ) << 5 ) ; self . w } }
# [ doc = "Reader of field `PGEB6`" ] pub type PGEB6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGEB6`" ] pub struct PGEB6_W < 'a > { w : & 'a mut W , } impl < 'a > PGEB6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u16 ) & 0x01 ) << 6 ) ; self . w } }
# [ doc = "Reader of field `PGEB7`" ] pub type PGEB7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGEB7`" ] pub struct PGEB7_W < 'a > { w : & 'a mut W , } impl < 'a > PGEB7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u16 ) & 0x01 ) << 7 ) ; self . w } }
# [ doc = "Reader of field `PGVB0`" ] pub type PGVB0_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGVB0`" ] pub struct PGVB0_W < 'a > { w : & 'a mut W , } impl < 'a > PGVB0_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 8 ) ) | ( ( ( value as u16 ) & 0x01 ) << 8 ) ; self . w } }
# [ doc = "Reader of field `PGVB1`" ] pub type PGVB1_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGVB1`" ] pub struct PGVB1_W < 'a > { w : & 'a mut W , } impl < 'a > PGVB1_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 9 ) ) | ( ( ( value as u16 ) & 0x01 ) << 9 ) ; self . w } }
# [ doc = "Reader of field `PGVB2`" ] pub type PGVB2_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGVB2`" ] pub struct PGVB2_W < 'a > { w : & 'a mut W , } impl < 'a > PGVB2_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 10 ) ) | ( ( ( value as u16 ) & 0x01 ) << 10 ) ; self . w } }
# [ doc = "Reader of field `PGVB3`" ] pub type PGVB3_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGVB3`" ] pub struct PGVB3_W < 'a > { w : & 'a mut W , } impl < 'a > PGVB3_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 11 ) ) | ( ( ( value as u16 ) & 0x01 ) << 11 ) ; self . w } }
# [ doc = "Reader of field `PGVB4`" ] pub type PGVB4_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGVB4`" ] pub struct PGVB4_W < 'a > { w : & 'a mut W , } impl < 'a > PGVB4_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 12 ) ) | ( ( ( value as u16 ) & 0x01 ) << 12 ) ; self . w } }
# [ doc = "Reader of field `PGVB5`" ] pub type PGVB5_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGVB5`" ] pub struct PGVB5_W < 'a > { w : & 'a mut W , } impl < 'a > PGVB5_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 13 ) ) | ( ( ( value as u16 ) & 0x01 ) << 13 ) ; self . w } }
# [ doc = "Reader of field `PGVB6`" ] pub type PGVB6_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGVB6`" ] pub struct PGVB6_W < 'a > { w : & 'a mut W , } impl < 'a > PGVB6_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 14 ) ) | ( ( ( value as u16 ) & 0x01 ) << 14 ) ; self . w } }
# [ doc = "Reader of field `PGVB7`" ] pub type PGVB7_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `PGVB7`" ] pub struct PGVB7_W < 'a > { w : & 'a mut W , } impl < 'a > PGVB7_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u16 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Pattern Generator 0 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb0 ( & self ) -> PGEB0_R { PGEB0_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Pattern Generator 1 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb1 ( & self ) -> PGEB1_R { PGEB1_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Pattern Generator 2 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb2 ( & self ) -> PGEB2_R { PGEB2_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Pattern Generator 3 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb3 ( & self ) -> PGEB3_R { PGEB3_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Pattern Generator 4 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb4 ( & self ) -> PGEB4_R { PGEB4_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 5 - Pattern Generator 5 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb5 ( & self ) -> PGEB5_R { PGEB5_R :: new ( ( ( self . bits >> 5 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Pattern Generator 6 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb6 ( & self ) -> PGEB6_R { PGEB6_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Pattern Generator 7 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb7 ( & self ) -> PGEB7_R { PGEB7_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 8 - Pattern Generator 0 Output Enable" ] # [ inline ( always ) ] pub fn pgvb0 ( & self ) -> PGVB0_R { PGVB0_R :: new ( ( ( self . bits >> 8 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Pattern Generator 1 Output Enable" ] # [ inline ( always ) ] pub fn pgvb1 ( & self ) -> PGVB1_R { PGVB1_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 10 - Pattern Generator 2 Output Enable" ] # [ inline ( always ) ] pub fn pgvb2 ( & self ) -> PGVB2_R { PGVB2_R :: new ( ( ( self . bits >> 10 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 11 - Pattern Generator 3 Output Enable" ] # [ inline ( always ) ] pub fn pgvb3 ( & self ) -> PGVB3_R { PGVB3_R :: new ( ( ( self . bits >> 11 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 12 - Pattern Generator 4 Output Enable" ] # [ inline ( always ) ] pub fn pgvb4 ( & self ) -> PGVB4_R { PGVB4_R :: new ( ( ( self . bits >> 12 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 13 - Pattern Generator 5 Output Enable" ] # [ inline ( always ) ] pub fn pgvb5 ( & self ) -> PGVB5_R { PGVB5_R :: new ( ( ( self . bits >> 13 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 14 - Pattern Generator 6 Output Enable" ] # [ inline ( always ) ] pub fn pgvb6 ( & self ) -> PGVB6_R { PGVB6_R :: new ( ( ( self . bits >> 14 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Pattern Generator 7 Output Enable" ] # [ inline ( always ) ] pub fn pgvb7 ( & self ) -> PGVB7_R { PGVB7_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Pattern Generator 0 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb0 ( & mut self ) -> PGEB0_W { PGEB0_W { w : self } }
# [ doc = "Bit 1 - Pattern Generator 1 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb1 ( & mut self ) -> PGEB1_W { PGEB1_W { w : self } }
# [ doc = "Bit 2 - Pattern Generator 2 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb2 ( & mut self ) -> PGEB2_W { PGEB2_W { w : self } }
# [ doc = "Bit 3 - Pattern Generator 3 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb3 ( & mut self ) -> PGEB3_W { PGEB3_W { w : self } }
# [ doc = "Bit 4 - Pattern Generator 4 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb4 ( & mut self ) -> PGEB4_W { PGEB4_W { w : self } }
# [ doc = "Bit 5 - Pattern Generator 5 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb5 ( & mut self ) -> PGEB5_W { PGEB5_W { w : self } }
# [ doc = "Bit 6 - Pattern Generator 6 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb6 ( & mut self ) -> PGEB6_W { PGEB6_W { w : self } }
# [ doc = "Bit 7 - Pattern Generator 7 Output Enable Buffer" ] # [ inline ( always ) ] pub fn pgeb7 ( & mut self ) -> PGEB7_W { PGEB7_W { w : self } }
# [ doc = "Bit 8 - Pattern Generator 0 Output Enable" ] # [ inline ( always ) ] pub fn pgvb0 ( & mut self ) -> PGVB0_W { PGVB0_W { w : self } }
# [ doc = "Bit 9 - Pattern Generator 1 Output Enable" ] # [ inline ( always ) ] pub fn pgvb1 ( & mut self ) -> PGVB1_W { PGVB1_W { w : self } }
# [ doc = "Bit 10 - Pattern Generator 2 Output Enable" ] # [ inline ( always ) ] pub fn pgvb2 ( & mut self ) -> PGVB2_W { PGVB2_W { w : self } }
# [ doc = "Bit 11 - Pattern Generator 3 Output Enable" ] # [ inline ( always ) ] pub fn pgvb3 ( & mut self ) -> PGVB3_W { PGVB3_W { w : self } }
# [ doc = "Bit 12 - Pattern Generator 4 Output Enable" ] # [ inline ( always ) ] pub fn pgvb4 ( & mut self ) -> PGVB4_W { PGVB4_W { w : self } }
# [ doc = "Bit 13 - Pattern Generator 5 Output Enable" ] # [ inline ( always ) ] pub fn pgvb5 ( & mut self ) -> PGVB5_W { PGVB5_W { w : self } }
# [ doc = "Bit 14 - Pattern Generator 6 Output Enable" ] # [ inline ( always ) ] pub fn pgvb6 ( & mut self ) -> PGVB6_W { PGVB6_W { w : self } }
# [ doc = "Bit 15 - Pattern Generator 7 Output Enable" ] # [ inline ( always ) ] pub fn pgvb7 ( & mut self ) -> PGVB7_W { PGVB7_W { w : self } }
}
}
# [ doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [perbuf](perbuf) module" ] pub type PERBUF = crate :: Reg < u32 , _PERBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PERBUF ;
# [ doc = "`read()` method returns [perbuf::R](perbuf::R) reader structure" ] impl crate :: Readable for PERBUF { }
# [ doc = "`write(|w| ..)` method takes [perbuf::W](perbuf::W) writer structure" ] impl crate :: Writable for PERBUF { }
# [ doc = "Period Buffer" ] pub mod perbuf {
# [ doc = "Reader of register PERBUF" ] pub type R = crate :: R < u32 , super :: PERBUF > ;
# [ doc = "Writer for register PERBUF" ] pub type W = crate :: W < u32 , super :: PERBUF > ;
# [ doc = "Register PERBUF `reset()`'s with value 0xffff_ffff" ] impl crate :: ResetValue for super :: PERBUF { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff_ffff } }
# [ doc = "Reader of field `PERBUF`" ] pub type PERBUF_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `PERBUF`" ] pub struct PERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > PERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & self ) -> PERBUF_R { PERBUF_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & mut self ) -> PERBUF_W { PERBUF_W { w : self } }
}
}
# [ doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [perbuf_dith4_mode](perbuf_dith4_mode) module" ] pub type PERBUF_DITH4_MODE = crate :: Reg < u32 , _PERBUF_DITH4_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PERBUF_DITH4_MODE ;
# [ doc = "`read()` method returns [perbuf_dith4_mode::R](perbuf_dith4_mode::R) reader structure" ] impl crate :: Readable for PERBUF_DITH4_MODE { }
# [ doc = "`write(|w| ..)` method takes [perbuf_dith4_mode::W](perbuf_dith4_mode::W) writer structure" ] impl crate :: Writable for PERBUF_DITH4_MODE { }
# [ doc = "Period Buffer" ] pub mod perbuf_dith4_mode {
# [ doc = "Reader of register PERBUF_DITH4_MODE" ] pub type R = crate :: R < u32 , super :: PERBUF_DITH4_MODE > ;
# [ doc = "Writer for register PERBUF_DITH4_MODE" ] pub type W = crate :: W < u32 , super :: PERBUF_DITH4_MODE > ;
# [ doc = "Register PERBUF_DITH4_MODE `reset()`'s with value 0xffff_ffff" ] impl crate :: ResetValue for super :: PERBUF_DITH4_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff_ffff } }
# [ doc = "Reader of field `DITHERBUF`" ] pub type DITHERBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHERBUF`" ] pub struct DITHERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > DITHERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u32 ) & 0x0f ) ; self . w } }
# [ doc = "Reader of field `PERBUF`" ] pub type PERBUF_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `PERBUF`" ] pub struct PERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > PERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x000f_ffff << 4 ) ) | ( ( ( value as u32 ) & 0x000f_ffff ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & self ) -> DITHERBUF_R { DITHERBUF_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:23 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & self ) -> PERBUF_R { PERBUF_R :: new ( ( ( self . bits >> 4 ) & 0x000f_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:3 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & mut self ) -> DITHERBUF_W { DITHERBUF_W { w : self } }
# [ doc = "Bits 4:23 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & mut self ) -> PERBUF_W { PERBUF_W { w : self } }
}
}
# [ doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [perbuf_dith5_mode](perbuf_dith5_mode) module" ] pub type PERBUF_DITH5_MODE = crate :: Reg < u32 , _PERBUF_DITH5_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PERBUF_DITH5_MODE ;
# [ doc = "`read()` method returns [perbuf_dith5_mode::R](perbuf_dith5_mode::R) reader structure" ] impl crate :: Readable for PERBUF_DITH5_MODE { }
# [ doc = "`write(|w| ..)` method takes [perbuf_dith5_mode::W](perbuf_dith5_mode::W) writer structure" ] impl crate :: Writable for PERBUF_DITH5_MODE { }
# [ doc = "Period Buffer" ] pub mod perbuf_dith5_mode {
# [ doc = "Reader of register PERBUF_DITH5_MODE" ] pub type R = crate :: R < u32 , super :: PERBUF_DITH5_MODE > ;
# [ doc = "Writer for register PERBUF_DITH5_MODE" ] pub type W = crate :: W < u32 , super :: PERBUF_DITH5_MODE > ;
# [ doc = "Register PERBUF_DITH5_MODE `reset()`'s with value 0xffff_ffff" ] impl crate :: ResetValue for super :: PERBUF_DITH5_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff_ffff } }
# [ doc = "Reader of field `DITHERBUF`" ] pub type DITHERBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHERBUF`" ] pub struct DITHERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > DITHERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u32 ) & 0x1f ) ; self . w } }
# [ doc = "Reader of field `PERBUF`" ] pub type PERBUF_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `PERBUF`" ] pub struct PERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > PERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0007_ffff << 5 ) ) | ( ( ( value as u32 ) & 0x0007_ffff ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bits 0:4 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & self ) -> DITHERBUF_R { DITHERBUF_R :: new ( ( self . bits & 0x1f ) as u8 ) }
# [ doc = "Bits 5:23 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & self ) -> PERBUF_R { PERBUF_R :: new ( ( ( self . bits >> 5 ) & 0x0007_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:4 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & mut self ) -> DITHERBUF_W { DITHERBUF_W { w : self } }
# [ doc = "Bits 5:23 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & mut self ) -> PERBUF_W { PERBUF_W { w : self } }
}
}
# [ doc = "Period Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [perbuf_dith6_mode](perbuf_dith6_mode) module" ] pub type PERBUF_DITH6_MODE = crate :: Reg < u32 , _PERBUF_DITH6_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _PERBUF_DITH6_MODE ;
# [ doc = "`read()` method returns [perbuf_dith6_mode::R](perbuf_dith6_mode::R) reader structure" ] impl crate :: Readable for PERBUF_DITH6_MODE { }
# [ doc = "`write(|w| ..)` method takes [perbuf_dith6_mode::W](perbuf_dith6_mode::W) writer structure" ] impl crate :: Writable for PERBUF_DITH6_MODE { }
# [ doc = "Period Buffer" ] pub mod perbuf_dith6_mode {
# [ doc = "Reader of register PERBUF_DITH6_MODE" ] pub type R = crate :: R < u32 , super :: PERBUF_DITH6_MODE > ;
# [ doc = "Writer for register PERBUF_DITH6_MODE" ] pub type W = crate :: W < u32 , super :: PERBUF_DITH6_MODE > ;
# [ doc = "Register PERBUF_DITH6_MODE `reset()`'s with value 0xffff_ffff" ] impl crate :: ResetValue for super :: PERBUF_DITH6_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xffff_ffff } }
# [ doc = "Reader of field `DITHERBUF`" ] pub type DITHERBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHERBUF`" ] pub struct DITHERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > DITHERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } }
# [ doc = "Reader of field `PERBUF`" ] pub type PERBUF_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `PERBUF`" ] pub struct PERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > PERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0003_ffff << 6 ) ) | ( ( ( value as u32 ) & 0x0003_ffff ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & self ) -> DITHERBUF_R { DITHERBUF_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 6:23 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & self ) -> PERBUF_R { PERBUF_R :: new ( ( ( self . bits >> 6 ) & 0x0003_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:5 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & mut self ) -> DITHERBUF_W { DITHERBUF_W { w : self } }
# [ doc = "Bits 6:23 - Period Buffer Value" ] # [ inline ( always ) ] pub fn perbuf ( & mut self ) -> PERBUF_W { PERBUF_W { w : self } }
}
}
# [ doc = "Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ccbuf](ccbuf) module" ] pub type CCBUF = crate :: Reg < u32 , _CCBUF > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CCBUF ;
# [ doc = "`read()` method returns [ccbuf::R](ccbuf::R) reader structure" ] impl crate :: Readable for CCBUF { }
# [ doc = "`write(|w| ..)` method takes [ccbuf::W](ccbuf::W) writer structure" ] impl crate :: Writable for CCBUF { }
# [ doc = "Compare and Capture Buffer" ] pub mod ccbuf {
# [ doc = "Reader of register CCBUF[%s]" ] pub type R = crate :: R < u32 , super :: CCBUF > ;
# [ doc = "Writer for register CCBUF[%s]" ] pub type W = crate :: W < u32 , super :: CCBUF > ;
# [ doc = "Register CCBUF[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CCBUF { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CCBUF`" ] pub type CCBUF_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CCBUF`" ] pub struct CCBUF_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Channel Compare/Capture Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & self ) -> CCBUF_R { CCBUF_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Channel Compare/Capture Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & mut self ) -> CCBUF_W { CCBUF_W { w : self } }
}
}
# [ doc = "Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ccbuf_dith4_mode](ccbuf_dith4_mode) module" ] pub type CCBUF_DITH4_MODE = crate :: Reg < u32 , _CCBUF_DITH4_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CCBUF_DITH4_MODE ;
# [ doc = "`read()` method returns [ccbuf_dith4_mode::R](ccbuf_dith4_mode::R) reader structure" ] impl crate :: Readable for CCBUF_DITH4_MODE { }
# [ doc = "`write(|w| ..)` method takes [ccbuf_dith4_mode::W](ccbuf_dith4_mode::W) writer structure" ] impl crate :: Writable for CCBUF_DITH4_MODE { }
# [ doc = "Compare and Capture Buffer" ] pub mod ccbuf_dith4_mode {
# [ doc = "Reader of register CCBUF_DITH4_MODE[%s]" ] pub type R = crate :: R < u32 , super :: CCBUF_DITH4_MODE > ;
# [ doc = "Writer for register CCBUF_DITH4_MODE[%s]" ] pub type W = crate :: W < u32 , super :: CCBUF_DITH4_MODE > ;
# [ doc = "Register CCBUF_DITH4_MODE[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CCBUF_DITH4_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CCBUF`" ] pub type CCBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `CCBUF`" ] pub struct CCBUF_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u32 ) & 0x0f ) ; self . w } }
# [ doc = "Reader of field `DITHERBUF`" ] pub type DITHERBUF_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `DITHERBUF`" ] pub struct DITHERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > DITHERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x000f_ffff << 4 ) ) | ( ( ( value as u32 ) & 0x000f_ffff ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Channel Compare/Capture Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & self ) -> CCBUF_R { CCBUF_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:23 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & self ) -> DITHERBUF_R { DITHERBUF_R :: new ( ( ( self . bits >> 4 ) & 0x000f_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:3 - Channel Compare/Capture Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & mut self ) -> CCBUF_W { CCBUF_W { w : self } }
# [ doc = "Bits 4:23 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & mut self ) -> DITHERBUF_W { DITHERBUF_W { w : self } }
}
}
# [ doc = "Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ccbuf_dith5_mode](ccbuf_dith5_mode) module" ] pub type CCBUF_DITH5_MODE = crate :: Reg < u32 , _CCBUF_DITH5_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CCBUF_DITH5_MODE ;
# [ doc = "`read()` method returns [ccbuf_dith5_mode::R](ccbuf_dith5_mode::R) reader structure" ] impl crate :: Readable for CCBUF_DITH5_MODE { }
# [ doc = "`write(|w| ..)` method takes [ccbuf_dith5_mode::W](ccbuf_dith5_mode::W) writer structure" ] impl crate :: Writable for CCBUF_DITH5_MODE { }
# [ doc = "Compare and Capture Buffer" ] pub mod ccbuf_dith5_mode {
# [ doc = "Reader of register CCBUF_DITH5_MODE[%s]" ] pub type R = crate :: R < u32 , super :: CCBUF_DITH5_MODE > ;
# [ doc = "Writer for register CCBUF_DITH5_MODE[%s]" ] pub type W = crate :: W < u32 , super :: CCBUF_DITH5_MODE > ;
# [ doc = "Register CCBUF_DITH5_MODE[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CCBUF_DITH5_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DITHERBUF`" ] pub type DITHERBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHERBUF`" ] pub struct DITHERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > DITHERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x1f ) | ( ( value as u32 ) & 0x1f ) ; self . w } }
# [ doc = "Reader of field `CCBUF`" ] pub type CCBUF_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CCBUF`" ] pub struct CCBUF_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0007_ffff << 5 ) ) | ( ( ( value as u32 ) & 0x0007_ffff ) << 5 ) ; self . w } }
impl R {
# [ doc = "Bits 0:4 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & self ) -> DITHERBUF_R { DITHERBUF_R :: new ( ( self . bits & 0x1f ) as u8 ) }
# [ doc = "Bits 5:23 - Channel Compare/Capture Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & self ) -> CCBUF_R { CCBUF_R :: new ( ( ( self . bits >> 5 ) & 0x0007_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:4 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & mut self ) -> DITHERBUF_W { DITHERBUF_W { w : self } }
# [ doc = "Bits 5:23 - Channel Compare/Capture Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & mut self ) -> CCBUF_W { CCBUF_W { w : self } }
}
}
# [ doc = "Compare and Capture Buffer\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ccbuf_dith6_mode](ccbuf_dith6_mode) module" ] pub type CCBUF_DITH6_MODE = crate :: Reg < u32 , _CCBUF_DITH6_MODE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CCBUF_DITH6_MODE ;
# [ doc = "`read()` method returns [ccbuf_dith6_mode::R](ccbuf_dith6_mode::R) reader structure" ] impl crate :: Readable for CCBUF_DITH6_MODE { }
# [ doc = "`write(|w| ..)` method takes [ccbuf_dith6_mode::W](ccbuf_dith6_mode::W) writer structure" ] impl crate :: Writable for CCBUF_DITH6_MODE { }
# [ doc = "Compare and Capture Buffer" ] pub mod ccbuf_dith6_mode {
# [ doc = "Reader of register CCBUF_DITH6_MODE[%s]" ] pub type R = crate :: R < u32 , super :: CCBUF_DITH6_MODE > ;
# [ doc = "Writer for register CCBUF_DITH6_MODE[%s]" ] pub type W = crate :: W < u32 , super :: CCBUF_DITH6_MODE > ;
# [ doc = "Register CCBUF_DITH6_MODE[%s] `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CCBUF_DITH6_MODE { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DITHERBUF`" ] pub type DITHERBUF_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `DITHERBUF`" ] pub struct DITHERBUF_W < 'a > { w : & 'a mut W , } impl < 'a > DITHERBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } }
# [ doc = "Reader of field `CCBUF`" ] pub type CCBUF_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CCBUF`" ] pub struct CCBUF_W < 'a > { w : & 'a mut W , } impl < 'a > CCBUF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0003_ffff << 6 ) ) | ( ( ( value as u32 ) & 0x0003_ffff ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & self ) -> DITHERBUF_R { DITHERBUF_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 6:23 - Channel Compare/Capture Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & self ) -> CCBUF_R { CCBUF_R :: new ( ( ( self . bits >> 6 ) & 0x0003_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:5 - Dithering Buffer Cycle Number" ] # [ inline ( always ) ] pub fn ditherbuf ( & mut self ) -> DITHERBUF_W { DITHERBUF_W { w : self } }
# [ doc = "Bits 6:23 - Channel Compare/Capture Buffer Value" ] # [ inline ( always ) ] pub fn ccbuf ( & mut self ) -> CCBUF_W { CCBUF_W { w : self } }
}
}
}
# [ doc = "Timer Counter Control" ] pub struct TCC1 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TCC1 { } impl TCC1 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tcc0 :: RegisterBlock { 0x4200_2800 as * const _ } } impl Deref for TCC1 { type Target = tcc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TCC1 :: ptr ( ) } } }
# [ doc = "Timer Counter Control" ] pub struct TCC2 { _marker : PhantomData < * const ( ) > } unsafe impl Send for TCC2 { } impl TCC2 { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tcc0 :: RegisterBlock { 0x4200_2c00 as * const _ } } impl Deref for TCC2 { type Target = tcc0 :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TCC2 :: ptr ( ) } } }
# [ doc = "Temperature Sensor" ] pub struct TSENS { _marker : PhantomData < * const ( ) > } unsafe impl Send for TSENS { } impl TSENS { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const tsens :: RegisterBlock { 0x4000_3000 as * const _ } } impl Deref for TSENS { type Target = tsens :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * TSENS :: ptr ( ) } } }
# [ doc = "Temperature Sensor" ] pub mod tsens {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control A Register" ] pub ctrla : CTRLA , # [ doc = "0x01 - Control B Register" ] pub ctrlb : CTRLB , # [ doc = "0x02 - Control C Register" ] pub ctrlc : CTRLC , # [ doc = "0x03 - Event Control Register" ] pub evctrl : EVCTRL , # [ doc = "0x04 - Interrupt Enable Clear Register" ] pub intenclr : INTENCLR , # [ doc = "0x05 - Interrupt Enable Set Register" ] pub intenset : INTENSET , # [ doc = "0x06 - Interrupt Flag Status and Clear Register" ] pub intflag : INTFLAG , # [ doc = "0x07 - Status Register" ] pub status : STATUS , # [ doc = "0x08 - Synchronization Busy Register" ] pub syncbusy : SYNCBUSY , # [ doc = "0x0c - Value Register" ] pub value : VALUE , # [ doc = "0x10 - Window Monitor Lower Threshold Register" ] pub winlt : WINLT , # [ doc = "0x14 - Window Monitor Upper Threshold Register" ] pub winut : WINUT , # [ doc = "0x18 - Gain Register" ] pub gain : GAIN , # [ doc = "0x1c - Offset Register" ] pub offset : OFFSET , # [ doc = "0x20 - Calibration Register" ] pub cal : CAL , # [ doc = "0x24 - Debug Control Register" ] pub dbgctrl : DBGCTRL , }
# [ doc = "Control A Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control A Register" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SWRST`" ] pub struct SWRST_W < 'a > { w : & 'a mut W , } impl < 'a > SWRST_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `RUNSTDBY`" ] pub type RUNSTDBY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RUNSTDBY`" ] pub struct RUNSTDBY_W < 'a > { w : & 'a mut W , } impl < 'a > RUNSTDBY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 6 ) ) | ( ( ( value as u8 ) & 0x01 ) << 6 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & self ) -> RUNSTDBY_R { RUNSTDBY_R :: new ( ( ( self . bits >> 6 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Software Reset" ] # [ inline ( always ) ] pub fn swrst ( & mut self ) -> SWRST_W { SWRST_W { w : self } }
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 6 - Run in Standby" ] # [ inline ( always ) ] pub fn runstdby ( & mut self ) -> RUNSTDBY_W { RUNSTDBY_W { w : self } }
}
}
# [ doc = "Control B Register\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlb](ctrlb) module" ] pub type CTRLB = crate :: Reg < u8 , _CTRLB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLB ;
# [ doc = "`write(|w| ..)` method takes [ctrlb::W](ctrlb::W) writer structure" ] impl crate :: Writable for CTRLB { }
# [ doc = "Control B Register" ] pub mod ctrlb {
# [ doc = "Writer for register CTRLB" ] pub type W = crate :: W < u8 , super :: CTRLB > ;
# [ doc = "Register CTRLB `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLB { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Write proxy for field `START`" ] pub struct START_W < 'a > { w : & 'a mut W , } impl < 'a > START_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl W {
# [ doc = "Bit 0 - Start Measurement" ] # [ inline ( always ) ] pub fn start ( & mut self ) -> START_W { START_W { w : self } }
}
}
# [ doc = "Control C Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrlc](ctrlc) module" ] pub type CTRLC = crate :: Reg < u8 , _CTRLC > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLC ;
# [ doc = "`read()` method returns [ctrlc::R](ctrlc::R) reader structure" ] impl crate :: Readable for CTRLC { }
# [ doc = "`write(|w| ..)` method takes [ctrlc::W](ctrlc::W) writer structure" ] impl crate :: Writable for CTRLC { }
# [ doc = "Control C Register" ] pub mod ctrlc {
# [ doc = "Reader of register CTRLC" ] pub type R = crate :: R < u8 , super :: CTRLC > ;
# [ doc = "Writer for register CTRLC" ] pub type W = crate :: W < u8 , super :: CTRLC > ;
# [ doc = "Register CTRLC `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLC { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `WINMODE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WINMODE_A { # [ doc = "No window mode (default)" ] DISABLE , # [ doc = "VALUE greater than WINLT" ] ABOVE , # [ doc = "VALUE less than WINUT" ] BELOW , # [ doc = "VALUE greater than WINLT and VALUE less than WINUT" ] INSIDE , # [ doc = "VALUE less than WINLT or VALUE greater than WINUT" ] OUTSIDE , # [ doc = "VALUE greater than WINUT with hysteresis to WINLT" ] HYST_ABOVE , # [ doc = "VALUE less than WINLST with hysteresis to WINUT" ] HYST_BELOW }
impl crate :: ToBits < u8 > for WINMODE_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WINMODE_A :: DISABLE => 0 , WINMODE_A :: ABOVE => 1 , WINMODE_A :: BELOW => 2 , WINMODE_A :: INSIDE => 3 , WINMODE_A :: OUTSIDE => 4 , WINMODE_A :: HYST_ABOVE => 5 , WINMODE_A :: HYST_BELOW => 6 } } }
# [ doc = "Reader of field `WINMODE`" ] pub type WINMODE_R = crate :: R < u8 , WINMODE_A > ; impl WINMODE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , WINMODE_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( WINMODE_A :: DISABLE ) , 1 => Val ( WINMODE_A :: ABOVE ) , 2 => Val ( WINMODE_A :: BELOW ) , 3 => Val ( WINMODE_A :: INSIDE ) , 4 => Val ( WINMODE_A :: OUTSIDE ) , 5 => Val ( WINMODE_A :: HYST_ABOVE ) , 6 => Val ( WINMODE_A :: HYST_BELOW ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `DISABLE`" ] # [ inline ( always ) ] pub fn is_disable ( & self ) -> bool { * self == WINMODE_A :: DISABLE } # [ doc = "Checks if the value of the field is `ABOVE`" ] # [ inline ( always ) ] pub fn is_above ( & self ) -> bool { * self == WINMODE_A :: ABOVE } # [ doc = "Checks if the value of the field is `BELOW`" ] # [ inline ( always ) ] pub fn is_below ( & self ) -> bool { * self == WINMODE_A :: BELOW } # [ doc = "Checks if the value of the field is `INSIDE`" ] # [ inline ( always ) ] pub fn is_inside ( & self ) -> bool { * self == WINMODE_A :: INSIDE } # [ doc = "Checks if the value of the field is `OUTSIDE`" ] # [ inline ( always ) ] pub fn is_outside ( & self ) -> bool { * self == WINMODE_A :: OUTSIDE } # [ doc = "Checks if the value of the field is `HYST_ABOVE`" ] # [ inline ( always ) ] pub fn is_hyst_above ( & self ) -> bool { * self == WINMODE_A :: HYST_ABOVE } # [ doc = "Checks if the value of the field is `HYST_BELOW`" ] # [ inline ( always ) ] pub fn is_hyst_below ( & self ) -> bool { * self == WINMODE_A :: HYST_BELOW } }
# [ doc = "Write proxy for field `WINMODE`" ] pub struct WINMODE_W < 'a > { w : & 'a mut W , } impl < 'a > WINMODE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WINMODE_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "No window mode (default)" ] # [ inline ( always ) ] pub fn disable ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: DISABLE ) } # [ doc = "VALUE greater than WINLT" ] # [ inline ( always ) ] pub fn above ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: ABOVE ) } # [ doc = "VALUE less than WINUT" ] # [ inline ( always ) ] pub fn below ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: BELOW ) } # [ doc = "VALUE greater than WINLT and VALUE less than WINUT" ] # [ inline ( always ) ] pub fn inside ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: INSIDE ) } # [ doc = "VALUE less than WINLT or VALUE greater than WINUT" ] # [ inline ( always ) ] pub fn outside ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: OUTSIDE ) } # [ doc = "VALUE greater than WINUT with hysteresis to WINLT" ] # [ inline ( always ) ] pub fn hyst_above ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: HYST_ABOVE ) } # [ doc = "VALUE less than WINLST with hysteresis to WINUT" ] # [ inline ( always ) ] pub fn hyst_below ( self ) -> & 'a mut W { self . variant ( WINMODE_A :: HYST_BELOW ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x07 ) | ( ( value as u8 ) & 0x07 ) ; self . w } }
# [ doc = "Reader of field `FREERUN`" ] pub type FREERUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `FREERUN`" ] pub struct FREERUN_W < 'a > { w : & 'a mut W , } impl < 'a > FREERUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u8 ) & 0x01 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:2 - Window Monitor Mode" ] # [ inline ( always ) ] pub fn winmode ( & self ) -> WINMODE_R { WINMODE_R :: new ( ( self . bits & 0x07 ) as u8 ) }
# [ doc = "Bit 4 - Free Running Measurement" ] # [ inline ( always ) ] pub fn freerun ( & self ) -> FREERUN_R { FREERUN_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:2 - Window Monitor Mode" ] # [ inline ( always ) ] pub fn winmode ( & mut self ) -> WINMODE_W { WINMODE_W { w : self } }
# [ doc = "Bit 4 - Free Running Measurement" ] # [ inline ( always ) ] pub fn freerun ( & mut self ) -> FREERUN_W { FREERUN_W { w : self } }
}
}
# [ doc = "Event Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [evctrl](evctrl) module" ] pub type EVCTRL = crate :: Reg < u8 , _EVCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EVCTRL ;
# [ doc = "`read()` method returns [evctrl::R](evctrl::R) reader structure" ] impl crate :: Readable for EVCTRL { }
# [ doc = "`write(|w| ..)` method takes [evctrl::W](evctrl::W) writer structure" ] impl crate :: Writable for EVCTRL { }
# [ doc = "Event Control Register" ] pub mod evctrl {
# [ doc = "Reader of register EVCTRL" ] pub type R = crate :: R < u8 , super :: EVCTRL > ;
# [ doc = "Writer for register EVCTRL" ] pub type W = crate :: W < u8 , super :: EVCTRL > ;
# [ doc = "Register EVCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: EVCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `STARTEI`" ] pub type STARTEI_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `STARTEI`" ] pub struct STARTEI_W < 'a > { w : & 'a mut W , } impl < 'a > STARTEI_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `STARTINV`" ] pub type STARTINV_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `STARTINV`" ] pub struct STARTINV_W < 'a > { w : & 'a mut W , } impl < 'a > STARTINV_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINEO`" ] pub type WINEO_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINEO`" ] pub struct WINEO_W < 'a > { w : & 'a mut W , } impl < 'a > WINEO_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Start Conversion Event Input Enable" ] # [ inline ( always ) ] pub fn startei ( & self ) -> STARTEI_R { STARTEI_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Start Conversion Event Invert Enable" ] # [ inline ( always ) ] pub fn startinv ( & self ) -> STARTINV_R { STARTINV_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor Event Out" ] # [ inline ( always ) ] pub fn wineo ( & self ) -> WINEO_R { WINEO_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Start Conversion Event Input Enable" ] # [ inline ( always ) ] pub fn startei ( & mut self ) -> STARTEI_W { STARTEI_W { w : self } }
# [ doc = "Bit 1 - Start Conversion Event Invert Enable" ] # [ inline ( always ) ] pub fn startinv ( & mut self ) -> STARTINV_W { STARTINV_W { w : self } }
# [ doc = "Bit 2 - Window Monitor Event Out" ] # [ inline ( always ) ] pub fn wineo ( & mut self ) -> WINEO_W { WINEO_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear Register" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RESRDY`" ] pub type RESRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDY`" ] pub struct RESRDY_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVERRUN`" ] pub type OVERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVERRUN`" ] pub struct OVERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > OVERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINMON`" ] pub type WINMON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMON`" ] pub struct WINMON_W < 'a > { w : & 'a mut W , } impl < 'a > WINMON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Result Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn resrdy ( & self ) -> RESRDY_R { RESRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn overrun ( & self ) -> OVERRUN_R { OVERRUN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor Interrupt Enable" ] # [ inline ( always ) ] pub fn winmon ( & self ) -> WINMON_R { WINMON_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Result Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn resrdy ( & mut self ) -> RESRDY_W { RESRDY_W { w : self } }
# [ doc = "Bit 1 - Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn overrun ( & mut self ) -> OVERRUN_W { OVERRUN_W { w : self } }
# [ doc = "Bit 2 - Window Monitor Interrupt Enable" ] # [ inline ( always ) ] pub fn winmon ( & mut self ) -> WINMON_W { WINMON_W { w : self } }
# [ doc = "Bit 3 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set Register" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RESRDY`" ] pub type RESRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDY`" ] pub struct RESRDY_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVERRUN`" ] pub type OVERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVERRUN`" ] pub struct OVERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > OVERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINMON`" ] pub type WINMON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMON`" ] pub struct WINMON_W < 'a > { w : & 'a mut W , } impl < 'a > WINMON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Result Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn resrdy ( & self ) -> RESRDY_R { RESRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn overrun ( & self ) -> OVERRUN_R { OVERRUN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor Interrupt Enable" ] # [ inline ( always ) ] pub fn winmon ( & self ) -> WINMON_R { WINMON_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Result Ready Interrupt Enable" ] # [ inline ( always ) ] pub fn resrdy ( & mut self ) -> RESRDY_W { RESRDY_W { w : self } }
# [ doc = "Bit 1 - Overrun Interrupt Enable" ] # [ inline ( always ) ] pub fn overrun ( & mut self ) -> OVERRUN_W { OVERRUN_W { w : self } }
# [ doc = "Bit 2 - Window Monitor Interrupt Enable" ] # [ inline ( always ) ] pub fn winmon ( & mut self ) -> WINMON_W { WINMON_W { w : self } }
# [ doc = "Bit 3 - Overflow Interrupt Enable" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear Register" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RESRDY`" ] pub type RESRDY_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `RESRDY`" ] pub struct RESRDY_W < 'a > { w : & 'a mut W , } impl < 'a > RESRDY_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `OVERRUN`" ] pub type OVERRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVERRUN`" ] pub struct OVERRUN_W < 'a > { w : & 'a mut W , } impl < 'a > OVERRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WINMON`" ] pub type WINMON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WINMON`" ] pub struct WINMON_W < 'a > { w : & 'a mut W , } impl < 'a > WINMON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `OVF`" ] pub struct OVF_W < 'a > { w : & 'a mut W , } impl < 'a > OVF_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u8 ) & 0x01 ) << 3 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Result Ready" ] # [ inline ( always ) ] pub fn resrdy ( & self ) -> RESRDY_R { RESRDY_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Overrun" ] # [ inline ( always ) ] pub fn overrun ( & self ) -> OVERRUN_R { OVERRUN_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Monitor" ] # [ inline ( always ) ] pub fn winmon ( & self ) -> WINMON_R { WINMON_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Result Ready" ] # [ inline ( always ) ] pub fn resrdy ( & mut self ) -> RESRDY_W { RESRDY_W { w : self } }
# [ doc = "Bit 1 - Overrun" ] # [ inline ( always ) ] pub fn overrun ( & mut self ) -> OVERRUN_W { OVERRUN_W { w : self } }
# [ doc = "Bit 2 - Window Monitor" ] # [ inline ( always ) ] pub fn winmon ( & mut self ) -> WINMON_W { WINMON_W { w : self } }
# [ doc = "Bit 3 - Overflow" ] # [ inline ( always ) ] pub fn ovf ( & mut self ) -> OVF_W { OVF_W { w : self } }
}
}
# [ doc = "Status Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [status](status) module" ] pub type STATUS = crate :: Reg < u8 , _STATUS > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _STATUS ;
# [ doc = "`read()` method returns [status::R](status::R) reader structure" ] impl crate :: Readable for STATUS { }
# [ doc = "Status Register" ] pub mod status {
# [ doc = "Reader of register STATUS" ] pub type R = crate :: R < u8 , super :: STATUS > ;
# [ doc = "Reader of field `OVF`" ] pub type OVF_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Result Overflow" ] # [ inline ( always ) ] pub fn ovf ( & self ) -> OVF_R { OVF_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
}
# [ doc = "Synchronization Busy Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy Register" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `SWRST`" ] pub type SWRST_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 0 - Software Reset Busy" ] # [ inline ( always ) ] pub fn swrst ( & self ) -> SWRST_R { SWRST_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Enable Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Value Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [value](value) module" ] pub type VALUE = crate :: Reg < u32 , _VALUE > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _VALUE ;
# [ doc = "`read()` method returns [value::R](value::R) reader structure" ] impl crate :: Readable for VALUE { }
# [ doc = "Value Register" ] pub mod value {
# [ doc = "Reader of register VALUE" ] pub type R = crate :: R < u32 , super :: VALUE > ;
# [ doc = "Reader of field `VALUE`" ] pub type VALUE_R = crate :: R < u32 , u32 > ;
impl R {
# [ doc = "Bits 0:23 - Measurement Value" ] # [ inline ( always ) ] pub fn value ( & self ) -> VALUE_R { VALUE_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
}
# [ doc = "Window Monitor Lower Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [winlt](winlt) module" ] pub type WINLT = crate :: Reg < u32 , _WINLT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WINLT ;
# [ doc = "`read()` method returns [winlt::R](winlt::R) reader structure" ] impl crate :: Readable for WINLT { }
# [ doc = "`write(|w| ..)` method takes [winlt::W](winlt::W) writer structure" ] impl crate :: Writable for WINLT { }
# [ doc = "Window Monitor Lower Threshold Register" ] pub mod winlt {
# [ doc = "Reader of register WINLT" ] pub type R = crate :: R < u32 , super :: WINLT > ;
# [ doc = "Writer for register WINLT" ] pub type W = crate :: W < u32 , super :: WINLT > ;
# [ doc = "Register WINLT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WINLT { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WINLT`" ] pub type WINLT_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `WINLT`" ] pub struct WINLT_W < 'a > { w : & 'a mut W , } impl < 'a > WINLT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Window Lower Threshold" ] # [ inline ( always ) ] pub fn winlt ( & self ) -> WINLT_R { WINLT_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Window Lower Threshold" ] # [ inline ( always ) ] pub fn winlt ( & mut self ) -> WINLT_W { WINLT_W { w : self } }
}
}
# [ doc = "Window Monitor Upper Threshold Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [winut](winut) module" ] pub type WINUT = crate :: Reg < u32 , _WINUT > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _WINUT ;
# [ doc = "`read()` method returns [winut::R](winut::R) reader structure" ] impl crate :: Readable for WINUT { }
# [ doc = "`write(|w| ..)` method takes [winut::W](winut::W) writer structure" ] impl crate :: Writable for WINUT { }
# [ doc = "Window Monitor Upper Threshold Register" ] pub mod winut {
# [ doc = "Reader of register WINUT" ] pub type R = crate :: R < u32 , super :: WINUT > ;
# [ doc = "Writer for register WINUT" ] pub type W = crate :: W < u32 , super :: WINUT > ;
# [ doc = "Register WINUT `reset()`'s with value 0" ] impl crate :: ResetValue for super :: WINUT { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `WINUT`" ] pub type WINUT_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `WINUT`" ] pub struct WINUT_W < 'a > { w : & 'a mut W , } impl < 'a > WINUT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Window Upper Threshold" ] # [ inline ( always ) ] pub fn winut ( & self ) -> WINUT_R { WINUT_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Window Upper Threshold" ] # [ inline ( always ) ] pub fn winut ( & mut self ) -> WINUT_W { WINUT_W { w : self } }
}
}
# [ doc = "Gain Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [gain](gain) module" ] pub type GAIN = crate :: Reg < u32 , _GAIN > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _GAIN ;
# [ doc = "`read()` method returns [gain::R](gain::R) reader structure" ] impl crate :: Readable for GAIN { }
# [ doc = "`write(|w| ..)` method takes [gain::W](gain::W) writer structure" ] impl crate :: Writable for GAIN { }
# [ doc = "Gain Register" ] pub mod gain {
# [ doc = "Reader of register GAIN" ] pub type R = crate :: R < u32 , super :: GAIN > ;
# [ doc = "Writer for register GAIN" ] pub type W = crate :: W < u32 , super :: GAIN > ;
# [ doc = "Register GAIN `reset()`'s with value 0" ] impl crate :: ResetValue for super :: GAIN { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `GAIN`" ] pub type GAIN_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `GAIN`" ] pub struct GAIN_W < 'a > { w : & 'a mut W , } impl < 'a > GAIN_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Time Amplifier Gain" ] # [ inline ( always ) ] pub fn gain ( & self ) -> GAIN_R { GAIN_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Time Amplifier Gain" ] # [ inline ( always ) ] pub fn gain ( & mut self ) -> GAIN_W { GAIN_W { w : self } }
}
}
# [ doc = "Offset Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [offset](offset) module" ] pub type OFFSET = crate :: Reg < u32 , _OFFSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _OFFSET ;
# [ doc = "`read()` method returns [offset::R](offset::R) reader structure" ] impl crate :: Readable for OFFSET { }
# [ doc = "`write(|w| ..)` method takes [offset::W](offset::W) writer structure" ] impl crate :: Writable for OFFSET { }
# [ doc = "Offset Register" ] pub mod offset {
# [ doc = "Reader of register OFFSET" ] pub type R = crate :: R < u32 , super :: OFFSET > ;
# [ doc = "Writer for register OFFSET" ] pub type W = crate :: W < u32 , super :: OFFSET > ;
# [ doc = "Register OFFSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: OFFSET { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `OFFSETC`" ] pub type OFFSETC_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `OFFSETC`" ] pub struct OFFSETC_W < 'a > { w : & 'a mut W , } impl < 'a > OFFSETC_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Offset Correction" ] # [ inline ( always ) ] pub fn offsetc ( & self ) -> OFFSETC_R { OFFSETC_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Offset Correction" ] # [ inline ( always ) ] pub fn offsetc ( & mut self ) -> OFFSETC_W { OFFSETC_W { w : self } }
}
}
# [ doc = "Calibration Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cal](cal) module" ] pub type CAL = crate :: Reg < u32 , _CAL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CAL ;
# [ doc = "`read()` method returns [cal::R](cal::R) reader structure" ] impl crate :: Readable for CAL { }
# [ doc = "`write(|w| ..)` method takes [cal::W](cal::W) writer structure" ] impl crate :: Writable for CAL { }
# [ doc = "Calibration Register" ] pub mod cal {
# [ doc = "Reader of register CAL" ] pub type R = crate :: R < u32 , super :: CAL > ;
# [ doc = "Writer for register CAL" ] pub type W = crate :: W < u32 , super :: CAL > ;
# [ doc = "Register CAL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CAL { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `FCAL`" ] pub type FCAL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `FCAL`" ] pub struct FCAL_W < 'a > { w : & 'a mut W , } impl < 'a > FCAL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x3f ) | ( ( value as u32 ) & 0x3f ) ; self . w } }
# [ doc = "Reader of field `TCAL`" ] pub type TCAL_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `TCAL`" ] pub struct TCAL_W < 'a > { w : & 'a mut W , } impl < 'a > TCAL_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x3f << 8 ) ) | ( ( ( value as u32 ) & 0x3f ) << 8 ) ; self . w } }
impl R {
# [ doc = "Bits 0:5 - Frequency Calibration" ] # [ inline ( always ) ] pub fn fcal ( & self ) -> FCAL_R { FCAL_R :: new ( ( self . bits & 0x3f ) as u8 ) }
# [ doc = "Bits 8:13 - Temperature Calibration" ] # [ inline ( always ) ] pub fn tcal ( & self ) -> TCAL_R { TCAL_R :: new ( ( ( self . bits >> 8 ) & 0x3f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:5 - Frequency Calibration" ] # [ inline ( always ) ] pub fn fcal ( & mut self ) -> FCAL_W { FCAL_W { w : self } }
# [ doc = "Bits 8:13 - Temperature Calibration" ] # [ inline ( always ) ] pub fn tcal ( & mut self ) -> TCAL_W { TCAL_W { w : self } }
}
}
# [ doc = "Debug Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dbgctrl](dbgctrl) module" ] pub type DBGCTRL = crate :: Reg < u8 , _DBGCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DBGCTRL ;
# [ doc = "`read()` method returns [dbgctrl::R](dbgctrl::R) reader structure" ] impl crate :: Readable for DBGCTRL { }
# [ doc = "`write(|w| ..)` method takes [dbgctrl::W](dbgctrl::W) writer structure" ] impl crate :: Writable for DBGCTRL { }
# [ doc = "Debug Control Register" ] pub mod dbgctrl {
# [ doc = "Reader of register DBGCTRL" ] pub type R = crate :: R < u8 , super :: DBGCTRL > ;
# [ doc = "Writer for register DBGCTRL" ] pub type W = crate :: W < u8 , super :: DBGCTRL > ;
# [ doc = "Register DBGCTRL `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DBGCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `DBGRUN`" ] pub type DBGRUN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DBGRUN`" ] pub struct DBGRUN_W < 'a > { w : & 'a mut W , } impl < 'a > DBGRUN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & self ) -> DBGRUN_R { DBGRUN_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Debug Run" ] # [ inline ( always ) ] pub fn dbgrun ( & mut self ) -> DBGRUN_W { DBGRUN_W { w : self } }
}
}
}
# [ doc = "Watchdog Timer" ] pub struct WDT { _marker : PhantomData < * const ( ) > } unsafe impl Send for WDT { } impl WDT { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const wdt :: RegisterBlock { 0x4000_2000 as * const _ } } impl Deref for WDT { type Target = wdt :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * WDT :: ptr ( ) } } }
# [ doc = "Watchdog Timer" ] pub mod wdt {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - Control" ] pub ctrla : CTRLA , # [ doc = "0x01 - Configuration" ] pub config : CONFIG , # [ doc = "0x02 - Early Warning Interrupt Control" ] pub ewctrl : EWCTRL , _reserved3 : [ u8 ; 1usize ] , # [ doc = "0x04 - Interrupt Enable Clear" ] pub intenclr : INTENCLR , # [ doc = "0x05 - Interrupt Enable Set" ] pub intenset : INTENSET , # [ doc = "0x06 - Interrupt Flag Status and Clear" ] pub intflag : INTFLAG , _reserved6 : [ u8 ; 1usize ] , # [ doc = "0x08 - Synchronization Busy" ] pub syncbusy : SYNCBUSY , # [ doc = "0x0c - Clear" ] pub clear : CLEAR , }
# [ doc = "Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ctrla](ctrla) module" ] pub type CTRLA = crate :: Reg < u8 , _CTRLA > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CTRLA ;
# [ doc = "`read()` method returns [ctrla::R](ctrla::R) reader structure" ] impl crate :: Readable for CTRLA { }
# [ doc = "`write(|w| ..)` method takes [ctrla::W](ctrla::W) writer structure" ] impl crate :: Writable for CTRLA { }
# [ doc = "Control" ] pub mod ctrla {
# [ doc = "Reader of register CTRLA" ] pub type R = crate :: R < u8 , super :: CTRLA > ;
# [ doc = "Writer for register CTRLA" ] pub type W = crate :: W < u8 , super :: CTRLA > ;
# [ doc = "Register CTRLA `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CTRLA { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u8 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `WEN`" ] pub type WEN_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `WEN`" ] pub struct WEN_W < 'a > { w : & 'a mut W , } impl < 'a > WEN_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u8 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `ALWAYSON`" ] pub type ALWAYSON_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ALWAYSON`" ] pub struct ALWAYSON_W < 'a > { w : & 'a mut W , } impl < 'a > ALWAYSON_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 7 ) ) | ( ( ( value as u8 ) & 0x01 ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Watchdog Timer Window Mode Enable" ] # [ inline ( always ) ] pub fn wen ( & self ) -> WEN_R { WEN_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 7 - Always-On" ] # [ inline ( always ) ] pub fn alwayson ( & self ) -> ALWAYSON_R { ALWAYSON_R :: new ( ( ( self . bits >> 7 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 2 - Watchdog Timer Window Mode Enable" ] # [ inline ( always ) ] pub fn wen ( & mut self ) -> WEN_W { WEN_W { w : self } }
# [ doc = "Bit 7 - Always-On" ] # [ inline ( always ) ] pub fn alwayson ( & mut self ) -> ALWAYSON_W { ALWAYSON_W { w : self } }
}
}
# [ doc = "Configuration\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [config](config) module" ] pub type CONFIG = crate :: Reg < u8 , _CONFIG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CONFIG ;
# [ doc = "`read()` method returns [config::R](config::R) reader structure" ] impl crate :: Readable for CONFIG { }
# [ doc = "`write(|w| ..)` method takes [config::W](config::W) writer structure" ] impl crate :: Writable for CONFIG { }
# [ doc = "Configuration" ] pub mod config {
# [ doc = "Reader of register CONFIG" ] pub type R = crate :: R < u8 , super :: CONFIG > ;
# [ doc = "Writer for register CONFIG" ] pub type W = crate :: W < u8 , super :: CONFIG > ;
# [ doc = "Register CONFIG `reset()`'s with value 0xbb" ] impl crate :: ResetValue for super :: CONFIG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0xbb } }
# [ doc = "Possible values of the field `PER`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PER_A { # [ doc = "8 clock cycles" ] CYC8 , # [ doc = "16 clock cycles" ] CYC16 , # [ doc = "32 clock cycles" ] CYC32 , # [ doc = "64 clock cycles" ] CYC64 , # [ doc = "128 clock cycles" ] CYC128 , # [ doc = "256 clock cycles" ] CYC256 , # [ doc = "512 clock cycles" ] CYC512 , # [ doc = "1024 clock cycles" ] CYC1024 , # [ doc = "2048 clock cycles" ] CYC2048 , # [ doc = "4096 clock cycles" ] CYC4096 , # [ doc = "8192 clock cycles" ] CYC8192 , # [ doc = "16384 clock cycles" ] CYC16384 }
impl crate :: ToBits < u8 > for PER_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { PER_A :: CYC8 => 0 , PER_A :: CYC16 => 1 , PER_A :: CYC32 => 2 , PER_A :: CYC64 => 3 , PER_A :: CYC128 => 4 , PER_A :: CYC256 => 5 , PER_A :: CYC512 => 6 , PER_A :: CYC1024 => 7 , PER_A :: CYC2048 => 8 , PER_A :: CYC4096 => 9 , PER_A :: CYC8192 => 10 , PER_A :: CYC16384 => 11 } } }
# [ doc = "Reader of field `PER`" ] pub type PER_R = crate :: R < u8 , PER_A > ; impl PER_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , PER_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( PER_A :: CYC8 ) , 1 => Val ( PER_A :: CYC16 ) , 2 => Val ( PER_A :: CYC32 ) , 3 => Val ( PER_A :: CYC64 ) , 4 => Val ( PER_A :: CYC128 ) , 5 => Val ( PER_A :: CYC256 ) , 6 => Val ( PER_A :: CYC512 ) , 7 => Val ( PER_A :: CYC1024 ) , 8 => Val ( PER_A :: CYC2048 ) , 9 => Val ( PER_A :: CYC4096 ) , 10 => Val ( PER_A :: CYC8192 ) , 11 => Val ( PER_A :: CYC16384 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `CYC8`" ] # [ inline ( always ) ] pub fn is_cyc8 ( & self ) -> bool { * self == PER_A :: CYC8 } # [ doc = "Checks if the value of the field is `CYC16`" ] # [ inline ( always ) ] pub fn is_cyc16 ( & self ) -> bool { * self == PER_A :: CYC16 } # [ doc = "Checks if the value of the field is `CYC32`" ] # [ inline ( always ) ] pub fn is_cyc32 ( & self ) -> bool { * self == PER_A :: CYC32 } # [ doc = "Checks if the value of the field is `CYC64`" ] # [ inline ( always ) ] pub fn is_cyc64 ( & self ) -> bool { * self == PER_A :: CYC64 } # [ doc = "Checks if the value of the field is `CYC128`" ] # [ inline ( always ) ] pub fn is_cyc128 ( & self ) -> bool { * self == PER_A :: CYC128 } # [ doc = "Checks if the value of the field is `CYC256`" ] # [ inline ( always ) ] pub fn is_cyc256 ( & self ) -> bool { * self == PER_A :: CYC256 } # [ doc = "Checks if the value of the field is `CYC512`" ] # [ inline ( always ) ] pub fn is_cyc512 ( & self ) -> bool { * self == PER_A :: CYC512 } # [ doc = "Checks if the value of the field is `CYC1024`" ] # [ inline ( always ) ] pub fn is_cyc1024 ( & self ) -> bool { * self == PER_A :: CYC1024 } # [ doc = "Checks if the value of the field is `CYC2048`" ] # [ inline ( always ) ] pub fn is_cyc2048 ( & self ) -> bool { * self == PER_A :: CYC2048 } # [ doc = "Checks if the value of the field is `CYC4096`" ] # [ inline ( always ) ] pub fn is_cyc4096 ( & self ) -> bool { * self == PER_A :: CYC4096 } # [ doc = "Checks if the value of the field is `CYC8192`" ] # [ inline ( always ) ] pub fn is_cyc8192 ( & self ) -> bool { * self == PER_A :: CYC8192 } # [ doc = "Checks if the value of the field is `CYC16384`" ] # [ inline ( always ) ] pub fn is_cyc16384 ( & self ) -> bool { * self == PER_A :: CYC16384 } }
# [ doc = "Write proxy for field `PER`" ] pub struct PER_W < 'a > { w : & 'a mut W , } impl < 'a > PER_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PER_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 clock cycles" ] # [ inline ( always ) ] pub fn cyc8 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC8 ) } # [ doc = "16 clock cycles" ] # [ inline ( always ) ] pub fn cyc16 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC16 ) } # [ doc = "32 clock cycles" ] # [ inline ( always ) ] pub fn cyc32 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC32 ) } # [ doc = "64 clock cycles" ] # [ inline ( always ) ] pub fn cyc64 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC64 ) } # [ doc = "128 clock cycles" ] # [ inline ( always ) ] pub fn cyc128 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC128 ) } # [ doc = "256 clock cycles" ] # [ inline ( always ) ] pub fn cyc256 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC256 ) } # [ doc = "512 clock cycles" ] # [ inline ( always ) ] pub fn cyc512 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC512 ) } # [ doc = "1024 clock cycles" ] # [ inline ( always ) ] pub fn cyc1024 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC1024 ) } # [ doc = "2048 clock cycles" ] # [ inline ( always ) ] pub fn cyc2048 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC2048 ) } # [ doc = "4096 clock cycles" ] # [ inline ( always ) ] pub fn cyc4096 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC4096 ) } # [ doc = "8192 clock cycles" ] # [ inline ( always ) ] pub fn cyc8192 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC8192 ) } # [ doc = "16384 clock cycles" ] # [ inline ( always ) ] pub fn cyc16384 ( self ) -> & 'a mut W { self . variant ( PER_A :: CYC16384 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } }
# [ doc = "Possible values of the field `WINDOW`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum WINDOW_A { # [ doc = "8 clock cycles" ] CYC8 , # [ doc = "16 clock cycles" ] CYC16 , # [ doc = "32 clock cycles" ] CYC32 , # [ doc = "64 clock cycles" ] CYC64 , # [ doc = "128 clock cycles" ] CYC128 , # [ doc = "256 clock cycles" ] CYC256 , # [ doc = "512 clock cycles" ] CYC512 , # [ doc = "1024 clock cycles" ] CYC1024 , # [ doc = "2048 clock cycles" ] CYC2048 , # [ doc = "4096 clock cycles" ] CYC4096 , # [ doc = "8192 clock cycles" ] CYC8192 , # [ doc = "16384 clock cycles" ] CYC16384 }
impl crate :: ToBits < u8 > for WINDOW_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { WINDOW_A :: CYC8 => 0 , WINDOW_A :: CYC16 => 1 , WINDOW_A :: CYC32 => 2 , WINDOW_A :: CYC64 => 3 , WINDOW_A :: CYC128 => 4 , WINDOW_A :: CYC256 => 5 , WINDOW_A :: CYC512 => 6 , WINDOW_A :: CYC1024 => 7 , WINDOW_A :: CYC2048 => 8 , WINDOW_A :: CYC4096 => 9 , WINDOW_A :: CYC8192 => 10 , WINDOW_A :: CYC16384 => 11 } } }
# [ doc = "Reader of field `WINDOW`" ] pub type WINDOW_R = crate :: R < u8 , WINDOW_A > ; impl WINDOW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , WINDOW_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( WINDOW_A :: CYC8 ) , 1 => Val ( WINDOW_A :: CYC16 ) , 2 => Val ( WINDOW_A :: CYC32 ) , 3 => Val ( WINDOW_A :: CYC64 ) , 4 => Val ( WINDOW_A :: CYC128 ) , 5 => Val ( WINDOW_A :: CYC256 ) , 6 => Val ( WINDOW_A :: CYC512 ) , 7 => Val ( WINDOW_A :: CYC1024 ) , 8 => Val ( WINDOW_A :: CYC2048 ) , 9 => Val ( WINDOW_A :: CYC4096 ) , 10 => Val ( WINDOW_A :: CYC8192 ) , 11 => Val ( WINDOW_A :: CYC16384 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `CYC8`" ] # [ inline ( always ) ] pub fn is_cyc8 ( & self ) -> bool { * self == WINDOW_A :: CYC8 } # [ doc = "Checks if the value of the field is `CYC16`" ] # [ inline ( always ) ] pub fn is_cyc16 ( & self ) -> bool { * self == WINDOW_A :: CYC16 } # [ doc = "Checks if the value of the field is `CYC32`" ] # [ inline ( always ) ] pub fn is_cyc32 ( & self ) -> bool { * self == WINDOW_A :: CYC32 } # [ doc = "Checks if the value of the field is `CYC64`" ] # [ inline ( always ) ] pub fn is_cyc64 ( & self ) -> bool { * self == WINDOW_A :: CYC64 } # [ doc = "Checks if the value of the field is `CYC128`" ] # [ inline ( always ) ] pub fn is_cyc128 ( & self ) -> bool { * self == WINDOW_A :: CYC128 } # [ doc = "Checks if the value of the field is `CYC256`" ] # [ inline ( always ) ] pub fn is_cyc256 ( & self ) -> bool { * self == WINDOW_A :: CYC256 } # [ doc = "Checks if the value of the field is `CYC512`" ] # [ inline ( always ) ] pub fn is_cyc512 ( & self ) -> bool { * self == WINDOW_A :: CYC512 } # [ doc = "Checks if the value of the field is `CYC1024`" ] # [ inline ( always ) ] pub fn is_cyc1024 ( & self ) -> bool { * self == WINDOW_A :: CYC1024 } # [ doc = "Checks if the value of the field is `CYC2048`" ] # [ inline ( always ) ] pub fn is_cyc2048 ( & self ) -> bool { * self == WINDOW_A :: CYC2048 } # [ doc = "Checks if the value of the field is `CYC4096`" ] # [ inline ( always ) ] pub fn is_cyc4096 ( & self ) -> bool { * self == WINDOW_A :: CYC4096 } # [ doc = "Checks if the value of the field is `CYC8192`" ] # [ inline ( always ) ] pub fn is_cyc8192 ( & self ) -> bool { * self == WINDOW_A :: CYC8192 } # [ doc = "Checks if the value of the field is `CYC16384`" ] # [ inline ( always ) ] pub fn is_cyc16384 ( & self ) -> bool { * self == WINDOW_A :: CYC16384 } }
# [ doc = "Write proxy for field `WINDOW`" ] pub struct WINDOW_W < 'a > { w : & 'a mut W , } impl < 'a > WINDOW_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : WINDOW_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 clock cycles" ] # [ inline ( always ) ] pub fn cyc8 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC8 ) } # [ doc = "16 clock cycles" ] # [ inline ( always ) ] pub fn cyc16 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC16 ) } # [ doc = "32 clock cycles" ] # [ inline ( always ) ] pub fn cyc32 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC32 ) } # [ doc = "64 clock cycles" ] # [ inline ( always ) ] pub fn cyc64 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC64 ) } # [ doc = "128 clock cycles" ] # [ inline ( always ) ] pub fn cyc128 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC128 ) } # [ doc = "256 clock cycles" ] # [ inline ( always ) ] pub fn cyc256 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC256 ) } # [ doc = "512 clock cycles" ] # [ inline ( always ) ] pub fn cyc512 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC512 ) } # [ doc = "1024 clock cycles" ] # [ inline ( always ) ] pub fn cyc1024 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC1024 ) } # [ doc = "2048 clock cycles" ] # [ inline ( always ) ] pub fn cyc2048 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC2048 ) } # [ doc = "4096 clock cycles" ] # [ inline ( always ) ] pub fn cyc4096 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC4096 ) } # [ doc = "8192 clock cycles" ] # [ inline ( always ) ] pub fn cyc8192 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC8192 ) } # [ doc = "16384 clock cycles" ] # [ inline ( always ) ] pub fn cyc16384 ( self ) -> & 'a mut W { self . variant ( WINDOW_A :: CYC16384 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x0f << 4 ) ) | ( ( ( value as u8 ) & 0x0f ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Time-Out Period" ] # [ inline ( always ) ] pub fn per ( & self ) -> PER_R { PER_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:7 - Window Mode Time-Out Period" ] # [ inline ( always ) ] pub fn window ( & self ) -> WINDOW_R { WINDOW_R :: new ( ( ( self . bits >> 4 ) & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:3 - Time-Out Period" ] # [ inline ( always ) ] pub fn per ( & mut self ) -> PER_W { PER_W { w : self } }
# [ doc = "Bits 4:7 - Window Mode Time-Out Period" ] # [ inline ( always ) ] pub fn window ( & mut self ) -> WINDOW_W { WINDOW_W { w : self } }
}
}
# [ doc = "Early Warning Interrupt Control\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ewctrl](ewctrl) module" ] pub type EWCTRL = crate :: Reg < u8 , _EWCTRL > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _EWCTRL ;
# [ doc = "`read()` method returns [ewctrl::R](ewctrl::R) reader structure" ] impl crate :: Readable for EWCTRL { }
# [ doc = "`write(|w| ..)` method takes [ewctrl::W](ewctrl::W) writer structure" ] impl crate :: Writable for EWCTRL { }
# [ doc = "Early Warning Interrupt Control" ] pub mod ewctrl {
# [ doc = "Reader of register EWCTRL" ] pub type R = crate :: R < u8 , super :: EWCTRL > ;
# [ doc = "Writer for register EWCTRL" ] pub type W = crate :: W < u8 , super :: EWCTRL > ;
# [ doc = "Register EWCTRL `reset()`'s with value 0x0b" ] impl crate :: ResetValue for super :: EWCTRL { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x0b } }
# [ doc = "Possible values of the field `EWOFFSET`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum EWOFFSET_A { # [ doc = "8 clock cycles" ] CYC8 , # [ doc = "16 clock cycles" ] CYC16 , # [ doc = "32 clock cycles" ] CYC32 , # [ doc = "64 clock cycles" ] CYC64 , # [ doc = "128 clock cycles" ] CYC128 , # [ doc = "256 clock cycles" ] CYC256 , # [ doc = "512 clock cycles" ] CYC512 , # [ doc = "1024 clock cycles" ] CYC1024 , # [ doc = "2048 clock cycles" ] CYC2048 , # [ doc = "4096 clock cycles" ] CYC4096 , # [ doc = "8192 clock cycles" ] CYC8192 , # [ doc = "16384 clock cycles" ] CYC16384 }
impl crate :: ToBits < u8 > for EWOFFSET_A { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { EWOFFSET_A :: CYC8 => 0 , EWOFFSET_A :: CYC16 => 1 , EWOFFSET_A :: CYC32 => 2 , EWOFFSET_A :: CYC64 => 3 , EWOFFSET_A :: CYC128 => 4 , EWOFFSET_A :: CYC256 => 5 , EWOFFSET_A :: CYC512 => 6 , EWOFFSET_A :: CYC1024 => 7 , EWOFFSET_A :: CYC2048 => 8 , EWOFFSET_A :: CYC4096 => 9 , EWOFFSET_A :: CYC8192 => 10 , EWOFFSET_A :: CYC16384 => 11 } } }
# [ doc = "Reader of field `EWOFFSET`" ] pub type EWOFFSET_R = crate :: R < u8 , EWOFFSET_A > ; impl EWOFFSET_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> crate :: Variant < u8 , EWOFFSET_A > { use crate :: Variant :: * ; match self . bits { 0 => Val ( EWOFFSET_A :: CYC8 ) , 1 => Val ( EWOFFSET_A :: CYC16 ) , 2 => Val ( EWOFFSET_A :: CYC32 ) , 3 => Val ( EWOFFSET_A :: CYC64 ) , 4 => Val ( EWOFFSET_A :: CYC128 ) , 5 => Val ( EWOFFSET_A :: CYC256 ) , 6 => Val ( EWOFFSET_A :: CYC512 ) , 7 => Val ( EWOFFSET_A :: CYC1024 ) , 8 => Val ( EWOFFSET_A :: CYC2048 ) , 9 => Val ( EWOFFSET_A :: CYC4096 ) , 10 => Val ( EWOFFSET_A :: CYC8192 ) , 11 => Val ( EWOFFSET_A :: CYC16384 ) , i => Res ( i ) } } # [ doc = "Checks if the value of the field is `CYC8`" ] # [ inline ( always ) ] pub fn is_cyc8 ( & self ) -> bool { * self == EWOFFSET_A :: CYC8 } # [ doc = "Checks if the value of the field is `CYC16`" ] # [ inline ( always ) ] pub fn is_cyc16 ( & self ) -> bool { * self == EWOFFSET_A :: CYC16 } # [ doc = "Checks if the value of the field is `CYC32`" ] # [ inline ( always ) ] pub fn is_cyc32 ( & self ) -> bool { * self == EWOFFSET_A :: CYC32 } # [ doc = "Checks if the value of the field is `CYC64`" ] # [ inline ( always ) ] pub fn is_cyc64 ( & self ) -> bool { * self == EWOFFSET_A :: CYC64 } # [ doc = "Checks if the value of the field is `CYC128`" ] # [ inline ( always ) ] pub fn is_cyc128 ( & self ) -> bool { * self == EWOFFSET_A :: CYC128 } # [ doc = "Checks if the value of the field is `CYC256`" ] # [ inline ( always ) ] pub fn is_cyc256 ( & self ) -> bool { * self == EWOFFSET_A :: CYC256 } # [ doc = "Checks if the value of the field is `CYC512`" ] # [ inline ( always ) ] pub fn is_cyc512 ( & self ) -> bool { * self == EWOFFSET_A :: CYC512 } # [ doc = "Checks if the value of the field is `CYC1024`" ] # [ inline ( always ) ] pub fn is_cyc1024 ( & self ) -> bool { * self == EWOFFSET_A :: CYC1024 } # [ doc = "Checks if the value of the field is `CYC2048`" ] # [ inline ( always ) ] pub fn is_cyc2048 ( & self ) -> bool { * self == EWOFFSET_A :: CYC2048 } # [ doc = "Checks if the value of the field is `CYC4096`" ] # [ inline ( always ) ] pub fn is_cyc4096 ( & self ) -> bool { * self == EWOFFSET_A :: CYC4096 } # [ doc = "Checks if the value of the field is `CYC8192`" ] # [ inline ( always ) ] pub fn is_cyc8192 ( & self ) -> bool { * self == EWOFFSET_A :: CYC8192 } # [ doc = "Checks if the value of the field is `CYC16384`" ] # [ inline ( always ) ] pub fn is_cyc16384 ( & self ) -> bool { * self == EWOFFSET_A :: CYC16384 } }
# [ doc = "Write proxy for field `EWOFFSET`" ] pub struct EWOFFSET_W < 'a > { w : & 'a mut W , } impl < 'a > EWOFFSET_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : EWOFFSET_A ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "8 clock cycles" ] # [ inline ( always ) ] pub fn cyc8 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC8 ) } # [ doc = "16 clock cycles" ] # [ inline ( always ) ] pub fn cyc16 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC16 ) } # [ doc = "32 clock cycles" ] # [ inline ( always ) ] pub fn cyc32 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC32 ) } # [ doc = "64 clock cycles" ] # [ inline ( always ) ] pub fn cyc64 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC64 ) } # [ doc = "128 clock cycles" ] # [ inline ( always ) ] pub fn cyc128 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC128 ) } # [ doc = "256 clock cycles" ] # [ inline ( always ) ] pub fn cyc256 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC256 ) } # [ doc = "512 clock cycles" ] # [ inline ( always ) ] pub fn cyc512 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC512 ) } # [ doc = "1024 clock cycles" ] # [ inline ( always ) ] pub fn cyc1024 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC1024 ) } # [ doc = "2048 clock cycles" ] # [ inline ( always ) ] pub fn cyc2048 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC2048 ) } # [ doc = "4096 clock cycles" ] # [ inline ( always ) ] pub fn cyc4096 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC4096 ) } # [ doc = "8192 clock cycles" ] # [ inline ( always ) ] pub fn cyc8192 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC8192 ) } # [ doc = "16384 clock cycles" ] # [ inline ( always ) ] pub fn cyc16384 ( self ) -> & 'a mut W { self . variant ( EWOFFSET_A :: CYC16384 ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x0f ) | ( ( value as u8 ) & 0x0f ) ; self . w } }
impl R {
# [ doc = "Bits 0:3 - Early Warning Interrupt Time Offset" ] # [ inline ( always ) ] pub fn ewoffset ( & self ) -> EWOFFSET_R { EWOFFSET_R :: new ( ( self . bits & 0x0f ) as u8 ) }
}
impl W {
# [ doc = "Bits 0:3 - Early Warning Interrupt Time Offset" ] # [ inline ( always ) ] pub fn ewoffset ( & mut self ) -> EWOFFSET_W { EWOFFSET_W { w : self } }
}
}
# [ doc = "Interrupt Enable Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenclr](intenclr) module" ] pub type INTENCLR = crate :: Reg < u8 , _INTENCLR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENCLR ;
# [ doc = "`read()` method returns [intenclr::R](intenclr::R) reader structure" ] impl crate :: Readable for INTENCLR { }
# [ doc = "`write(|w| ..)` method takes [intenclr::W](intenclr::W) writer structure" ] impl crate :: Writable for INTENCLR { }
# [ doc = "Interrupt Enable Clear" ] pub mod intenclr {
# [ doc = "Reader of register INTENCLR" ] pub type R = crate :: R < u8 , super :: INTENCLR > ;
# [ doc = "Writer for register INTENCLR" ] pub type W = crate :: W < u8 , super :: INTENCLR > ;
# [ doc = "Register INTENCLR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENCLR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EW`" ] pub type EW_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EW`" ] pub struct EW_W < 'a > { w : & 'a mut W , } impl < 'a > EW_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Early Warning Interrupt Enable" ] # [ inline ( always ) ] pub fn ew ( & self ) -> EW_R { EW_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Early Warning Interrupt Enable" ] # [ inline ( always ) ] pub fn ew ( & mut self ) -> EW_W { EW_W { w : self } }
}
}
# [ doc = "Interrupt Enable Set\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intenset](intenset) module" ] pub type INTENSET = crate :: Reg < u8 , _INTENSET > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTENSET ;
# [ doc = "`read()` method returns [intenset::R](intenset::R) reader structure" ] impl crate :: Readable for INTENSET { }
# [ doc = "`write(|w| ..)` method takes [intenset::W](intenset::W) writer structure" ] impl crate :: Writable for INTENSET { }
# [ doc = "Interrupt Enable Set" ] pub mod intenset {
# [ doc = "Reader of register INTENSET" ] pub type R = crate :: R < u8 , super :: INTENSET > ;
# [ doc = "Writer for register INTENSET" ] pub type W = crate :: W < u8 , super :: INTENSET > ;
# [ doc = "Register INTENSET `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTENSET { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EW`" ] pub type EW_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EW`" ] pub struct EW_W < 'a > { w : & 'a mut W , } impl < 'a > EW_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Early Warning Interrupt Enable" ] # [ inline ( always ) ] pub fn ew ( & self ) -> EW_R { EW_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Early Warning Interrupt Enable" ] # [ inline ( always ) ] pub fn ew ( & mut self ) -> EW_W { EW_W { w : self } }
}
}
# [ doc = "Interrupt Flag Status and Clear\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [intflag](intflag) module" ] pub type INTFLAG = crate :: Reg < u8 , _INTFLAG > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _INTFLAG ;
# [ doc = "`read()` method returns [intflag::R](intflag::R) reader structure" ] impl crate :: Readable for INTFLAG { }
# [ doc = "`write(|w| ..)` method takes [intflag::W](intflag::W) writer structure" ] impl crate :: Writable for INTFLAG { }
# [ doc = "Interrupt Flag Status and Clear" ] pub mod intflag {
# [ doc = "Reader of register INTFLAG" ] pub type R = crate :: R < u8 , super :: INTFLAG > ;
# [ doc = "Writer for register INTFLAG" ] pub type W = crate :: W < u8 , super :: INTFLAG > ;
# [ doc = "Register INTFLAG `reset()`'s with value 0" ] impl crate :: ResetValue for super :: INTFLAG { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `EW`" ] pub type EW_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EW`" ] pub struct EW_W < 'a > { w : & 'a mut W , } impl < 'a > EW_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u8 ) & 0x01 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Early Warning" ] # [ inline ( always ) ] pub fn ew ( & self ) -> EW_R { EW_R :: new ( ( self . bits & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Early Warning" ] # [ inline ( always ) ] pub fn ew ( & mut self ) -> EW_W { EW_W { w : self } }
}
}
# [ doc = "Synchronization Busy\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [syncbusy](syncbusy) module" ] pub type SYNCBUSY = crate :: Reg < u32 , _SYNCBUSY > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SYNCBUSY ;
# [ doc = "`read()` method returns [syncbusy::R](syncbusy::R) reader structure" ] impl crate :: Readable for SYNCBUSY { }
# [ doc = "Synchronization Busy" ] pub mod syncbusy {
# [ doc = "Reader of register SYNCBUSY" ] pub type R = crate :: R < u32 , super :: SYNCBUSY > ;
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `WEN`" ] pub type WEN_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `ALWAYSON`" ] pub type ALWAYSON_R = crate :: R < bool , bool > ;
# [ doc = "Reader of field `CLEAR`" ] pub type CLEAR_R = crate :: R < bool , bool > ;
impl R {
# [ doc = "Bit 1 - Enable Busy" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Window Enable Busy" ] # [ inline ( always ) ] pub fn wen ( & self ) -> WEN_R { WEN_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Always-On Busy" ] # [ inline ( always ) ] pub fn alwayson ( & self ) -> ALWAYSON_R { ALWAYSON_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Clear Busy" ] # [ inline ( always ) ] pub fn clear ( & self ) -> CLEAR_R { CLEAR_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "Clear\n\nThis register you can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [clear](clear) module" ] pub type CLEAR = crate :: Reg < u8 , _CLEAR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CLEAR ;
# [ doc = "`write(|w| ..)` method takes [clear::W](clear::W) writer structure" ] impl crate :: Writable for CLEAR { }
# [ doc = "Clear" ] pub mod clear {
# [ doc = "Writer for register CLEAR" ] pub type W = crate :: W < u8 , super :: CLEAR > ;
# [ doc = "Register CLEAR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CLEAR { type Type = u8 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `CLEAR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CLEAR_AW { # [ doc = "Clear Key" ] KEY }
impl crate :: ToBits < u8 > for CLEAR_AW { # [ inline ( always ) ] fn _bits ( & self ) -> u8 { match * self { CLEAR_AW :: KEY => 165 } } }
# [ doc = "Write proxy for field `CLEAR`" ] pub struct CLEAR_W < 'a > { w : & 'a mut W , } impl < 'a > CLEAR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLEAR_AW ) -> & 'a mut W { use crate :: ToBits ; unsafe { self . bits ( variant . _bits ( ) ) } } # [ doc = "Clear Key" ] # [ inline ( always ) ] pub fn key ( self ) -> & 'a mut W { self . variant ( CLEAR_AW :: KEY ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0xff ) | ( ( value as u8 ) & 0xff ) ; self . w } }
impl W {
# [ doc = "Bits 0:7 - Watchdog Clear" ] # [ inline ( always ) ] pub fn clear ( & mut self ) -> CLEAR_W { CLEAR_W { w : self } }
}
}
}
# [ doc = "System timer" ] pub struct SYSTICK { _marker : PhantomData < * const ( ) > } unsafe impl Send for SYSTICK { } impl SYSTICK { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const sys_tick :: RegisterBlock { 0xe000_e010 as * const _ } } impl Deref for SYSTICK { type Target = sys_tick :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SYSTICK :: ptr ( ) } } }
# [ doc = "System timer" ] pub mod sys_tick {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { # [ doc = "0x00 - SysTick Control and Status Register" ] pub csr : CSR , # [ doc = "0x04 - SysTick Reload Value Register" ] pub rvr : RVR , # [ doc = "0x08 - SysTick Current Value Register" ] pub cvr : CVR , # [ doc = "0x0c - SysTick Calibration Value Register" ] pub calib : CALIB , }
# [ doc = "SysTick Control and Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [csr](csr) module" ] pub type CSR = crate :: Reg < u32 , _CSR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CSR ;
# [ doc = "`read()` method returns [csr::R](csr::R) reader structure" ] impl crate :: Readable for CSR { }
# [ doc = "`write(|w| ..)` method takes [csr::W](csr::W) writer structure" ] impl crate :: Writable for CSR { }
# [ doc = "SysTick Control and Status Register" ] pub mod csr {
# [ doc = "Reader of register CSR" ] pub type R = crate :: R < u32 , super :: CSR > ;
# [ doc = "Writer for register CSR" ] pub type W = crate :: W < u32 , super :: CSR > ;
# [ doc = "Register CSR `reset()`'s with value 0x04" ] impl crate :: ResetValue for super :: CSR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0x04 } }
# [ doc = "Possible values of the field `ENABLE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENABLE_A { # [ doc = "Counter disabled" ] VALUE_0 , # [ doc = "Counter enabled" ] VALUE_1 }
impl crate :: ToBits < bool > for ENABLE_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { ENABLE_A :: VALUE_0 => false , ENABLE_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `ENABLE`" ] pub type ENABLE_R = crate :: R < bool , ENABLE_A > ; impl ENABLE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ENABLE_A { match self . bits { false => ENABLE_A :: VALUE_0 , true => ENABLE_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == ENABLE_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == ENABLE_A :: VALUE_1 } }
# [ doc = "Write proxy for field `ENABLE`" ] pub struct ENABLE_W < 'a > { w : & 'a mut W , } impl < 'a > ENABLE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ENABLE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Counter disabled" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( ENABLE_A :: VALUE_0 ) } # [ doc = "Counter enabled" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( ENABLE_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Possible values of the field `TICKINT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum TICKINT_A { # [ doc = "Counting down to 0 does not assert the SysTick exception request" ] VALUE_0 , # [ doc = "Counting down to 0 asserts the SysTick exception request" ] VALUE_1 }
impl crate :: ToBits < bool > for TICKINT_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { TICKINT_A :: VALUE_0 => false , TICKINT_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `TICKINT`" ] pub type TICKINT_R = crate :: R < bool , TICKINT_A > ; impl TICKINT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> TICKINT_A { match self . bits { false => TICKINT_A :: VALUE_0 , true => TICKINT_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == TICKINT_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == TICKINT_A :: VALUE_1 } }
# [ doc = "Write proxy for field `TICKINT`" ] pub struct TICKINT_W < 'a > { w : & 'a mut W , } impl < 'a > TICKINT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : TICKINT_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Counting down to 0 does not assert the SysTick exception request" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( TICKINT_A :: VALUE_0 ) } # [ doc = "Counting down to 0 asserts the SysTick exception request" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( TICKINT_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Possible values of the field `CLKSOURCE`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum CLKSOURCE_A { # [ doc = "External clock" ] VALUE_0 , # [ doc = "Processor clock" ] VALUE_1 }
impl crate :: ToBits < bool > for CLKSOURCE_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { CLKSOURCE_A :: VALUE_0 => false , CLKSOURCE_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `CLKSOURCE`" ] pub type CLKSOURCE_R = crate :: R < bool , CLKSOURCE_A > ; impl CLKSOURCE_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> CLKSOURCE_A { match self . bits { false => CLKSOURCE_A :: VALUE_0 , true => CLKSOURCE_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == CLKSOURCE_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == CLKSOURCE_A :: VALUE_1 } }
# [ doc = "Write proxy for field `CLKSOURCE`" ] pub struct CLKSOURCE_W < 'a > { w : & 'a mut W , } impl < 'a > CLKSOURCE_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : CLKSOURCE_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "External clock" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( CLKSOURCE_A :: VALUE_0 ) } # [ doc = "Processor clock" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( CLKSOURCE_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `COUNTFLAG`" ] pub type COUNTFLAG_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `COUNTFLAG`" ] pub struct COUNTFLAG_W < 'a > { w : & 'a mut W , } impl < 'a > COUNTFLAG_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 16 ) ) | ( ( ( value as u32 ) & 0x01 ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - SysTick Counter Enable" ] # [ inline ( always ) ] pub fn enable ( & self ) -> ENABLE_R { ENABLE_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - SysTick Exception Request Enable" ] # [ inline ( always ) ] pub fn tickint ( & self ) -> TICKINT_R { TICKINT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Clock Source 0=external, 1=processor" ] # [ inline ( always ) ] pub fn clksource ( & self ) -> CLKSOURCE_R { CLKSOURCE_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 16 - Timer counted to 0 since last read of register" ] # [ inline ( always ) ] pub fn countflag ( & self ) -> COUNTFLAG_R { COUNTFLAG_R :: new ( ( ( self . bits >> 16 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - SysTick Counter Enable" ] # [ inline ( always ) ] pub fn enable ( & mut self ) -> ENABLE_W { ENABLE_W { w : self } }
# [ doc = "Bit 1 - SysTick Exception Request Enable" ] # [ inline ( always ) ] pub fn tickint ( & mut self ) -> TICKINT_W { TICKINT_W { w : self } }
# [ doc = "Bit 2 - Clock Source 0=external, 1=processor" ] # [ inline ( always ) ] pub fn clksource ( & mut self ) -> CLKSOURCE_W { CLKSOURCE_W { w : self } }
# [ doc = "Bit 16 - Timer counted to 0 since last read of register" ] # [ inline ( always ) ] pub fn countflag ( & mut self ) -> COUNTFLAG_W { COUNTFLAG_W { w : self } }
}
}
# [ doc = "SysTick Reload Value Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [rvr](rvr) module" ] pub type RVR = crate :: Reg < u32 , _RVR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _RVR ;
# [ doc = "`read()` method returns [rvr::R](rvr::R) reader structure" ] impl crate :: Readable for RVR { }
# [ doc = "`write(|w| ..)` method takes [rvr::W](rvr::W) writer structure" ] impl crate :: Writable for RVR { }
# [ doc = "SysTick Reload Value Register" ] pub mod rvr {
# [ doc = "Reader of register RVR" ] pub type R = crate :: R < u32 , super :: RVR > ;
# [ doc = "Writer for register RVR" ] pub type W = crate :: W < u32 , super :: RVR > ;
# [ doc = "Register RVR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: RVR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `RELOAD`" ] pub type RELOAD_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `RELOAD`" ] pub struct RELOAD_W < 'a > { w : & 'a mut W , } impl < 'a > RELOAD_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Value to load into the SysTick Current Value Register when the counter reaches 0" ] # [ inline ( always ) ] pub fn reload ( & self ) -> RELOAD_R { RELOAD_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Value to load into the SysTick Current Value Register when the counter reaches 0" ] # [ inline ( always ) ] pub fn reload ( & mut self ) -> RELOAD_W { RELOAD_W { w : self } }
}
}
# [ doc = "SysTick Current Value Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cvr](cvr) module" ] pub type CVR = crate :: Reg < u32 , _CVR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CVR ;
# [ doc = "`read()` method returns [cvr::R](cvr::R) reader structure" ] impl crate :: Readable for CVR { }
# [ doc = "`write(|w| ..)` method takes [cvr::W](cvr::W) writer structure" ] impl crate :: Writable for CVR { }
# [ doc = "SysTick Current Value Register" ] pub mod cvr {
# [ doc = "Reader of register CVR" ] pub type R = crate :: R < u32 , super :: CVR > ;
# [ doc = "Writer for register CVR" ] pub type W = crate :: W < u32 , super :: CVR > ;
# [ doc = "Register CVR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: CVR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `CURRENT`" ] pub type CURRENT_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `CURRENT`" ] pub struct CURRENT_W < 'a > { w : & 'a mut W , } impl < 'a > CURRENT_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x00ff_ffff ) | ( ( value as u32 ) & 0x00ff_ffff ) ; self . w } }
impl R {
# [ doc = "Bits 0:23 - Current value at the time the register is accessed" ] # [ inline ( always ) ] pub fn current ( & self ) -> CURRENT_R { CURRENT_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 0:23 - Current value at the time the register is accessed" ] # [ inline ( always ) ] pub fn current ( & mut self ) -> CURRENT_W { CURRENT_W { w : self } }
}
}
# [ doc = "SysTick Calibration Value Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [calib](calib) module" ] pub type CALIB = crate :: Reg < u32 , _CALIB > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CALIB ;
# [ doc = "`read()` method returns [calib::R](calib::R) reader structure" ] impl crate :: Readable for CALIB { }
# [ doc = "SysTick Calibration Value Register" ] pub mod calib {
# [ doc = "Reader of register CALIB" ] pub type R = crate :: R < u32 , super :: CALIB > ;
# [ doc = "Reader of field `TENMS`" ] pub type TENMS_R = crate :: R < u32 , u32 > ;
# [ doc = "Possible values of the field `SKEW`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SKEW_A { # [ doc = "10ms calibration value is exact" ] VALUE_0 , # [ doc = "10ms calibration value is inexact, because of the clock frequency" ] VALUE_1 }
impl crate :: ToBits < bool > for SKEW_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { SKEW_A :: VALUE_0 => false , SKEW_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `SKEW`" ] pub type SKEW_R = crate :: R < bool , SKEW_A > ; impl SKEW_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SKEW_A { match self . bits { false => SKEW_A :: VALUE_0 , true => SKEW_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == SKEW_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == SKEW_A :: VALUE_1 } }
# [ doc = "Possible values of the field `NOREF`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NOREF_A { # [ doc = "The reference clock is provided" ] VALUE_0 , # [ doc = "The reference clock is not provided" ] VALUE_1 }
impl crate :: ToBits < bool > for NOREF_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { NOREF_A :: VALUE_0 => false , NOREF_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `NOREF`" ] pub type NOREF_R = crate :: R < bool , NOREF_A > ; impl NOREF_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NOREF_A { match self . bits { false => NOREF_A :: VALUE_0 , true => NOREF_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == NOREF_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == NOREF_A :: VALUE_1 } }
impl R {
# [ doc = "Bits 0:23 - Reload value to use for 10ms timing" ] # [ inline ( always ) ] pub fn tenms ( & self ) -> TENMS_R { TENMS_R :: new ( ( self . bits & 0x00ff_ffff ) as u32 ) }
# [ doc = "Bit 30 - TENMS is rounded from non-integer ratio" ] # [ inline ( always ) ] pub fn skew ( & self ) -> SKEW_R { SKEW_R :: new ( ( ( self . bits >> 30 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - No Separate Reference Clock" ] # [ inline ( always ) ] pub fn noref ( & self ) -> NOREF_R { NOREF_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
}
}
# [ doc = "System Control Registers" ] pub struct SYSTEMCONTROL { _marker : PhantomData < * const ( ) > } unsafe impl Send for SYSTEMCONTROL { } impl SYSTEMCONTROL { # [ doc = r"Returns a pointer to the register block" ] # [ inline ( always ) ] pub const fn ptr ( ) -> * const system_control :: RegisterBlock { 0xe000_e000 as * const _ } } impl Deref for SYSTEMCONTROL { type Target = system_control :: RegisterBlock ; fn deref ( & self ) -> & Self :: Target { unsafe { & * SYSTEMCONTROL :: ptr ( ) } } }
# [ doc = "System Control Registers" ] pub mod system_control {
# [ doc = r"Register block" ] # [ repr ( C ) ] pub struct RegisterBlock { _reserved0 : [ u8 ; 3328usize ] , # [ doc = "0xd00 - CPUID Base Register" ] pub cpuid : CPUID , # [ doc = "0xd04 - Interrupt Control and State Register" ] pub icsr : ICSR , # [ doc = "0xd08 - Vector Table Offset Register" ] pub vtor : VTOR , # [ doc = "0xd0c - Application Interrupt and Reset Control Register" ] pub aircr : AIRCR , # [ doc = "0xd10 - System Control Register" ] pub scr : SCR , # [ doc = "0xd14 - Configuration and Control Register" ] pub ccr : CCR , _reserved6 : [ u8 ; 4usize ] , # [ doc = "0xd1c - System Handler Priority Register 2" ] pub shpr2 : SHPR2 , # [ doc = "0xd20 - System Handler Priority Register 3" ] pub shpr3 : SHPR3 , # [ doc = "0xd24 - System Handler Control and State Register" ] pub shcsr : SHCSR , _reserved9 : [ u8 ; 8usize ] , # [ doc = "0xd30 - Debug Fault Status Register" ] pub dfsr : DFSR , }
# [ doc = "CPUID Base Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [cpuid](cpuid) module" ] pub type CPUID = crate :: Reg < u32 , _CPUID > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CPUID ;
# [ doc = "`read()` method returns [cpuid::R](cpuid::R) reader structure" ] impl crate :: Readable for CPUID { }
# [ doc = "CPUID Base Register" ] pub mod cpuid {
# [ doc = "Reader of register CPUID" ] pub type R = crate :: R < u32 , super :: CPUID > ;
# [ doc = "Reader of field `REVISION`" ] pub type REVISION_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `PARTNO`" ] pub type PARTNO_R = crate :: R < u16 , u16 > ;
# [ doc = "Reader of field `ARCHITECTURE`" ] pub type ARCHITECTURE_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `VARIANT`" ] pub type VARIANT_R = crate :: R < u8 , u8 > ;
# [ doc = "Reader of field `IMPLEMENTER`" ] pub type IMPLEMENTER_R = crate :: R < u8 , u8 > ;
impl R {
# [ doc = "Bits 0:3 - Minor revision number" ] # [ inline ( always ) ] pub fn revision ( & self ) -> REVISION_R { REVISION_R :: new ( ( self . bits & 0x0f ) as u8 ) }
# [ doc = "Bits 4:15 - Processor Part Number, 0xC60=Cortex-M0+" ] # [ inline ( always ) ] pub fn partno ( & self ) -> PARTNO_R { PARTNO_R :: new ( ( ( self . bits >> 4 ) & 0x0fff ) as u16 ) }
# [ doc = "Bits 16:19 - Processor Architecture, 0xC=ARMv6-M" ] # [ inline ( always ) ] pub fn architecture ( & self ) -> ARCHITECTURE_R { ARCHITECTURE_R :: new ( ( ( self . bits >> 16 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 20:23 - Major revision number" ] # [ inline ( always ) ] pub fn variant ( & self ) -> VARIANT_R { VARIANT_R :: new ( ( ( self . bits >> 20 ) & 0x0f ) as u8 ) }
# [ doc = "Bits 24:31 - Implementer code, ARM=0x41" ] # [ inline ( always ) ] pub fn implementer ( & self ) -> IMPLEMENTER_R { IMPLEMENTER_R :: new ( ( ( self . bits >> 24 ) & 0xff ) as u8 ) }
}
}
# [ doc = "Interrupt Control and State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [icsr](icsr) module" ] pub type ICSR = crate :: Reg < u32 , _ICSR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _ICSR ;
# [ doc = "`read()` method returns [icsr::R](icsr::R) reader structure" ] impl crate :: Readable for ICSR { }
# [ doc = "`write(|w| ..)` method takes [icsr::W](icsr::W) writer structure" ] impl crate :: Writable for ICSR { }
# [ doc = "Interrupt Control and State Register" ] pub mod icsr {
# [ doc = "Reader of register ICSR" ] pub type R = crate :: R < u32 , super :: ICSR > ;
# [ doc = "Writer for register ICSR" ] pub type W = crate :: W < u32 , super :: ICSR > ;
# [ doc = "Register ICSR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: ICSR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `VECTACTIVE`" ] pub type VECTACTIVE_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `VECTACTIVE`" ] pub struct VECTACTIVE_W < 'a > { w : & 'a mut W , } impl < 'a > VECTACTIVE_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01ff ) | ( ( value as u32 ) & 0x01ff ) ; self . w } }
# [ doc = "Reader of field `VECTPENDING`" ] pub type VECTPENDING_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `VECTPENDING`" ] pub struct VECTPENDING_W < 'a > { w : & 'a mut W , } impl < 'a > VECTPENDING_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff << 12 ) ) | ( ( ( value as u32 ) & 0x01ff ) << 12 ) ; self . w } }
# [ doc = "Reader of field `ISRPENDING`" ] pub type ISRPENDING_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ISRPENDING`" ] pub struct ISRPENDING_W < 'a > { w : & 'a mut W , } impl < 'a > ISRPENDING_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 22 ) ) | ( ( ( value as u32 ) & 0x01 ) << 22 ) ; self . w } }
# [ doc = "Reader of field `ISRPREEMPT`" ] pub type ISRPREEMPT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `ISRPREEMPT`" ] pub struct ISRPREEMPT_W < 'a > { w : & 'a mut W , } impl < 'a > ISRPREEMPT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 23 ) ) | ( ( ( value as u32 ) & 0x01 ) << 23 ) ; self . w } }
# [ doc = "Possible values of the field `PENDSTCLR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PENDSTCLR_A { # [ doc = "No effect" ] VALUE_0 , # [ doc = "Removes the pending state from the SysTick exception" ] VALUE_1 }
impl crate :: ToBits < bool > for PENDSTCLR_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { PENDSTCLR_A :: VALUE_0 => false , PENDSTCLR_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `PENDSTCLR`" ] pub type PENDSTCLR_R = crate :: R < bool , PENDSTCLR_A > ; impl PENDSTCLR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PENDSTCLR_A { match self . bits { false => PENDSTCLR_A :: VALUE_0 , true => PENDSTCLR_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == PENDSTCLR_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == PENDSTCLR_A :: VALUE_1 } }
# [ doc = "Write proxy for field `PENDSTCLR`" ] pub struct PENDSTCLR_W < 'a > { w : & 'a mut W , } impl < 'a > PENDSTCLR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PENDSTCLR_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "No effect" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( PENDSTCLR_A :: VALUE_0 ) } # [ doc = "Removes the pending state from the SysTick exception" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( PENDSTCLR_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 25 ) ) | ( ( ( value as u32 ) & 0x01 ) << 25 ) ; self . w } }
# [ doc = "Possible values of the field `PENDSTSET`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PENDSTSET_A { # [ doc = "Write: no effect; read: SysTick exception is not pending" ] VALUE_0 , # [ doc = "Write: changes SysTick exception state to pending; read: SysTick exception is pending" ] VALUE_1 }
impl crate :: ToBits < bool > for PENDSTSET_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { PENDSTSET_A :: VALUE_0 => false , PENDSTSET_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `PENDSTSET`" ] pub type PENDSTSET_R = crate :: R < bool , PENDSTSET_A > ; impl PENDSTSET_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PENDSTSET_A { match self . bits { false => PENDSTSET_A :: VALUE_0 , true => PENDSTSET_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == PENDSTSET_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == PENDSTSET_A :: VALUE_1 } }
# [ doc = "Write proxy for field `PENDSTSET`" ] pub struct PENDSTSET_W < 'a > { w : & 'a mut W , } impl < 'a > PENDSTSET_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PENDSTSET_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Write: no effect; read: SysTick exception is not pending" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( PENDSTSET_A :: VALUE_0 ) } # [ doc = "Write: changes SysTick exception state to pending; read: SysTick exception is pending" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( PENDSTSET_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 26 ) ) | ( ( ( value as u32 ) & 0x01 ) << 26 ) ; self . w } }
# [ doc = "Possible values of the field `PENDSVCLR`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PENDSVCLR_A { # [ doc = "No effect" ] VALUE_0 , # [ doc = "Removes the pending state from the PendSV exception" ] VALUE_1 }
impl crate :: ToBits < bool > for PENDSVCLR_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { PENDSVCLR_A :: VALUE_0 => false , PENDSVCLR_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `PENDSVCLR`" ] pub type PENDSVCLR_R = crate :: R < bool , PENDSVCLR_A > ; impl PENDSVCLR_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PENDSVCLR_A { match self . bits { false => PENDSVCLR_A :: VALUE_0 , true => PENDSVCLR_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == PENDSVCLR_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == PENDSVCLR_A :: VALUE_1 } }
# [ doc = "Write proxy for field `PENDSVCLR`" ] pub struct PENDSVCLR_W < 'a > { w : & 'a mut W , } impl < 'a > PENDSVCLR_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PENDSVCLR_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "No effect" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( PENDSVCLR_A :: VALUE_0 ) } # [ doc = "Removes the pending state from the PendSV exception" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( PENDSVCLR_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 27 ) ) | ( ( ( value as u32 ) & 0x01 ) << 27 ) ; self . w } }
# [ doc = "Possible values of the field `PENDSVSET`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum PENDSVSET_A { # [ doc = "Write: no effect; read: PendSV exception is not pending" ] VALUE_0 , # [ doc = "Write: changes PendSV exception state to pending; read: PendSV exception is pending" ] VALUE_1 }
impl crate :: ToBits < bool > for PENDSVSET_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { PENDSVSET_A :: VALUE_0 => false , PENDSVSET_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `PENDSVSET`" ] pub type PENDSVSET_R = crate :: R < bool , PENDSVSET_A > ; impl PENDSVSET_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> PENDSVSET_A { match self . bits { false => PENDSVSET_A :: VALUE_0 , true => PENDSVSET_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == PENDSVSET_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == PENDSVSET_A :: VALUE_1 } }
# [ doc = "Write proxy for field `PENDSVSET`" ] pub struct PENDSVSET_W < 'a > { w : & 'a mut W , } impl < 'a > PENDSVSET_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : PENDSVSET_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Write: no effect; read: PendSV exception is not pending" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( PENDSVSET_A :: VALUE_0 ) } # [ doc = "Write: changes PendSV exception state to pending; read: PendSV exception is pending" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( PENDSVSET_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 28 ) ) | ( ( ( value as u32 ) & 0x01 ) << 28 ) ; self . w } }
# [ doc = "Possible values of the field `NMIPENDSET`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum NMIPENDSET_A { # [ doc = "Write: no effect; read: NMI exception is not pending" ] VALUE_0 , # [ doc = "Write: changes NMI exception state to pending; read: NMI exception is pending" ] VALUE_1 }
impl crate :: ToBits < bool > for NMIPENDSET_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { NMIPENDSET_A :: VALUE_0 => false , NMIPENDSET_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `NMIPENDSET`" ] pub type NMIPENDSET_R = crate :: R < bool , NMIPENDSET_A > ; impl NMIPENDSET_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> NMIPENDSET_A { match self . bits { false => NMIPENDSET_A :: VALUE_0 , true => NMIPENDSET_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == NMIPENDSET_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == NMIPENDSET_A :: VALUE_1 } }
# [ doc = "Write proxy for field `NMIPENDSET`" ] pub struct NMIPENDSET_W < 'a > { w : & 'a mut W , } impl < 'a > NMIPENDSET_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : NMIPENDSET_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Write: no effect; read: NMI exception is not pending" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( NMIPENDSET_A :: VALUE_0 ) } # [ doc = "Write: changes NMI exception state to pending; read: NMI exception is pending" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( NMIPENDSET_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 31 ) ) | ( ( ( value as u32 ) & 0x01 ) << 31 ) ; self . w } }
impl R {
# [ doc = "Bits 0:8 - Debug: Exception number of currently executing exception, or 0 if thread mode" ] # [ inline ( always ) ] pub fn vectactive ( & self ) -> VECTACTIVE_R { VECTACTIVE_R :: new ( ( self . bits & 0x01ff ) as u16 ) }
# [ doc = "Bits 12:20 - Exception number of the highest priority pending enabled exception" ] # [ inline ( always ) ] pub fn vectpending ( & self ) -> VECTPENDING_R { VECTPENDING_R :: new ( ( ( self . bits >> 12 ) & 0x01ff ) as u16 ) }
# [ doc = "Bit 22 - Debug: NVIC interrupt pending" ] # [ inline ( always ) ] pub fn isrpending ( & self ) -> ISRPENDING_R { ISRPENDING_R :: new ( ( ( self . bits >> 22 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 23 - Debug: Pending exception serviced on exit from debug halt" ] # [ inline ( always ) ] pub fn isrpreempt ( & self ) -> ISRPREEMPT_R { ISRPREEMPT_R :: new ( ( ( self . bits >> 23 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 25 - SysTick exception clear-pending bit" ] # [ inline ( always ) ] pub fn pendstclr ( & self ) -> PENDSTCLR_R { PENDSTCLR_R :: new ( ( ( self . bits >> 25 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 26 - SysTick exception set-pending bit" ] # [ inline ( always ) ] pub fn pendstset ( & self ) -> PENDSTSET_R { PENDSTSET_R :: new ( ( ( self . bits >> 26 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 27 - PendSV clear-pending bit" ] # [ inline ( always ) ] pub fn pendsvclr ( & self ) -> PENDSVCLR_R { PENDSVCLR_R :: new ( ( ( self . bits >> 27 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 28 - PendSV set-pending bit" ] # [ inline ( always ) ] pub fn pendsvset ( & self ) -> PENDSVSET_R { PENDSVSET_R :: new ( ( ( self . bits >> 28 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 31 - NMI set-pending bit" ] # [ inline ( always ) ] pub fn nmipendset ( & self ) -> NMIPENDSET_R { NMIPENDSET_R :: new ( ( ( self . bits >> 31 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bits 0:8 - Debug: Exception number of currently executing exception, or 0 if thread mode" ] # [ inline ( always ) ] pub fn vectactive ( & mut self ) -> VECTACTIVE_W { VECTACTIVE_W { w : self } }
# [ doc = "Bits 12:20 - Exception number of the highest priority pending enabled exception" ] # [ inline ( always ) ] pub fn vectpending ( & mut self ) -> VECTPENDING_W { VECTPENDING_W { w : self } }
# [ doc = "Bit 22 - Debug: NVIC interrupt pending" ] # [ inline ( always ) ] pub fn isrpending ( & mut self ) -> ISRPENDING_W { ISRPENDING_W { w : self } }
# [ doc = "Bit 23 - Debug: Pending exception serviced on exit from debug halt" ] # [ inline ( always ) ] pub fn isrpreempt ( & mut self ) -> ISRPREEMPT_W { ISRPREEMPT_W { w : self } }
# [ doc = "Bit 25 - SysTick exception clear-pending bit" ] # [ inline ( always ) ] pub fn pendstclr ( & mut self ) -> PENDSTCLR_W { PENDSTCLR_W { w : self } }
# [ doc = "Bit 26 - SysTick exception set-pending bit" ] # [ inline ( always ) ] pub fn pendstset ( & mut self ) -> PENDSTSET_W { PENDSTSET_W { w : self } }
# [ doc = "Bit 27 - PendSV clear-pending bit" ] # [ inline ( always ) ] pub fn pendsvclr ( & mut self ) -> PENDSVCLR_W { PENDSVCLR_W { w : self } }
# [ doc = "Bit 28 - PendSV set-pending bit" ] # [ inline ( always ) ] pub fn pendsvset ( & mut self ) -> PENDSVSET_W { PENDSVSET_W { w : self } }
# [ doc = "Bit 31 - NMI set-pending bit" ] # [ inline ( always ) ] pub fn nmipendset ( & mut self ) -> NMIPENDSET_W { NMIPENDSET_W { w : self } }
}
}
# [ doc = "Vector Table Offset Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [vtor](vtor) module" ] pub type VTOR = crate :: Reg < u32 , _VTOR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _VTOR ;
# [ doc = "`read()` method returns [vtor::R](vtor::R) reader structure" ] impl crate :: Readable for VTOR { }
# [ doc = "`write(|w| ..)` method takes [vtor::W](vtor::W) writer structure" ] impl crate :: Writable for VTOR { }
# [ doc = "Vector Table Offset Register" ] pub mod vtor {
# [ doc = "Reader of register VTOR" ] pub type R = crate :: R < u32 , super :: VTOR > ;
# [ doc = "Writer for register VTOR" ] pub type W = crate :: W < u32 , super :: VTOR > ;
# [ doc = "Register VTOR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: VTOR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `TBLOFF`" ] pub type TBLOFF_R = crate :: R < u32 , u32 > ;
# [ doc = "Write proxy for field `TBLOFF`" ] pub struct TBLOFF_W < 'a > { w : & 'a mut W , } impl < 'a > TBLOFF_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u32 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01ff_ffff << 7 ) ) | ( ( ( value as u32 ) & 0x01ff_ffff ) << 7 ) ; self . w } }
impl R {
# [ doc = "Bits 7:31 - Vector table base offset" ] # [ inline ( always ) ] pub fn tbloff ( & self ) -> TBLOFF_R { TBLOFF_R :: new ( ( ( self . bits >> 7 ) & 0x01ff_ffff ) as u32 ) }
}
impl W {
# [ doc = "Bits 7:31 - Vector table base offset" ] # [ inline ( always ) ] pub fn tbloff ( & mut self ) -> TBLOFF_W { TBLOFF_W { w : self } }
}
}
# [ doc = "Application Interrupt and Reset Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [aircr](aircr) module" ] pub type AIRCR = crate :: Reg < u32 , _AIRCR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _AIRCR ;
# [ doc = "`read()` method returns [aircr::R](aircr::R) reader structure" ] impl crate :: Readable for AIRCR { }
# [ doc = "`write(|w| ..)` method takes [aircr::W](aircr::W) writer structure" ] impl crate :: Writable for AIRCR { }
# [ doc = "Application Interrupt and Reset Control Register" ] pub mod aircr {
# [ doc = "Reader of register AIRCR" ] pub type R = crate :: R < u32 , super :: AIRCR > ;
# [ doc = "Writer for register AIRCR" ] pub type W = crate :: W < u32 , super :: AIRCR > ;
# [ doc = "Register AIRCR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: AIRCR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `VECTCLRACTIVE`" ] pub type VECTCLRACTIVE_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `VECTCLRACTIVE`" ] pub struct VECTCLRACTIVE_W < 'a > { w : & 'a mut W , } impl < 'a > VECTCLRACTIVE_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Possible values of the field `SYSRESETREQ`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SYSRESETREQ_A { # [ doc = "No system reset request" ] VALUE_0 , # [ doc = "Asserts a signal to the outer system that requests a reset" ] VALUE_1 }
impl crate :: ToBits < bool > for SYSRESETREQ_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { SYSRESETREQ_A :: VALUE_0 => false , SYSRESETREQ_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `SYSRESETREQ`" ] pub type SYSRESETREQ_R = crate :: R < bool , SYSRESETREQ_A > ; impl SYSRESETREQ_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SYSRESETREQ_A { match self . bits { false => SYSRESETREQ_A :: VALUE_0 , true => SYSRESETREQ_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == SYSRESETREQ_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == SYSRESETREQ_A :: VALUE_1 } }
# [ doc = "Write proxy for field `SYSRESETREQ`" ] pub struct SYSRESETREQ_W < 'a > { w : & 'a mut W , } impl < 'a > SYSRESETREQ_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SYSRESETREQ_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "No system reset request" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( SYSRESETREQ_A :: VALUE_0 ) } # [ doc = "Asserts a signal to the outer system that requests a reset" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( SYSRESETREQ_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `ENDIANNESS`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum ENDIANNESS_A { # [ doc = "Little-endian" ] VALUE_0 , # [ doc = "Big-endian" ] VALUE_1 }
impl crate :: ToBits < bool > for ENDIANNESS_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { ENDIANNESS_A :: VALUE_0 => false , ENDIANNESS_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `ENDIANNESS`" ] pub type ENDIANNESS_R = crate :: R < bool , ENDIANNESS_A > ; impl ENDIANNESS_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> ENDIANNESS_A { match self . bits { false => ENDIANNESS_A :: VALUE_0 , true => ENDIANNESS_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == ENDIANNESS_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == ENDIANNESS_A :: VALUE_1 } }
# [ doc = "Write proxy for field `ENDIANNESS`" ] pub struct ENDIANNESS_W < 'a > { w : & 'a mut W , } impl < 'a > ENDIANNESS_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : ENDIANNESS_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Little-endian" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( ENDIANNESS_A :: VALUE_0 ) } # [ doc = "Big-endian" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( ENDIANNESS_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
# [ doc = "Reader of field `VECTKEY`" ] pub type VECTKEY_R = crate :: R < u16 , u16 > ;
# [ doc = "Write proxy for field `VECTKEY`" ] pub struct VECTKEY_W < 'a > { w : & 'a mut W , } impl < 'a > VECTKEY_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u16 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xffff << 16 ) ) | ( ( ( value as u32 ) & 0xffff ) << 16 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Debug: Clear state information" ] # [ inline ( always ) ] pub fn vectclractive ( & self ) -> VECTCLRACTIVE_R { VECTCLRACTIVE_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - System Reset Request" ] # [ inline ( always ) ] pub fn sysresetreq ( & self ) -> SYSRESETREQ_R { SYSRESETREQ_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 15 - Data Endianness, 0=little, 1=big" ] # [ inline ( always ) ] pub fn endianness ( & self ) -> ENDIANNESS_R { ENDIANNESS_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
# [ doc = "Bits 16:31 - Register key (0x05FA)" ] # [ inline ( always ) ] pub fn vectkey ( & self ) -> VECTKEY_R { VECTKEY_R :: new ( ( ( self . bits >> 16 ) & 0xffff ) as u16 ) }
}
impl W {
# [ doc = "Bit 1 - Debug: Clear state information" ] # [ inline ( always ) ] pub fn vectclractive ( & mut self ) -> VECTCLRACTIVE_W { VECTCLRACTIVE_W { w : self } }
# [ doc = "Bit 2 - System Reset Request" ] # [ inline ( always ) ] pub fn sysresetreq ( & mut self ) -> SYSRESETREQ_W { SYSRESETREQ_W { w : self } }
# [ doc = "Bit 15 - Data Endianness, 0=little, 1=big" ] # [ inline ( always ) ] pub fn endianness ( & mut self ) -> ENDIANNESS_W { ENDIANNESS_W { w : self } }
# [ doc = "Bits 16:31 - Register key (0x05FA)" ] # [ inline ( always ) ] pub fn vectkey ( & mut self ) -> VECTKEY_W { VECTKEY_W { w : self } }
}
}
# [ doc = "System Control Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [scr](scr) module" ] pub type SCR = crate :: Reg < u32 , _SCR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SCR ;
# [ doc = "`read()` method returns [scr::R](scr::R) reader structure" ] impl crate :: Readable for SCR { }
# [ doc = "`write(|w| ..)` method takes [scr::W](scr::W) writer structure" ] impl crate :: Writable for SCR { }
# [ doc = "System Control Register" ] pub mod scr {
# [ doc = "Reader of register SCR" ] pub type R = crate :: R < u32 , super :: SCR > ;
# [ doc = "Writer for register SCR" ] pub type W = crate :: W < u32 , super :: SCR > ;
# [ doc = "Register SCR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SCR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Possible values of the field `SLEEPONEXIT`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SLEEPONEXIT_A { # [ doc = "O not sleep when returning to Thread mode" ] VALUE_0 , # [ doc = "Enter sleep, or deep sleep, on return from an ISR" ] VALUE_1 }
impl crate :: ToBits < bool > for SLEEPONEXIT_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { SLEEPONEXIT_A :: VALUE_0 => false , SLEEPONEXIT_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `SLEEPONEXIT`" ] pub type SLEEPONEXIT_R = crate :: R < bool , SLEEPONEXIT_A > ; impl SLEEPONEXIT_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SLEEPONEXIT_A { match self . bits { false => SLEEPONEXIT_A :: VALUE_0 , true => SLEEPONEXIT_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == SLEEPONEXIT_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == SLEEPONEXIT_A :: VALUE_1 } }
# [ doc = "Write proxy for field `SLEEPONEXIT`" ] pub struct SLEEPONEXIT_W < 'a > { w : & 'a mut W , } impl < 'a > SLEEPONEXIT_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SLEEPONEXIT_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "O not sleep when returning to Thread mode" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( SLEEPONEXIT_A :: VALUE_0 ) } # [ doc = "Enter sleep, or deep sleep, on return from an ISR" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( SLEEPONEXIT_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Possible values of the field `SLEEPDEEP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SLEEPDEEP_A { # [ doc = "Sleep" ] VALUE_0 , # [ doc = "Deep sleep" ] VALUE_1 }
impl crate :: ToBits < bool > for SLEEPDEEP_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { SLEEPDEEP_A :: VALUE_0 => false , SLEEPDEEP_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `SLEEPDEEP`" ] pub type SLEEPDEEP_R = crate :: R < bool , SLEEPDEEP_A > ; impl SLEEPDEEP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SLEEPDEEP_A { match self . bits { false => SLEEPDEEP_A :: VALUE_0 , true => SLEEPDEEP_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == SLEEPDEEP_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == SLEEPDEEP_A :: VALUE_1 } }
# [ doc = "Write proxy for field `SLEEPDEEP`" ] pub struct SLEEPDEEP_W < 'a > { w : & 'a mut W , } impl < 'a > SLEEPDEEP_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SLEEPDEEP_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Sleep" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( SLEEPDEEP_A :: VALUE_0 ) } # [ doc = "Deep sleep" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( SLEEPDEEP_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Possible values of the field `SEVONPEND`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum SEVONPEND_A { # [ doc = "Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded" ] VALUE_0 , # [ doc = "Enabled events and all interrupts, including disabled interrupts, can wakeup the processor" ] VALUE_1 }
impl crate :: ToBits < bool > for SEVONPEND_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { SEVONPEND_A :: VALUE_0 => false , SEVONPEND_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `SEVONPEND`" ] pub type SEVONPEND_R = crate :: R < bool , SEVONPEND_A > ; impl SEVONPEND_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> SEVONPEND_A { match self . bits { false => SEVONPEND_A :: VALUE_0 , true => SEVONPEND_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == SEVONPEND_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == SEVONPEND_A :: VALUE_1 } }
# [ doc = "Write proxy for field `SEVONPEND`" ] pub struct SEVONPEND_W < 'a > { w : & 'a mut W , } impl < 'a > SEVONPEND_W < 'a > { # [ doc = r"Writes `variant` to the field" ] # [ inline ( always ) ] pub fn variant ( self , variant : SEVONPEND_A ) -> & 'a mut W { use crate :: ToBits ; { self . bit ( variant . _bits ( ) ) } } # [ doc = "Only enabled interrupts or events can wakeup the processor, disabled interrupts are excluded" ] # [ inline ( always ) ] pub fn value_0 ( self ) -> & 'a mut W { self . variant ( SEVONPEND_A :: VALUE_0 ) } # [ doc = "Enabled events and all interrupts, including disabled interrupts, can wakeup the processor" ] # [ inline ( always ) ] pub fn value_1 ( self ) -> & 'a mut W { self . variant ( SEVONPEND_A :: VALUE_1 ) } # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 1 - Sleep-On-Exit when exiting Handler mode" ] # [ inline ( always ) ] pub fn sleeponexit ( & self ) -> SLEEPONEXIT_R { SLEEPONEXIT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - Uses Deep Sleep as low power mode" ] # [ inline ( always ) ] pub fn sleepdeep ( & self ) -> SLEEPDEEP_R { SLEEPDEEP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - Send Event on Pending bit" ] # [ inline ( always ) ] pub fn sevonpend ( & self ) -> SEVONPEND_R { SEVONPEND_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 1 - Sleep-On-Exit when exiting Handler mode" ] # [ inline ( always ) ] pub fn sleeponexit ( & mut self ) -> SLEEPONEXIT_W { SLEEPONEXIT_W { w : self } }
# [ doc = "Bit 2 - Uses Deep Sleep as low power mode" ] # [ inline ( always ) ] pub fn sleepdeep ( & mut self ) -> SLEEPDEEP_W { SLEEPDEEP_W { w : self } }
# [ doc = "Bit 4 - Send Event on Pending bit" ] # [ inline ( always ) ] pub fn sevonpend ( & mut self ) -> SEVONPEND_W { SEVONPEND_W { w : self } }
}
}
# [ doc = "Configuration and Control Register\n\nThis register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [ccr](ccr) module" ] pub type CCR = crate :: Reg < u32 , _CCR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _CCR ;
# [ doc = "`read()` method returns [ccr::R](ccr::R) reader structure" ] impl crate :: Readable for CCR { }
# [ doc = "Configuration and Control Register" ] pub mod ccr {
# [ doc = "Reader of register CCR" ] pub type R = crate :: R < u32 , super :: CCR > ;
# [ doc = "Possible values of the field `UNALIGN_TRP`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum UNALIGN_TRP_A { # [ doc = "Do not trap unaligned halfword and word accesses" ] VALUE_0 , # [ doc = "Trap unaligned halfword and word accesses" ] VALUE_1 }
impl crate :: ToBits < bool > for UNALIGN_TRP_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { UNALIGN_TRP_A :: VALUE_0 => false , UNALIGN_TRP_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `UNALIGN_TRP`" ] pub type UNALIGN_TRP_R = crate :: R < bool , UNALIGN_TRP_A > ; impl UNALIGN_TRP_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> UNALIGN_TRP_A { match self . bits { false => UNALIGN_TRP_A :: VALUE_0 , true => UNALIGN_TRP_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == UNALIGN_TRP_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == UNALIGN_TRP_A :: VALUE_1 } }
# [ doc = "Possible values of the field `STKALIGN`" ] # [ derive ( Clone , Copy , Debug , PartialEq ) ] pub enum STKALIGN_A { # [ doc = "4-byte aligned" ] VALUE_0 , # [ doc = "8-byte aligned" ] VALUE_1 }
impl crate :: ToBits < bool > for STKALIGN_A { # [ inline ( always ) ] fn _bits ( & self ) -> bool { match * self { STKALIGN_A :: VALUE_0 => false , STKALIGN_A :: VALUE_1 => true } } }
# [ doc = "Reader of field `STKALIGN`" ] pub type STKALIGN_R = crate :: R < bool , STKALIGN_A > ; impl STKALIGN_R { # [ doc = r"Get enumerated values variant" ] # [ inline ( always ) ] pub fn variant ( & self ) -> STKALIGN_A { match self . bits { false => STKALIGN_A :: VALUE_0 , true => STKALIGN_A :: VALUE_1 } } # [ doc = "Checks if the value of the field is `VALUE_0`" ] # [ inline ( always ) ] pub fn is_value_0 ( & self ) -> bool { * self == STKALIGN_A :: VALUE_0 } # [ doc = "Checks if the value of the field is `VALUE_1`" ] # [ inline ( always ) ] pub fn is_value_1 ( & self ) -> bool { * self == STKALIGN_A :: VALUE_1 } }
impl R {
# [ doc = "Bit 3 - Unaligned accesses generates a Hard Fault" ] # [ inline ( always ) ] pub fn unalign_trp ( & self ) -> UNALIGN_TRP_R { UNALIGN_TRP_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 9 - Stack 8-byte aligned on exception entry" ] # [ inline ( always ) ] pub fn stkalign ( & self ) -> STKALIGN_R { STKALIGN_R :: new ( ( ( self . bits >> 9 ) & 0x01 ) != 0 ) }
}
}
# [ doc = "System Handler Priority Register 2\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [shpr2](shpr2) module" ] pub type SHPR2 = crate :: Reg < u32 , _SHPR2 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SHPR2 ;
# [ doc = "`read()` method returns [shpr2::R](shpr2::R) reader structure" ] impl crate :: Readable for SHPR2 { }
# [ doc = "`write(|w| ..)` method takes [shpr2::W](shpr2::W) writer structure" ] impl crate :: Writable for SHPR2 { }
# [ doc = "System Handler Priority Register 2" ] pub mod shpr2 {
# [ doc = "Reader of register SHPR2" ] pub type R = crate :: R < u32 , super :: SHPR2 > ;
# [ doc = "Writer for register SHPR2" ] pub type W = crate :: W < u32 , super :: SHPR2 > ;
# [ doc = "Register SHPR2 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SHPR2 { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `PRI_11`" ] pub type PRI_11_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `PRI_11`" ] pub struct PRI_11_W < 'a > { w : & 'a mut W , } impl < 'a > PRI_11_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 24 ) ) | ( ( ( value as u32 ) & 0xff ) << 24 ) ; self . w } }
impl R {
# [ doc = "Bits 24:31 - Priority of system handler 11, SVCall" ] # [ inline ( always ) ] pub fn pri_11 ( & self ) -> PRI_11_R { PRI_11_R :: new ( ( ( self . bits >> 24 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 24:31 - Priority of system handler 11, SVCall" ] # [ inline ( always ) ] pub fn pri_11 ( & mut self ) -> PRI_11_W { PRI_11_W { w : self } }
}
}
# [ doc = "System Handler Priority Register 3\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [shpr3](shpr3) module" ] pub type SHPR3 = crate :: Reg < u32 , _SHPR3 > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SHPR3 ;
# [ doc = "`read()` method returns [shpr3::R](shpr3::R) reader structure" ] impl crate :: Readable for SHPR3 { }
# [ doc = "`write(|w| ..)` method takes [shpr3::W](shpr3::W) writer structure" ] impl crate :: Writable for SHPR3 { }
# [ doc = "System Handler Priority Register 3" ] pub mod shpr3 {
# [ doc = "Reader of register SHPR3" ] pub type R = crate :: R < u32 , super :: SHPR3 > ;
# [ doc = "Writer for register SHPR3" ] pub type W = crate :: W < u32 , super :: SHPR3 > ;
# [ doc = "Register SHPR3 `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SHPR3 { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `PRI_14`" ] pub type PRI_14_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `PRI_14`" ] pub struct PRI_14_W < 'a > { w : & 'a mut W , } impl < 'a > PRI_14_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 16 ) ) | ( ( ( value as u32 ) & 0xff ) << 16 ) ; self . w } }
# [ doc = "Reader of field `PRI_15`" ] pub type PRI_15_R = crate :: R < u8 , u8 > ;
# [ doc = "Write proxy for field `PRI_15`" ] pub struct PRI_15_W < 'a > { w : & 'a mut W , } impl < 'a > PRI_15_W < 'a > { # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub unsafe fn bits ( self , value : u8 ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0xff << 24 ) ) | ( ( ( value as u32 ) & 0xff ) << 24 ) ; self . w } }
impl R {
# [ doc = "Bits 16:23 - Priority of system handler 14, PendSV" ] # [ inline ( always ) ] pub fn pri_14 ( & self ) -> PRI_14_R { PRI_14_R :: new ( ( ( self . bits >> 16 ) & 0xff ) as u8 ) }
# [ doc = "Bits 24:31 - Priority of system handler 15, SysTick exception" ] # [ inline ( always ) ] pub fn pri_15 ( & self ) -> PRI_15_R { PRI_15_R :: new ( ( ( self . bits >> 24 ) & 0xff ) as u8 ) }
}
impl W {
# [ doc = "Bits 16:23 - Priority of system handler 14, PendSV" ] # [ inline ( always ) ] pub fn pri_14 ( & mut self ) -> PRI_14_W { PRI_14_W { w : self } }
# [ doc = "Bits 24:31 - Priority of system handler 15, SysTick exception" ] # [ inline ( always ) ] pub fn pri_15 ( & mut self ) -> PRI_15_W { PRI_15_W { w : self } }
}
}
# [ doc = "System Handler Control and State Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [shcsr](shcsr) module" ] pub type SHCSR = crate :: Reg < u32 , _SHCSR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _SHCSR ;
# [ doc = "`read()` method returns [shcsr::R](shcsr::R) reader structure" ] impl crate :: Readable for SHCSR { }
# [ doc = "`write(|w| ..)` method takes [shcsr::W](shcsr::W) writer structure" ] impl crate :: Writable for SHCSR { }
# [ doc = "System Handler Control and State Register" ] pub mod shcsr {
# [ doc = "Reader of register SHCSR" ] pub type R = crate :: R < u32 , super :: SHCSR > ;
# [ doc = "Writer for register SHCSR" ] pub type W = crate :: W < u32 , super :: SHCSR > ;
# [ doc = "Register SHCSR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: SHCSR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `SVCALLPENDED`" ] pub type SVCALLPENDED_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `SVCALLPENDED`" ] pub struct SVCALLPENDED_W < 'a > { w : & 'a mut W , } impl < 'a > SVCALLPENDED_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 15 ) ) | ( ( ( value as u32 ) & 0x01 ) << 15 ) ; self . w } }
impl R {
# [ doc = "Bit 15" ] # [ inline ( always ) ] pub fn svcallpended ( & self ) -> SVCALLPENDED_R { SVCALLPENDED_R :: new ( ( ( self . bits >> 15 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 15" ] # [ inline ( always ) ] pub fn svcallpended ( & mut self ) -> SVCALLPENDED_W { SVCALLPENDED_W { w : self } }
}
}
# [ doc = "Debug Fault Status Register\n\nThis register you can [`read`](crate::generic::Reg::read), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about avaliable fields see [dfsr](dfsr) module" ] pub type DFSR = crate :: Reg < u32 , _DFSR > ; # [ allow ( missing_docs ) ] # [ doc ( hidden ) ] pub struct _DFSR ;
# [ doc = "`read()` method returns [dfsr::R](dfsr::R) reader structure" ] impl crate :: Readable for DFSR { }
# [ doc = "`write(|w| ..)` method takes [dfsr::W](dfsr::W) writer structure" ] impl crate :: Writable for DFSR { }
# [ doc = "Debug Fault Status Register" ] pub mod dfsr {
# [ doc = "Reader of register DFSR" ] pub type R = crate :: R < u32 , super :: DFSR > ;
# [ doc = "Writer for register DFSR" ] pub type W = crate :: W < u32 , super :: DFSR > ;
# [ doc = "Register DFSR `reset()`'s with value 0" ] impl crate :: ResetValue for super :: DFSR { type Type = u32 ; # [ inline ( always ) ] fn reset_value ( ) -> Self :: Type { 0 } }
# [ doc = "Reader of field `HALTED`" ] pub type HALTED_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `HALTED`" ] pub struct HALTED_W < 'a > { w : & 'a mut W , } impl < 'a > HALTED_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! 0x01 ) | ( ( value as u32 ) & 0x01 ) ; self . w } }
# [ doc = "Reader of field `BKPT`" ] pub type BKPT_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `BKPT`" ] pub struct BKPT_W < 'a > { w : & 'a mut W , } impl < 'a > BKPT_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 1 ) ) | ( ( ( value as u32 ) & 0x01 ) << 1 ) ; self . w } }
# [ doc = "Reader of field `DWTTRAP`" ] pub type DWTTRAP_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `DWTTRAP`" ] pub struct DWTTRAP_W < 'a > { w : & 'a mut W , } impl < 'a > DWTTRAP_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 2 ) ) | ( ( ( value as u32 ) & 0x01 ) << 2 ) ; self . w } }
# [ doc = "Reader of field `VCATCH`" ] pub type VCATCH_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `VCATCH`" ] pub struct VCATCH_W < 'a > { w : & 'a mut W , } impl < 'a > VCATCH_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 3 ) ) | ( ( ( value as u32 ) & 0x01 ) << 3 ) ; self . w } }
# [ doc = "Reader of field `EXTERNAL`" ] pub type EXTERNAL_R = crate :: R < bool , bool > ;
# [ doc = "Write proxy for field `EXTERNAL`" ] pub struct EXTERNAL_W < 'a > { w : & 'a mut W , } impl < 'a > EXTERNAL_W < 'a > { # [ doc = r"Sets the field bit" ] # [ inline ( always ) ] pub fn set_bit ( self ) -> & 'a mut W { self . bit ( true ) } # [ doc = r"Clears the field bit" ] # [ inline ( always ) ] pub fn clear_bit ( self ) -> & 'a mut W { self . bit ( false ) } # [ doc = r"Writes raw bits to the field" ] # [ inline ( always ) ] pub fn bit ( self , value : bool ) -> & 'a mut W { self . w . bits = ( self . w . bits & ! ( 0x01 << 4 ) ) | ( ( ( value as u32 ) & 0x01 ) << 4 ) ; self . w } }
impl R {
# [ doc = "Bit 0 - Halt request debug event active" ] # [ inline ( always ) ] pub fn halted ( & self ) -> HALTED_R { HALTED_R :: new ( ( self . bits & 0x01 ) != 0 ) }
# [ doc = "Bit 1 - Breakpoint debug event" ] # [ inline ( always ) ] pub fn bkpt ( & self ) -> BKPT_R { BKPT_R :: new ( ( ( self . bits >> 1 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 2 - DWT debug event" ] # [ inline ( always ) ] pub fn dwttrap ( & self ) -> DWTTRAP_R { DWTTRAP_R :: new ( ( ( self . bits >> 2 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 3 - Vector catch debug event" ] # [ inline ( always ) ] pub fn vcatch ( & self ) -> VCATCH_R { VCATCH_R :: new ( ( ( self . bits >> 3 ) & 0x01 ) != 0 ) }
# [ doc = "Bit 4 - EDBGRQ debug event" ] # [ inline ( always ) ] pub fn external ( & self ) -> EXTERNAL_R { EXTERNAL_R :: new ( ( ( self . bits >> 4 ) & 0x01 ) != 0 ) }
}
impl W {
# [ doc = "Bit 0 - Halt request debug event active" ] # [ inline ( always ) ] pub fn halted ( & mut self ) -> HALTED_W { HALTED_W { w : self } }
# [ doc = "Bit 1 - Breakpoint debug event" ] # [ inline ( always ) ] pub fn bkpt ( & mut self ) -> BKPT_W { BKPT_W { w : self } }
# [ doc = "Bit 2 - DWT debug event" ] # [ inline ( always ) ] pub fn dwttrap ( & mut self ) -> DWTTRAP_W { DWTTRAP_W { w : self } }
# [ doc = "Bit 3 - Vector catch debug event" ] # [ inline ( always ) ] pub fn vcatch ( & mut self ) -> VCATCH_W { VCATCH_W { w : self } }
# [ doc = "Bit 4 - EDBGRQ debug event" ] # [ inline ( always ) ] pub fn external ( & mut self ) -> EXTERNAL_W { EXTERNAL_W { w : self } }
}
}
}
# [ no_mangle ] static mut DEVICE_PERIPHERALS : bool = false ; # [ doc = r"All the peripherals" ] # [ allow ( non_snake_case ) ] pub struct Peripherals { # [ doc = "AC" ] pub AC : AC , # [ doc = "ADC0" ] pub ADC0 : ADC0 , # [ doc = "ADC1" ] pub ADC1 : ADC1 , # [ doc = "CAN0" ] pub CAN0 : CAN0 , # [ doc = "CAN1" ] pub CAN1 : CAN1 , # [ doc = "CCL" ] pub CCL : CCL , # [ doc = "DAC" ] pub DAC : DAC , # [ doc = "DIVAS" ] pub DIVAS : DIVAS , # [ doc = "DMAC" ] pub DMAC : DMAC , # [ doc = "DSU" ] pub DSU : DSU , # [ doc = "EIC" ] pub EIC : EIC , # [ doc = "EVSYS" ] pub EVSYS : EVSYS , # [ doc = "FREQM" ] pub FREQM : FREQM , # [ doc = "GCLK" ] pub GCLK : GCLK , # [ doc = "HMATRIXHS" ] pub HMATRIXHS : HMATRIXHS , # [ doc = "MCLK" ] pub MCLK : MCLK , # [ doc = "MTB" ] pub MTB : MTB , # [ doc = "NVMCTRL" ] pub NVMCTRL : NVMCTRL , # [ doc = "OSCCTRL" ] pub OSCCTRL : OSCCTRL , # [ doc = "OSC32KCTRL" ] pub OSC32KCTRL : OSC32KCTRL , # [ doc = "PAC" ] pub PAC : PAC , # [ doc = "PM" ] pub PM : PM , # [ doc = "PORT" ] pub PORT : PORT , # [ doc = "PORT_IOBUS" ] pub PORT_IOBUS : PORT_IOBUS , # [ doc = "RSTC" ] pub RSTC : RSTC , # [ doc = "RTC" ] pub RTC : RTC , # [ doc = "SDADC" ] pub SDADC : SDADC , # [ doc = "SERCOM0" ] pub SERCOM0 : SERCOM0 , # [ doc = "SERCOM1" ] pub SERCOM1 : SERCOM1 , # [ doc = "SERCOM2" ] pub SERCOM2 : SERCOM2 , # [ doc = "SERCOM3" ] pub SERCOM3 : SERCOM3 , # [ doc = "SERCOM4" ] pub SERCOM4 : SERCOM4 , # [ doc = "SERCOM5" ] pub SERCOM5 : SERCOM5 , # [ doc = "SERCOM6" ] pub SERCOM6 : SERCOM6 , # [ doc = "SERCOM7" ] pub SERCOM7 : SERCOM7 , # [ doc = "SUPC" ] pub SUPC : SUPC , # [ doc = "TC0" ] pub TC0 : TC0 , # [ doc = "TC1" ] pub TC1 : TC1 , # [ doc = "TC2" ] pub TC2 : TC2 , # [ doc = "TC3" ] pub TC3 : TC3 , # [ doc = "TC4" ] pub TC4 : TC4 , # [ doc = "TC5" ] pub TC5 : TC5 , # [ doc = "TC6" ] pub TC6 : TC6 , # [ doc = "TC7" ] pub TC7 : TC7 , # [ doc = "TCC0" ] pub TCC0 : TCC0 , # [ doc = "TCC1" ] pub TCC1 : TCC1 , # [ doc = "TCC2" ] pub TCC2 : TCC2 , # [ doc = "TSENS" ] pub TSENS : TSENS , # [ doc = "WDT" ] pub WDT : WDT , # [ doc = "SYSTICK" ] pub SYSTICK : SYSTICK , # [ doc = "SYSTEMCONTROL" ] pub SYSTEMCONTROL : SYSTEMCONTROL , } impl Peripherals { # [ doc = r"Returns all the peripherals *once*" ] # [ inline ] pub fn take ( ) -> Option < Self > { cortex_m :: interrupt :: free ( | _ | { if unsafe { DEVICE_PERIPHERALS } { None } else { Some ( unsafe { Peripherals :: steal ( ) } ) } } ) } # [ doc = r"Unchecked version of `Peripherals::take`" ] pub unsafe fn steal ( ) -> Self { DEVICE_PERIPHERALS = true ; Peripherals { AC : AC { _marker : PhantomData } , ADC0 : ADC0 { _marker : PhantomData } , ADC1 : ADC1 { _marker : PhantomData } , CAN0 : CAN0 { _marker : PhantomData } , CAN1 : CAN1 { _marker : PhantomData } , CCL : CCL { _marker : PhantomData } , DAC : DAC { _marker : PhantomData } , DIVAS : DIVAS { _marker : PhantomData } , DMAC : DMAC { _marker : PhantomData } , DSU : DSU { _marker : PhantomData } , EIC : EIC { _marker : PhantomData } , EVSYS : EVSYS { _marker : PhantomData } , FREQM : FREQM { _marker : PhantomData } , GCLK : GCLK { _marker : PhantomData } , HMATRIXHS : HMATRIXHS { _marker : PhantomData } , MCLK : MCLK { _marker : PhantomData } , MTB : MTB { _marker : PhantomData } , NVMCTRL : NVMCTRL { _marker : PhantomData } , OSCCTRL : OSCCTRL { _marker : PhantomData } , OSC32KCTRL : OSC32KCTRL { _marker : PhantomData } , PAC : PAC { _marker : PhantomData } , PM : PM { _marker : PhantomData } , PORT : PORT { _marker : PhantomData } , PORT_IOBUS : PORT_IOBUS { _marker : PhantomData } , RSTC : RSTC { _marker : PhantomData } , RTC : RTC { _marker : PhantomData } , SDADC : SDADC { _marker : PhantomData } , SERCOM0 : SERCOM0 { _marker : PhantomData } , SERCOM1 : SERCOM1 { _marker : PhantomData } , SERCOM2 : SERCOM2 { _marker : PhantomData } , SERCOM3 : SERCOM3 { _marker : PhantomData } , SERCOM4 : SERCOM4 { _marker : PhantomData } , SERCOM5 : SERCOM5 { _marker : PhantomData } , SERCOM6 : SERCOM6 { _marker : PhantomData } , SERCOM7 : SERCOM7 { _marker : PhantomData } , SUPC : SUPC { _marker : PhantomData } , TC0 : TC0 { _marker : PhantomData } , TC1 : TC1 { _marker : PhantomData } , TC2 : TC2 { _marker : PhantomData } , TC3 : TC3 { _marker : PhantomData } , TC4 : TC4 { _marker : PhantomData } , TC5 : TC5 { _marker : PhantomData } , TC6 : TC6 { _marker : PhantomData } , TC7 : TC7 { _marker : PhantomData } , TCC0 : TCC0 { _marker : PhantomData } , TCC1 : TCC1 { _marker : PhantomData } , TCC2 : TCC2 { _marker : PhantomData } , TSENS : TSENS { _marker : PhantomData } , WDT : WDT { _marker : PhantomData } , SYSTICK : SYSTICK { _marker : PhantomData } , SYSTEMCONTROL : SYSTEMCONTROL { _marker : PhantomData } , } } }
